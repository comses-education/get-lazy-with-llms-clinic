# Comprehensive Requirements for `dirdigest` Command Line Tool

Below is a detailed specification for your `dirdigest` tool that builds upon your draft requirements while adding clarity, organization, and additional functionality.

## Overview

`dirdigest` is a Python command line tool that recursively processes directories and files, creating a structured digest in markdown or JSON format suitable for LLM context ingestion. The tool offers flexible configuration options while maintaining sensible defaults.

## Command Line Interface

```
dirdigest [OPTIONS] [DIRECTORY]
```

### Primary Arguments

- `DIRECTORY`: Directory to process (default: current directory)
- `--output, -o`: Output file path (default: stdout)
- `--format, -f`: Output format - `json` or `markdown` (default: `markdown`)

### Content Selection Arguments

- `--include, -i`: Pattern(s) for files/directories to include (can be specified multiple times)
- `--exclude, -x`: Pattern(s) for files/directories to exclude (can be specified multiple times)
- `--max-size, -s`: Maximum file size to include in KB (default: 300KB)
- `--max-depth, -d`: Maximum directory depth to traverse (default: unlimited)
- `--no-default-ignore`: Disable default ignore patterns

### Behavior Control Arguments

- `--follow-symlinks`: Follow symbolic links (default: false)
- `--ignore-errors`: Continue on error when reading files (default: false)
- `--clipboard, -c`: Copy output to clipboard (default: true)
- `--no-clipboard`: Disable copying to clipboard

### Output Control Arguments

- `--verbose, -v`: Increase verbosity (can be specified multiple times)
- `--quiet, -q`: Suppress all output except errors
- `--log-file`: Specify log file path

### Configuration Arguments

- `--config`: Specify configuration file (default: `.diringest` in current directory)

## Functional Requirements

### File Traversal and Selection

- Recursively traverse the specified directory structure
- Apply include/exclude patterns to filter files and directories
- Follow symlinks only when explicitly enabled
- Respect maximum file size and depth limits
- Generate appropriate warnings for skipped or unreadable content

### Default Ignore Patterns

Unless `--no-default-ignore` is specified, exclude:

1. **Hidden files and directories**
   - All files and directories starting with `.`

2. **Binary and media files**
   - Images (*.jpg, *.png, *.gif, *.bmp, etc.)
   - Videos (*.mp4, *.avi, *.mov, etc.)
   - Audio (*.mp3, *.wav, *.flac, etc.)
   - Executables (*.exe, *.dll, *.so, etc.)
   - Archives (*.zip, *.tar.gz, *.7z, etc.)
   - Font files (*.woff, *.ttf, etc.)
   - Document formats (*.pdf, *.docx, etc.)

3. **Development artifacts**
   - Compiled code (*.pyc, *.class, etc.)
   - Cache directories (`__pycache__`, `.cache`, etc.)
   - Build directories (`dist/`, `build/`, etc.)
   - Package manager directories (`node_modules/`, `.venv/`, etc.)
   - Version control directories (`.git/`, `.svn/`, etc.)

4. **Data and temporary files**
   - Database files (*.db, *.sqlite, etc.)
   - Log files (*.log)
   - Temporary files (*.tmp, *.temp, etc.)
   - System files (`.DS_Store`, `Thumbs.db`, etc.)

### Output Generation

#### JSON Format
- Generate a structured, nested JSON document representing the directory hierarchy
- Use objects with the following schema:
  ```json
  {
    "metadata": {
      "tool_version": "1.0.0",
      "created_at": "ISO-8601 timestamp",
      "base_directory": "/path/to/base/dir",
      "included_files_count": 42,
      "excluded_files_count": 123,
      "total_content_size_kb": 456.7
    },
    "root": {
      "relative_path": ".",
      "type": "folder",
      "children": [
        {
          "relative_path": "file1.txt",
          "type": "file",
          "size_kb": 1.5,
          "content": "Content of file1.txt..."
        },
        {
          "relative_path": "folder1",
          "type": "folder",
          "children": []
        }
      ]
    }
  }
  ```

#### Markdown Format
- Generate a formatted markdown document with:
  - A header section containing metadata
  - A directory structure visualization
  - File contents in clearly delimited code blocks
  - Relative paths in file/folder headers
  - Properly formatted code blocks with language hints when possible
  - Example structure:
    ```markdown
    # Directory Digest: /path/to/directory
    
    *Generated by dirdigest v1.0.0 on YYYY-MM-DD HH:MM:SS*
    
    ## Directory Structure
    ```
    .
    ├── file1.txt
    └── folder1
        └── file2.py
    ```
    
    ## Contents
    
    ### ./file1.txt
    ```
    Content of file1.txt...
    ```
    
    ### ./folder1/file2.py
    ```
    def hello():
        print("Hello!")
    ```
    ```

### Logging and Reporting

- Log included and excluded files with their respective counts
- Report total size of included content
- Provide execution time
- Generate summary statistics
- Support different verbosity levels
- Display progress indicators for large directories

### Clipboard Integration

- Copy the output to the clipboard by default unless disabled
- Provide clear notification when content is copied
- Handle clipboard access failures gracefully

### Configuration File Support

- Support a `.diringest` configuration file in YAML format
- Allow configuration of all command line options
- Support multiple configuration profiles
- Command line arguments should override config file settings

Example configuration file structure:
```yaml
# Default configuration
default:
  output: stdout
  format: markdown
  max_size: 300
  clipboard: true
  
  # Default patterns
  exclude:
    - ".*"
    - "**/*.pyc"
    - "**/__pycache__/"
    # Additional patterns...
    
  include: []

# Custom profiles
production:
  max_size: 500
  exclude:
    - "tests/"
    - "docs/"
```

## Non-Functional Requirements

### Performance Requirements

- Handle large directory structures efficiently
- Use stream processing for large files
- Implement progress indicators for long-running operations

### Code Quality Requirements

- Implement modular, readable, maintainable, and testable code
- Use type hints throughout the codebase
- Follow PEP 8 style guidelines
- Maintain a high test coverage

### Dependency Requirements

- Use `uv` for package management
- Use `rich` library for beautiful terminal output
- Minimize external dependencies

### Compatibility Requirements

- Support Python 3.8+
- Ensure cross-platform compatibility (Windows, macOS, Linux)

### Documentation Requirements

- Include comprehensive CLI help text
- Provide detailed documentation for configuration options
- Include examples for common use cases

## Implementation Recommendations

### Project Structure

```
dirdigest/
├── __init__.py
├── cli.py           # Command line interface
├── core.py          # Core functionality
├── formatter.py     # Output formatting (JSON/Markdown)
├── utils/
│   ├── __init__.py
│   ├── clipboard.py # Clipboard handling
│   ├── config.py    # Configuration handling
│   └── patterns.py  # Pattern matching utilities
├── constants.py     # Default patterns and constants
└── tests/           # Test suite
```

### Key Components

1. **CLI Handler**: Process arguments using the Click library
2. **File Traversal Engine**: Recursively traverse directories with filtering
3. **Content Processor**: Read and process file contents
4. **Formatters**: Generate JSON or Markdown output
5. **Clipboard Manager**: Handle copying to clipboard
6. **Configuration Manager**: Handle config file loading and merging with CLI args

### Libraries to Consider

- `click` for CLI argument parsing
- `rich` for beautiful terminal output
- `gitignore_parser` to leverage gitignore-style pattern matching
- `pyperclip` for clipboard functionality
- `pyyaml` for configuration file parsing

## Future Enhancement Possibilities

1. Support for additional file formats (PDF, DOCX, etc.) (converting to markdown on the fly)
2. Content transformation options (summarization for large files using an LLM, etc.)
3. Integration with version control systems for smarter file selection
4. Remote directory support (SSH, S3, etc.)
5. Incremental updates to existing digests