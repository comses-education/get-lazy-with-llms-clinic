Directory structure:
└── landlab/
    ├── README.md
    ├── CITATION.cff
    ├── CONTRIBUTING.md
    ├── LICENSE.md
    ├── MANIFEST.in
    ├── conftest.py
    ├── environment-dev.yml
    ├── environment.yml
    ├── notebooks.py
    ├── noxfile.py
    ├── pyproject.toml
    ├── requirements-testing.in
    ├── requirements.in
    ├── setup.cfg
    ├── setup.py
    ├── docs/
    │   ├── Makefile
    │   ├── fix_redirects.py
    │   ├── index.toml
    │   ├── make.bat
    │   ├── requirements.in
    │   └── source/
    │       ├── conf.py
    │       ├── index.md
    │       ├── installation.md
    │       ├── _static/
    │       ├── _templates/
    │       │   ├── module.rst_t
    │       │   ├── package.rst_t
    │       │   └── sidebaroutro.html
    │       ├── about/
    │       │   ├── authors.md
    │       │   ├── changes.md
    │       │   ├── citing.md
    │       │   ├── contact_us.md
    │       │   ├── funding.md
    │       │   ├── license.md
    │       │   └── usedby.md
    │       ├── development/
    │       │   ├── index.md
    │       │   ├── package_organization.md
    │       │   ├── contribution/
    │       │   │   ├── desired_contributions.md
    │       │   │   ├── develop_a_component.md
    │       │   │   ├── index.md
    │       │   │   ├── joss_workflow.md
    │       │   │   ├── ongoing_development.md
    │       │   │   └── recommendations.md
    │       │   └── practices/
    │       │       ├── continuous_integration.md
    │       │       ├── dependencies.md
    │       │       ├── dev_guide_releases.md
    │       │       ├── develop_with_git.md
    │       │       ├── index.md
    │       │       ├── style_conventions.md
    │       │       └── writing_tests.md
    │       ├── generated/
    │       │   └── .gitignore
    │       ├── getting_started/
    │       │   └── index.md
    │       ├── install/
    │       │   ├── developer_install.md
    │       │   ├── environments.md
    │       │   ├── index.md
    │       │   └── update_uninstall.md
    │       └── user_guide/
    │           ├── build_a_model.md
    │           ├── cell_lab_user_guide.md
    │           ├── component_list.md
    │           ├── components.md
    │           ├── dupuit_theory.md
    │           ├── faq.md
    │           ├── field_definitions.md
    │           ├── grid.md
    │           ├── grid_summary.md
    │           ├── index.md
    │           ├── move_files_to_rst.py
    │           ├── overland_flow_user_guide.md
    │           ├── time_steps.md
    │           ├── units.md
    │           ├── grid_methods/
    │           │   ├── 01_nodes_links_patches.md
    │           │   ├── 02_corners_faces_cells.md
    │           │   ├── 03_boundary_conditions.md
    │           │   ├── 04_element_subsets.md
    │           │   ├── 05_element_mapping.md
    │           │   ├── 06_gradients.md
    │           │   ├── 07_surface_analysis.md
    │           │   ├── 08_fields.md
    │           │   └── 99_uncategorized.md
    │           ├── images/
    │           └── reference/
    │               ├── components.md
    │               ├── grid.md
    │               ├── index.md
    │               ├── layers.md
    │               └── values.md
    ├── joss/
    ├── news/
    ├── notebooks/
    │   ├── requirements.in
    │   ├── welcome.ipynb
    │   ├── teaching/
    │   │   ├── index.md
    │   │   ├── welcome_teaching.ipynb
    │   │   ├── geomorphology_exercises/
    │   │   │   ├── channels_streampower_notebooks/
    │   │   │   │   └── stream_power_channels_class_notebook.ipynb
    │   │   │   ├── drainage_density_notebooks/
    │   │   │   │   └── drainage_density_class_notebook.ipynb
    │   │   │   └── hillslope_notebooks/
    │   │   │       ├── hillslope_diffusion_class_notebook.ipynb
    │   │   │       └── north_carolina_piedmont_hillslope_class_notebook.ipynb
    │   │   └── surface_water_hydrology_exercises/
    │   │       └── overland_flow_notebooks/
    │   │           └── hydrograph_class_notebook.ipynb
    │   └── tutorials/
    │       ├── index.md
    │       ├── advection/
    │       │   └── overview_of_advection_solver.ipynb
    │       ├── agent_based_modeling/
    │       │   ├── README.md
    │       │   ├── groundwater/
    │       │   │   └── landlab_mesa_groundwater_pumping.ipynb
    │       │   └── wolf_sheep/
    │       │       └── wolf_sheep_with_soil_creep.ipynb
    │       ├── boundary_conditions/
    │       │   ├── set_BCs_from_xy.ipynb
    │       │   ├── set_BCs_on_raster_perimeter.ipynb
    │       │   ├── set_BCs_on_voronoi.ipynb
    │       │   └── set_watershed_BCs_raster.ipynb
    │       ├── carbonates/
    │       │   └── carbonate_producer.ipynb
    │       ├── component_tutorial/
    │       │   ├── component_tutorial.ipynb
    │       │   ├── coupled_params.txt
    │       │   └── coupled_params_storms.txt
    │       ├── data_record/
    │       │   └── DataRecord_tutorial.ipynb
    │       ├── ecohydrology/
    │       │   ├── cellular_automaton_vegetation_DEM/
    │       │   │   ├── Inputs_Vegetation_CA_DEM.txt
    │       │   │   └── cellular_automaton_vegetation_DEM.ipynb
    │       │   └── cellular_automaton_vegetation_flat_surface/
    │       │       ├── Inputs_Vegetation_CA_flat.txt
    │       │       └── cellular_automaton_vegetation_flat_domain.ipynb
    │       ├── fault_scarp/
    │       │   └── landlab-fault-scarp.ipynb
    │       ├── fields/
    │       │   └── working_with_fields.ipynb
    │       ├── flexure/
    │       │   ├── flexure_1d.ipynb
    │       │   └── lots_of_loads.ipynb
    │       ├── flow_direction_and_accumulation/
    │       │   ├── PriorityFlood_LandscapeEvolutionModel.ipynb
    │       │   ├── PriorityFlood_realDEMs.ipynb
    │       │   ├── compare_FlowDirectors.ipynb
    │       │   ├── the_FlowAccumulator.ipynb
    │       │   ├── the_FlowDirectors.ipynb
    │       │   ├── the_Flow_Director_Accumulator_PriorityFlood.ipynb
    │       │   └── data/
    │       ├── fracture_grid/
    │       │   └── using_fracture_grid.ipynb
    │       ├── gradient_and_divergence/
    │       │   └── gradient_and_divergence.ipynb
    │       ├── grids/
    │       │   ├── diverse_grid_classes.ipynb
    │       │   ├── grid_object_demo.ipynb
    │       │   ├── how_to_create_and_viz_icosphere_grid.ipynb
    │       │   ├── icosphere_example_models.ipynb
    │       │   └── media/
    │       ├── groundwater/
    │       │   └── groundwater_flow.ipynb
    │       ├── hillslope_geomorphology/
    │       │   ├── depth_dependent_taylor_diffuser/
    │       │   │   └── depth_dependent_taylor_diffuser.ipynb
    │       │   ├── taylor_diffuser/
    │       │   │   └── taylor_diffuser.ipynb
    │       │   └── transport-length_hillslope_diffuser/
    │       │       └── TLHDiff_tutorial.ipynb
    │       ├── landscape_evolution/
    │       │   ├── area_slope_transporter/
    │       │   │   ├── einstein-brown.ipynb
    │       │   │   └── transport-limited-LEM-example.ipynb
    │       │   ├── erosion_deposition/
    │       │   │   ├── erosion_deposition_component.ipynb
    │       │   │   └── shared_stream_power.ipynb
    │       │   ├── gravel_bedrock_eroder/
    │       │   │   └── gravel_bedrock_transporter_unit_tests.ipynb
    │       │   ├── gravel_river_transporter/
    │       │   │   └── gravel_river_transporter.ipynb
    │       │   ├── hylands/
    │       │   │   └── HyLandsTutorial.ipynb
    │       │   ├── river_input_lem/
    │       │   │   └── adding_discharge_point_source_to_a_lem.ipynb
    │       │   ├── smooth_threshold_eroder/
    │       │   │   └── stream_power_smooth_threshold_eroder.ipynb
    │       │   ├── space/
    │       │   │   ├── SPACE_large_scale_eroder_user_guide_and_examples.ipynb
    │       │   │   └── SPACE_user_guide_and_examples.ipynb
    │       │   └── threshold_eroder/
    │       │       └── threshold_eroder.ipynb
    │       ├── lithology/
    │       │   └── lithology_and_litholayers.ipynb
    │       ├── making_components/
    │       │   ├── component_design_tips.ipynb
    │       │   └── making_components.ipynb
    │       ├── mappers/
    │       │   └── mappers.ipynb
    │       ├── marine_sediment_transport/
    │       │   └── simple_submarine_diffuser_tutorial.ipynb
    │       ├── mass_wasting_runout/
    │       │   ├── landslide_runout_animation.ipynb
    │       │   └── synthetic_landscape_animation.ipynb
    │       ├── matrix_creation/
    │       │   └── numerical_matrix_building_tools.ipynb
    │       ├── network_sediment_transporter/
    │       │   ├── bed_parcel_initializer.ipynb
    │       │   ├── create_networkgrid_from_rastergrid.ipynb
    │       │   ├── network_plotting_examples.ipynb
    │       │   ├── network_sediment_transporter.ipynb
    │       │   ├── network_sediment_transporter_NHDPlus_HR_network.ipynb
    │       │   ├── network_sediment_transporter_shapefile_network.ipynb
    │       │   ├── nst_scaling_profiling.ipynb
    │       │   ├── run_network_generator_OpenTopoDEM.ipynb
    │       │   ├── sediment_pulser_at_links.ipynb
    │       │   └── sediment_pulser_each_parcel.ipynb
    │       ├── normal_fault/
    │       │   └── normal_fault_component_tutorial.ipynb
    │       ├── output/
    │       │   └── writing_legacy_vtk_files.ipynb
    │       ├── overland_flow/
    │       │   ├── coupled_rainfall_runoff.ipynb
    │       │   ├── how_to_d4_pitfill_a_dem.ipynb
    │       │   ├── overland_flow_driver.ipynb
    │       │   ├── kinwave_implicit/
    │       │   │   └── kinwave_implicit_overland_flow.ipynb
    │       │   ├── linear_diffusion_overland_flow/
    │       │   │   └── linear_diffusion_overland_flow_router.ipynb
    │       │   ├── overland_flow_erosion/
    │       │   │   └── ol_flow_erosion_components.ipynb
    │       │   ├── rainfall/
    │       │   └── soil_infiltration_green_ampt/
    │       │       └── infilt_green_ampt_with_overland_flow.ipynb
    │       ├── plotting/
    │       │   ├── animate-landlab-output.ipynb
    │       │   └── landlab-plotting.ipynb
    │       ├── python_intro/
    │       │   └── python_intro.ipynb
    │       ├── reading_dem_into_landlab/
    │       │   └── reading_dem_into_landlab.ipynb
    │       ├── river_flow_dynamics/
    │       │   ├── river_flow_dynamics_tutorial.ipynb
    │       │   └── river_flow_dynamics_tutorial2.ipynb
    │       ├── species_evolution/
    │       │   ├── Introduction_to_SpeciesEvolver.ipynb
    │       │   └── img/
    │       ├── tectonics/
    │       │   └── listric_kinematic_extender.ipynb
    │       ├── terrain_analysis/
    │       │   ├── chi_finder/
    │       │   │   ├── chi_finder.ipynb
    │       │   │   └── west_bijou_escarpment_snippet.prj
    │       │   ├── drainage_density/
    │       │   │   └── drainage_density.ipynb
    │       │   ├── flow__distance_utility/
    │       │   │   └── application_of_flow__distance_utility.ipynb
    │       │   ├── hack_calculator/
    │       │   │   └── hack_calculator.ipynb
    │       │   └── steepness_finder/
    │       │       └── steepness_finder.ipynb
    │       ├── tidal_flow/
    │       │   └── tidal_flow_calculator.ipynb
    │       └── visualization/
    │           ├── blender/
    │           │   └── landlab_to_blender.ipynb
    │           └── paraview/
    │               ├── importing_landlab_netcdf_to_paraview.ipynb
    │               └── assets/
    ├── requirements/
    │   ├── README.md
    │   ├── docs.txt
    │   ├── notebooks.txt
    │   ├── required.txt
    │   └── testing.txt
    ├── scripts/
    ├── src/
    ├── tests/
    └── .github/

================================================
File: README.md
================================================
![[DOI][doi-link]][doi-badge]
![[Documentation][rtd-link]][rtd-badge]
![[Coverage][coveralls-link]][coveralls-badge]
![[Testing][test-link]][test-badge]
![[Lint][lint-link]][lint-badge]


[coveralls-badge]: https://coveralls.io/repos/landlab/landlab/badge.png
[coveralls-link]: https://coveralls.io/r/landlab/landlab
[doi-badge]: https://zenodo.org/badge/DOI/10.5281/zenodo.3776837.svg
[doi-link]: https://doi.org/10.5281/zenodo.3776837
[lint-badge]: https://github.com/landlab/landlab/actions/workflows/lint.yml/badge.svg
[lint-link]: https://github.com/landlab/landlab/actions/workflows/lint.yml
[rtd-badge]:https://readthedocs.org/projects/landlab/badge/?version=latest
[rtd-link]: https://landlab.csdms.io
[test-badge]: https://github.com/landlab/landlab/actions/workflows/test.yml/badge.svg
[test-link]: https://github.com/landlab/landlab/actions/workflows/test.yml

# Landlab

## What does Landlab do?

<!-- start-intro -->

Landlab is an open-source Python-language package for numerical modeling of
Earth surface dynamics. It contains

- A gridding engine which represents the model domain. Regular and irregular
  grids are supported.
- A library of process components, each of which represents a physical process
  (e.g., generation of rain, erosion by flowing water). These components have
  a common interface and can be combined based on a user's needs.
- Utilities that support general numerical methods, file input/output, and
  visualization.

In addition Landlab contains a set of Jupyter notebook tutorials providing
an introduction to core concepts and examples of use.

Landlab was designed for disciplines that quantify Earth surface dynamics such
as geomorphology, hydrology, glaciology, and stratigraphy. It can also be used
in related fields. Scientists who use this type of model often build
their own unique model from the ground up, re-coding the basic building blocks
of their landscape model rather than taking advantage of codes that have
already been written. Landlab saves practitioners from the need for this kind
of re-invention by providing standardized components that they can re-use.

Watch the webinar [Landlab Toolkit Overview](https://csdms.colorado.edu/wiki/Presenters-0407)
at CSDMS to learn more.

<!-- end-intro -->

______________________________________________________________________

[Read the documentation on ReadTheDocs!](https://landlab.csdms.io/)

______________________________________________________________________

## Installation

To install the latest release of *landlab* using *pip*, simply run the following
in your terminal of choice:

```bash
$ pip install landlab
```

For a full description of how to install *Landlab*, including using *mamba*/*conda*,
please see the documentation for our [installation instructions].

## Source code

If you would like to modify or contribute code to *Landlab* or use the very latest
development version, please see the documentation that describes how to
[install landlab from source].

## Are there any examples of using Landlab I can look at?

The Landlab package contains a directory, `landlab/notebooks`, with
Jupyter Notebooks describing core concepts and giving examples of using components.
The file `landlab/notebooks/welcome.ipynb` provides a table of contents to
the notebooks and is the recommended starting place.
Additionally, there are a set of notebooks curated to teach physical processes
located in the directory `landlab/notebooks/teaching`.

### Run on Binder

To launch an instance of
Binder and [explore the notebooks click here].

To launch a Binder instance that goes straight to the [teaching notebooks click here].

### Run on EarthscapeHub

The Landlab notebooks can also be run on [EarthscapeHub].
Visit this link to learn how to sign up for a free account.
Explore the example notebooks on the
[lab](https://lab.openearthscape.org/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Flandlab%2Flandlab&urlpath=lab%2Ftree%2Flandlab%2Fnotebooks%2Fwelcome.ipynb&branch=master) or [jupyter](https://jupyter.openearthscape.org/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Flandlab%2Flandlab&urlpath=lab%2Ftree%2Flandlab%2Fnotebooks%2Fwelcome.ipynb&branch=master) Hub instance.
Or, use the teaching notebooks on the
[lab](https://lab.openearthscape.org/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Flandlab%2Flandlab&urlpath=lab%2Ftree%2Flandlab%2Fnotebooks%2Fteaching%2Fwelcome_teaching.ipynb&branch=master) or [jupyter](https://jupyter.openearthscape.org/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Flandlab%2Flandlab&urlpath=lab%2Ftree%2Flandlab%2Fnotebooks%2Fteaching%2Fwelcome_teaching.ipynb&branch=master) Hub instance.
Be sure to run all notebooks with the *CSDMS* kernel.

## License

*landlab* is licensed under the MIT License.

## Citing Landlab

If you use any portion of Landlab, please see the documentation for our
[citation guidelines].

## Contact

<!-- start-contact -->

The recommended way to contact the Landlab team is with a
[GitHub Issue](https://github.com/landlab/landlab/issues).

- **Bug reports**: Please make an Issue describing the bug so we can address it, or work
  with you to address it. Please try to provide a [minimal, reproducible example](https://stackoverflow.com/help/minimal-reproducible-example).
- **Documentation**: If something in our documentation is not clear to you, please make an
  issue describing the what isn't clear. Someone will tag
  the most appropriate member of the core Landlab team. We will work to clarify
  your question and revise the documentation so that it is clear for the next user.

Keep in touch with the latest *landlab* news by following us on [Twitter](https://twitter.com/landlabtoolkit).

During workshops and clinics, we sometimes use the
[Landlab Slack channel](https://landlab.slack.com).

<!-- end-contact -->

[citation guidelines]: https://landlab.csdms.io/about/citing.html
[earthscapehub]: https://csdms.colorado.edu/wiki/JupyterHub
[explore the notebooks click here]: https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/welcome.ipynb
[install landlab from source]: https://landlab.csdms.io/install/
[installation instructions]: https://landlab.csdms.io/installation.html
[teaching notebooks click here]: https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/teaching/welcome_teaching.ipynb



================================================
File: CITATION.cff
================================================
# YAML 1.2
---
cff-version: "1.2.0"
message: "If you use this software, please cite it using these metadata."
abstract : "Landlab is an open-source Python-language package for numerical modeling of Earth surface dynamics."
type: software
authors:
  -
    family-names: Hutton
    given-names: Eric
    orcid: "https://orcid.org/0000-0002-5864-6459"
  -
    family-names: Barnhart
    given-names: Katy
    orcid: "https://orcid.org/0000-0001-5682-455X"
  -
    family-names: Hobley
    given-names: Dan
    orcid: "https://orcid.org/0000-0003-2371-0534"
  -
    family-names: Tucker
    given-names: Greg
    orcid: "https://orcid.org/0000-0003-0364-5800"
  -
    family-names: Nudurupati
    given-names: Sai
    orcid: "https://orcid.org/0000-0002-2090-7561"
  -
    family-names: Adams
    given-names: Jordan
    orcid: "https://orcid.org/0000-0003-0137-9879"
  -
    family-names: Gasparini
    given-names: Nicole
    orcid: "https://orcid.org/0000-0002-0803-3697"
  -
    family-names: Shobe
    given-names: Charlie
    orcid: "https://orcid.org/0000-0003-3015-1283"
  -
    family-names: Strauch
    given-names: Ronda
    orcid: "https://orcid.org/0000-0003-3093-8449"
  -
    family-names: Knuth
    given-names: Jenny
    orcid: "https://orcid.org/0000-0001-7066-7992"
  -
    family-names: Mouchene
    given-names: Margaux
    orcid: "https://orcid.org/0000-0002-8243-3517"
  -
    family-names: Lyons
    given-names: Nathan
    orcid: "https://orcid.org/0000-0001-6965-3374"
  -
    family-names: Litwin
    given-names: David
    orcid: "https://orcid.org/0000-0002-8097-4029"
  -
    family-names: Glade
    given-names: Rachel
    orcid: "https://orcid.org/0000-0002-0345-1953"
  -
    name: Giuseppecipolla95
  -
    family-names: Manaster
    given-names: Amanda
  -
    family-names: Abby
    given-names: Langston
  -
    family-names: Thyng
    given-names: Kristen
    orcid: "https://orcid.org/0000-0002-8746-614X"
  -
    family-names: Rengers
    given-names: Francis
    orcid: "https://orcid.org/0000-0002-1825-0943"
title: "landlab"
identifiers:
  -
    type: doi
    value: 10.5194/esurf-8-379-2020
    description: >-
      "Short communication: Landlab v2.0: A software package for
      Earth surface dynamics". Earth Surface Dynamics Discussions,
      May 2020, Volume 8, Issue 2
  -
    type: doi
    value: 10.5194/esurf-5-21-2017
    description: >-
      "Creative computing with Landlab: an open-source
       toolkit for building, coupling, and exploring
       two-dimensional numerical models of
       Earth-surface dynamics". Earth Surface Dynamics,
       January 2017, Volume 5, Issue 1
  -
    type: doi
    value: 10.5281/zenodo.3776837
    description: The versioned DOI for the version 2.0.1 of landlab.
  -
    type: doi
    value: 10.5281/zenodo.595872
    description: The concept DOI for the collection containing all versions of landlab.
repository-code: "https://github.com/landlab/landlab"
url: "https://landlab.csdms.io"
date-released: "2020-04-29"
keywords:
  - "bmi"
  - "component modeling"
  - "earth science"
  - "gridding engine"
  - "model coupling"
  - "numerical modeling"
license: MIT
doi: 10.5281/zenodo.595872
...



================================================
File: CONTRIBUTING.md
================================================
# Contributing to landlab

Thank you for contributing to Landlab! We appreciate
your help as this is largely as volunteer effort! :heart: :heart: :heart:

# How to contribute

## Reporting Bugs

Before creating a bug report, please do at least a cursory check that the
bug has not already been reported by searching the Issues portion of the
GitHub repository. If it has, add a comment to the existing issue instead of
opening a new one.

### Submitting a Bug Report

Bugs are tracked as
[GitHub issues](https://guides.github.com/features/issues/). After you've
determined you've found a new bug, please open a
[new issue](https://github.com/landlab/landlab/issues).

Explain the problem and include additional details to help maintainers
reproduce the problem. Here are some items that will make it easier
to track down the source of the problem.

*  **Use a clear and descriptive title** for the issue that identifies the
   problem.
*  **Describe the exact steps that reproduce the problem**.
*  **Provide a [minimal example](https://stackoverflow.com/help/minimal-reproducible-example)
   that demonstrates the steps** as, for example, a bash script
   along with input files. This example should reproduce your
   problem with as few lines of code as possible and easily
   reproducible my another person. Such an example almost certainly will not
   include an input file or any dependencies beyond those required by the
   `landlab_dev` conda environment.
*  **Describe the behavior you are seeing after these steps**.
*  **Describe the behavior you expect to see after these steps**.

Additionally, the answers to the following questions about your run
environment will be helpful.

*  **Which version of landlab are you using?** This could be a specific
   git sha or a release number. The best way to find this information is to
   import landlab and evaluate `landlab.__version__`
*  **What is he name and version of you OS?**
*  **What compiler are you using?**
*  **How did you build landlab (if using the development version)?**


## Submitting Changes

:tada: Whoa! This is great! We love it when folks contibute code! :tada:

Changes to landlab should be submitted as
[pull requests](http://help.github.com/pull-requests/)).

*  Create a GitHub issue that describes what you propose to do.
*  Create a topic branch that contains your changes.
*  Open a new [GitHub pull request](https://github.com/landlab/landlab/pull/new/master).
*  Ensure the pull request description clearly describes the problem
   and solution. Include the relevant issue number.

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally
* For fun, consider starting the commit message with an applicable emoji:
    * :art: `:art:` when improving the format/structure of the code
    * :racehorse: `:racehorse:` when improving performance
    * :non-potable_water: `:non-potable_water:` when plugging memory leaks
    * :memo: `:memo:` when writing docs
    * :penguin: `:penguin:` when fixing something on Linux
    * :apple: `:apple:` when fixing something on macOS
    * :checkered_flag: `:checkered_flag:` when fixing something on Windows
    * :bug: `:bug:` when fixing a bug
    * :fire: `:fire:` when removing code or files
    * :green_heart: `:green_heart:` when fixing the CI build
    * :white_check_mark: `:white_check_mark:` when adding tests
    * :shirt: `:shirt:` when removing linter warnings

### Pull Request Messages

  * Rename the pull request and provide a comment that synthesizes what
    the pull request changes or adds. This helps us synthesize what
    changes have occured between Landlab releases.

## Adding new components

If you would like to create a new component, we a few conventions that we would
like you to follow.

Please visit [this part](https://landlab.csdms.io/install/)
of the main Landlab documentation page to read about developer installation,
guidelines to contributing code, and our software development practices.

**Landlab 2 is Python >=3.6 only.**

Thanks! :heart: :heart: :heart:

The Landlab team



================================================
File: LICENSE.md
================================================
# The MIT License (MIT)

Copyright (c) `2013` `The Landlab Team`

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
File: MANIFEST.in
================================================
include .credits.toml
include .mailmap
include AUTHORS.rst
include CHANGES.rst
include FUNDING.rst
include LICENSE.rst
include README.rst
include USEDBY.rst
include CITATION.cff
include cython-files.txt
include requirements*
include noxfile.py
include notebooks.py

recursive-include docs *.txt
recursive-include landlab README.md
recursive-include requirements *.md *.txt
recursive-include src/landlab *.pyx *.pxd *.hpp
recursive-include src/landlab/data *
recursive-include tests *py
recursive-include tests *.asc
recursive-include tests *.dbf
recursive-include tests *.nc
recursive-include tests *.shp
recursive-include tests *.shx
recursive-include tests *.txt
recursive-include tests *.yaml
recursive-include tests *.pyx *.pxd *.hpp

exclude .readthedocs.yaml
exclude conftest.py
exclude CONTRIBUTING.md
exclude environment*yml
exclude .pre-commit-config.yaml

recursive-exclude docs *
recursive-exclude joss *
recursive-exclude news *
recursive-exclude notebooks *
recursive-exclude scripts *py
recursive-exclude scripts *sh
recursive-exclude landlab *.c *.cpp
recursive-exclude tests *.c *.cpp

prune */__pycache__
global-exclude *.so *.pyc *.pyo *.pyd *.swp *.bak *~



================================================
File: conftest.py
================================================
import numpy as np
import pytest


@pytest.fixture(scope="session", autouse=True)
def set_numpy_printoptions():
    np.set_printoptions(legacy="1.25")



================================================
File: environment-dev.yml
================================================
name: landlab_dev
dependencies:
- pip
- pip:
  - -r requirements.txt
  - -r requirements-testing.txt
  - -r requirements-dev.txt
  - -r requirements-notebooks.txt
  - -r requirements-docs.txt



================================================
File: environment.yml
================================================
name: landlab_notebooks
channels:
  - conda-forge
dependencies:
- landlab>=2.1
- pip
- pip:
  - -r notebooks/requirements.in



================================================
File: notebooks.py
================================================
"""Get the landlab tutorial and teaching notebooks.

Run this script to fetch the set of *landlab* notebooks compatible with
an installed version of landlab.

Usage
-----

Get notebooks for a currently installed *landlab*,

    $ python -m notebooks

To get notebooks for a particular version of *landlab*, provide
a version number as an argument. For example,

    $ python -m notebooks 2.5.0
"""

import argparse
import os
import pathlib
import sys
import tarfile
from urllib.error import HTTPError
from urllib.parse import urljoin
from urllib.request import urlopen

from packaging.version import Version


def main(version=None):
    if version in ("master", "latest", "dev"):
        version = None

    if not version or (version := Version(version)).is_devrelease:
        tag = "master"
    else:
        tag = "v" + version.base_version

    notebooks = NotebookFetcher(tag)

    out(f"fetching notebooks for landlab {notebooks.version}")
    out(f"{notebooks.url}")

    try:
        stream = notebooks.open()
    except NotebookError as error:
        err(str(error))
        return -1

    with tarfile.open(fileobj=stream, mode="r|gz") as tfile:
        base = NotebookExtractor(tfile).extract()

    out(f"notebooks have been extracted into {base}")
    out("To run the notebooks first install the required dependencies:")
    out("")
    out(f"    $ conda install --file={base}/requirements-notebooks.txt")
    out("")
    out("and then open the welcome notebook:")
    out("")
    out(f"    $ jupyter notebook {base}/notebooks/welcome.ipynb")
    print(base)

    return 0


class NotebookError(Exception):
    def __init__(self, msg):
        self._msg = msg

    def __str__(self):
        return self._msg


class NotebookFetcher:
    URL = "https://github.com/landlab/landlab/archive/refs"

    def __init__(self, version):
        self._version = version

    @property
    def version(self):
        return self._version

    @property
    def url(self):
        return urljoin(NotebookFetcher.URL, f"{self.version}.tar.gz")

    def open(self):
        try:
            stream = urlopen(self.url)
        except HTTPError as error:
            if error.code == 404:
                msg = f"unable to find notebooks for requested landlab version ({self.version})"
            else:
                msg = f"unable to fetch notebooks ({error.reason})"
            raise NotebookError(msg) from error
        else:
            return stream


class NotebookExtractor:
    def __init__(self, tfile):
        self._tfile = tfile
        self._names = []

    def extract(self):
        self._tfile.extractall(members=self._notebooks())
        return self.base

    def _notebooks(self):
        for tarinfo in self._tfile:
            parts = pathlib.Path(tarinfo.name).parts
            if (len(parts) > 1 and parts[1] == "notebooks") or (
                parts[-1] == "requirements-notebooks.txt"
            ):
                self._names.append(tarinfo.name)
                yield tarinfo

    @property
    def names(self):
        return sorted(self._names)

    @property
    def base(self):
        return pathlib.Path(os.path.commonprefix(self.names))


def out(text):
    print("\033[1m" + text + "\033[0m", file=sys.stderr)


def err(text):
    print("\033[91m" + text + "\033[0m", file=sys.stderr)


if __name__ == "__main__":
    try:
        import landlab
    except ModuleNotFoundError:
        version = ""
    else:
        version = landlab.__version__

    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "version",
        metavar="VERSION",
        nargs="?",
        default=version,
        help="a landlab version (e.g. 2.5.0)",
    )
    args = parser.parse_args()

    sys.exit(main(args.version))



================================================
File: noxfile.py
================================================
import difflib
import glob
import json
import os
import pathlib
import shutil

import nox
from packaging.requirements import Requirement

PROJECT = "landlab"
ROOT = pathlib.Path(__file__).parent
PYTHON_VERSION = "3.12"
PATH = {
    "build": ROOT / "build",
    "docs": ROOT / "docs",
    "nox": pathlib.Path(".nox"),
    "requirements": ROOT / "requirements",
    "root": ROOT,
}


@nox.session(python=PYTHON_VERSION)
def build(session: nox.Session) -> str:
    """Build sdist and wheel dists."""
    outdir = str(PATH["build"] / "wheelhouse")

    os.environ["WITH_OPENMP"] = "1"

    session.log(f"CC = {os.environ.get('CC', 'NOT FOUND')}")
    session.install(
        "build",
        *("-r", PATH["requirements"] / "required.txt"),
    )

    session.run("python", "-m", "build", "--outdir", outdir)

    return outdir


@nox.session(python=PYTHON_VERSION)
def install(session: nox.Session) -> None:
    arg = session.posargs[0] if session.posargs else build(session)

    session.install("-r", PATH["requirements"] / "required.txt")

    if os.path.isdir(arg):
        session.install("landlab", f"--find-links={arg}", "--no-deps", "--no-index")
    elif os.path.isfile(arg):
        session.install(arg, "--no-deps")
    else:
        session.error("first argument must be either a wheel or a wheelhouse folder")


@nox.session(python=PYTHON_VERSION)
def test(session: nox.Session) -> None:
    """Run the tests."""
    session.install("-r", PATH["requirements"] / "testing.txt")
    install(session)

    session.run(
        "coverage",
        "run",
        "--source=landlab,tests",
        "--branch",
        "--module",
        "pytest",
        env={"PYTEST_ADDOPTS": os.environ.get("PYTEST_ADDOPTS", "-m 'not richdem'")},
    )
    session.run("coverage", "report", "--ignore-errors", "--show-missing")
    session.run("coverage", "xml", "-o", "coverage.xml")


@nox.session(name="test-notebooks", python=PYTHON_VERSION)
def test_notebooks(session: nox.Session) -> None:
    """Run the notebooks."""
    session.install(
        "git+https://github.com/mcflugen/nbmake.git@v1.5.4-markers",
        *("-r", PATH["requirements"] / "testing.txt"),
        *("-r", PATH["requirements"] / "notebooks.txt"),
    )
    install(session)

    session.run(
        "pytest",
        "notebooks",
        "--nbmake",
        "--nbmake-kernel=python3",
        "--nbmake-timeout=3000",
        *("-n", "auto"),
        "-vvv",
        env={"PYTEST_ADDOPTS": os.environ.get("PYTEST_ADDOPTS", "-m 'not richdem'")},
    )


@nox.session(name="test-richdem", venv_backend="conda")
def test_richdem(session: nox.Session) -> None:
    """Run richdem tests."""
    session.conda_install("richdem", channel=["nodefaults", "conda-forge"])
    session.install(
        "git+https://github.com/mcflugen/nbmake.git@v1.5.4-markers",
        *("-r", PATH["requirements"] / "testing.txt"),
        *("-r", PATH["requirements"] / "notebooks.txt"),
    )
    install(session)

    session.run(
        "coverage",
        "run",
        "--source=landlab,tests",
        "--branch",
        "--module",
        "pytest",
        "tests",
        "notebooks",
        "--nbmake",
        "--nbmake-kernel=python3",
        "--nbmake-timeout=3000",
        *("-m", "richdem"),
        *("-n", "auto"),
        "-vvv",
    )
    session.run("coverage", "report", "--ignore-errors", "--show-missing")
    session.run("coverage", "xml", "-o", "coverage.xml")


@nox.session(name="test-cli")
def test_cli(session: nox.Session) -> None:
    """Test the command line interface."""
    install(session)
    session.run("landlab", "--help")
    session.run("landlab", "--version")
    session.run("landlab", "index", "--help")
    session.run("landlab", "list", "--help")
    session.run("landlab", "provided-by", "--help")
    session.run("landlab", "provides", "--help")
    session.run("landlab", "used-by", "--help")
    session.run("landlab", "uses", "--help")
    session.run("landlab", "validate", "--help")


@nox.session
def lint(session: nox.Session) -> None:
    """Look for lint."""
    skip_hooks = [] if "--no-skip" in session.posargs else ["check-manifest", "pyroma"]

    if session.virtualenv.venv_backend != "none":
        session.install("pre-commit")

    session.run("pre-commit", "run", "--all-files", env={"SKIP": ",".join(skip_hooks)})


@nox.session
def towncrier(session: nox.Session) -> None:
    """Check that there is a news fragment."""
    session.install("towncrier")
    session.run("towncrier", "check", "--compare-with", "origin/master")


@nox.session(name="build-index")
def build_index(session: nox.Session) -> None:
    index_file = ROOT / "docs" / "index.toml"
    header = """
# This file was automatically generated with:
#     nox -s build-index
    """.strip()

    session.install("sphinx")
    session.install(".")

    with open(index_file, "w") as fp:
        print(header, file=fp, flush=True)
        session.run(
            "landlab", "--silent", "index", "components", "fields", "grids", stdout=fp
        )
    session.log(f"generated index at {index_file!s}")


@nox.session(name="docs-build")
def docs_build(session: nox.Session) -> None:
    """Build the docs."""
    docs_build_api(session)
    docs_build_notebook_index(session)

    session.install("-r", PATH["requirements"] / "docs.txt")

    PATH["build"].mkdir(exist_ok=True)
    session.run(
        "sphinx-build",
        *("-j", "auto"),
        *("-b", "html"),
        # "-W",
        "--keep-going",
        PATH["docs"] / "source",
        PATH["build"] / "html",
    )
    session.log(f"generated docs at {PATH['build'] / 'html'!s}")


@nox.session(name="docs-check-links")
def docs_check_links(session: nox.Session) -> None:
    """Check for working links in the docs."""
    docs_build_api(session)
    docs_build_notebook_index(session)

    session.install("-r", PATH["requirements"] / "docs.txt")

    PATH["build"].mkdir(exist_ok=True)
    session.run(
        "sphinx-build",
        *("-j", "auto"),
        *("-b", "linkcheck"),
        "--keep-going",
        PATH["docs"] / "source",
        PATH["build"] / "html",
        success_codes=(0, 1),
    )

    output_json = PATH["build"] / "html" / "output.json"

    broken_links = [
        f"{entry['filename']}:{entry['lineno']}:{entry['uri']}"
        for entry in load_linkcheck_output(output_json)
        if entry["status"] == "broken" and not entry["info"].startswith("403")
    ]

    if broken_links:
        print("\n".join(sorted(broken_links)))
        session.error(
            f"{len(broken_links)} broken links were found."
            f" see {output_json} for a complete log"
        )
    else:
        session.log("no broken links were found")


def load_linkcheck_output(filepath):
    with open(filepath) as stream:
        entries = [json.loads(line) for line in stream.readlines()]
    return entries


@nox.session(name="docs-build-api")
def docs_build_api(session: nox.Session) -> None:
    docs_dir = PATH["docs"] / "source"

    generated_dir = os.path.join(docs_dir, "generated", "api")

    if session.virtualenv.venv_backend != "none":
        session.install("-r", PATH["requirements"] / "docs.txt")

    session.log(f"generating api docs in {generated_dir}")
    session.run(
        "sphinx-apidoc",
        "-e",
        "-force",
        "--no-toc",
        "--module-first",
        *("-d", "2"),
        f"--templatedir={docs_dir / '_templates'}",
        *("-o", generated_dir),
        "src/landlab",
        "*.pyx",
        "*.so",
    )


@nox.session(name="docs-build-gallery-index", python=None)
def docs_build_notebook_index(session: nox.Session) -> None:
    docs_dir = PATH["docs"] / "source"

    for gallery in ("tutorials", "teaching"):
        gallery_index = docs_dir / "generated" / gallery / "index.md"
        os.makedirs(os.path.dirname(gallery_index), exist_ok=True)

        sections = [
            os.path.abspath(f.path)
            for f in os.scandir(docs_dir / gallery)
            if f.is_dir()
        ]

        content = (
            [
                f"""\
({gallery}-gallery)=

# {gallery.title()} Gallery
"""
            ]
            + [
                format_nbgallery(section, str(docs_dir), level=2)
                for section in sorted(sections)
            ]
        )

        with open(gallery_index, "w") as fp:
            print((2 * os.linesep).join(content), file=fp)

        session.log(gallery_index)


def format_nbgallery(path, start, level=1):
    title = pathlib.Path(path).stem.replace("_", " ").title()

    p = os.path.relpath(path, start)

    files = []
    if glob.glob(os.path.join(path, "*.ipynb")):
        files += [f"/{p}/*"]
    if glob.glob(os.path.join(path, "**/*.ipynb")):
        files += [f"/{p}/**"]

    body = "\n".join(files)
    return (
        f"""\
{'#' * level} {title}

```{{nbgallery}}
:glob:

{body}
```
"""
        if files
        else ""
    )


@nox.session(name="check-versions")
def check_package_versions(session, files=("required.txt",)):
    output_lines = session.run("pip", "list", "--format=json", silent=True).splitlines()

    installed_version = {
        p["name"].lower(): p["version"] for p in json.loads(output_lines[0])
    }

    for file_ in files:
        required_version = {}
        with (PATH["requirements"] / file_).open() as fp:
            for line in fp.readlines():
                requirement = Requirement(line)
                required_version[requirement.name.lower()] = requirement.specifier

        mismatch = set()
        for name, version in required_version.items():
            if name not in installed_version or not version.contains(
                installed_version[name]
            ):
                mismatch.add(name)

        session.log(f"Checking installed package versions for {file_}")
        for name in sorted(required_version):
            print(f"[{name}]")
            print(f"requested = {str(required_version[name])!r}")
            if name in installed_version:
                print(f"installed = {installed_version[name]!r}")
            else:
                print("installed = false")

        if mismatch:
            session.warn(
                f"There were package version mismatches for packages required in {file_}"
            )


@nox.session
def locks(session: nox.Session) -> None:
    """Create lock files."""
    folders = session.posargs or [".", "docs", "notebooks"]

    session.install("pip-tools")

    def upgrade_requirements(src, dst="requirements.txt"):
        with open(dst, "wb") as fp:
            session.run("pip-compile", "--upgrade", src, stdout=fp)

    for folder in folders:
        with session.chdir(ROOT / folder):
            upgrade_requirements("requirements.in", dst="requirements.txt")

    for folder in folders:
        session.log(f"updated {ROOT / folder / 'requirements.txt'!s}")

    # session.install("conda-lock[pip_support]")
    # session.run("conda-lock", "lock", "--mamba", "--kind=lock")


@nox.session(name="sync-requirements", python=PYTHON_VERSION, venv_backend="conda")
def sync_requirements(session: nox.Session) -> None:
    """Sync requirements.in with pyproject.toml."""
    with open("requirements.in", "w") as fp:
        session.run(
            "python",
            "-c",
            """
import os, tomllib
with open("pyproject.toml", "rb") as fp:
    print(os.linesep.join(sorted(tomllib.load(fp)["project"]["dependencies"])))
""",
            stdout=fp,
        )


@nox.session(python=False, name="check-cython-files")
def check_cython_files(session: nox.Session) -> None:
    """Find cython files for extension modules."""
    cython_files = {
        str(p.relative_to(PATH["root"]))
        for p in pathlib.Path(PATH["root"] / "src" / "landlab").rglob("**/*.pyx")
    }
    print(os.linesep.join(sorted(cython_files)))

    with open("cython-files.txt") as fp:
        actual = [line.rstrip() for line in fp.readlines()]

    diff = list(
        difflib.unified_diff(
            actual, sorted(cython_files), fromfile="old", tofile="new", lineterm=""
        )
    )
    if diff:
        session.error("\n".join([""] + diff + ["cython-files.txt needs updating"]))


@nox.session
def release(session):
    """Tag, build and publish a new release to PyPI."""
    session.install("zest.releaser[recommended]")
    session.install("zestreleaser.towncrier")
    session.run("fullrelease")


@nox.session(name="publish-testpypi")
def publish_testpypi(session):
    """Publish wheelhouse/* to TestPyPI."""
    session.run("twine", "check", "build/wheelhouse/*")
    session.run(
        "twine",
        "upload",
        "--skip-existing",
        "--repository-url",
        "https://test.pypi.org/legacy/",
        "build/wheelhouse/*.tar.gz",
    )


@nox.session(name="publish-pypi")
def publish_pypi(session):
    """Publish wheelhouse/* to PyPI."""
    session.run("twine", "check", "build/wheelhouse/*")
    session.run(
        "twine",
        "upload",
        "--skip-existing",
        "build/wheelhouse/*.tar.gz",
    )


@nox.session(python=False)
def clean(session):
    """Remove all .venv's, build files and caches in the directory."""
    for folder in _args_to_folders(session.posargs):
        with session.chdir(folder):
            shutil.rmtree("build", ignore_errors=True)
            shutil.rmtree("build/wheelhouse", ignore_errors=True)
            shutil.rmtree(f"src/{PROJECT}.egg-info", ignore_errors=True)
            shutil.rmtree(".pytest_cache", ignore_errors=True)
            shutil.rmtree(".venv", ignore_errors=True)

            for pattern in ["*.py[co]", "__pycache__"]:
                _clean_rglob(pattern)


@nox.session(python=False, name="clean-checkpoints")
def clean_checkpoints(session):
    """Remove jupyter notebook checkpoint files."""
    for folder in _args_to_folders(session.posargs):
        with session.chdir(folder):
            _clean_rglob("*-checkpoint.ipynb")
            _clean_rglob(".ipynb_checkpoints")


@nox.session(python=False, name="clean-docs")
def clean_docs(session: nox.Session) -> None:
    """Clean up the docs folder."""
    if (PATH["build"] / "html").is_dir():
        with session.chdir(PATH["build"]):
            shutil.rmtree("html")

    if PATH["build"].is_dir():
        session.chdir(PATH["build"])
        if os.path.exists("html"):
            shutil.rmtree("html")


@nox.session(python=False, name="clean-ext")
def clean_ext(session: nox.Session) -> None:
    """Clean shared libraries for extension modules."""
    for folder in _args_to_folders(session.posargs):
        with session.chdir(folder):
            _clean_rglob("*.so")


@nox.session(python=False)
def nuke(session):
    """Run all clean sessions."""
    clean_checkpoints(session)
    clean_docs(session)
    clean(session)
    clean_ext(session)


@nox.session(name="list-wheels")
def list_wheels(session):
    print(os.linesep.join(_get_wheels(session)))


@nox.session(name="list-ci-matrix")
def list_ci_matrix(session):
    """Create a matrix entry for a gha workflow that builds wheels"""

    def _os_from_wheel(name):
        if "linux" in name:
            return "ubuntu-" + ("24.04" if name.endswith("x86_64") else "24.04-arm")
        elif "macos" in name:
            return "macos-" + ("13" if name.endswith("x86_64") else "14")
        elif "win" in name:
            return "windows-2022"

    include_lines = [
        f"- {{ os: {_os_from_wheel(wheel)}, cibw-only: {wheel} }}"
        for wheel in _get_wheels(session)
    ]
    print("\n".join(sorted(include_lines)))


def _get_wheels(session):
    platforms = session.posargs or ["linux", "macos", "windows"]
    session.install("cibuildwheel")

    wheels = []
    for platform in platforms:
        wheels += session.run(
            "cibuildwheel",
            "--print-build-identifiers",
            "--platform",
            platform,
            silent=True,
        ).splitlines()
    return wheels


def _args_to_folders(args):
    return [ROOT] if not args else [pathlib.Path(f) for f in args]


def _clean_rglob(pattern):
    for p in pathlib.Path(".").rglob(pattern):
        if PATH["nox"] in p.parents:
            continue
        if p.is_dir():
            p.rmdir()
        else:
            p.unlink()


@nox.session
def credits(session):
    """Update the various authors files."""
    from landlab.cmd.authors import AuthorsConfig

    config = AuthorsConfig()

    with open(".mailmap", "wb") as fp:
        session.run(
            "landlab", "--silent", "authors", "mailmap", stdout=fp, external=True
        )

    contents = session.run(
        "landlab",
        "--silent",
        "authors",
        "create",
        "--update-existing",
        external=True,
        silent=True,
    )
    with open(config["credits_file"], "w") as fp:
        print(contents, file=fp, end="")

    contents = session.run(
        "landlab", "--silent", "authors", "build", silent=True, external=True
    )
    with open(config["authors_file"], "w") as fp:
        print(contents, file=fp, end="")



================================================
File: pyproject.toml
================================================
[build-system]
requires = ["cython", "numpy>=2.0,<3", "setuptools", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "landlab"
description = "Open-source Python package for numerical modeling of Earth surface dynamics."
authors = [
  {email = "mcflugen@gmail.com"},
  {name = "The landlab team"}
]
maintainers = [
  {email = "mcflugen@gmail.com"},
  {name = "The landlab team"}
]
keywords = [
  "bmi",
  "component modeling",
  "earth science",
  "gridding engine",
  "model coupling",
  "numerical modeling",
]
classifiers = [
  "Development Status :: 4 - Beta",
  "Intended Audience :: Science/Research",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Cython",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: 3.13",
  "Programming Language :: Python :: Implementation :: CPython",
  "Topic :: Scientific/Engineering :: Physics",
]
requires-python = ">=3.10"
dependencies = [
  "bmipy",
  "importlib-resources; python_version < '3.12'",
  "matplotlib",
  "netcdf4",
  "numpy >=1.20",
  "pyyaml",
  "pyshp != 2.3.0",
  "rich-click",
  "scipy",
  "statsmodels",
  "pandas",
  "xarray >= 0.16",
]
dynamic = ["readme", "version"]

[project.license]
text = "MIT"

[project.urls]
homepage = "https://github.com/landlab"
documentation = "https://landlab.csdms.io"
repository = "https://github.com/landlab"
changelog = "https://github.com/landlab/landlab/blob/develop/CHANGES.md"

[project.optional-dependencies]
dev = ["nox"]
testing = [
  "coverage",
  "hypothesis",
  "pytest",
  "pytest-datadir",
  "pytest-xdist",
]

[project.scripts]
landlab = "landlab.cmd.landlab:landlab"

[tool.setuptools]
include-package-data = true
package-dir = { "" = "src" }

[tool.setuptools.package-data]
landlab = [
  "tests/*txt",
  "data/*asc",
  "data/*nc",
  "data/*shp",
  "test/*shx",
  "data/*dbf",
  "preciptest.in",
  "test_*/*nc",
  "test_*/*asc",
]

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.dynamic]
version = {attr = "landlab._version.__version__"}

[tool.setuptools.dynamic.readme]
file = ["README.md", "AUTHORS.md"]
content-type = "text/markdown"

[tool.pytest.ini_options]
minversion = "6.0"
testpaths = ["notebooks", "landlab", "tests"]
norecursedirs = [".*", "*.egg*", "build", "dist", "examples"]
addopts = """
  --ignore setup.py
  --tb native
  --durations 16
  --strict-markers
  --doctest-modules
  -vvv
  --ignore-glob=*/animate-landlab-output.ipynb
  --ignore-glob=*/cellular_automaton_vegetation_flat_domain.ipynb
  --ignore-glob=*/cellular_automaton_vegetation_DEM.ipynb
  --ignore-glob=*/lithology_and_litholayers.ipynb
  --ignore-glob=*/nst_scaling_profiling.ipynb
  --ignore-glob=*/test_networkcreator_otherDEMs.ipynb
  --ignore-glob=*/run_network_generator_OpenTopoDEM.ipynb
"""
doctest_optionflags = [
  "NORMALIZE_WHITESPACE",
  "IGNORE_EXCEPTION_DETAIL"
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "richdem: marks tests that use richdem (deselect with '-m \"not richdem\"')",
    "notebook: marks tests as notebook (deselect with '-m \"not notebook\"')"
]

[tool.isort]
combine_as_imports = true
known_first_party = "landlab"
profile = "black"

[tool.check-manifest]
ignore = [".nox", "build"]

[tool.cibuildwheel]
build = "cp310-* cp311-* cp312-*"
skip = "*-musllinux_* *-win32*"
archs = "x86_64,aarch64,arm64,AMD64,x86"
test-command = [
	"python -c \"import landlab; print(landlab.__version__)\"",
	"python -c \"from landlab import RasterModelGrid; print(RasterModelGrid((3, 3)))\"",
]

[tool.cibuildwheel.linux.environment]
CPPFLAGS = "-fopenmp"

[tool.cibuildwheel.macos.environment]
MACOSX_DEPLOYMENT_TARGET = "12.0"
CC = "clang"
CXX = "clang++"
# CPPFLAGS = "-Xclang -fopenmp"
# LDFLAGS = "-lomp"

[tool.cython-lint]
max-line-length = 88
exclude = "tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx"

[tool.conda-lock]
channels = ["conda-forge", "defaults"]
platforms = ["osx-arm64", "linux-64", "osx-64", "win-64"]

[tool.towncrier]
directory = "news"
name = "landlab"
filename = "CHANGES.md"
create_add_extension = false
single_file = true
underlines = [
    "",
    "",
    "",
]
start_string = """
<!-- towncrier release notes start -->
"""
template = "news/changelog_template.jinja"
issue_format = "[#{issue}](https://github.com/landlab/landlab/issues/{issue})"
title_format = "## {version} ({project_date})"
type = [
  {name="✨ New Components", directory="component", showcontent=true},
  {name="📚 New Tutorial Notebooks", directory="notebook", showcontent=true},
  {name="🍰 New Features", directory="feature", showcontent=true},
  {name="🛠️ Bug Fixes", directory="bugfix", showcontent=true},
  {name="📖 Documentation Enhancements", directory="docs", showcontent=true},
  {name="🔩 Other Changes and Additions", directory="misc", showcontent=true},
]

[tool.landlab.credits]
exclude = '''
(?x)^(
  \(no\ author\)|
  root|
  .*\[bot\]  # ignore all bots
)
'''
authors_file = "AUTHORS.md"
author_format = "- [{name}](https://github.com/{github})"
start_string = "<!-- credits-roll start-author-list -->"



================================================
File: requirements-testing.in
================================================
# Requirements extracted from pyproject.toml
# [project.optional-dependencies] testing
coverage
flaky
hypothesis
pytest
pytest-datadir
pytest-xdist



================================================
File: requirements.in
================================================
bmipy
importlib-resources; python_version < '3.12'
matplotlib
netcdf4
numpy >=1.20
pandas
pyshp != 2.3.0
pyyaml
rich-click
scipy
statsmodels
xarray >= 0.16



================================================
File: setup.cfg
================================================
[flake8]
exclude = docs, build, .nox
ignore = C901, E203, E266, E501, E704, W503, B905
max-line-length = 88
max-complexity = 18
select = B,C,E,F,W,T4,B9

[zest.releaser]
tag-format = v{version}
python-file-with-version = src/landlab/_version.py

[coverage:run]
relative_files = True



================================================
File: setup.py
================================================
#! /usr/bin/env python
import numpy as np
from Cython.Build import cythonize
from setuptools import Extension
from setuptools import setup

with open("cython-files.txt") as fp:
    cython_files = {fname.strip() for fname in fp.readlines()}

ext_modules = cythonize(
    [
        Extension(
            path[4:-4].replace("/", "."),
            [path],
            define_macros=[("NPY_NO_DEPRECATED_API", "1")],
        )
        for path in cython_files
    ],
    compiler_directives={"embedsignature": True, "language_level": 3},
)

setup(
    include_dirs=[np.get_include()],
    ext_modules=ext_modules,
)



================================================
File: docs/Makefile
================================================
# Makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = sphinx-build
SPHINXAPIDOC  = sphinx-apidoc
SPHINXEXCLUDE = $(shell find ../landlab/* -name tests)
PAPER         =
SOURCEDIR     = source
BUILDDIR      = build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O) -W



================================================
File: docs/fix_redirects.py
================================================
# fix redirects
import fileinput
import os

_SRC = "source"

with open("build/linkcheck/output.txt") as f:
    link_out = f.readlines()


for link in link_out:
    if "redirected" in link:
        file_name = os.path.join(_SRC, link.split(":")[0])

        assert os.path.exists(file_name)

        old, new = link.strip().split("] ")[-1].split(" to ")

        with fileinput.FileInput(file_name, inplace=True) as file:
            for line in file:
                line.replace(old, new)



================================================
File: docs/index.toml
================================================

# Generated using `landlab index components`
[components]

[components.AdvectionSolverTVD]
name = 'landlab.components.advection.advection_solver_tvd.AdvectionSolverTVD'
unit_agnostic = true
summary = 'Numerical solution for advection using a Total Variation Diminishing method.'

[components.AdvectionSolverTVD.info.advected__quantity]
doc = 'Scalar quantity advected'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.AdvectionSolverTVD.info.advection__flux]
doc = 'Link-parallel advection flux'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = true
units = 'm2/y'

[components.AdvectionSolverTVD.info.advection__velocity]
doc = 'Link-parallel advection velocity magnitude'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm/y'

[components.AreaSlopeTransporter]
name = 'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter'
unit_agnostic = true
summary = 'Model drainage network evolution for a network of transport-limited'

[components.AreaSlopeTransporter.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.AreaSlopeTransporter.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.AreaSlopeTransporter.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.AreaSlopeTransporter.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.AreaSlopeTransporter.info.sediment__rate_of_change]
doc = 'Time rate of change of sediment thickness'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.AreaSlopeTransporter.info.sediment__volume_influx]
doc = 'Volumetric incoming streamwise sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.AreaSlopeTransporter.info.sediment__volume_outflux]
doc = 'Volumetric outgoing streamwise sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.AreaSlopeTransporter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.AreaSlopeTransporter.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedParcelInitializerArea]
name = 'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerArea'
unit_agnostic = false
summary = 'Create a *landlab* :class:`~.DataRecord` to represent parcels of sediment on'

[components.BedParcelInitializerArea.info.drainage_area_coefficient]
doc = 'Coefficient in a power law grain size-drainage area scaling relationship'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = '--'

[components.BedParcelInitializerArea.info.drainage_area_exponent]
doc = 'Exponent in a power law grain size-drainage area scaling relationship.'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = '--'

[components.BedParcelInitializerArea.info.time]
doc = 'The initial time to add to the record'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = true
units = 's'

[components.BedParcelInitializerDepth]
name = 'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerDepth'
unit_agnostic = false
summary = 'Create a *landlab* :class:`~.DataRecord` to represent parcels of sediment on'

[components.BedParcelInitializerDepth.info.flow_depth_at_link]
doc = 'Dominant/formative flow depth at each link in the network'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm'

[components.BedParcelInitializerDischarge]
name = 'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerDischarge'
unit_agnostic = false
summary = 'Create a landlab :class:`~.DataRecord` to represent parcels of sediment on'

[components.BedParcelInitializerDischarge.info.discharge_at_link]
doc = 'Dominant/formative discharge at each link in the network'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm^3 / s'

[components.BedParcelInitializerUserD50]
name = 'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerUserD50'
unit_agnostic = false
summary = 'Create a *landlab* :class:`~.DataRecord` to represent parcels of sediment on'

[components.BedParcelInitializerUserD50.info.time]
doc = 'The initial time to add to the record'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = true
units = 's'

[components.BedParcelInitializerUserD50.info.user_d50]
doc = 'Median grain size of the bed sediment in each link'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm'

[components.BedrockLandslider]
name = 'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider'
unit_agnostic = true
summary = 'Calculate the location and magnitude of episodic bedrock landsliding.'

[components.BedrockLandslider.info.LS_sediment__flux]
doc = 'Sediment flux originating from landslides                 (volume per unit time of sediment entering each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.BedrockLandslider.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedrockLandslider.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedrockLandslider.info.hill_flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedrockLandslider.info.hill_flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedrockLandslider.info.hill_topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.BedrockLandslider.info.landslide__deposition]
doc = 'Total deposition of derived sediment'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.BedrockLandslider.info.landslide__erosion]
doc = 'Total erosion caused by landsliding '
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.BedrockLandslider.info.landslide_sediment_point_source]
doc = 'Landslide derived sediment, as point sources on all the                 critical nodes where landslides initiate,                 before landslide runout is calculated '
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3'

[components.BedrockLandslider.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.BedrockLandslider.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.BedrockLandslider.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.CarbonateProducer]
name = 'landlab.components.carbonate.carbonate_producer.CarbonateProducer'
unit_agnostic = true
summary = 'Calculate marine carbonate production and deposition.'

[components.CarbonateProducer.info.carbonate_production_rate]
doc = 'Carbonate production rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm / y'

[components.CarbonateProducer.info.carbonate_thickness]
doc = 'Carbonate thickness'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = 'm'

[components.CarbonateProducer.info.sea_level__elevation]
doc = 'Sea level elevation'
dtype = 'float64'
intent = 'in'
mapping = 'grid'
optional = false
units = 'm'

[components.CarbonateProducer.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.CarbonateProducer.info.water_depth]
doc = 'Water depth'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.ChannelProfiler]
name = 'landlab.components.profiler.channel_profiler.ChannelProfiler'
unit_agnostic = true
summary = 'Extract and plot the channel profiles in drainage networks.'

[components.ChannelProfiler.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm**2'

[components.ChannelProfiler.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ChannelProfiler.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ChiFinder]
name = 'landlab.components.chi_index.channel_chi.ChiFinder'
unit_agnostic = true
summary = 'Calculate Chi Indices.'

[components.ChiFinder.info.channel__chi_index]
doc = 'the local steepness index'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'variable'

[components.ChiFinder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.ChiFinder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ChiFinder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ChiFinder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ChiFinder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.ChiFinder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ConcentrationTrackerForDiffusion]
name = 'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion'
unit_agnostic = true
summary = 'Track the concentration of any user-defined property.'

[components.ConcentrationTrackerForDiffusion.info.bedrock_property__concentration]
doc = 'Mass concentration of property per unit volume of bedrock'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-/m^3'

[components.ConcentrationTrackerForDiffusion.info.sediment_property__concentration]
doc = 'Mass concentration of property per unit volume of sediment'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-/m^3'

[components.ConcentrationTrackerForDiffusion.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.ConcentrationTrackerForDiffusion.info.soil__flux]
doc = 'flux of soil in direction of link'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm^2/yr'

[components.ConcentrationTrackerForDiffusion.info.soil_production__rate]
doc = 'rate of soil production at nodes'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/yr'

[components.ConcentrationTrackerForDiffusion.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.DepressionFinderAndRouter]
name = 'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter'
unit_agnostic = true
summary = 'Find depressions on a topographic surface.'

[components.DepressionFinderAndRouter.info.depression__depth]
doc = 'Depth of depression below its spillway point'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.DepressionFinderAndRouter.info.depression__outlet_node]
doc = 'If a depression, the id of the outlet node for that depression, otherwise grid.BAD_INDEX'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.DepressionFinderAndRouter.info.flood_status_code]
doc = 'Map of flood status (_PIT, _CURRENT_LAKE, _UNFLOODED, or _FLOODED).'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.DepressionFinderAndRouter.info.is_pit]
doc = 'Boolean flag indicating whether a node is a pit.'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.DepressionFinderAndRouter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentDiffuser]
name = 'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser'
unit_agnostic = true
summary = 'This component implements a depth and slope dependent linear diffusion'

[components.DepthDependentDiffuser.info.bedrock__elevation]
doc = 'elevation of the bedrock surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentDiffuser.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentDiffuser.info.soil__flux]
doc = 'flux of soil in direction of link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm^2/yr'

[components.DepthDependentDiffuser.info.soil_production__rate]
doc = 'rate of soil production at nodes'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/yr'

[components.DepthDependentDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentDiffuser.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.DepthDependentTaylorDiffuser]
name = 'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser'
unit_agnostic = true
summary = 'This component implements a depth-dependent Taylor series diffusion rule,'

[components.DepthDependentTaylorDiffuser.info.bedrock__elevation]
doc = 'elevation of the bedrock surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentTaylorDiffuser.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentTaylorDiffuser.info.soil__flux]
doc = 'flux of soil in direction of link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm^2/yr'

[components.DepthDependentTaylorDiffuser.info.soil_production__rate]
doc = 'rate of soil production at nodes'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/yr'

[components.DepthDependentTaylorDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DepthDependentTaylorDiffuser.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.DepthSlopeProductErosion]
name = 'landlab.components.detachment_ltd_erosion.generate_erosion_by_depth_slope.DepthSlopeProductErosion'
unit_agnostic = true
summary = 'Calculate erosion rate as a function of the depth-slope product.'

[components.DepthSlopeProductErosion.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.DepthSlopeProductErosion.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DepthSlopeProductErosion.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DetachmentLtdErosion]
name = 'landlab.components.detachment_ltd_erosion.generate_detachment_ltd_erosion.DetachmentLtdErosion'
unit_agnostic = true
summary = 'Simulate detachment limited sediment transport.'

[components.DetachmentLtdErosion.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.DetachmentLtdErosion.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DetachmentLtdErosion.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DimensionlessDischarge]
name = 'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge'
unit_agnostic = false
summary = 'Component that calculates dimensionless discharge of stream'

[components.DimensionlessDischarge.info.channel_bottom_sediment_grain__d50_diameter]
doc = 'soil grain size average in stream segment'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.DimensionlessDischarge.info.dimensionless_discharge]
doc = 'Dimensionless discharge value for a stream segment.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'none'

[components.DimensionlessDischarge.info.dimensionless_discharge_above_threshold]
doc = 'True if dimensionless discharge value is above threshold value, false otherwise.'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = 'none'

[components.DimensionlessDischarge.info.dimensionless_discharge_threshold]
doc = 'Dimensionless discharge threshold for each stream segment.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'none'

[components.DimensionlessDischarge.info.surface_water__unit_discharge]
doc = 'Volumetric discharge of surface water per unit width'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2/s'

[components.DimensionlessDischarge.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DischargeDiffuser]
name = 'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser'
unit_agnostic = true
summary = 'Diffuse sediment proportional to an implicit water discharge value.'

[components.DischargeDiffuser.info.flow__potential]
doc = "Value of the hypothetical field 'K', used to force water flux to flow downhill"
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.DischargeDiffuser.info.sediment__discharge_in]
doc = 'Sediment discharge into a node.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.DischargeDiffuser.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.DischargeDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.DischargeDiffuser.info.water__discharge_in]
doc = 'Incoming water discharge at node.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.DrainageDensity]
name = 'landlab.components.drainage_density.drainage_density.DrainageDensity'
unit_agnostic = true
summary = 'Calculate drainage density over a DEM.'

[components.DrainageDensity.info.area_coefficient]
doc = 'Area coefficient to define channels.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.area_exponent]
doc = 'Area exponent to define channels.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.channel__mask]
doc = 'Logical map of at which grid nodes channels are present'
dtype = 'uint8'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.channelization_threshold]
doc = 'Channelization threshold for use with area and slope coefficients and exponents.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.DrainageDensity.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.DrainageDensity.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.DrainageDensity.info.slope_coefficient]
doc = 'Slope coefficient to define channels.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.slope_exponent]
doc = 'Slope exponent to define channels.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.DrainageDensity.info.surface_to_channel__minimum_distance]
doc = 'Distance from each node to the nearest channel'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.DrainageDensity.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ErosionDeposition]
name = 'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition'
unit_agnostic = true
summary = 'Erosion-Deposition model in the style of Davy and Lague (2009). It uses a'

[components.ErosionDeposition.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ErosionDeposition.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ErosionDeposition.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ErosionDeposition.info.sediment__influx]
doc = 'Sediment flux (volume per unit time of sediment entering each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.ErosionDeposition.info.sediment__outflux]
doc = 'Sediment flux (volume per unit time of sediment leaving each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.ErosionDeposition.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2/s'

[components.ErosionDeposition.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.ErosionDeposition.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ExponentialWeatherer]
name = 'landlab.components.weathering.exponential_weathering.ExponentialWeatherer'
unit_agnostic = true
summary = 'Calculate exponential weathering of bedrock on hillslopes.'

[components.ExponentialWeatherer.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.ExponentialWeatherer.info.soil_production__rate]
doc = 'rate of soil production at nodes'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.ExponentialWeathererIntegrated]
name = 'landlab.components.weathering.exponential_weathering_integrated.ExponentialWeathererIntegrated'
unit_agnostic = true
summary = 'This component implements exponential weathering of bedrock on'

[components.ExponentialWeathererIntegrated.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.ExponentialWeathererIntegrated.info.soil_production__dt_produced_depth]
doc = 'thickness of soil produced at nodes over time dt'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.ExponentialWeathererIntegrated.info.soil_production__dt_weathered_depth]
doc = 'thickness of bedrock weathered at nodes over time dt'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.ExponentialWeathererIntegrated.info.soil_production__rate]
doc = 'rate of soil production at nodes'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.FastscapeEroder]
name = 'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder'
unit_agnostic = true
summary = 'Fastscape stream power erosion.'

[components.FastscapeEroder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.FastscapeEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.FastscapeEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.FastscapeEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.FastscapeEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.FireGenerator]
name = 'landlab.components.fire_generator.generate_fire.FireGenerator'
unit_agnostic = true
summary = 'Generate a random fire event or time series.'

[components.Flexure]
name = 'landlab.components.flexure.flexure.Flexure'
unit_agnostic = true
summary = 'Deform the lithosphere with 1D or 2D flexure.'

[components.Flexure.info.lithosphere__overlying_pressure_increment]
doc = 'Applied pressure to the lithosphere over a time step'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa'

[components.Flexure.info.lithosphere_surface__elevation_increment]
doc = 'The change in elevation of the top of the lithosphere (the land surface) in one timestep'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.Flexure1D]
name = 'landlab.components.flexure.flexure_1d.Flexure1D'
unit_agnostic = true
summary = 'Deform the lithosphere with 1D flexure.'

[components.Flexure1D.info.lithosphere__increment_of_overlying_pressure]
doc = 'Applied pressure to the lithosphere over a time step'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa'

[components.Flexure1D.info.lithosphere_surface__increment_of_elevation]
doc = 'The change in elevation of the top of the lithosphere (the land surface) in one timestep'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.FlowAccumulator]
name = 'landlab.components.flow_accum.flow_accumulator.FlowAccumulator'
unit_agnostic = true
summary = 'Component to accumulate flow and calculate drainage area.'

[components.FlowAccumulator.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**2'

[components.FlowAccumulator.info.flow__data_structure_delta]
doc = "Node array containing the elements delta[1:] of the data structure 'delta' used for construction of the downstream-to-upstream node array"
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowAccumulator.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowAccumulator.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.FlowAccumulator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.FlowAccumulator.info.water__unit_flux_in]
doc = 'External volume water per area per time input to each node (e.g., rainfall rate)'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm/s'

[components.FlowDirectorD8]
name = 'landlab.components.flow_director.flow_director_d8.FlowDirectorD8'
unit_agnostic = true
summary = 'Single-path (steepest direction) flow direction with diagonals on'

[components.FlowDirectorD8.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorD8.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorD8.info.flow__sink_flag]
doc = 'Boolean array, True at local lows'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorD8.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.FlowDirectorD8.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorDINF]
name = 'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF'
unit_agnostic = true
summary = 'Flow direction on a raster grid by the D infinity method.'

[components.FlowDirectorDINF.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorDINF.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorDINF.info.flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorDINF.info.flow__sink_flag]
doc = 'Boolean array, True at local lows'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorDINF.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.FlowDirectorDINF.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorMFD]
name = 'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD'
unit_agnostic = true
summary = 'Multiple-path flow direction with or without out diagonals.'

[components.FlowDirectorMFD.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorMFD.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorMFD.info.flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorMFD.info.flow__sink_flag]
doc = 'Boolean array, True at local lows'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorMFD.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.FlowDirectorMFD.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorSteepest]
name = 'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest'
unit_agnostic = true
summary = 'Single-path (steepest direction) flow direction without diagonals.'

[components.FlowDirectorSteepest.info.flow__link_direction]
doc = 'Direction of flow on link. A value of -1 indicates that water flow goes from head node to tail node, while a value of 1 indicates that water flow goes from tail node to head node.'
dtype = 'int8'
intent = 'out'
mapping = 'link'
optional = false
units = '-'

[components.FlowDirectorSteepest.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorSteepest.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorSteepest.info.flow__sink_flag]
doc = 'Boolean array, True at local lows'
dtype = 'bool'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FlowDirectorSteepest.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.FlowDirectorSteepest.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.FractureGridGenerator]
name = 'landlab.components.fracture_grid.fracture_grid.FractureGridGenerator'
unit_agnostic = true
summary = 'Create a 2D grid with randomly generated fractures.'

[components.FractureGridGenerator.info.fracture_at_node]
doc = 'presence (1) or absence (0) of fracture'
dtype = 'int8'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.GravelBedrockEroder]
name = 'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder'
unit_agnostic = true
summary = 'Drainage network evolution of rivers with gravel alluvium overlying bedrock.'

[components.GravelBedrockEroder.info.bedload_sediment__rate_of_loss_to_abrasion]
doc = 'Rate of bedload sediment volume loss to abrasion per unit area'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelBedrockEroder.info.bedload_sediment__volume_influx]
doc = 'Volumetric incoming streamwise bedload sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.GravelBedrockEroder.info.bedload_sediment__volume_outflux]
doc = 'Volumetric outgoing streamwise bedload sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.GravelBedrockEroder.info.bedrock__abrasion_rate]
doc = 'rate of bedrock lowering by abrasion'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelBedrockEroder.info.bedrock__elevation]
doc = 'elevation of the bedrock surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.GravelBedrockEroder.info.bedrock__exposure_fraction]
doc = 'fractional exposure of bedrock'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.GravelBedrockEroder.info.bedrock__lowering_rate]
doc = 'Rate of lowering of bedrock surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelBedrockEroder.info.bedrock__plucking_rate]
doc = 'rate of bedrock lowering by plucking'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelBedrockEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelBedrockEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelBedrockEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelBedrockEroder.info.sediment__rate_of_change]
doc = 'Time rate of change of sediment thickness'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelBedrockEroder.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.GravelBedrockEroder.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.GravelBedrockEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.GravelBedrockEroder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelRiverTransporter]
name = 'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter'
unit_agnostic = true
summary = 'Model drainage network evolution for a network of transport-limited'

[components.GravelRiverTransporter.info.bedload_sediment__rate_of_loss_to_abrasion]
doc = 'Rate of bedload sediment volume loss to abrasion per unit area'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelRiverTransporter.info.bedload_sediment__volume_influx]
doc = 'Volumetric incoming streamwise bedload sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**2/y'

[components.GravelRiverTransporter.info.bedload_sediment__volume_outflux]
doc = 'Volumetric outgoing streamwise bedload sediment transport rate'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**2/y'

[components.GravelRiverTransporter.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelRiverTransporter.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelRiverTransporter.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GravelRiverTransporter.info.sediment__rate_of_change]
doc = 'Time rate of change of sediment thickness'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/y'

[components.GravelRiverTransporter.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/y'

[components.GravelRiverTransporter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.GravelRiverTransporter.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.GroundwaterDupuitPercolator]
name = 'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator'
unit_agnostic = true
summary = 'Simulate groundwater flow in a shallow unconfined aquifer.'

[components.GroundwaterDupuitPercolator.info.aquifer__thickness]
doc = 'thickness of saturated zone'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.GroundwaterDupuitPercolator.info.aquifer_base__elevation]
doc = 'elevation of impervious layer'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.GroundwaterDupuitPercolator.info.aquifer_base__gradient]
doc = 'gradient of the aquifer base in the link direction'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.GroundwaterDupuitPercolator.info.average_surface_water__specific_discharge]
doc = 'average surface water specific discharge over variable timesteps'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/s'

[components.GroundwaterDupuitPercolator.info.groundwater__specific_discharge]
doc = 'discharge per width in link dir'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm2/s'

[components.GroundwaterDupuitPercolator.info.groundwater__velocity]
doc = 'velocity of groundwater in link direction'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.GroundwaterDupuitPercolator.info.hydraulic__gradient]
doc = 'gradient of water table in link direction'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.GroundwaterDupuitPercolator.info.surface_water__specific_discharge]
doc = 'rate of seepage to surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/s'

[components.GroundwaterDupuitPercolator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.GroundwaterDupuitPercolator.info.water_table__elevation]
doc = 'elevation of water table'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.HackCalculator]
name = 'landlab.components.hack_calculator.hack_calculator.HackCalculator'
unit_agnostic = true
summary = "This component calculates Hack's law parameters for drainage basins."

[components.HackCalculator.info.distance_to_divide]
doc = 'Distance from drainage divide.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.HackCalculator.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.HackCalculator.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.HackCalculator.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.HackCalculator.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.HackCalculator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.HeightAboveDrainageCalculator]
name = 'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator'
unit_agnostic = true
summary = 'Calculate the elevation difference between each node and its nearest'

[components.HeightAboveDrainageCalculator.info.channel__mask]
doc = 'Logical map of at which grid nodes channels are present'
dtype = 'uint8'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.HeightAboveDrainageCalculator.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.HeightAboveDrainageCalculator.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.HeightAboveDrainageCalculator.info.height_above_drainage__elevation]
doc = 'Elevation above the nearest channel node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.HeightAboveDrainageCalculator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.KinematicWaveRengers]
name = 'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers'
unit_agnostic = false
summary = 'This code is based on an overland flow model by Francis Rengers and'

[components.KinematicWaveRengers.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.KinematicWaveRengers.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.KinematicWaveRengers.info.surface_water__velocity]
doc = 'Speed of water flow above the surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/s'

[components.KinematicWaveRengers.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.KinwaveImplicitOverlandFlow]
name = 'landlab.components.overland_flow.generate_overland_flow_implicit_kinwave.KinwaveImplicitOverlandFlow'
unit_agnostic = false
summary = 'Calculate shallow water flow over topography.'

[components.KinwaveImplicitOverlandFlow.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.KinwaveImplicitOverlandFlow.info.surface_water_inflow__discharge]
doc = 'water volume inflow rate to the cell around each node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.KinwaveImplicitOverlandFlow.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.KinwaveImplicitOverlandFlow.info.topographic__gradient]
doc = 'Gradient of the ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.KinwaveOverlandFlowModel]
name = 'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel'
unit_agnostic = false
summary = 'Calculate water flow over topography.'

[components.KinwaveOverlandFlowModel.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.KinwaveOverlandFlowModel.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.KinwaveOverlandFlowModel.info.topographic__gradient]
doc = 'Gradient of the ground surface'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm/m'

[components.KinwaveOverlandFlowModel.info.water__specific_discharge]
doc = 'flow discharge component in the direction of the link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm2/s'

[components.KinwaveOverlandFlowModel.info.water__velocity]
doc = 'flow velocity component in the direction of the link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.LakeMapperBarnes]
name = 'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes'
unit_agnostic = true
summary = 'A Landlab implementation of the Barnes et al. (2014) lake filling & lake'

[components.LakeMapperBarnes.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm**2'

[components.LakeMapperBarnes.info.flow__data_structure_delta]
doc = "Node array containing the elements delta[1:] of the data structure 'delta' used for construction of the downstream-to-upstream node array"
dtype = 'int64'
intent = 'inout'
mapping = 'node'
optional = false
units = '-'

[components.LakeMapperBarnes.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'inout'
mapping = 'node'
optional = false
units = '-'

[components.LakeMapperBarnes.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'inout'
mapping = 'node'
optional = false
units = '-'

[components.LakeMapperBarnes.info.flow__sink_flag]
doc = 'Boolean array, True at local lows'
dtype = 'bool'
intent = 'inout'
mapping = 'node'
optional = false
units = '-'

[components.LakeMapperBarnes.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'inout'
mapping = 'node'
optional = false
units = '-'

[components.LakeMapperBarnes.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.LakeMapperBarnes.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.LandslideProbability]
name = 'landlab.components.landslides.landslide_probability.LandslideProbability'
unit_agnostic = false
summary = 'Landslide probability component using the infinite slope stability'

[components.LandslideProbability.info.landslide__probability_of_failure]
doc = 'number of times FS is <=1 out of number of iterations user selected'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'None'

[components.LandslideProbability.info.soil__density]
doc = 'wet bulk density of soil'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'kg/m3'

[components.LandslideProbability.info.soil__internal_friction_angle]
doc = 'critical angle just before failure due to friction between particles'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'degrees'

[components.LandslideProbability.info.soil__maximum_total_cohesion]
doc = 'maximum of combined root and soil cohesion at node'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa or kg/m-s2'

[components.LandslideProbability.info.soil__mean_relative_wetness]
doc = 'Indicator of soil wetness; relative depth perched water table within the soil layer'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'None'

[components.LandslideProbability.info.soil__minimum_total_cohesion]
doc = 'minimum of combined root and soil cohesion at node'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa or kg/m-s2'

[components.LandslideProbability.info.soil__mode_total_cohesion]
doc = 'mode of combined root and soil cohesion at node'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa or kg/m-s2'

[components.LandslideProbability.info.soil__probability_of_saturation]
doc = 'number of times relative wetness is >=1 out of number of iterations user selected'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'None'

[components.LandslideProbability.info.soil__saturated_hydraulic_conductivity]
doc = 'mode rate of water transmitted through soil - provided if transmissivity is NOT provided to calculate tranmissivity with soil depth'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/day'

[components.LandslideProbability.info.soil__thickness]
doc = 'soil depth to restrictive layer'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.LandslideProbability.info.soil__transmissivity]
doc = 'mode rate of water transmitted through a unit width of saturated soil - either provided or calculated with Ksat and soil depth'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm2/day'

[components.LandslideProbability.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'tan theta'

[components.LandslideProbability.info.topographic__specific_contributing_area]
doc = 'specific contributing (upslope area/cell face ) that drains to node'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.LateralEroder]
name = 'landlab.components.lateral_erosion.lateral_erosion.LateralEroder'
unit_agnostic = false
summary = 'Laterally erode neighbor node through fluvial erosion.'

[components.LateralEroder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.LateralEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.LateralEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.LateralEroder.info.lateral_erosion__depth_increment]
doc = 'Change in elevation at each node from lateral erosion during time step'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.LateralEroder.info.sediment__influx]
doc = 'Sediment flux (volume per unit time of sediment entering each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/y'

[components.LateralEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.LateralEroder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.LateralEroder.info.volume__lateral_erosion]
doc = 'Array tracking volume eroded at each node from lateral erosion'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3'

[components.LinearDiffuser]
name = 'landlab.components.diffusion.diffusion.LinearDiffuser'
unit_agnostic = true
summary = 'Linear diffusion of a Landlab field.'

[components.LinearDiffuser.info.hillslope_sediment__unit_volume_flux]
doc = 'Volume flux per unit width along links'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm**2/s'

[components.LinearDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.LinearDiffuser.info.topographic__gradient]
doc = 'Gradient of the ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = '-'

[components.LinearDiffusionOverlandFlowRouter]
name = 'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter'
unit_agnostic = true
summary = 'Calculate water flow over topography.'

[components.LinearDiffusionOverlandFlowRouter.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.LinearDiffusionOverlandFlowRouter.info.surface_water__depth_at_link]
doc = 'Depth of water on the surface at grid links'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm'

[components.LinearDiffusionOverlandFlowRouter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.LinearDiffusionOverlandFlowRouter.info.water__specific_discharge]
doc = 'flow discharge component in the direction of the link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm2/s'

[components.LinearDiffusionOverlandFlowRouter.info.water__velocity]
doc = 'flow velocity component in the direction of the link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.LinearDiffusionOverlandFlowRouter.info.water_surface__elevation]
doc = 'Elevation of the water surface.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.LinearDiffusionOverlandFlowRouter.info.water_surface__gradient]
doc = 'Downstream gradient of the water surface.'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.ListricKinematicExtender]
name = 'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender'
unit_agnostic = true
summary = 'Apply tectonic extension kinematically to a raster or'

[components.ListricKinematicExtender.info.advection__velocity]
doc = 'Link-parallel advection velocity magnitude'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = true
units = 'm/y'

[components.ListricKinematicExtender.info.fault_plane__elevation]
doc = 'Elevation of fault plane'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.ListricKinematicExtender.info.hangingwall__thickness]
doc = 'Thickness of material in hangingwall block'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.ListricKinematicExtender.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.LithoLayers]
name = 'landlab.components.lithology.litholayers.LithoLayers'
unit_agnostic = true
summary = 'Create LithoLayers component.'

[components.Lithology]
name = 'landlab.components.lithology.lithology.Lithology'
unit_agnostic = true
summary = 'Create a Lithology object.'

[components.LossyFlowAccumulator]
name = 'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator'
unit_agnostic = true
summary = 'Component to calculate drainage area and accumulate flow, while'

[components.LossyFlowAccumulator.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**2'

[components.LossyFlowAccumulator.info.flow__data_structure_delta]
doc = "Node array containing the elements delta[1:] of the data structure 'delta' used for construction of the downstream-to-upstream node array"
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.LossyFlowAccumulator.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.LossyFlowAccumulator.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.LossyFlowAccumulator.info.surface_water__discharge_loss]
doc = 'Total volume of water per second lost during all flow out of the node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.LossyFlowAccumulator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.LossyFlowAccumulator.info.water__unit_flux_in]
doc = 'External volume water per area per time input to each node (e.g., rainfall rate)'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm/s'

[components.MassWastingRunout]
name = 'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout'
unit_agnostic = false
summary = 'a cellular-automata mass wasting runout model that routes an initial mass'

[components.MassWastingRunout.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.MassWastingRunout.info.flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.MassWastingRunout.info.mass__wasting_id]
doc = 'interger or float id of each mass wasting area is assigned                 to all nodes representing the mass wasting area.'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.MassWastingRunout.info.particle__diameter]
doc = 'representative particle diameter at each node, this might             vary with underlying geology, contributing area or field observations'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = true
units = 'm'

[components.MassWastingRunout.info.soil__thickness]
doc = 'soil depth to restrictive layer'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.MassWastingRunout.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = true
units = 'm'

[components.MassWastingRunout.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.NetworkSedimentTransporter]
name = 'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter'
unit_agnostic = false
summary = 'Move sediment parcels on a river network.'

[components.NetworkSedimentTransporter.info.bedrock__elevation]
doc = 'elevation of the bedrock surface'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.NetworkSedimentTransporter.info.channel_slope]
doc = 'Slope of the river channel through each reach'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.NetworkSedimentTransporter.info.channel_width]
doc = 'Flow width of the channel, assuming constant width'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm'

[components.NetworkSedimentTransporter.info.flow_depth]
doc = 'Flow depth of the channel'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm'

[components.NetworkSedimentTransporter.info.reach_length]
doc = 'Length of each reach'
dtype = 'float64'
intent = 'in'
mapping = 'link'
optional = false
units = 'm'

[components.NetworkSedimentTransporter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.NormalFault]
name = 'landlab.components.normal_fault.normal_fault.NormalFault'
unit_agnostic = true
summary = 'NormalFault implements relative rock motion due to a normal fault.'

[components.NormalFault.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = true
units = 'm'

[components.OverlandFlow]
name = 'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow'
unit_agnostic = false
summary = 'Simulate overland flow using de Almeida approximations.'

[components.OverlandFlow.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.OverlandFlow.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm3/s'

[components.OverlandFlow.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.OverlandFlow.info.water_surface__gradient]
doc = 'Downstream gradient of the water surface.'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = '-'

[components.OverlandFlowBates]
name = 'landlab.components.overland_flow.generate_overland_flow_Bates.OverlandFlowBates'
unit_agnostic = false
summary = 'Simulate overland flow using Bates et al. (2010).'

[components.OverlandFlowBates.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.OverlandFlowBates.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm3/s'

[components.OverlandFlowBates.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.PerronNLDiffuse]
name = 'landlab.components.nonlinear_diffusion.Perron_nl_diffuse.PerronNLDiffuse'
unit_agnostic = true
summary = 'Nonlinear diffusion, following Perron (2011).'

[components.PerronNLDiffuse.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.PotentialEvapotranspiration]
name = 'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration'
unit_agnostic = false
summary = 'Potential Evapotranspiration Component calculates spatially distributed'

[components.PotentialEvapotranspiration.info.radiation__incoming_shortwave_flux]
doc = 'incident shortwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.PotentialEvapotranspiration.info.radiation__net_flux]
doc = 'net radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.PotentialEvapotranspiration.info.radiation__net_longwave_flux]
doc = 'net incident longwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.PotentialEvapotranspiration.info.radiation__net_shortwave_flux]
doc = 'net incident shortwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.PotentialEvapotranspiration.info.radiation__ratio_to_flat_surface]
doc = 'ratio of incident shortwave radiation on sloped surface to flat surface'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.PotentialEvapotranspiration.info.surface__potential_evapotranspiration_rate]
doc = 'potential sum of evaporation and potential transpiration'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'mm'

[components.PotentialityFlowRouter]
name = 'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter'
unit_agnostic = false
summary = 'Multidirectional flow routing using a novel method.'

[components.PotentialityFlowRouter.info.flow__potential]
doc = "Value of the hypothetical field 'K', used to force water flux to flow downhill"
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.PotentialityFlowRouter.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.PotentialityFlowRouter.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.PotentialityFlowRouter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.PotentialityFlowRouter.info.water__unit_flux_in]
doc = 'External volume water per area per time input to each node (e.g., rainfall rate)'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/s'

[components.PrecipitationDistribution]
name = 'landlab.components.uniform_precip.generate_uniform_precip.PrecipitationDistribution'
unit_agnostic = true
summary = 'Generate precipitation events.'

[components.PrecipitationDistribution.info.rainfall__flux]
doc = 'Depth of water delivered per unit time in each storm'
dtype = 'float64'
intent = 'out'
mapping = 'grid'
optional = true
units = '[depth unit]/[time unit]'

[components.PriorityFloodFlowRouter]
name = 'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter'
unit_agnostic = true
summary = 'Component to accumulate flow and calculate drainage area based RICHDEM software package.'

[components.PriorityFloodFlowRouter.info.depression_free_elevation]
doc = 'Filled land surface topographic elevation, at closed borders, value equals -1!'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.PriorityFloodFlowRouter.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**2'

[components.PriorityFloodFlowRouter.info.flood_status_code]
doc = 'Map of flood status (_PIT, _CURRENT_LAKE, _UNFLOODED, or _FLOODED).'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.hill_drainage_area]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.hill_flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.hill_flow__receiver_proportions]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.hill_flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.hill_surface_water__discharge]
doc = 'Node array of proportion of flow sent to each receiver.'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.hill_topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = '-'

[components.PriorityFloodFlowRouter.info.squared_length_adjacent]
doc = 'Length to adjacent nodes, squared (calcualted in advance to save time during calculation'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.PriorityFloodFlowRouter.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.PriorityFloodFlowRouter.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.PriorityFloodFlowRouter.info.water__unit_flux_in]
doc = 'External volume water per area per time input to each node (e.g., rainfall rate)'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm/s'

[components.Profiler]
name = 'landlab.components.profiler.profiler.Profiler'
unit_agnostic = true
summary = 'Extract and plot profiles set up using points within a grid.'

[components.Radiation]
name = 'landlab.components.radiation.radiation.Radiation'
unit_agnostic = false
summary = 'Compute 1D and 2D daily incident shortwave radiation.'

[components.Radiation.info.radiation__clearsky_flux]
doc = 'clearsky radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__extraterrestrial_flux]
doc = 'extraterrestrial radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__incoming_shortwave_flux]
doc = 'incident shortwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__net_flux]
doc = 'net radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__net_longwave_flux]
doc = 'net incident longwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__net_shortwave_flux]
doc = 'net incident shortwave radiation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'W/m^2'

[components.Radiation.info.radiation__ratio_to_flat_surface]
doc = 'ratio of incident shortwave radiation on sloped surface to flat surface'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.Radiation.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.SedDepEroder]
name = 'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder'
unit_agnostic = false
summary = 'This module implements sediment flux dependent channel incision'

[components.SedDepEroder.info.channel__bed_shear_stress]
doc = 'Shear exerted on the bed of the channel, assuming all discharge travels along a single, self-formed channel'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'Pa'

[components.SedDepEroder.info.channel__depth]
doc = 'Depth of the a single channel carrying all runoff through the node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = 'm'

[components.SedDepEroder.info.channel__discharge]
doc = 'Volumetric water flux of the a single channel carrying all runoff through the node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.SedDepEroder.info.channel__width]
doc = 'Width of the a single channel carrying all runoff through the node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = true
units = 'm'

[components.SedDepEroder.info.channel_sediment__relative_flux]
doc = 'The fluvial_sediment_flux_into_node divided by the fluvial_sediment_transport_capacity'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.SedDepEroder.info.channel_sediment__volumetric_flux]
doc = 'Total volumetric fluvial sediment flux brought into the node from upstream'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.SedDepEroder.info.channel_sediment__volumetric_transport_capacity]
doc = 'Volumetric transport capacity of a channel carrying all runoff through the node, assuming the Meyer-Peter Muller transport equation'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.SedDepEroder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.SedDepEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SedDepEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SedDepEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SedDepEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SedDepEroder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SedimentPulserAtLinks]
name = 'landlab.components.network_sediment_transporter.sediment_pulser_at_links.SedimentPulserAtLinks'
unit_agnostic = false
summary = 'Send a pulse of parcels to specific links in a channel network'

[components.SedimentPulserEachParcel]
name = 'landlab.components.network_sediment_transporter.sediment_pulser_each_parcel.SedimentPulserEachParcel'
unit_agnostic = false
summary = 'Send pulses of sediment to specific point locations within the channel'

[components.SimpleSubmarineDiffuser]
name = 'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser'
unit_agnostic = true
summary = 'Transport marine sediment using a water-depth-dependent diffusion model.'

[components.SimpleSubmarineDiffuser.info.sea_level__elevation]
doc = 'Sea level elevation'
dtype = 'float64'
intent = 'in'
mapping = 'grid'
optional = false
units = 'm'

[components.SimpleSubmarineDiffuser.info.sediment_deposit__thickness]
doc = 'Thickness of deposition or erosion in latest time step'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.SimpleSubmarineDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SimpleSubmarineDiffuser.info.water__depth]
doc = 'depth of water under current sea level'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.SinkFiller]
name = 'landlab.components.sink_fill.fill_sinks.SinkFiller'
unit_agnostic = true
summary = 'This component identifies depressions in a topographic surface, then'

[components.SinkFiller.info.sediment_fill__depth]
doc = 'Depth of sediment added at eachnode'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.SinkFiller.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SinkFillerBarnes]
name = 'landlab.components.sink_fill.sink_fill_barnes.SinkFillerBarnes'
unit_agnostic = true
summary = 'Uses the Barnes et al (2014) algorithms to replace pits in a topography'

[components.SinkFillerBarnes.info.sediment_fill__depth]
doc = 'Depth of sediment added at eachnode'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.SinkFillerBarnes.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SoilInfiltrationGreenAmpt]
name = 'landlab.components.soil_moisture.infiltrate_soil_green_ampt.SoilInfiltrationGreenAmpt'
unit_agnostic = false
summary = 'Infiltrate surface water into a soil following the Green-Ampt method.'

[components.SoilInfiltrationGreenAmpt.info.soil_water_infiltration__depth]
doc = 'Water column height above the surface previously absorbed into the soil. Note that this is NOT the actual depth of the wetted front, which also depends on the porosity.'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SoilInfiltrationGreenAmpt.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SoilMoisture]
name = 'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture'
unit_agnostic = false
summary = 'Landlab component that simulates root-zone average soil moisture at each'

[components.SoilMoisture.info.rainfall__daily_depth]
doc = 'Rain in (mm) as a field, allowing spatio-temporal soil moisture saturation analysis.'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'mm'

[components.SoilMoisture.info.soil_moisture__initial_saturation_fraction]
doc = 'initial soil_moisture__saturation_fraction'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.SoilMoisture.info.soil_moisture__root_zone_leakage]
doc = 'leakage of water into deeper portions of the soil not accessible to the plant'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'mm'

[components.SoilMoisture.info.soil_moisture__saturation_fraction]
doc = 'relative volumetric water content (theta) - limits=[0,1]'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.SoilMoisture.info.surface__evapotranspiration]
doc = 'actual sum of evaporation and plant transpiration'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'mm'

[components.SoilMoisture.info.surface__potential_evapotranspiration_rate]
doc = 'potential sum of evaporation and potential transpiration'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'mm'

[components.SoilMoisture.info.surface__runoff]
doc = 'runoff from ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'mm'

[components.SoilMoisture.info.vegetation__cover_fraction]
doc = 'fraction of land covered by vegetation'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.SoilMoisture.info.vegetation__live_leaf_area_index]
doc = 'one-sided green leaf area per unit ground surface area'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.SoilMoisture.info.vegetation__plant_functional_type]
doc = 'classification of plants (int), grass=0, shrub=1, tree=2, bare=3, shrub_seedling=4, tree_seedling=5'
dtype = 'int64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.SoilMoisture.info.vegetation__water_stress]
doc = 'parameter that represents nonlinear effects of water deficit on plants'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.Space]
name = 'landlab.components.space.space.Space'
unit_agnostic = true
summary = 'Stream Power with Alluvium Conservation and Entrainment (SPACE)'

[components.Space.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.Space.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.Space.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.Space.info.sediment__influx]
doc = 'Sediment flux (volume per unit time of sediment entering each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.Space.info.sediment__outflux]
doc = 'Sediment flux (volume per unit time of sediment leaving each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.Space.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.Space.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.Space.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.Space.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SpaceLargeScaleEroder]
name = 'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder'
unit_agnostic = true
summary = 'Stream Power with Alluvium Conservation and Entrainment (SPACE) large scale eroder'

[components.SpaceLargeScaleEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.SpaceLargeScaleEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SpaceLargeScaleEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SpaceLargeScaleEroder.info.sediment__influx]
doc = 'Sediment flux (volume per unit time of sediment entering each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.SpaceLargeScaleEroder.info.sediment__outflux]
doc = 'Sediment flux (volume per unit time of sediment leaving each node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm3/s'

[components.SpaceLargeScaleEroder.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SpaceLargeScaleEroder.info.surface_water__discharge]
doc = 'Volumetric discharge of surface water'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**3/s'

[components.SpaceLargeScaleEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.SpaceLargeScaleEroder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = '-'

[components.SpatialPrecipitationDistribution]
name = 'landlab.components.spatial_precip.generate_spatial_precip.SpatialPrecipitationDistribution'
unit_agnostic = false
summary = 'Generate spatially resolved precipitation events.'

[components.SpatialPrecipitationDistribution.info.rainfall__flux]
doc = 'Depth of water delivered per unit time in each storm'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'mm/hr'

[components.SpatialPrecipitationDistribution.info.rainfall__total_depth_per_year]
doc = 'Depth of water delivered in total in each model year'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'mm/yr'

[components.SpatialPrecipitationDistribution.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = true
units = 'm'

[components.SpeciesEvolver]
name = 'landlab.components.species_evolution.species_evolver.SpeciesEvolver'
unit_agnostic = true
summary = 'Evolve life in a landscape.'

[components.SpeciesEvolver.info.taxa__richness]
doc = 'The number of taxa at each node'
dtype = 'int64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.SteepnessFinder]
name = 'landlab.components.steepness_index.channel_steepness.SteepnessFinder'
unit_agnostic = true
summary = 'This component calculates steepness indices, sensu Wobus et al. 2006,'

[components.SteepnessFinder.info.channel__steepness_index]
doc = 'the local steepness index'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'variable'

[components.SteepnessFinder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.SteepnessFinder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SteepnessFinder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SteepnessFinder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.SteepnessFinder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.SteepnessFinder.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerEroder]
name = 'landlab.components.stream_power.stream_power.StreamPowerEroder'
unit_agnostic = true
summary = 'Erode where channels are.'

[components.StreamPowerEroder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.StreamPowerEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.StreamPowerSmoothThresholdEroder]
name = 'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder'
unit_agnostic = true
summary = 'Stream erosion component with smooth threshold function.'

[components.StreamPowerSmoothThresholdEroder.info.drainage_area]
doc = "Upstream accumulated surface area contributing to the node's discharge"
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm**2'

[components.StreamPowerSmoothThresholdEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerSmoothThresholdEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerSmoothThresholdEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.StreamPowerSmoothThresholdEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.TaylorNonLinearDiffuser]
name = 'landlab.components.taylor_nonlinear_hillslope_flux.taylor_nonlinear_hillslope_flux.TaylorNonLinearDiffuser'
unit_agnostic = true
summary = 'Hillslope evolution using a Taylor Series expansion of the Andrews-'

[components.TaylorNonLinearDiffuser.info.soil__flux]
doc = 'flux of soil in direction of link'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm^2/yr'

[components.TaylorNonLinearDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.TaylorNonLinearDiffuser.info.topographic__slope]
doc = 'gradient of the ground surface'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/m'

[components.ThresholdEroder]
name = 'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder'
unit_agnostic = true
summary = 'Threshold eroder.'

[components.ThresholdEroder.info.bedrock__elevation]
doc = 'elevation of the bedrock surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = true
units = 'm'

[components.ThresholdEroder.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ThresholdEroder.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ThresholdEroder.info.flow__upstream_node_order]
doc = 'Node array containing downstream-to-upstream ordered list of node IDs'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.ThresholdEroder.info.soil__depth]
doc = 'Depth of soil or weathered bedrock'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = true
units = 'm'

[components.ThresholdEroder.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.TidalFlowCalculator]
name = 'landlab.components.tidal_flow.tidal_flow_calculator.TidalFlowCalculator'
unit_agnostic = false
summary = 'Component that calculates average flow over a tidal cycle.'

[components.TidalFlowCalculator.info.ebb_tide_flow__velocity]
doc = 'Horizontal flow velocity along links during ebb tide'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.TidalFlowCalculator.info.flood_tide_flow__velocity]
doc = 'Horizontal flow velocity along links during flood tide'
dtype = 'float64'
intent = 'out'
mapping = 'link'
optional = false
units = 'm/s'

[components.TidalFlowCalculator.info.mean_water__depth]
doc = 'Tidal mean water depth'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.TidalFlowCalculator.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

[components.TransportLengthHillslopeDiffuser]
name = 'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser'
unit_agnostic = true
summary = 'Transport length hillslope diffusion.'

[components.TransportLengthHillslopeDiffuser.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.TransportLengthHillslopeDiffuser.info.sediment__deposition_coeff]
doc = 'Fraction of incoming sediment that is deposited on the node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = '-'

[components.TransportLengthHillslopeDiffuser.info.sediment__deposition_rate]
doc = 'Deposition rate on node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.TransportLengthHillslopeDiffuser.info.sediment__erosion_rate]
doc = 'Erosion rate on node'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.TransportLengthHillslopeDiffuser.info.sediment__flux_in]
doc = 'Incoming sediment rate on node (=qs/dx)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.TransportLengthHillslopeDiffuser.info.sediment__flux_out]
doc = 'Outgoing sediment rate on node = sediment eroded on node + sediment transported across node from upstream'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.TransportLengthHillslopeDiffuser.info.sediment__transfer_rate]
doc = 'Rate of transferred sediment across a node (incoming sediment - deposited sediment on node)'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm/yr'

[components.TransportLengthHillslopeDiffuser.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.TransportLengthHillslopeDiffuser.info.topographic__steepest_slope]
doc = 'The steepest *downhill* slope'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm/m'

[components.TrickleDownProfiler]
name = 'landlab.components.profiler.trickle_down_profiler.TrickleDownProfiler'
unit_agnostic = true
summary = 'Extract and a profile from one or more node IDs to their downstream termini.'

[components.TrickleDownProfiler.info.flow__link_to_receiver_node]
doc = 'ID of link downstream of each node, which carries the discharge'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.TrickleDownProfiler.info.flow__receiver_node]
doc = 'Node array of receivers (node that receives flow from current node)'
dtype = 'int64'
intent = 'in'
mapping = 'node'
optional = false
units = '-'

[components.VegCA]
name = 'landlab.components.plant_competition_ca.plant_competition_ca.VegCA'
unit_agnostic = false
summary = 'Landlab component that simulates inter-species plant competition using a'

[components.VegCA.info.plant__age]
doc = 'Age of plant'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'Years'

[components.VegCA.info.plant__live_index]
doc = '1 - vegetation__cumulative_water_stress'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.VegCA.info.vegetation__cumulative_water_stress]
doc = 'cumulative vegetation__water_stress over the growing season'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.VegCA.info.vegetation__plant_functional_type]
doc = 'classification of plants (int), grass=0, shrub=1, tree=2, bare=3, shrub_seedling=4, tree_seedling=5'
dtype = 'int64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.Vegetation]
name = 'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation'
unit_agnostic = false
summary = 'Landlab component that simulates net primary productivity, biomass and'

[components.Vegetation.info.surface__evapotranspiration]
doc = 'actual sum of evaporation and plant transpiration'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'mm'

[components.Vegetation.info.surface__potential_evapotranspiration_30day_mean]
doc = '30 day mean of surface__potential_evapotranspiration'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'mm'

[components.Vegetation.info.surface__potential_evapotranspiration_rate]
doc = 'potential sum of evaporation and potential transpiration'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'mm'

[components.Vegetation.info.vegetation__cover_fraction]
doc = 'fraction of land covered by vegetation'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.Vegetation.info.vegetation__dead_biomass]
doc = 'weight of dead organic mass per unit area - measured in terms of dry matter'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'g m^-2 d^-1'

[components.Vegetation.info.vegetation__dead_leaf_area_index]
doc = 'one-sided dead leaf area per unit ground surface area'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.Vegetation.info.vegetation__live_biomass]
doc = 'weight of green organic mass per unit area - measured in terms of dry matter'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'g m^-2 d^-1'

[components.Vegetation.info.vegetation__live_leaf_area_index]
doc = 'one-sided green leaf area per unit ground surface area'
dtype = 'float64'
intent = 'out'
mapping = 'cell'
optional = false
units = 'None'

[components.Vegetation.info.vegetation__plant_functional_type]
doc = 'classification of plants (int), grass=0, shrub=1, tree=2, bare=3, shrub_seedling=4, tree_seedling=5'
dtype = 'int64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.Vegetation.info.vegetation__water_stress]
doc = 'parameter that represents nonlinear effects of water deficit on plants'
dtype = 'float64'
intent = 'in'
mapping = 'cell'
optional = false
units = 'None'

[components.gFlex]
name = 'landlab.components.gflex.flexure.gFlex'
unit_agnostic = true
summary = "This is a Landlab wrapper for A Wickert's gFlex flexure model (Wickert"

[components.gFlex.info.lithosphere_surface__elevation_increment]
doc = 'The change in elevation of the top of the lithosphere (the land surface) in one timestep'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.gFlex.info.surface_load__stress]
doc = 'Magnitude of stress exerted by surface load'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'Pa'

[components.gFlex.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'out'
mapping = 'node'
optional = false
units = 'm'

[components.river_flow_dynamics]
name = 'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics'
unit_agnostic = false
summary = 'Simulate surface fluid flow based on Casulli and Cheng (1992).'

[components.river_flow_dynamics.info.surface_water__depth]
doc = 'Depth of water on the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.river_flow_dynamics.info.surface_water__elevation]
doc = 'Water surface elevation at time N'
dtype = 'float64'
intent = 'inout'
mapping = 'node'
optional = false
units = 'm'

[components.river_flow_dynamics.info.surface_water__velocity]
doc = 'Speed of water flow above the surface'
dtype = 'float64'
intent = 'inout'
mapping = 'link'
optional = false
units = 'm/s'

[components.river_flow_dynamics.info.topographic__elevation]
doc = 'Land surface topographic elevation'
dtype = 'float64'
intent = 'in'
mapping = 'node'
optional = false
units = 'm'

# Generated using `landlab index fields`
[fields]

[fields.LS_sediment__flux]
desc = 'Sediment flux originating from landslides                 (volume per unit time of sediment entering each node)'
used_by = []
provided_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]

[fields.advected__quantity]
desc = 'Scalar quantity advected'
used_by = []
provided_by = [
  'landlab.components.advection.advection_solver_tvd.AdvectionSolverTVD',
]

[fields.advection__flux]
desc = 'Link-parallel advection flux'
used_by = []
provided_by = [
  'landlab.components.advection.advection_solver_tvd.AdvectionSolverTVD',
]

[fields.advection__velocity]
desc = 'Link-parallel advection velocity magnitude'
used_by = [
  'landlab.components.advection.advection_solver_tvd.AdvectionSolverTVD',
  'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender',
]
provided_by = []

[fields.aquifer__thickness]
desc = 'thickness of saturated zone'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.aquifer_base__elevation]
desc = 'elevation of impervious layer'
used_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]
provided_by = []

[fields.aquifer_base__gradient]
desc = 'gradient of the aquifer base in the link direction'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.area_coefficient]
desc = 'Area coefficient to define channels.'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]
provided_by = []

[fields.area_exponent]
desc = 'Area exponent to define channels.'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]
provided_by = []

[fields.average_surface_water__specific_discharge]
desc = 'average surface water specific discharge over variable timesteps'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.bedload_sediment__rate_of_loss_to_abrasion]
desc = 'Rate of bedload sediment volume loss to abrasion per unit area'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
]

[fields.bedload_sediment__volume_influx]
desc = 'Volumetric incoming streamwise bedload sediment transport rate'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
]

[fields.bedload_sediment__volume_outflux]
desc = 'Volumetric outgoing streamwise bedload sediment transport rate'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
]

[fields.bedrock__abrasion_rate]
desc = 'rate of bedrock lowering by abrasion'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
]

[fields.bedrock__elevation]
desc = 'elevation of the bedrock surface'
used_by = [
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
]
provided_by = [
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
]

[fields.bedrock__exposure_fraction]
desc = 'fractional exposure of bedrock'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
]

[fields.bedrock__lowering_rate]
desc = 'Rate of lowering of bedrock surface'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
]

[fields.bedrock__plucking_rate]
desc = 'rate of bedrock lowering by plucking'
used_by = []
provided_by = [
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
]

[fields.bedrock_property__concentration]
desc = 'Mass concentration of property per unit volume of bedrock'
used_by = []
provided_by = [
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
]

[fields.carbonate_production_rate]
desc = 'Carbonate production rate'
used_by = []
provided_by = [
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
]

[fields.carbonate_thickness]
desc = 'Carbonate thickness'
used_by = []
provided_by = [
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
]

[fields.channel__bed_shear_stress]
desc = 'Shear exerted on the bed of the channel, assuming all discharge travels along a single, self-formed channel'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel__chi_index]
desc = 'the local steepness index'
used_by = []
provided_by = [
  'landlab.components.chi_index.channel_chi.ChiFinder',
]

[fields.channel__depth]
desc = 'Depth of the a single channel carrying all runoff through the node'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel__discharge]
desc = 'Volumetric water flux of the a single channel carrying all runoff through the node'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel__mask]
desc = 'Logical map of at which grid nodes channels are present'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
  'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator',
]
provided_by = []

[fields.channel__steepness_index]
desc = 'the local steepness index'
used_by = []
provided_by = [
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
]

[fields.channel__width]
desc = 'Width of the a single channel carrying all runoff through the node'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel_bottom_sediment_grain__d50_diameter]
desc = 'soil grain size average in stream segment'
used_by = [
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
]
provided_by = []

[fields.channel_sediment__relative_flux]
desc = 'The fluvial_sediment_flux_into_node divided by the fluvial_sediment_transport_capacity'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel_sediment__volumetric_flux]
desc = 'Total volumetric fluvial sediment flux brought into the node from upstream'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel_sediment__volumetric_transport_capacity]
desc = 'Volumetric transport capacity of a channel carrying all runoff through the node, assuming the Meyer-Peter Muller transport equation'
used_by = []
provided_by = [
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
]

[fields.channel_slope]
desc = 'Slope of the river channel through each reach'
used_by = []
provided_by = [
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
]

[fields.channel_width]
desc = 'Flow width of the channel, assuming constant width'
used_by = [
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
]
provided_by = []

[fields.channelization_threshold]
desc = 'Channelization threshold for use with area and slope coefficients and exponents.'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]
provided_by = []

[fields.depression__depth]
desc = 'Depth of depression below its spillway point'
used_by = []
provided_by = [
  'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter',
]

[fields.depression__outlet_node]
desc = 'If a depression, the id of the outlet node for that depression, otherwise grid.BAD_INDEX'
used_by = []
provided_by = [
  'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter',
]

[fields.depression_free_elevation]
desc = 'Filled land surface topographic elevation, at closed borders, value equals -1!'
used_by = []
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.dimensionless_discharge]
desc = 'Dimensionless discharge value for a stream segment.'
used_by = []
provided_by = [
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
]

[fields.dimensionless_discharge_above_threshold]
desc = 'True if dimensionless discharge value is above threshold value, false otherwise.'
used_by = []
provided_by = [
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
]

[fields.dimensionless_discharge_threshold]
desc = 'Dimensionless discharge threshold for each stream segment.'
used_by = []
provided_by = [
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
]

[fields.discharge_at_link]
desc = 'Dominant/formative discharge at each link in the network'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerDischarge',
]
provided_by = []

[fields.distance_to_divide]
desc = 'Distance from drainage divide.'
used_by = []
provided_by = [
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
]

[fields.drainage_area]
desc = "Upstream accumulated surface area contributing to the node's discharge"
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.profiler.channel_profiler.ChannelProfiler',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
]
provided_by = [
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.drainage_area_coefficient]
desc = 'Coefficient in a power law grain size-drainage area scaling relationship'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerArea',
]
provided_by = []

[fields.drainage_area_exponent]
desc = 'Exponent in a power law grain size-drainage area scaling relationship.'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerArea',
]
provided_by = []

[fields.ebb_tide_flow__velocity]
desc = 'Horizontal flow velocity along links during ebb tide'
used_by = []
provided_by = [
  'landlab.components.tidal_flow.tidal_flow_calculator.TidalFlowCalculator',
]

[fields.fault_plane__elevation]
desc = 'Elevation of fault plane'
used_by = []
provided_by = [
  'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender',
]

[fields.flood_status_code]
desc = 'Map of flood status (_PIT, _CURRENT_LAKE, _UNFLOODED, or _FLOODED).'
used_by = []
provided_by = [
  'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.flood_tide_flow__velocity]
desc = 'Horizontal flow velocity along links during flood tide'
used_by = []
provided_by = [
  'landlab.components.tidal_flow.tidal_flow_calculator.TidalFlowCalculator',
]

[fields.flow__data_structure_delta]
desc = "Node array containing the elements delta[1:] of the data structure 'delta' used for construction of the downstream-to-upstream node array"
used_by = [
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
]
provided_by = [
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
]

[fields.flow__link_direction]
desc = 'Direction of flow on link. A value of -1 indicates that water flow goes from head node to tail node, while a value of 1 indicates that water flow goes from tail node to head node.'
used_by = []
provided_by = [
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
]

[fields.flow__link_to_receiver_node]
desc = 'ID of link downstream of each node, which carries the discharge'
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.profiler.channel_profiler.ChannelProfiler',
  'landlab.components.profiler.trickle_down_profiler.TrickleDownProfiler',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
]
provided_by = [
  'landlab.components.flow_director.flow_director_d8.FlowDirectorD8',
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.flow__potential]
desc = "Value of the hypothetical field 'K', used to force water flux to flow downhill"
used_by = []
provided_by = [
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
  'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter',
]

[fields.flow__receiver_node]
desc = 'Node array of receivers (node that receives flow from current node)'
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
  'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
  'landlab.components.profiler.channel_profiler.ChannelProfiler',
  'landlab.components.profiler.trickle_down_profiler.TrickleDownProfiler',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]
provided_by = [
  'landlab.components.flow_director.flow_director_d8.FlowDirectorD8',
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.flow__receiver_proportions]
desc = 'Node array of proportion of flow sent to each receiver.'
used_by = [
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]
provided_by = [
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.flow__sink_flag]
desc = 'Boolean array, True at local lows'
used_by = [
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
]
provided_by = [
  'landlab.components.flow_director.flow_director_d8.FlowDirectorD8',
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
]

[fields.flow__upstream_node_order]
desc = 'Node array containing downstream-to-upstream ordered list of node IDs'
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
  'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
]
provided_by = [
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.flow_depth]
desc = 'Flow depth of the channel'
used_by = [
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
]
provided_by = []

[fields.flow_depth_at_link]
desc = 'Dominant/formative flow depth at each link in the network'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerDepth',
]
provided_by = []

[fields.fracture_at_node]
desc = 'presence (1) or absence (0) of fracture'
used_by = []
provided_by = [
  'landlab.components.fracture_grid.fracture_grid.FractureGridGenerator',
]

[fields.groundwater__specific_discharge]
desc = 'discharge per width in link dir'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.groundwater__velocity]
desc = 'velocity of groundwater in link direction'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.hangingwall__thickness]
desc = 'Thickness of material in hangingwall block'
used_by = []
provided_by = [
  'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender',
]

[fields.height_above_drainage__elevation]
desc = 'Elevation above the nearest channel node'
used_by = []
provided_by = [
  'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator',
]

[fields.hill_drainage_area]
desc = 'Node array of proportion of flow sent to each receiver.'
used_by = []
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hill_flow__receiver_node]
desc = 'Node array of receivers (node that receives flow from current node)'
used_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hill_flow__receiver_proportions]
desc = 'Node array of proportion of flow sent to each receiver.'
used_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hill_flow__upstream_node_order]
desc = 'Node array containing downstream-to-upstream ordered list of node IDs'
used_by = []
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hill_surface_water__discharge]
desc = 'Node array of proportion of flow sent to each receiver.'
used_by = []
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hill_topographic__steepest_slope]
desc = 'The steepest *downhill* slope'
used_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.hillslope_sediment__unit_volume_flux]
desc = 'Volume flux per unit width along links'
used_by = []
provided_by = [
  'landlab.components.diffusion.diffusion.LinearDiffuser',
]

[fields.hydraulic__gradient]
desc = 'gradient of water table in link direction'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.is_pit]
desc = 'Boolean flag indicating whether a node is a pit.'
used_by = []
provided_by = [
  'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter',
]

[fields.landslide__deposition]
desc = 'Total deposition of derived sediment'
used_by = []
provided_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]

[fields.landslide__erosion]
desc = 'Total erosion caused by landsliding '
used_by = []
provided_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]

[fields.landslide__probability_of_failure]
desc = 'number of times FS is <=1 out of number of iterations user selected'
used_by = []
provided_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]

[fields.landslide_sediment_point_source]
desc = 'Landslide derived sediment, as point sources on all the                 critical nodes where landslides initiate,                 before landslide runout is calculated '
used_by = []
provided_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
]

[fields.lateral_erosion__depth_increment]
desc = 'Change in elevation at each node from lateral erosion during time step'
used_by = []
provided_by = [
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
]

[fields.lithosphere__increment_of_overlying_pressure]
desc = 'Applied pressure to the lithosphere over a time step'
used_by = [
  'landlab.components.flexure.flexure_1d.Flexure1D',
]
provided_by = []

[fields.lithosphere__overlying_pressure_increment]
desc = 'Applied pressure to the lithosphere over a time step'
used_by = [
  'landlab.components.flexure.flexure.Flexure',
]
provided_by = []

[fields.lithosphere_surface__elevation_increment]
desc = 'The change in elevation of the top of the lithosphere (the land surface) in one timestep'
used_by = []
provided_by = [
  'landlab.components.flexure.flexure.Flexure',
  'landlab.components.gflex.flexure.gFlex',
]

[fields.lithosphere_surface__increment_of_elevation]
desc = 'The change in elevation of the top of the lithosphere (the land surface) in one timestep'
used_by = []
provided_by = [
  'landlab.components.flexure.flexure_1d.Flexure1D',
]

[fields.mass__wasting_id]
desc = 'interger or float id of each mass wasting area is assigned                 to all nodes representing the mass wasting area.'
used_by = [
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]
provided_by = []

[fields.mean_water__depth]
desc = 'Tidal mean water depth'
used_by = []
provided_by = [
  'landlab.components.tidal_flow.tidal_flow_calculator.TidalFlowCalculator',
]

[fields.particle__diameter]
desc = 'representative particle diameter at each node, this might             vary with underlying geology, contributing area or field observations'
used_by = [
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]
provided_by = [
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]

[fields.plant__age]
desc = 'Age of plant'
used_by = []
provided_by = [
  'landlab.components.plant_competition_ca.plant_competition_ca.VegCA',
]

[fields.plant__live_index]
desc = '1 - vegetation__cumulative_water_stress'
used_by = []
provided_by = [
  'landlab.components.plant_competition_ca.plant_competition_ca.VegCA',
]

[fields.radiation__clearsky_flux]
desc = 'clearsky radiation'
used_by = []
provided_by = [
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__extraterrestrial_flux]
desc = 'extraterrestrial radiation'
used_by = []
provided_by = [
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__incoming_shortwave_flux]
desc = 'incident shortwave radiation'
used_by = []
provided_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__net_flux]
desc = 'net radiation'
used_by = []
provided_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__net_longwave_flux]
desc = 'net incident longwave radiation'
used_by = []
provided_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__net_shortwave_flux]
desc = 'net incident shortwave radiation'
used_by = []
provided_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
  'landlab.components.radiation.radiation.Radiation',
]

[fields.radiation__ratio_to_flat_surface]
desc = 'ratio of incident shortwave radiation on sloped surface to flat surface'
used_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
]
provided_by = [
  'landlab.components.radiation.radiation.Radiation',
]

[fields.rainfall__daily_depth]
desc = 'Rain in (mm) as a field, allowing spatio-temporal soil moisture saturation analysis.'
used_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]
provided_by = []

[fields.rainfall__flux]
desc = 'Depth of water delivered per unit time in each storm'
used_by = []
provided_by = [
  'landlab.components.spatial_precip.generate_spatial_precip.SpatialPrecipitationDistribution',
  'landlab.components.uniform_precip.generate_uniform_precip.PrecipitationDistribution',
]

[fields.rainfall__total_depth_per_year]
desc = 'Depth of water delivered in total in each model year'
used_by = []
provided_by = [
  'landlab.components.spatial_precip.generate_spatial_precip.SpatialPrecipitationDistribution',
]

[fields.reach_length]
desc = 'Length of each reach'
used_by = [
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
]
provided_by = []

[fields.sea_level__elevation]
desc = 'Sea level elevation'
used_by = [
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
  'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser',
]
provided_by = []

[fields.sediment__deposition_coeff]
desc = 'Fraction of incoming sediment that is deposited on the node'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__deposition_rate]
desc = 'Deposition rate on node'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__discharge_in]
desc = 'Sediment discharge into a node.'
used_by = [
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
]
provided_by = []

[fields.sediment__erosion_rate]
desc = 'Erosion rate on node'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__flux_in]
desc = 'Incoming sediment rate on node (=qs/dx)'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__flux_out]
desc = 'Outgoing sediment rate on node = sediment eroded on node + sediment transported across node from upstream'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__influx]
desc = 'Sediment flux (volume per unit time of sediment entering each node)'
used_by = []
provided_by = [
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
]

[fields.sediment__outflux]
desc = 'Sediment flux (volume per unit time of sediment leaving each node)'
used_by = []
provided_by = [
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
]

[fields.sediment__rate_of_change]
desc = 'Time rate of change of sediment thickness'
used_by = []
provided_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
]

[fields.sediment__transfer_rate]
desc = 'Rate of transferred sediment across a node (incoming sediment - deposited sediment on node)'
used_by = []
provided_by = [
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.sediment__volume_influx]
desc = 'Volumetric incoming streamwise sediment transport rate'
used_by = []
provided_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
]

[fields.sediment__volume_outflux]
desc = 'Volumetric outgoing streamwise sediment transport rate'
used_by = []
provided_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
]

[fields.sediment_deposit__thickness]
desc = 'Thickness of deposition or erosion in latest time step'
used_by = []
provided_by = [
  'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser',
]

[fields.sediment_fill__depth]
desc = 'Depth of sediment added at eachnode'
used_by = []
provided_by = [
  'landlab.components.sink_fill.fill_sinks.SinkFiller',
  'landlab.components.sink_fill.sink_fill_barnes.SinkFillerBarnes',
]

[fields.sediment_property__concentration]
desc = 'Mass concentration of property per unit volume of sediment'
used_by = []
provided_by = [
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
]

[fields.slope_coefficient]
desc = 'Slope coefficient to define channels.'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]
provided_by = []

[fields.slope_exponent]
desc = 'Slope exponent to define channels.'
used_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]
provided_by = []

[fields.soil__density]
desc = 'wet bulk density of soil'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__depth]
desc = 'Depth of soil or weathered bedrock'
used_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
  'landlab.components.weathering.exponential_weathering.ExponentialWeatherer',
  'landlab.components.weathering.exponential_weathering_integrated.ExponentialWeathererIntegrated',
]
provided_by = [
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
]

[fields.soil__flux]
desc = 'flux of soil in direction of link'
used_by = [
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
]
provided_by = [
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.taylor_nonlinear_hillslope_flux.taylor_nonlinear_hillslope_flux.TaylorNonLinearDiffuser',
]

[fields.soil__internal_friction_angle]
desc = 'critical angle just before failure due to friction between particles'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__maximum_total_cohesion]
desc = 'maximum of combined root and soil cohesion at node'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__mean_relative_wetness]
desc = 'Indicator of soil wetness; relative depth perched water table within the soil layer'
used_by = []
provided_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]

[fields.soil__minimum_total_cohesion]
desc = 'minimum of combined root and soil cohesion at node'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__mode_total_cohesion]
desc = 'mode of combined root and soil cohesion at node'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__probability_of_saturation]
desc = 'number of times relative wetness is >=1 out of number of iterations user selected'
used_by = []
provided_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]

[fields.soil__saturated_hydraulic_conductivity]
desc = 'mode rate of water transmitted through soil - provided if transmissivity is NOT provided to calculate tranmissivity with soil depth'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil__thickness]
desc = 'soil depth to restrictive layer'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]
provided_by = [
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
]

[fields.soil__transmissivity]
desc = 'mode rate of water transmitted through a unit width of saturated soil - either provided or calculated with Ksat and soil depth'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.soil_moisture__initial_saturation_fraction]
desc = 'initial soil_moisture__saturation_fraction'
used_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]
provided_by = []

[fields.soil_moisture__root_zone_leakage]
desc = 'leakage of water into deeper portions of the soil not accessible to the plant'
used_by = []
provided_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]

[fields.soil_moisture__saturation_fraction]
desc = 'relative volumetric water content (theta) - limits=[0,1]'
used_by = []
provided_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]

[fields.soil_production__dt_produced_depth]
desc = 'thickness of soil produced at nodes over time dt'
used_by = []
provided_by = [
  'landlab.components.weathering.exponential_weathering_integrated.ExponentialWeathererIntegrated',
]

[fields.soil_production__dt_weathered_depth]
desc = 'thickness of bedrock weathered at nodes over time dt'
used_by = []
provided_by = [
  'landlab.components.weathering.exponential_weathering_integrated.ExponentialWeathererIntegrated',
]

[fields.soil_production__rate]
desc = 'rate of soil production at nodes'
used_by = [
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
]
provided_by = [
  'landlab.components.weathering.exponential_weathering.ExponentialWeatherer',
  'landlab.components.weathering.exponential_weathering_integrated.ExponentialWeathererIntegrated',
]

[fields.soil_water_infiltration__depth]
desc = 'Water column height above the surface previously absorbed into the soil. Note that this is NOT the actual depth of the wetted front, which also depends on the porosity.'
used_by = [
  'landlab.components.soil_moisture.infiltrate_soil_green_ampt.SoilInfiltrationGreenAmpt',
]
provided_by = [
  'landlab.components.soil_moisture.infiltrate_soil_green_ampt.SoilInfiltrationGreenAmpt',
]

[fields.squared_length_adjacent]
desc = 'Length to adjacent nodes, squared (calcualted in advance to save time during calculation'
used_by = []
provided_by = [
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.surface__evapotranspiration]
desc = 'actual sum of evaporation and plant transpiration'
used_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]
provided_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]

[fields.surface__potential_evapotranspiration_30day_mean]
desc = '30 day mean of surface__potential_evapotranspiration'
used_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]
provided_by = []

[fields.surface__potential_evapotranspiration_rate]
desc = 'potential sum of evaporation and potential transpiration'
used_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]
provided_by = [
  'landlab.components.pet.potential_evapotranspiration_field.PotentialEvapotranspiration',
]

[fields.surface__runoff]
desc = 'runoff from ground surface'
used_by = []
provided_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]

[fields.surface_load__stress]
desc = 'Magnitude of stress exerted by surface load'
used_by = [
  'landlab.components.gflex.flexure.gFlex',
]
provided_by = []

[fields.surface_to_channel__minimum_distance]
desc = 'Distance from each node to the nearest channel'
used_by = []
provided_by = [
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
]

[fields.surface_water__depth]
desc = 'Depth of water on the surface'
used_by = [
  'landlab.components.detachment_ltd_erosion.generate_erosion_by_depth_slope.DepthSlopeProductErosion',
  'landlab.components.overland_flow.generate_overland_flow_Bates.OverlandFlowBates',
  'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow',
  'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers',
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
  'landlab.components.soil_moisture.infiltrate_soil_green_ampt.SoilInfiltrationGreenAmpt',
]
provided_by = [
  'landlab.components.overland_flow.generate_overland_flow_Bates.OverlandFlowBates',
  'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow',
  'landlab.components.overland_flow.generate_overland_flow_implicit_kinwave.KinwaveImplicitOverlandFlow',
  'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel',
  'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers',
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
  'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter',
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
  'landlab.components.soil_moisture.infiltrate_soil_green_ampt.SoilInfiltrationGreenAmpt',
]

[fields.surface_water__depth_at_link]
desc = 'Depth of water on the surface at grid links'
used_by = []
provided_by = [
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
]

[fields.surface_water__discharge]
desc = 'Volumetric discharge of surface water'
used_by = [
  'landlab.components.detachment_ltd_erosion.generate_detachment_ltd_erosion.DetachmentLtdErosion',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
]
provided_by = [
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.overland_flow.generate_overland_flow_Bates.OverlandFlowBates',
  'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow',
  'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers',
  'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.surface_water__discharge_loss]
desc = 'Total volume of water per second lost during all flow out of the node'
used_by = []
provided_by = [
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
]

[fields.surface_water__elevation]
desc = 'Water surface elevation at time N'
used_by = [
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
]
provided_by = [
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
]

[fields.surface_water__specific_discharge]
desc = 'rate of seepage to surface'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

[fields.surface_water__unit_discharge]
desc = 'Volumetric discharge of surface water per unit width'
used_by = [
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
]
provided_by = []

[fields.surface_water__velocity]
desc = 'Speed of water flow above the surface'
used_by = [
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
]
provided_by = [
  'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers',
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
]

[fields.surface_water_inflow__discharge]
desc = 'water volume inflow rate to the cell around each node'
used_by = []
provided_by = [
  'landlab.components.overland_flow.generate_overland_flow_implicit_kinwave.KinwaveImplicitOverlandFlow',
]

[fields.taxa__richness]
desc = 'The number of taxa at each node'
used_by = []
provided_by = [
  'landlab.components.species_evolution.species_evolver.SpeciesEvolver',
]

[fields.time]
desc = 'The initial time to add to the record'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerArea',
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerUserD50',
]
provided_by = []

[fields.topographic__elevation]
desc = 'Land surface topographic elevation'
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.concentration_tracker.concentration_tracker_for_diffusion.ConcentrationTrackerForDiffusion',
  'landlab.components.depression_finder.lake_mapper.DepressionFinderAndRouter',
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.detachment_ltd_erosion.generate_detachment_ltd_erosion.DetachmentLtdErosion',
  'landlab.components.detachment_ltd_erosion.generate_erosion_by_depth_slope.DepthSlopeProductErosion',
  'landlab.components.diffusion.diffusion.LinearDiffuser',
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.flow_director.flow_director_d8.FlowDirectorD8',
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
  'landlab.components.hack_calculator.hack_calculator.HackCalculator',
  'landlab.components.hand_calculator.hand_calculator.HeightAboveDrainageCalculator',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser',
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
  'landlab.components.nonlinear_diffusion.Perron_nl_diffuse.PerronNLDiffuse',
  'landlab.components.normal_fault.normal_fault.NormalFault',
  'landlab.components.overland_flow.generate_overland_flow_Bates.OverlandFlowBates',
  'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow',
  'landlab.components.overland_flow.generate_overland_flow_implicit_kinwave.KinwaveImplicitOverlandFlow',
  'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel',
  'landlab.components.overland_flow.kinematic_wave_rengers.KinematicWaveRengers',
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
  'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
  'landlab.components.radiation.radiation.Radiation',
  'landlab.components.river_flow_dynamics.river_flow_dynamics.river_flow_dynamics',
  'landlab.components.sink_fill.fill_sinks.SinkFiller',
  'landlab.components.sink_fill.sink_fill_barnes.SinkFillerBarnes',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.spatial_precip.generate_spatial_precip.SpatialPrecipitationDistribution',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
  'landlab.components.taylor_nonlinear_hillslope_flux.taylor_nonlinear_hillslope_flux.TaylorNonLinearDiffuser',
  'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
  'landlab.components.tidal_flow.tidal_flow_calculator.TidalFlowCalculator',
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]
provided_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.detachment_ltd_erosion.generate_detachment_ltd_erosion.DetachmentLtdErosion',
  'landlab.components.detachment_ltd_erosion.generate_erosion_by_depth_slope.DepthSlopeProductErosion',
  'landlab.components.diffusion.diffusion.LinearDiffuser',
  'landlab.components.dimensionless_discharge.dimensionless_discharge.DimensionlessDischarge',
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gflex.flexure.gFlex',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.lake_fill.lake_fill_barnes.LakeMapperBarnes',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser',
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
  'landlab.components.network_sediment_transporter.network_sediment_transporter.NetworkSedimentTransporter',
  'landlab.components.nonlinear_diffusion.Perron_nl_diffuse.PerronNLDiffuse',
  'landlab.components.normal_fault.normal_fault.NormalFault',
  'landlab.components.sink_fill.fill_sinks.SinkFiller',
  'landlab.components.sink_fill.sink_fill_barnes.SinkFillerBarnes',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.stream_power.fastscape_stream_power.FastscapeEroder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.stream_power.stream_power.StreamPowerEroder',
  'landlab.components.stream_power.stream_power_smooth_threshold.StreamPowerSmoothThresholdEroder',
  'landlab.components.taylor_nonlinear_hillslope_flux.taylor_nonlinear_hillslope_flux.TaylorNonLinearDiffuser',
  'landlab.components.tectonics.listric_kinematic_extender.ListricKinematicExtender',
  'landlab.components.threshold_eroder.threshold_eroder.ThresholdEroder',
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]

[fields.topographic__gradient]
desc = 'Gradient of the ground surface'
used_by = [
  'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel',
]
provided_by = [
  'landlab.components.diffusion.diffusion.LinearDiffuser',
  'landlab.components.overland_flow.generate_overland_flow_implicit_kinwave.KinwaveImplicitOverlandFlow',
]

[fields.topographic__slope]
desc = 'gradient of the ground surface'
used_by = [
  'landlab.components.detachment_ltd_erosion.generate_detachment_ltd_erosion.DetachmentLtdErosion',
  'landlab.components.detachment_ltd_erosion.generate_erosion_by_depth_slope.DepthSlopeProductErosion',
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = [
  'landlab.components.depth_dependent_diffusion.hillslope_depth_dependent_linear_flux.DepthDependentDiffuser',
  'landlab.components.depth_dependent_taylor_soil_creep.hillslope_depth_dependent_taylor_flux.DepthDependentTaylorDiffuser',
  'landlab.components.taylor_nonlinear_hillslope_flux.taylor_nonlinear_hillslope_flux.TaylorNonLinearDiffuser',
]

[fields.topographic__specific_contributing_area]
desc = 'specific contributing (upslope area/cell face ) that drains to node'
used_by = [
  'landlab.components.landslides.landslide_probability.LandslideProbability',
]
provided_by = []

[fields.topographic__steepest_slope]
desc = 'The steepest *downhill* slope'
used_by = [
  'landlab.components.area_slope_transporter.area_slope_transporter.AreaSlopeTransporter',
  'landlab.components.bedrock_landslider.bedrock_landslider.BedrockLandslider',
  'landlab.components.chi_index.channel_chi.ChiFinder',
  'landlab.components.drainage_density.drainage_density.DrainageDensity',
  'landlab.components.erosion_deposition.erosion_deposition.ErosionDeposition',
  'landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder.GravelBedrockEroder',
  'landlab.components.gravel_river_transporter.gravel_river_transporter.GravelRiverTransporter',
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
  'landlab.components.mass_wasting_runout.mass_wasting_runout.MassWastingRunout',
  'landlab.components.space.space.Space',
  'landlab.components.space.space_large_scale_eroder.SpaceLargeScaleEroder',
  'landlab.components.steepness_index.channel_steepness.SteepnessFinder',
  'landlab.components.stream_power.sed_flux_dep_incision.SedDepEroder',
  'landlab.components.transport_length_diffusion.transport_length_hillslope_diffusion.TransportLengthHillslopeDiffuser',
]
provided_by = [
  'landlab.components.flow_director.flow_director_d8.FlowDirectorD8',
  'landlab.components.flow_director.flow_director_dinf.FlowDirectorDINF',
  'landlab.components.flow_director.flow_director_mfd.FlowDirectorMFD',
  'landlab.components.flow_director.flow_director_steepest.FlowDirectorSteepest',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]

[fields.user_d50]
desc = 'Median grain size of the bed sediment in each link'
used_by = [
  'landlab.components.network_sediment_transporter.bed_parcel_initializers.BedParcelInitializerUserD50',
]
provided_by = []

[fields.vegetation__cover_fraction]
desc = 'fraction of land covered by vegetation'
used_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]
provided_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]

[fields.vegetation__cumulative_water_stress]
desc = 'cumulative vegetation__water_stress over the growing season'
used_by = [
  'landlab.components.plant_competition_ca.plant_competition_ca.VegCA',
]
provided_by = []

[fields.vegetation__dead_biomass]
desc = 'weight of dead organic mass per unit area - measured in terms of dry matter'
used_by = []
provided_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]

[fields.vegetation__dead_leaf_area_index]
desc = 'one-sided dead leaf area per unit ground surface area'
used_by = []
provided_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]

[fields.vegetation__live_biomass]
desc = 'weight of green organic mass per unit area - measured in terms of dry matter'
used_by = []
provided_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]

[fields.vegetation__live_leaf_area_index]
desc = 'one-sided green leaf area per unit ground surface area'
used_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]
provided_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]

[fields.vegetation__plant_functional_type]
desc = 'classification of plants (int), grass=0, shrub=1, tree=2, bare=3, shrub_seedling=4, tree_seedling=5'
used_by = [
  'landlab.components.plant_competition_ca.plant_competition_ca.VegCA',
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]
provided_by = []

[fields.vegetation__water_stress]
desc = 'parameter that represents nonlinear effects of water deficit on plants'
used_by = [
  'landlab.components.vegetation_dynamics.vegetation_dynamics.Vegetation',
]
provided_by = [
  'landlab.components.soil_moisture.soil_moisture_dynamics.SoilMoisture',
]

[fields.volume__lateral_erosion]
desc = 'Array tracking volume eroded at each node from lateral erosion'
used_by = []
provided_by = [
  'landlab.components.lateral_erosion.lateral_erosion.LateralEroder',
]

[fields.water__depth]
desc = 'depth of water under current sea level'
used_by = []
provided_by = [
  'landlab.components.marine_sediment_transport.simple_submarine_diffuser.SimpleSubmarineDiffuser',
]

[fields.water__discharge_in]
desc = 'Incoming water discharge at node.'
used_by = [
  'landlab.components.discharge_diffuser.diffuse_by_discharge.DischargeDiffuser',
]
provided_by = []

[fields.water__specific_discharge]
desc = 'flow discharge component in the direction of the link'
used_by = []
provided_by = [
  'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel',
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
]

[fields.water__unit_flux_in]
desc = 'External volume water per area per time input to each node (e.g., rainfall rate)'
used_by = [
  'landlab.components.flow_accum.flow_accumulator.FlowAccumulator',
  'landlab.components.flow_accum.lossy_flow_accumulator.LossyFlowAccumulator',
  'landlab.components.potentiality_flowrouting.route_flow_by_boundary.PotentialityFlowRouter',
  'landlab.components.priority_flood_flow_router.priority_flood_flow_router.PriorityFloodFlowRouter',
]
provided_by = []

[fields.water__velocity]
desc = 'flow velocity component in the direction of the link'
used_by = []
provided_by = [
  'landlab.components.overland_flow.generate_overland_flow_kinwave.KinwaveOverlandFlowModel',
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
]

[fields.water_depth]
desc = 'Water depth'
used_by = []
provided_by = [
  'landlab.components.carbonate.carbonate_producer.CarbonateProducer',
]

[fields.water_surface__elevation]
desc = 'Elevation of the water surface.'
used_by = []
provided_by = [
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
]

[fields.water_surface__gradient]
desc = 'Downstream gradient of the water surface.'
used_by = []
provided_by = [
  'landlab.components.overland_flow.generate_overland_flow_deAlmeida.OverlandFlow',
  'landlab.components.overland_flow.linear_diffusion_overland_flow_router.LinearDiffusionOverlandFlowRouter',
]

[fields.water_table__elevation]
desc = 'elevation of water table'
used_by = []
provided_by = [
  'landlab.components.groundwater.dupuit_percolator.GroundwaterDupuitPercolator',
]

# Generated using `landlab index grids`
[grids]

[grids.FramedVoronoiGrid]
boundary-condition = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_adjacent_nodes_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.closed_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_cells',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_value_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_core_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_has_boundary_neighbor',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_is_boundary',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_active_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_active_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_cells',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_fixed_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.open_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.set_nodata_nodes_to_closed',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_node',
]
connectivity = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_adjacent_nodes_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_link_dirs_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cell_area_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.downwind_links_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_downwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_upwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_core_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_has_boundary_neighbor',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.add_empty',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.add_field',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.add_full',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.add_ones',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.add_zeros',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.delete_field',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.empty',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.new_field_location',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.ones',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.zeros',
]
field-io = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.field_values',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_diff_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_flux_div_at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_flux_div_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_grad_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_grad_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_net_flux_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_slope_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_slope_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cell_area_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_cells',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_node_to_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_core_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.field_units',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.has_field',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.has_group',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.keys',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.size',
]
info-grid = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.axis_name',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.axis_units',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_axis_coordinates',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_elements',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.size',
]
info-link = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_link_dirs_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.angle_of_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.angle_of_link_about_head',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_diff_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_grad_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.downwind_links_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.length_of_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_downwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_upwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.links_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.links_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_head_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_tail_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_vector_sum_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_max_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_min_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.midpoint_of_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_active_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_fixed_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_present_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.resolve_values_on_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_adjacent_nodes_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_link_dirs_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.adjacent_nodes_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_node_azimuths_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_node_distances_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_aspect_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_flux_div_at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_flux_div_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_hillshade_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_net_flux_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_slope_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cell_area_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.closed_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.downwind_links_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_value_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_downwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_node_is_upwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_head_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_tail_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_node_to_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_max_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_min_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_core_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_link_head',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_link_tail',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_axis_coordinates',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_has_boundary_neighbor',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_is_boundary',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.open_boundary_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_present_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.set_nodata_nodes_to_closed',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.upwind_links_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.x_of_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.y_of_node',
]
info-patch = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.area_of_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_grad_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_slope_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_unit_normal_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_vector_sum_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_patches_present_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_present_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patches_present_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_patch',
]
map = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_head_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_tail_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_vector_sum_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_node_links_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_node_to_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_max_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_min_node_to_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_node_azimuths_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_node_distances_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.angle_of_link_about_head',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_axis_coordinates',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [

]
surface = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_aspect_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_hillshade_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BAD_INDEX',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_LINK_IS_FIXED',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_NODE_IS_CORE',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.VALID_LOCATIONS',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_adjacent_corners_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.active_face_dirs_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.adjacent_corners_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.adjacent_faces_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.adjacent_links_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_corner_azimuths_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.all_corner_distances_map',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.angle_of_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.angle_of_face_about_head',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.area_of_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.as_dataarray',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.as_dataset',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_grid',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_layer',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.boundary_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cell_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cells_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cells_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cells_present_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.cells_present_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.closed_boundary_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.core_patches',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_at_core_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_at_face_head',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_at_face_tail',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_at_patch',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_layout',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_x',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corner_y',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_bottom_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_left_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_right_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.corners_at_top_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.default_group',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.ds',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.dual',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.event_layers',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.face_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.face_dirs_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.face_status_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.faces_at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.faces_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fields',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_corner_anchor_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_corner_fixed_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.fixed_value_boundary_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.freeze',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.from_dict',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.from_file',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.from_netcdf',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.frozen',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.groups',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.imshow',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.length_of_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_dirs_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_status_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_with_angle',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.link_with_node_status',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.load',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_link_vector_components_to_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_node_to_link_linear_upwind',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.map_vectors_to_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.material_layers',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.merge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.midpoint_of_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.ndim',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_at_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_layout',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_x',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.node_y',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_bottom_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_left_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_right_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.nodes_at_top_edge',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_cells',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_cells_present_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_cells_present_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_core_patches',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_fixed_faces',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.number_of_links',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.open_boundary_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.orientation',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patch_area_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.patch_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.perimeter_corners',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.perimeter_nodes',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.reset_status_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.shape',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.sort',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.status_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.thaw',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.thawed',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.to_dict',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.to_json',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.to_netcdf',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_at_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_at_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_at_node',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_xcomponent_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.unit_vector_sum_ycomponent_at_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.x_of_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_cell',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_corner',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_face',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_link',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_of_reference',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.xy_spacing',
  'landlab.grid.framed_voronoi.FramedVoronoiGrid.y_of_corner',
]

[grids.HexModelGrid]
boundary-condition = [
  'landlab.grid.hex.HexModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.hex.HexModelGrid.active_faces',
  'landlab.grid.hex.HexModelGrid.active_links',
  'landlab.grid.hex.HexModelGrid.boundary_nodes',
  'landlab.grid.hex.HexModelGrid.closed_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.core_cells',
  'landlab.grid.hex.HexModelGrid.core_nodes',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.fixed_links',
  'landlab.grid.hex.HexModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.node_at_core_cell',
  'landlab.grid.hex.HexModelGrid.node_has_boundary_neighbor',
  'landlab.grid.hex.HexModelGrid.node_is_boundary',
  'landlab.grid.hex.HexModelGrid.number_of_active_faces',
  'landlab.grid.hex.HexModelGrid.number_of_active_links',
  'landlab.grid.hex.HexModelGrid.number_of_core_cells',
  'landlab.grid.hex.HexModelGrid.number_of_core_nodes',
  'landlab.grid.hex.HexModelGrid.number_of_fixed_links',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_link',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_node',
  'landlab.grid.hex.HexModelGrid.open_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.hex.HexModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.hex.HexModelGrid.set_watershed_boundary_condition',
  'landlab.grid.hex.HexModelGrid.set_watershed_boundary_condition_outlet_id',
  'landlab.grid.hex.HexModelGrid.status_at_link',
  'landlab.grid.hex.HexModelGrid.status_at_node',
]
connectivity = [
  'landlab.grid.hex.HexModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.hex.HexModelGrid.active_link_dirs_at_node',
  'landlab.grid.hex.HexModelGrid.cell_area_at_node',
  'landlab.grid.hex.HexModelGrid.downwind_links_at_node',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_downwind',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_upwind',
  'landlab.grid.hex.HexModelGrid.node_at_core_cell',
  'landlab.grid.hex.HexModelGrid.node_has_boundary_neighbor',
  'landlab.grid.hex.HexModelGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.hex.HexModelGrid.add_empty',
  'landlab.grid.hex.HexModelGrid.add_field',
  'landlab.grid.hex.HexModelGrid.add_full',
  'landlab.grid.hex.HexModelGrid.add_ones',
  'landlab.grid.hex.HexModelGrid.add_zeros',
  'landlab.grid.hex.HexModelGrid.delete_field',
  'landlab.grid.hex.HexModelGrid.empty',
  'landlab.grid.hex.HexModelGrid.new_field_location',
  'landlab.grid.hex.HexModelGrid.ones',
  'landlab.grid.hex.HexModelGrid.zeros',
]
field-io = [
  'landlab.grid.hex.HexModelGrid.at_cell',
  'landlab.grid.hex.HexModelGrid.at_corner',
  'landlab.grid.hex.HexModelGrid.at_face',
  'landlab.grid.hex.HexModelGrid.at_link',
  'landlab.grid.hex.HexModelGrid.at_node',
  'landlab.grid.hex.HexModelGrid.at_patch',
  'landlab.grid.hex.HexModelGrid.field_values',
  'landlab.grid.hex.HexModelGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.hex.HexModelGrid.calc_diff_at_link',
  'landlab.grid.hex.HexModelGrid.calc_flux_div_at_cell',
  'landlab.grid.hex.HexModelGrid.calc_flux_div_at_node',
  'landlab.grid.hex.HexModelGrid.calc_grad_at_link',
  'landlab.grid.hex.HexModelGrid.calc_grad_at_patch',
  'landlab.grid.hex.HexModelGrid.calc_net_flux_at_node',
  'landlab.grid.hex.HexModelGrid.calc_slope_at_node',
  'landlab.grid.hex.HexModelGrid.calc_slope_at_patch',
  'landlab.grid.hex.HexModelGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.hex.HexModelGrid.cell_area_at_node',
  'landlab.grid.hex.HexModelGrid.core_cells',
  'landlab.grid.hex.HexModelGrid.map_node_to_cell',
  'landlab.grid.hex.HexModelGrid.node_at_core_cell',
  'landlab.grid.hex.HexModelGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.hex.HexModelGrid.active_faces',
  'landlab.grid.hex.HexModelGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.hex.HexModelGrid.field_units',
  'landlab.grid.hex.HexModelGrid.has_field',
  'landlab.grid.hex.HexModelGrid.has_group',
  'landlab.grid.hex.HexModelGrid.keys',
  'landlab.grid.hex.HexModelGrid.size',
]
info-grid = [
  'landlab.grid.hex.HexModelGrid.axis_name',
  'landlab.grid.hex.HexModelGrid.axis_units',
  'landlab.grid.hex.HexModelGrid.hexplot',
  'landlab.grid.hex.HexModelGrid.node_axis_coordinates',
  'landlab.grid.hex.HexModelGrid.number_of_elements',
  'landlab.grid.hex.HexModelGrid.number_of_node_columns',
  'landlab.grid.hex.HexModelGrid.number_of_node_rows',
  'landlab.grid.hex.HexModelGrid.size',
]
info-link = [
  'landlab.grid.hex.HexModelGrid.active_link_dirs_at_node',
  'landlab.grid.hex.HexModelGrid.active_links',
  'landlab.grid.hex.HexModelGrid.angle_of_link',
  'landlab.grid.hex.HexModelGrid.angle_of_link_about_head',
  'landlab.grid.hex.HexModelGrid.calc_diff_at_link',
  'landlab.grid.hex.HexModelGrid.calc_grad_at_link',
  'landlab.grid.hex.HexModelGrid.downwind_links_at_node',
  'landlab.grid.hex.HexModelGrid.fixed_links',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_downwind',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_upwind',
  'landlab.grid.hex.HexModelGrid.links_at_node',
  'landlab.grid.hex.HexModelGrid.links_at_patch',
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_link_head_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_link_tail_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.hex.HexModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.midpoint_of_link',
  'landlab.grid.hex.HexModelGrid.number_of_active_links',
  'landlab.grid.hex.HexModelGrid.number_of_fixed_links',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_link',
  'landlab.grid.hex.HexModelGrid.patches_present_at_link',
  'landlab.grid.hex.HexModelGrid.resolve_values_on_links',
  'landlab.grid.hex.HexModelGrid.status_at_link',
  'landlab.grid.hex.HexModelGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.hex.HexModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.hex.HexModelGrid.active_link_dirs_at_node',
  'landlab.grid.hex.HexModelGrid.adjacent_nodes_at_node',
  'landlab.grid.hex.HexModelGrid.all_node_azimuths_map',
  'landlab.grid.hex.HexModelGrid.all_node_distances_map',
  'landlab.grid.hex.HexModelGrid.boundary_nodes',
  'landlab.grid.hex.HexModelGrid.calc_aspect_at_node',
  'landlab.grid.hex.HexModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.hex.HexModelGrid.calc_flux_div_at_cell',
  'landlab.grid.hex.HexModelGrid.calc_flux_div_at_node',
  'landlab.grid.hex.HexModelGrid.calc_hillshade_at_node',
  'landlab.grid.hex.HexModelGrid.calc_net_flux_at_node',
  'landlab.grid.hex.HexModelGrid.calc_slope_at_node',
  'landlab.grid.hex.HexModelGrid.cell_area_at_node',
  'landlab.grid.hex.HexModelGrid.closed_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.core_nodes',
  'landlab.grid.hex.HexModelGrid.downwind_links_at_node',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_downwind',
  'landlab.grid.hex.HexModelGrid.link_at_node_is_upwind',
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_link_head_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_link_tail_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_node_to_cell',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.node_at_core_cell',
  'landlab.grid.hex.HexModelGrid.node_at_link_head',
  'landlab.grid.hex.HexModelGrid.node_at_link_tail',
  'landlab.grid.hex.HexModelGrid.node_axis_coordinates',
  'landlab.grid.hex.HexModelGrid.node_has_boundary_neighbor',
  'landlab.grid.hex.HexModelGrid.node_is_boundary',
  'landlab.grid.hex.HexModelGrid.nodes',
  'landlab.grid.hex.HexModelGrid.nodes_at_link',
  'landlab.grid.hex.HexModelGrid.nodes_at_patch',
  'landlab.grid.hex.HexModelGrid.number_of_core_nodes',
  'landlab.grid.hex.HexModelGrid.number_of_node_columns',
  'landlab.grid.hex.HexModelGrid.number_of_node_rows',
  'landlab.grid.hex.HexModelGrid.number_of_nodes',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_node',
  'landlab.grid.hex.HexModelGrid.open_boundary_nodes',
  'landlab.grid.hex.HexModelGrid.patches_present_at_node',
  'landlab.grid.hex.HexModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.hex.HexModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.hex.HexModelGrid.status_at_node',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.hex.HexModelGrid.upwind_links_at_node',
  'landlab.grid.hex.HexModelGrid.x_of_node',
  'landlab.grid.hex.HexModelGrid.xy_of_node',
  'landlab.grid.hex.HexModelGrid.y_of_node',
]
info-patch = [
  'landlab.grid.hex.HexModelGrid.area_of_patch',
  'landlab.grid.hex.HexModelGrid.calc_grad_at_patch',
  'landlab.grid.hex.HexModelGrid.calc_slope_at_patch',
  'landlab.grid.hex.HexModelGrid.calc_unit_normal_at_patch',
  'landlab.grid.hex.HexModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.hex.HexModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.number_of_patches',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_link',
  'landlab.grid.hex.HexModelGrid.number_of_patches_present_at_node',
  'landlab.grid.hex.HexModelGrid.patches_at_link',
  'landlab.grid.hex.HexModelGrid.patches_at_node',
  'landlab.grid.hex.HexModelGrid.patches_present_at_link',
  'landlab.grid.hex.HexModelGrid.patches_present_at_node',
  'landlab.grid.hex.HexModelGrid.xy_of_patch',
]
map = [
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_link_head_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_link_tail_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.hex.HexModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.hex.HexModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.hex.HexModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.hex.HexModelGrid.map_node_to_cell',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.hex.HexModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.hex.HexModelGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.hex.HexModelGrid.all_node_azimuths_map',
  'landlab.grid.hex.HexModelGrid.all_node_distances_map',
  'landlab.grid.hex.HexModelGrid.angle_of_link_about_head',
  'landlab.grid.hex.HexModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.hex.HexModelGrid.node_axis_coordinates',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [

]
surface = [
  'landlab.grid.hex.HexModelGrid.calc_aspect_at_node',
  'landlab.grid.hex.HexModelGrid.calc_hillshade_at_node',
  'landlab.grid.hex.HexModelGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.hex.HexModelGrid.BAD_INDEX',
  'landlab.grid.hex.HexModelGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.hex.HexModelGrid.BC_LINK_IS_FIXED',
  'landlab.grid.hex.HexModelGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.hex.HexModelGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.hex.HexModelGrid.BC_NODE_IS_CORE',
  'landlab.grid.hex.HexModelGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.hex.HexModelGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.hex.HexModelGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.hex.HexModelGrid.VALID_LOCATIONS',
  'landlab.grid.hex.HexModelGrid.active_adjacent_corners_at_corner',
  'landlab.grid.hex.HexModelGrid.active_face_dirs_at_corner',
  'landlab.grid.hex.HexModelGrid.adjacent_corners_at_corner',
  'landlab.grid.hex.HexModelGrid.adjacent_faces_at_face',
  'landlab.grid.hex.HexModelGrid.adjacent_links_at_link',
  'landlab.grid.hex.HexModelGrid.all_corner_azimuths_map',
  'landlab.grid.hex.HexModelGrid.all_corner_distances_map',
  'landlab.grid.hex.HexModelGrid.angle_of_face',
  'landlab.grid.hex.HexModelGrid.angle_of_face_about_head',
  'landlab.grid.hex.HexModelGrid.area_of_cell',
  'landlab.grid.hex.HexModelGrid.as_dataarray',
  'landlab.grid.hex.HexModelGrid.as_dataset',
  'landlab.grid.hex.HexModelGrid.at_cell',
  'landlab.grid.hex.HexModelGrid.at_corner',
  'landlab.grid.hex.HexModelGrid.at_face',
  'landlab.grid.hex.HexModelGrid.at_grid',
  'landlab.grid.hex.HexModelGrid.at_layer',
  'landlab.grid.hex.HexModelGrid.at_link',
  'landlab.grid.hex.HexModelGrid.at_node',
  'landlab.grid.hex.HexModelGrid.at_patch',
  'landlab.grid.hex.HexModelGrid.boundary_corners',
  'landlab.grid.hex.HexModelGrid.cell_at_node',
  'landlab.grid.hex.HexModelGrid.cells_at_corner',
  'landlab.grid.hex.HexModelGrid.cells_at_face',
  'landlab.grid.hex.HexModelGrid.cells_present_at_corner',
  'landlab.grid.hex.HexModelGrid.cells_present_at_face',
  'landlab.grid.hex.HexModelGrid.closed_boundary_corners',
  'landlab.grid.hex.HexModelGrid.core_corners',
  'landlab.grid.hex.HexModelGrid.core_patches',
  'landlab.grid.hex.HexModelGrid.corner_at_core_patch',
  'landlab.grid.hex.HexModelGrid.corner_at_face_head',
  'landlab.grid.hex.HexModelGrid.corner_at_face_tail',
  'landlab.grid.hex.HexModelGrid.corner_at_patch',
  'landlab.grid.hex.HexModelGrid.corner_layout',
  'landlab.grid.hex.HexModelGrid.corner_x',
  'landlab.grid.hex.HexModelGrid.corner_y',
  'landlab.grid.hex.HexModelGrid.corners',
  'landlab.grid.hex.HexModelGrid.corners_at_bottom_edge',
  'landlab.grid.hex.HexModelGrid.corners_at_cell',
  'landlab.grid.hex.HexModelGrid.corners_at_face',
  'landlab.grid.hex.HexModelGrid.corners_at_left_edge',
  'landlab.grid.hex.HexModelGrid.corners_at_link',
  'landlab.grid.hex.HexModelGrid.corners_at_right_edge',
  'landlab.grid.hex.HexModelGrid.corners_at_top_edge',
  'landlab.grid.hex.HexModelGrid.default_group',
  'landlab.grid.hex.HexModelGrid.ds',
  'landlab.grid.hex.HexModelGrid.dual',
  'landlab.grid.hex.HexModelGrid.event_layers',
  'landlab.grid.hex.HexModelGrid.face_at_link',
  'landlab.grid.hex.HexModelGrid.face_dirs_at_corner',
  'landlab.grid.hex.HexModelGrid.face_status_at_corner',
  'landlab.grid.hex.HexModelGrid.faces_at_cell',
  'landlab.grid.hex.HexModelGrid.faces_at_corner',
  'landlab.grid.hex.HexModelGrid.fields',
  'landlab.grid.hex.HexModelGrid.fixed_faces',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_corner_anchor_corner',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_corner_fixed_face',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_corners',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.hex.HexModelGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.hex.HexModelGrid.fixed_value_boundary_corners',
  'landlab.grid.hex.HexModelGrid.freeze',
  'landlab.grid.hex.HexModelGrid.from_dataset',
  'landlab.grid.hex.HexModelGrid.from_dict',
  'landlab.grid.hex.HexModelGrid.from_file',
  'landlab.grid.hex.HexModelGrid.from_netcdf',
  'landlab.grid.hex.HexModelGrid.frozen',
  'landlab.grid.hex.HexModelGrid.groups',
  'landlab.grid.hex.HexModelGrid.imshow',
  'landlab.grid.hex.HexModelGrid.length_of_face',
  'landlab.grid.hex.HexModelGrid.length_of_link',
  'landlab.grid.hex.HexModelGrid.link_at_face',
  'landlab.grid.hex.HexModelGrid.link_dirs_at_node',
  'landlab.grid.hex.HexModelGrid.link_status_at_node',
  'landlab.grid.hex.HexModelGrid.link_with_angle',
  'landlab.grid.hex.HexModelGrid.link_with_node_status',
  'landlab.grid.hex.HexModelGrid.load',
  'landlab.grid.hex.HexModelGrid.map_link_vector_components_to_node',
  'landlab.grid.hex.HexModelGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.hex.HexModelGrid.map_node_to_link_linear_upwind',
  'landlab.grid.hex.HexModelGrid.map_vectors_to_links',
  'landlab.grid.hex.HexModelGrid.material_layers',
  'landlab.grid.hex.HexModelGrid.merge',
  'landlab.grid.hex.HexModelGrid.midpoint_of_face',
  'landlab.grid.hex.HexModelGrid.ndim',
  'landlab.grid.hex.HexModelGrid.node_at_cell',
  'landlab.grid.hex.HexModelGrid.node_layout',
  'landlab.grid.hex.HexModelGrid.node_row_and_column',
  'landlab.grid.hex.HexModelGrid.node_x',
  'landlab.grid.hex.HexModelGrid.node_y',
  'landlab.grid.hex.HexModelGrid.nodes_at_bottom_edge',
  'landlab.grid.hex.HexModelGrid.nodes_at_face',
  'landlab.grid.hex.HexModelGrid.nodes_at_left_edge',
  'landlab.grid.hex.HexModelGrid.nodes_at_right_edge',
  'landlab.grid.hex.HexModelGrid.nodes_at_top_edge',
  'landlab.grid.hex.HexModelGrid.number_of_cells',
  'landlab.grid.hex.HexModelGrid.number_of_cells_present_at_corner',
  'landlab.grid.hex.HexModelGrid.number_of_cells_present_at_face',
  'landlab.grid.hex.HexModelGrid.number_of_core_corners',
  'landlab.grid.hex.HexModelGrid.number_of_core_patches',
  'landlab.grid.hex.HexModelGrid.number_of_corner_columns',
  'landlab.grid.hex.HexModelGrid.number_of_corner_rows',
  'landlab.grid.hex.HexModelGrid.number_of_corners',
  'landlab.grid.hex.HexModelGrid.number_of_faces',
  'landlab.grid.hex.HexModelGrid.number_of_fixed_faces',
  'landlab.grid.hex.HexModelGrid.number_of_links',
  'landlab.grid.hex.HexModelGrid.open_boundary_corners',
  'landlab.grid.hex.HexModelGrid.orientation',
  'landlab.grid.hex.HexModelGrid.orientation_of_face',
  'landlab.grid.hex.HexModelGrid.orientation_of_link',
  'landlab.grid.hex.HexModelGrid.parallel_faces_at_face',
  'landlab.grid.hex.HexModelGrid.parallel_links_at_link',
  'landlab.grid.hex.HexModelGrid.patch_area_at_corner',
  'landlab.grid.hex.HexModelGrid.patch_at_corner',
  'landlab.grid.hex.HexModelGrid.perimeter_corners',
  'landlab.grid.hex.HexModelGrid.perimeter_nodes',
  'landlab.grid.hex.HexModelGrid.reset_status_at_node',
  'landlab.grid.hex.HexModelGrid.shape',
  'landlab.grid.hex.HexModelGrid.sort',
  'landlab.grid.hex.HexModelGrid.spacing',
  'landlab.grid.hex.HexModelGrid.status_at_corner',
  'landlab.grid.hex.HexModelGrid.status_at_face',
  'landlab.grid.hex.HexModelGrid.thaw',
  'landlab.grid.hex.HexModelGrid.thawed',
  'landlab.grid.hex.HexModelGrid.to_dict',
  'landlab.grid.hex.HexModelGrid.to_json',
  'landlab.grid.hex.HexModelGrid.to_netcdf',
  'landlab.grid.hex.HexModelGrid.unit_vector_at_corner',
  'landlab.grid.hex.HexModelGrid.unit_vector_at_face',
  'landlab.grid.hex.HexModelGrid.unit_vector_at_link',
  'landlab.grid.hex.HexModelGrid.unit_vector_at_node',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_xcomponent_at_corner',
  'landlab.grid.hex.HexModelGrid.unit_vector_sum_ycomponent_at_corner',
  'landlab.grid.hex.HexModelGrid.x_of_corner',
  'landlab.grid.hex.HexModelGrid.xy_of_cell',
  'landlab.grid.hex.HexModelGrid.xy_of_corner',
  'landlab.grid.hex.HexModelGrid.xy_of_face',
  'landlab.grid.hex.HexModelGrid.xy_of_link',
  'landlab.grid.hex.HexModelGrid.xy_of_lower_left',
  'landlab.grid.hex.HexModelGrid.xy_of_reference',
  'landlab.grid.hex.HexModelGrid.y_of_corner',
]

[grids.IcosphereGlobalGrid]
boundary-condition = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_adjacent_nodes_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_faces',
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.closed_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.core_cells',
  'landlab.grid.icosphere.IcosphereGlobalGrid.core_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_value_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_at_core_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_has_boundary_neighbor',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_is_boundary',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_active_faces',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_active_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_core_cells',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_core_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_fixed_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.open_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.set_nodata_nodes_to_closed',
  'landlab.grid.icosphere.IcosphereGlobalGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.icosphere.IcosphereGlobalGrid.status_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.status_at_node',
]
connectivity = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_adjacent_nodes_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_link_dirs_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.cell_area_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.downwind_links_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_downwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_upwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_at_core_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_has_boundary_neighbor',
  'landlab.grid.icosphere.IcosphereGlobalGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.add_empty',
  'landlab.grid.icosphere.IcosphereGlobalGrid.add_field',
  'landlab.grid.icosphere.IcosphereGlobalGrid.add_full',
  'landlab.grid.icosphere.IcosphereGlobalGrid.add_ones',
  'landlab.grid.icosphere.IcosphereGlobalGrid.add_zeros',
  'landlab.grid.icosphere.IcosphereGlobalGrid.delete_field',
  'landlab.grid.icosphere.IcosphereGlobalGrid.empty',
  'landlab.grid.icosphere.IcosphereGlobalGrid.new_field_location',
  'landlab.grid.icosphere.IcosphereGlobalGrid.ones',
  'landlab.grid.icosphere.IcosphereGlobalGrid.zeros',
]
field-io = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_corner',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_face',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.field_values',
  'landlab.grid.icosphere.IcosphereGlobalGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_diff_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_flux_div_at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_flux_div_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_grad_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_grad_at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_net_flux_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_slope_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_slope_at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.cell_area_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.core_cells',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_node_to_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_at_core_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_faces',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.field_units',
  'landlab.grid.icosphere.IcosphereGlobalGrid.has_field',
  'landlab.grid.icosphere.IcosphereGlobalGrid.has_group',
  'landlab.grid.icosphere.IcosphereGlobalGrid.keys',
  'landlab.grid.icosphere.IcosphereGlobalGrid.size',
]
info-grid = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.axis_name',
  'landlab.grid.icosphere.IcosphereGlobalGrid.axis_units',
  'landlab.grid.icosphere.IcosphereGlobalGrid.ndim',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_axis_coordinates',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_elements',
  'landlab.grid.icosphere.IcosphereGlobalGrid.size',
]
info-link = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_link_dirs_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.angle_of_link_about_head',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_diff_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_grad_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.downwind_links_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_downwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_upwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_head_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_tail_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_vector_sum_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_max_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_min_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_active_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_fixed_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.patches_present_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.resolve_values_on_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.status_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_adjacent_nodes_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.active_link_dirs_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.all_node_azimuths_map',
  'landlab.grid.icosphere.IcosphereGlobalGrid.all_node_distances_map',
  'landlab.grid.icosphere.IcosphereGlobalGrid.boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_aspect_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_flux_div_at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_flux_div_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_hillshade_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_net_flux_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_slope_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.cell_area_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.closed_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.core_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.downwind_links_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_value_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_downwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_node_is_upwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_head_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_tail_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_node_to_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_max_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_min_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_at_core_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_axis_coordinates',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_has_boundary_neighbor',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_is_boundary',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_core_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.open_boundary_nodes',
  'landlab.grid.icosphere.IcosphereGlobalGrid.patches_present_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.set_nodata_nodes_to_closed',
  'landlab.grid.icosphere.IcosphereGlobalGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.icosphere.IcosphereGlobalGrid.status_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.upwind_links_at_node',
]
info-patch = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_grad_at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_slope_at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_unit_normal_at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_vector_sum_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.number_of_patches_present_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.patches_present_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.patches_present_at_node',
]
map = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_head_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_tail_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_vector_sum_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_node_links_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_node_to_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_max_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_min_node_to_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.all_node_azimuths_map',
  'landlab.grid.icosphere.IcosphereGlobalGrid.all_node_distances_map',
  'landlab.grid.icosphere.IcosphereGlobalGrid.angle_of_link_about_head',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_axis_coordinates',
  'landlab.grid.icosphere.IcosphereGlobalGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [

]
surface = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_aspect_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_hillshade_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.icosphere.IcosphereGlobalGrid.BAD_INDEX',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_LINK_IS_FIXED',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_NODE_IS_CORE',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.icosphere.IcosphereGlobalGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.icosphere.IcosphereGlobalGrid.VALID_LOCATIONS',
  'landlab.grid.icosphere.IcosphereGlobalGrid.area_of_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.as_dataarray',
  'landlab.grid.icosphere.IcosphereGlobalGrid.as_dataset',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_corner',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_face',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_grid',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_layer',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.at_patch',
  'landlab.grid.icosphere.IcosphereGlobalGrid.cell_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.corners_at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.default_group',
  'landlab.grid.icosphere.IcosphereGlobalGrid.event_layers',
  'landlab.grid.icosphere.IcosphereGlobalGrid.face_at_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.faces_at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fields',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.icosphere.IcosphereGlobalGrid.from_dict',
  'landlab.grid.icosphere.IcosphereGlobalGrid.from_file',
  'landlab.grid.icosphere.IcosphereGlobalGrid.groups',
  'landlab.grid.icosphere.IcosphereGlobalGrid.imshow',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_at_face',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_status_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_with_angle',
  'landlab.grid.icosphere.IcosphereGlobalGrid.link_with_node_status',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_link_vector_components_to_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_node_to_link_linear_upwind',
  'landlab.grid.icosphere.IcosphereGlobalGrid.map_vectors_to_links',
  'landlab.grid.icosphere.IcosphereGlobalGrid.material_layers',
  'landlab.grid.icosphere.IcosphereGlobalGrid.node_at_cell',
  'landlab.grid.icosphere.IcosphereGlobalGrid.patches_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.phi_of_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.r_of_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.reset_status_at_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.theta_of_node',
  'landlab.grid.icosphere.IcosphereGlobalGrid.xy_of_reference',
]

[grids.ModelGrid]
boundary-condition = [
  'landlab.grid.base.ModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.base.ModelGrid.active_faces',
  'landlab.grid.base.ModelGrid.active_links',
  'landlab.grid.base.ModelGrid.boundary_nodes',
  'landlab.grid.base.ModelGrid.closed_boundary_nodes',
  'landlab.grid.base.ModelGrid.core_cells',
  'landlab.grid.base.ModelGrid.core_nodes',
  'landlab.grid.base.ModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.base.ModelGrid.fixed_links',
  'landlab.grid.base.ModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.base.ModelGrid.node_at_core_cell',
  'landlab.grid.base.ModelGrid.node_has_boundary_neighbor',
  'landlab.grid.base.ModelGrid.node_is_boundary',
  'landlab.grid.base.ModelGrid.number_of_active_faces',
  'landlab.grid.base.ModelGrid.number_of_active_links',
  'landlab.grid.base.ModelGrid.number_of_core_cells',
  'landlab.grid.base.ModelGrid.number_of_core_nodes',
  'landlab.grid.base.ModelGrid.number_of_fixed_links',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_link',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_node',
  'landlab.grid.base.ModelGrid.open_boundary_nodes',
  'landlab.grid.base.ModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.base.ModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.base.ModelGrid.status_at_link',
  'landlab.grid.base.ModelGrid.status_at_node',
]
connectivity = [
  'landlab.grid.base.ModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.base.ModelGrid.active_link_dirs_at_node',
  'landlab.grid.base.ModelGrid.cell_area_at_node',
  'landlab.grid.base.ModelGrid.downwind_links_at_node',
  'landlab.grid.base.ModelGrid.link_at_node_is_downwind',
  'landlab.grid.base.ModelGrid.link_at_node_is_upwind',
  'landlab.grid.base.ModelGrid.node_at_core_cell',
  'landlab.grid.base.ModelGrid.node_has_boundary_neighbor',
  'landlab.grid.base.ModelGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.base.ModelGrid.add_empty',
  'landlab.grid.base.ModelGrid.add_field',
  'landlab.grid.base.ModelGrid.add_full',
  'landlab.grid.base.ModelGrid.add_ones',
  'landlab.grid.base.ModelGrid.add_zeros',
  'landlab.grid.base.ModelGrid.delete_field',
  'landlab.grid.base.ModelGrid.empty',
  'landlab.grid.base.ModelGrid.new_field_location',
  'landlab.grid.base.ModelGrid.ones',
  'landlab.grid.base.ModelGrid.zeros',
]
field-io = [
  'landlab.grid.base.ModelGrid.at_cell',
  'landlab.grid.base.ModelGrid.at_corner',
  'landlab.grid.base.ModelGrid.at_face',
  'landlab.grid.base.ModelGrid.at_link',
  'landlab.grid.base.ModelGrid.at_node',
  'landlab.grid.base.ModelGrid.at_patch',
  'landlab.grid.base.ModelGrid.field_values',
  'landlab.grid.base.ModelGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.base.ModelGrid.calc_diff_at_link',
  'landlab.grid.base.ModelGrid.calc_flux_div_at_cell',
  'landlab.grid.base.ModelGrid.calc_flux_div_at_node',
  'landlab.grid.base.ModelGrid.calc_grad_at_link',
  'landlab.grid.base.ModelGrid.calc_grad_at_patch',
  'landlab.grid.base.ModelGrid.calc_net_flux_at_node',
  'landlab.grid.base.ModelGrid.calc_slope_at_node',
  'landlab.grid.base.ModelGrid.calc_slope_at_patch',
  'landlab.grid.base.ModelGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.base.ModelGrid.cell_area_at_node',
  'landlab.grid.base.ModelGrid.core_cells',
  'landlab.grid.base.ModelGrid.map_node_to_cell',
  'landlab.grid.base.ModelGrid.node_at_core_cell',
  'landlab.grid.base.ModelGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.base.ModelGrid.active_faces',
  'landlab.grid.base.ModelGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.base.ModelGrid.field_units',
  'landlab.grid.base.ModelGrid.has_field',
  'landlab.grid.base.ModelGrid.has_group',
  'landlab.grid.base.ModelGrid.keys',
  'landlab.grid.base.ModelGrid.size',
]
info-grid = [
  'landlab.grid.base.ModelGrid.axis_name',
  'landlab.grid.base.ModelGrid.axis_units',
  'landlab.grid.base.ModelGrid.ndim',
  'landlab.grid.base.ModelGrid.node_axis_coordinates',
  'landlab.grid.base.ModelGrid.number_of_elements',
  'landlab.grid.base.ModelGrid.size',
]
info-link = [
  'landlab.grid.base.ModelGrid.active_link_dirs_at_node',
  'landlab.grid.base.ModelGrid.active_links',
  'landlab.grid.base.ModelGrid.angle_of_link_about_head',
  'landlab.grid.base.ModelGrid.calc_diff_at_link',
  'landlab.grid.base.ModelGrid.calc_grad_at_link',
  'landlab.grid.base.ModelGrid.downwind_links_at_node',
  'landlab.grid.base.ModelGrid.fixed_links',
  'landlab.grid.base.ModelGrid.link_at_node_is_downwind',
  'landlab.grid.base.ModelGrid.link_at_node_is_upwind',
  'landlab.grid.base.ModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_link_head_node_to_link',
  'landlab.grid.base.ModelGrid.map_link_tail_node_to_link',
  'landlab.grid.base.ModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.base.ModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.number_of_active_links',
  'landlab.grid.base.ModelGrid.number_of_fixed_links',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_link',
  'landlab.grid.base.ModelGrid.patches_present_at_link',
  'landlab.grid.base.ModelGrid.resolve_values_on_links',
  'landlab.grid.base.ModelGrid.status_at_link',
  'landlab.grid.base.ModelGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.base.ModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.base.ModelGrid.active_link_dirs_at_node',
  'landlab.grid.base.ModelGrid.all_node_azimuths_map',
  'landlab.grid.base.ModelGrid.all_node_distances_map',
  'landlab.grid.base.ModelGrid.boundary_nodes',
  'landlab.grid.base.ModelGrid.calc_aspect_at_node',
  'landlab.grid.base.ModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.base.ModelGrid.calc_flux_div_at_cell',
  'landlab.grid.base.ModelGrid.calc_flux_div_at_node',
  'landlab.grid.base.ModelGrid.calc_hillshade_at_node',
  'landlab.grid.base.ModelGrid.calc_net_flux_at_node',
  'landlab.grid.base.ModelGrid.calc_slope_at_node',
  'landlab.grid.base.ModelGrid.cell_area_at_node',
  'landlab.grid.base.ModelGrid.closed_boundary_nodes',
  'landlab.grid.base.ModelGrid.core_nodes',
  'landlab.grid.base.ModelGrid.downwind_links_at_node',
  'landlab.grid.base.ModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.base.ModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.base.ModelGrid.link_at_node_is_downwind',
  'landlab.grid.base.ModelGrid.link_at_node_is_upwind',
  'landlab.grid.base.ModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_link_head_node_to_link',
  'landlab.grid.base.ModelGrid.map_link_tail_node_to_link',
  'landlab.grid.base.ModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_node_to_cell',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.node_at_core_cell',
  'landlab.grid.base.ModelGrid.node_axis_coordinates',
  'landlab.grid.base.ModelGrid.node_has_boundary_neighbor',
  'landlab.grid.base.ModelGrid.node_is_boundary',
  'landlab.grid.base.ModelGrid.number_of_core_nodes',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_node',
  'landlab.grid.base.ModelGrid.open_boundary_nodes',
  'landlab.grid.base.ModelGrid.patches_present_at_node',
  'landlab.grid.base.ModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.base.ModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.base.ModelGrid.status_at_node',
  'landlab.grid.base.ModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.base.ModelGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.base.ModelGrid.upwind_links_at_node',
]
info-patch = [
  'landlab.grid.base.ModelGrid.calc_grad_at_patch',
  'landlab.grid.base.ModelGrid.calc_slope_at_patch',
  'landlab.grid.base.ModelGrid.calc_unit_normal_at_patch',
  'landlab.grid.base.ModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.base.ModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_link',
  'landlab.grid.base.ModelGrid.number_of_patches_present_at_node',
  'landlab.grid.base.ModelGrid.patches_present_at_link',
  'landlab.grid.base.ModelGrid.patches_present_at_node',
]
map = [
  'landlab.grid.base.ModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_link_head_node_to_link',
  'landlab.grid.base.ModelGrid.map_link_tail_node_to_link',
  'landlab.grid.base.ModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.base.ModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.base.ModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.base.ModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.base.ModelGrid.map_node_to_cell',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.base.ModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.base.ModelGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.base.ModelGrid.all_node_azimuths_map',
  'landlab.grid.base.ModelGrid.all_node_distances_map',
  'landlab.grid.base.ModelGrid.angle_of_link_about_head',
  'landlab.grid.base.ModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.base.ModelGrid.node_axis_coordinates',
  'landlab.grid.base.ModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.base.ModelGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [

]
surface = [
  'landlab.grid.base.ModelGrid.calc_aspect_at_node',
  'landlab.grid.base.ModelGrid.calc_hillshade_at_node',
  'landlab.grid.base.ModelGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.base.ModelGrid.BAD_INDEX',
  'landlab.grid.base.ModelGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.base.ModelGrid.BC_LINK_IS_FIXED',
  'landlab.grid.base.ModelGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.base.ModelGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.base.ModelGrid.BC_NODE_IS_CORE',
  'landlab.grid.base.ModelGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.base.ModelGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.base.ModelGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.base.ModelGrid.VALID_LOCATIONS',
  'landlab.grid.base.ModelGrid.as_dataarray',
  'landlab.grid.base.ModelGrid.as_dataset',
  'landlab.grid.base.ModelGrid.at_cell',
  'landlab.grid.base.ModelGrid.at_corner',
  'landlab.grid.base.ModelGrid.at_face',
  'landlab.grid.base.ModelGrid.at_grid',
  'landlab.grid.base.ModelGrid.at_layer',
  'landlab.grid.base.ModelGrid.at_link',
  'landlab.grid.base.ModelGrid.at_node',
  'landlab.grid.base.ModelGrid.at_patch',
  'landlab.grid.base.ModelGrid.default_group',
  'landlab.grid.base.ModelGrid.event_layers',
  'landlab.grid.base.ModelGrid.fields',
  'landlab.grid.base.ModelGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.base.ModelGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.base.ModelGrid.from_dict',
  'landlab.grid.base.ModelGrid.from_file',
  'landlab.grid.base.ModelGrid.groups',
  'landlab.grid.base.ModelGrid.imshow',
  'landlab.grid.base.ModelGrid.link_status_at_node',
  'landlab.grid.base.ModelGrid.link_with_angle',
  'landlab.grid.base.ModelGrid.link_with_node_status',
  'landlab.grid.base.ModelGrid.map_link_vector_components_to_node',
  'landlab.grid.base.ModelGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.base.ModelGrid.map_node_to_link_linear_upwind',
  'landlab.grid.base.ModelGrid.map_vectors_to_links',
  'landlab.grid.base.ModelGrid.material_layers',
  'landlab.grid.base.ModelGrid.reset_status_at_node',
  'landlab.grid.base.ModelGrid.xy_of_reference',
]

[grids.NetworkModelGrid]
boundary-condition = [
  'landlab.grid.network.NetworkModelGrid.active_links',
  'landlab.grid.network.NetworkModelGrid.perimeter_nodes',
  'landlab.grid.network.NetworkModelGrid.status_at_link',
  'landlab.grid.network.NetworkModelGrid.status_at_node',
]
connectivity = [

]
deprecated = [

]
field-add = [
  'landlab.grid.network.NetworkModelGrid.add_empty',
  'landlab.grid.network.NetworkModelGrid.add_field',
  'landlab.grid.network.NetworkModelGrid.add_full',
  'landlab.grid.network.NetworkModelGrid.add_ones',
  'landlab.grid.network.NetworkModelGrid.add_zeros',
  'landlab.grid.network.NetworkModelGrid.delete_field',
  'landlab.grid.network.NetworkModelGrid.empty',
  'landlab.grid.network.NetworkModelGrid.new_field_location',
  'landlab.grid.network.NetworkModelGrid.ones',
  'landlab.grid.network.NetworkModelGrid.zeros',
]
field-io = [
  'landlab.grid.network.NetworkModelGrid.at_cell',
  'landlab.grid.network.NetworkModelGrid.at_corner',
  'landlab.grid.network.NetworkModelGrid.at_face',
  'landlab.grid.network.NetworkModelGrid.at_link',
  'landlab.grid.network.NetworkModelGrid.at_node',
  'landlab.grid.network.NetworkModelGrid.at_patch',
  'landlab.grid.network.NetworkModelGrid.field_values',
  'landlab.grid.network.NetworkModelGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.network.NetworkModelGrid.calc_grad_at_link',
]
info-cell = [

]
info-corner = [

]
info-face = [

]
info-field = [
  'landlab.grid.network.NetworkModelGrid.field_units',
  'landlab.grid.network.NetworkModelGrid.has_field',
  'landlab.grid.network.NetworkModelGrid.has_group',
  'landlab.grid.network.NetworkModelGrid.keys',
  'landlab.grid.network.NetworkModelGrid.size',
]
info-grid = [
  'landlab.grid.network.NetworkModelGrid.axis_name',
  'landlab.grid.network.NetworkModelGrid.axis_units',
  'landlab.grid.network.NetworkModelGrid.size',
]
info-link = [
  'landlab.grid.network.NetworkModelGrid.angle_of_link',
  'landlab.grid.network.NetworkModelGrid.calc_grad_at_link',
  'landlab.grid.network.NetworkModelGrid.length_of_link',
  'landlab.grid.network.NetworkModelGrid.links_at_node',
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_link_head_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_link_tail_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.midpoint_of_link',
  'landlab.grid.network.NetworkModelGrid.status_at_link',
  'landlab.grid.network.NetworkModelGrid.x_of_link',
  'landlab.grid.network.NetworkModelGrid.y_of_link',
]
info-node = [
  'landlab.grid.network.NetworkModelGrid.active_links',
  'landlab.grid.network.NetworkModelGrid.adjacent_nodes_at_node',
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_link_head_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_link_tail_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.node_at_link_head',
  'landlab.grid.network.NetworkModelGrid.node_at_link_tail',
  'landlab.grid.network.NetworkModelGrid.nodes',
  'landlab.grid.network.NetworkModelGrid.nodes_at_link',
  'landlab.grid.network.NetworkModelGrid.number_of_nodes',
  'landlab.grid.network.NetworkModelGrid.perimeter_nodes',
  'landlab.grid.network.NetworkModelGrid.status_at_node',
  'landlab.grid.network.NetworkModelGrid.x_of_node',
  'landlab.grid.network.NetworkModelGrid.xy_of_node',
  'landlab.grid.network.NetworkModelGrid.y_of_node',
]
info-patch = [

]
map = [
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_link_head_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_link_tail_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.network.NetworkModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.network.NetworkModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.network.NetworkModelGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.network.NetworkModelGrid.x_of_link',
  'landlab.grid.network.NetworkModelGrid.y_of_link',
]
subset = [
  'landlab.grid.network.NetworkModelGrid.active_links',
  'landlab.grid.network.NetworkModelGrid.perimeter_nodes',
]
surface = [

]
uncategorized = [
  'landlab.grid.network.NetworkModelGrid.BAD_INDEX',
  'landlab.grid.network.NetworkModelGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.network.NetworkModelGrid.BC_LINK_IS_FIXED',
  'landlab.grid.network.NetworkModelGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.network.NetworkModelGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.network.NetworkModelGrid.BC_NODE_IS_CORE',
  'landlab.grid.network.NetworkModelGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.network.NetworkModelGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.network.NetworkModelGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.network.NetworkModelGrid.VALID_LOCATIONS',
  'landlab.grid.network.NetworkModelGrid.adjacent_links_at_link',
  'landlab.grid.network.NetworkModelGrid.at_grid',
  'landlab.grid.network.NetworkModelGrid.at_link',
  'landlab.grid.network.NetworkModelGrid.at_node',
  'landlab.grid.network.NetworkModelGrid.default_group',
  'landlab.grid.network.NetworkModelGrid.ds',
  'landlab.grid.network.NetworkModelGrid.freeze',
  'landlab.grid.network.NetworkModelGrid.from_dict',
  'landlab.grid.network.NetworkModelGrid.from_file',
  'landlab.grid.network.NetworkModelGrid.from_netcdf',
  'landlab.grid.network.NetworkModelGrid.frozen',
  'landlab.grid.network.NetworkModelGrid.groups',
  'landlab.grid.network.NetworkModelGrid.link_dirs_at_node',
  'landlab.grid.network.NetworkModelGrid.load',
  'landlab.grid.network.NetworkModelGrid.map_link_vector_components_to_node',
  'landlab.grid.network.NetworkModelGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.network.NetworkModelGrid.map_node_to_link_linear_upwind',
  'landlab.grid.network.NetworkModelGrid.map_vectors_to_links',
  'landlab.grid.network.NetworkModelGrid.ndim',
  'landlab.grid.network.NetworkModelGrid.node_x',
  'landlab.grid.network.NetworkModelGrid.node_y',
  'landlab.grid.network.NetworkModelGrid.number_of_links',
  'landlab.grid.network.NetworkModelGrid.reset_status_at_node',
  'landlab.grid.network.NetworkModelGrid.sort',
  'landlab.grid.network.NetworkModelGrid.thaw',
  'landlab.grid.network.NetworkModelGrid.thawed',
  'landlab.grid.network.NetworkModelGrid.to_dict',
  'landlab.grid.network.NetworkModelGrid.to_json',
  'landlab.grid.network.NetworkModelGrid.to_netcdf',
  'landlab.grid.network.NetworkModelGrid.unit_vector_at_link',
  'landlab.grid.network.NetworkModelGrid.unit_vector_at_node',
  'landlab.grid.network.NetworkModelGrid.xy_of_link',
  'landlab.grid.network.NetworkModelGrid.xy_of_reference',
]

[grids.RadialModelGrid]
boundary-condition = [
  'landlab.grid.radial.RadialModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.radial.RadialModelGrid.active_faces',
  'landlab.grid.radial.RadialModelGrid.active_links',
  'landlab.grid.radial.RadialModelGrid.boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.closed_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.core_cells',
  'landlab.grid.radial.RadialModelGrid.core_nodes',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.fixed_links',
  'landlab.grid.radial.RadialModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.node_at_core_cell',
  'landlab.grid.radial.RadialModelGrid.node_has_boundary_neighbor',
  'landlab.grid.radial.RadialModelGrid.node_is_boundary',
  'landlab.grid.radial.RadialModelGrid.number_of_active_faces',
  'landlab.grid.radial.RadialModelGrid.number_of_active_links',
  'landlab.grid.radial.RadialModelGrid.number_of_core_cells',
  'landlab.grid.radial.RadialModelGrid.number_of_core_nodes',
  'landlab.grid.radial.RadialModelGrid.number_of_fixed_links',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_link',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_node',
  'landlab.grid.radial.RadialModelGrid.open_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.perimeter_nodes',
  'landlab.grid.radial.RadialModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.radial.RadialModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.radial.RadialModelGrid.status_at_link',
  'landlab.grid.radial.RadialModelGrid.status_at_node',
]
connectivity = [
  'landlab.grid.radial.RadialModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.radial.RadialModelGrid.active_link_dirs_at_node',
  'landlab.grid.radial.RadialModelGrid.cell_area_at_node',
  'landlab.grid.radial.RadialModelGrid.downwind_links_at_node',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_downwind',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_upwind',
  'landlab.grid.radial.RadialModelGrid.node_at_core_cell',
  'landlab.grid.radial.RadialModelGrid.node_has_boundary_neighbor',
  'landlab.grid.radial.RadialModelGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.radial.RadialModelGrid.add_empty',
  'landlab.grid.radial.RadialModelGrid.add_field',
  'landlab.grid.radial.RadialModelGrid.add_full',
  'landlab.grid.radial.RadialModelGrid.add_ones',
  'landlab.grid.radial.RadialModelGrid.add_zeros',
  'landlab.grid.radial.RadialModelGrid.delete_field',
  'landlab.grid.radial.RadialModelGrid.empty',
  'landlab.grid.radial.RadialModelGrid.new_field_location',
  'landlab.grid.radial.RadialModelGrid.ones',
  'landlab.grid.radial.RadialModelGrid.zeros',
]
field-io = [
  'landlab.grid.radial.RadialModelGrid.at_cell',
  'landlab.grid.radial.RadialModelGrid.at_corner',
  'landlab.grid.radial.RadialModelGrid.at_face',
  'landlab.grid.radial.RadialModelGrid.at_link',
  'landlab.grid.radial.RadialModelGrid.at_node',
  'landlab.grid.radial.RadialModelGrid.at_patch',
  'landlab.grid.radial.RadialModelGrid.field_values',
  'landlab.grid.radial.RadialModelGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.radial.RadialModelGrid.calc_diff_at_link',
  'landlab.grid.radial.RadialModelGrid.calc_flux_div_at_cell',
  'landlab.grid.radial.RadialModelGrid.calc_flux_div_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_grad_at_link',
  'landlab.grid.radial.RadialModelGrid.calc_grad_at_patch',
  'landlab.grid.radial.RadialModelGrid.calc_net_flux_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_slope_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_slope_at_patch',
  'landlab.grid.radial.RadialModelGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.radial.RadialModelGrid.cell_area_at_node',
  'landlab.grid.radial.RadialModelGrid.core_cells',
  'landlab.grid.radial.RadialModelGrid.map_node_to_cell',
  'landlab.grid.radial.RadialModelGrid.node_at_core_cell',
  'landlab.grid.radial.RadialModelGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.radial.RadialModelGrid.active_faces',
  'landlab.grid.radial.RadialModelGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.radial.RadialModelGrid.field_units',
  'landlab.grid.radial.RadialModelGrid.has_field',
  'landlab.grid.radial.RadialModelGrid.has_group',
  'landlab.grid.radial.RadialModelGrid.keys',
  'landlab.grid.radial.RadialModelGrid.size',
]
info-grid = [
  'landlab.grid.radial.RadialModelGrid.axis_name',
  'landlab.grid.radial.RadialModelGrid.axis_units',
  'landlab.grid.radial.RadialModelGrid.node_axis_coordinates',
  'landlab.grid.radial.RadialModelGrid.number_of_elements',
  'landlab.grid.radial.RadialModelGrid.number_of_rings',
  'landlab.grid.radial.RadialModelGrid.size',
  'landlab.grid.radial.RadialModelGrid.spacing_of_rings',
]
info-link = [
  'landlab.grid.radial.RadialModelGrid.active_link_dirs_at_node',
  'landlab.grid.radial.RadialModelGrid.active_links',
  'landlab.grid.radial.RadialModelGrid.angle_of_link',
  'landlab.grid.radial.RadialModelGrid.angle_of_link_about_head',
  'landlab.grid.radial.RadialModelGrid.calc_diff_at_link',
  'landlab.grid.radial.RadialModelGrid.calc_grad_at_link',
  'landlab.grid.radial.RadialModelGrid.downwind_links_at_node',
  'landlab.grid.radial.RadialModelGrid.fixed_links',
  'landlab.grid.radial.RadialModelGrid.length_of_link',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_downwind',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_upwind',
  'landlab.grid.radial.RadialModelGrid.links_at_node',
  'landlab.grid.radial.RadialModelGrid.links_at_patch',
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_link_head_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_link_tail_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.midpoint_of_link',
  'landlab.grid.radial.RadialModelGrid.number_of_active_links',
  'landlab.grid.radial.RadialModelGrid.number_of_fixed_links',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_link',
  'landlab.grid.radial.RadialModelGrid.patches_present_at_link',
  'landlab.grid.radial.RadialModelGrid.resolve_values_on_links',
  'landlab.grid.radial.RadialModelGrid.status_at_link',
  'landlab.grid.radial.RadialModelGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.radial.RadialModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.radial.RadialModelGrid.active_link_dirs_at_node',
  'landlab.grid.radial.RadialModelGrid.adjacent_nodes_at_node',
  'landlab.grid.radial.RadialModelGrid.all_node_azimuths_map',
  'landlab.grid.radial.RadialModelGrid.all_node_distances_map',
  'landlab.grid.radial.RadialModelGrid.boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.calc_aspect_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.radial.RadialModelGrid.calc_flux_div_at_cell',
  'landlab.grid.radial.RadialModelGrid.calc_flux_div_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_hillshade_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_net_flux_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_slope_at_node',
  'landlab.grid.radial.RadialModelGrid.cell_area_at_node',
  'landlab.grid.radial.RadialModelGrid.closed_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.core_nodes',
  'landlab.grid.radial.RadialModelGrid.downwind_links_at_node',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_downwind',
  'landlab.grid.radial.RadialModelGrid.link_at_node_is_upwind',
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_link_head_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_link_tail_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_node_to_cell',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.node_at_core_cell',
  'landlab.grid.radial.RadialModelGrid.node_at_link_head',
  'landlab.grid.radial.RadialModelGrid.node_at_link_tail',
  'landlab.grid.radial.RadialModelGrid.node_axis_coordinates',
  'landlab.grid.radial.RadialModelGrid.node_has_boundary_neighbor',
  'landlab.grid.radial.RadialModelGrid.node_is_boundary',
  'landlab.grid.radial.RadialModelGrid.nodes',
  'landlab.grid.radial.RadialModelGrid.nodes_at_link',
  'landlab.grid.radial.RadialModelGrid.nodes_at_patch',
  'landlab.grid.radial.RadialModelGrid.number_of_core_nodes',
  'landlab.grid.radial.RadialModelGrid.number_of_nodes',
  'landlab.grid.radial.RadialModelGrid.number_of_nodes_in_ring',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_node',
  'landlab.grid.radial.RadialModelGrid.open_boundary_nodes',
  'landlab.grid.radial.RadialModelGrid.patches_present_at_node',
  'landlab.grid.radial.RadialModelGrid.perimeter_nodes',
  'landlab.grid.radial.RadialModelGrid.radius_at_node',
  'landlab.grid.radial.RadialModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.radial.RadialModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.radial.RadialModelGrid.status_at_node',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.radial.RadialModelGrid.upwind_links_at_node',
  'landlab.grid.radial.RadialModelGrid.x_of_node',
  'landlab.grid.radial.RadialModelGrid.xy_of_node',
  'landlab.grid.radial.RadialModelGrid.y_of_node',
]
info-patch = [
  'landlab.grid.radial.RadialModelGrid.area_of_patch',
  'landlab.grid.radial.RadialModelGrid.calc_grad_at_patch',
  'landlab.grid.radial.RadialModelGrid.calc_slope_at_patch',
  'landlab.grid.radial.RadialModelGrid.calc_unit_normal_at_patch',
  'landlab.grid.radial.RadialModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.number_of_patches',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_link',
  'landlab.grid.radial.RadialModelGrid.number_of_patches_present_at_node',
  'landlab.grid.radial.RadialModelGrid.patches_at_link',
  'landlab.grid.radial.RadialModelGrid.patches_at_node',
  'landlab.grid.radial.RadialModelGrid.patches_present_at_link',
  'landlab.grid.radial.RadialModelGrid.patches_present_at_node',
  'landlab.grid.radial.RadialModelGrid.xy_of_patch',
]
map = [
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_link_head_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_link_tail_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.radial.RadialModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.radial.RadialModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.radial.RadialModelGrid.map_node_to_cell',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.radial.RadialModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.radial.RadialModelGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.radial.RadialModelGrid.all_node_azimuths_map',
  'landlab.grid.radial.RadialModelGrid.all_node_distances_map',
  'landlab.grid.radial.RadialModelGrid.angle_of_link_about_head',
  'landlab.grid.radial.RadialModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.radial.RadialModelGrid.node_axis_coordinates',
  'landlab.grid.radial.RadialModelGrid.number_of_nodes_in_ring',
  'landlab.grid.radial.RadialModelGrid.radius_at_node',
  'landlab.grid.radial.RadialModelGrid.spacing_of_rings',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [
  'landlab.grid.radial.RadialModelGrid.perimeter_nodes',
]
surface = [
  'landlab.grid.radial.RadialModelGrid.calc_aspect_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_hillshade_at_node',
  'landlab.grid.radial.RadialModelGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.radial.RadialModelGrid.BAD_INDEX',
  'landlab.grid.radial.RadialModelGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.radial.RadialModelGrid.BC_LINK_IS_FIXED',
  'landlab.grid.radial.RadialModelGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.radial.RadialModelGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.radial.RadialModelGrid.BC_NODE_IS_CORE',
  'landlab.grid.radial.RadialModelGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.radial.RadialModelGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.radial.RadialModelGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.radial.RadialModelGrid.VALID_LOCATIONS',
  'landlab.grid.radial.RadialModelGrid.active_adjacent_corners_at_corner',
  'landlab.grid.radial.RadialModelGrid.active_face_dirs_at_corner',
  'landlab.grid.radial.RadialModelGrid.adjacent_corners_at_corner',
  'landlab.grid.radial.RadialModelGrid.adjacent_faces_at_face',
  'landlab.grid.radial.RadialModelGrid.adjacent_links_at_link',
  'landlab.grid.radial.RadialModelGrid.all_corner_azimuths_map',
  'landlab.grid.radial.RadialModelGrid.all_corner_distances_map',
  'landlab.grid.radial.RadialModelGrid.angle_at_corner',
  'landlab.grid.radial.RadialModelGrid.angle_at_node',
  'landlab.grid.radial.RadialModelGrid.angle_of_face',
  'landlab.grid.radial.RadialModelGrid.angle_of_face_about_head',
  'landlab.grid.radial.RadialModelGrid.angle_spacing_of_ring',
  'landlab.grid.radial.RadialModelGrid.area_of_cell',
  'landlab.grid.radial.RadialModelGrid.as_dataarray',
  'landlab.grid.radial.RadialModelGrid.as_dataset',
  'landlab.grid.radial.RadialModelGrid.at_cell',
  'landlab.grid.radial.RadialModelGrid.at_corner',
  'landlab.grid.radial.RadialModelGrid.at_face',
  'landlab.grid.radial.RadialModelGrid.at_grid',
  'landlab.grid.radial.RadialModelGrid.at_layer',
  'landlab.grid.radial.RadialModelGrid.at_link',
  'landlab.grid.radial.RadialModelGrid.at_node',
  'landlab.grid.radial.RadialModelGrid.at_patch',
  'landlab.grid.radial.RadialModelGrid.boundary_corners',
  'landlab.grid.radial.RadialModelGrid.cell_at_node',
  'landlab.grid.radial.RadialModelGrid.cells_at_corner',
  'landlab.grid.radial.RadialModelGrid.cells_at_face',
  'landlab.grid.radial.RadialModelGrid.cells_present_at_corner',
  'landlab.grid.radial.RadialModelGrid.cells_present_at_face',
  'landlab.grid.radial.RadialModelGrid.closed_boundary_corners',
  'landlab.grid.radial.RadialModelGrid.core_corners',
  'landlab.grid.radial.RadialModelGrid.core_patches',
  'landlab.grid.radial.RadialModelGrid.corner_at_core_patch',
  'landlab.grid.radial.RadialModelGrid.corner_at_face_head',
  'landlab.grid.radial.RadialModelGrid.corner_at_face_tail',
  'landlab.grid.radial.RadialModelGrid.corner_at_patch',
  'landlab.grid.radial.RadialModelGrid.corner_x',
  'landlab.grid.radial.RadialModelGrid.corner_y',
  'landlab.grid.radial.RadialModelGrid.corners',
  'landlab.grid.radial.RadialModelGrid.corners_at_cell',
  'landlab.grid.radial.RadialModelGrid.corners_at_face',
  'landlab.grid.radial.RadialModelGrid.corners_at_link',
  'landlab.grid.radial.RadialModelGrid.corners_per_ring',
  'landlab.grid.radial.RadialModelGrid.default_group',
  'landlab.grid.radial.RadialModelGrid.ds',
  'landlab.grid.radial.RadialModelGrid.dual',
  'landlab.grid.radial.RadialModelGrid.event_layers',
  'landlab.grid.radial.RadialModelGrid.face_at_link',
  'landlab.grid.radial.RadialModelGrid.face_dirs_at_corner',
  'landlab.grid.radial.RadialModelGrid.face_status_at_corner',
  'landlab.grid.radial.RadialModelGrid.faces_at_cell',
  'landlab.grid.radial.RadialModelGrid.faces_at_corner',
  'landlab.grid.radial.RadialModelGrid.fields',
  'landlab.grid.radial.RadialModelGrid.fixed_faces',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_corner_anchor_corner',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_corner_fixed_face',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_corners',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.radial.RadialModelGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.radial.RadialModelGrid.fixed_value_boundary_corners',
  'landlab.grid.radial.RadialModelGrid.freeze',
  'landlab.grid.radial.RadialModelGrid.from_dataset',
  'landlab.grid.radial.RadialModelGrid.from_dict',
  'landlab.grid.radial.RadialModelGrid.from_file',
  'landlab.grid.radial.RadialModelGrid.from_netcdf',
  'landlab.grid.radial.RadialModelGrid.frozen',
  'landlab.grid.radial.RadialModelGrid.groups',
  'landlab.grid.radial.RadialModelGrid.imshow',
  'landlab.grid.radial.RadialModelGrid.length_of_face',
  'landlab.grid.radial.RadialModelGrid.link_at_face',
  'landlab.grid.radial.RadialModelGrid.link_dirs_at_node',
  'landlab.grid.radial.RadialModelGrid.link_status_at_node',
  'landlab.grid.radial.RadialModelGrid.link_with_angle',
  'landlab.grid.radial.RadialModelGrid.link_with_node_status',
  'landlab.grid.radial.RadialModelGrid.load',
  'landlab.grid.radial.RadialModelGrid.map_link_vector_components_to_node',
  'landlab.grid.radial.RadialModelGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.radial.RadialModelGrid.map_node_to_link_linear_upwind',
  'landlab.grid.radial.RadialModelGrid.map_vectors_to_links',
  'landlab.grid.radial.RadialModelGrid.material_layers',
  'landlab.grid.radial.RadialModelGrid.merge',
  'landlab.grid.radial.RadialModelGrid.midpoint_of_face',
  'landlab.grid.radial.RadialModelGrid.ndim',
  'landlab.grid.radial.RadialModelGrid.node_at_cell',
  'landlab.grid.radial.RadialModelGrid.node_x',
  'landlab.grid.radial.RadialModelGrid.node_y',
  'landlab.grid.radial.RadialModelGrid.nodes_at_face',
  'landlab.grid.radial.RadialModelGrid.nodes_per_ring',
  'landlab.grid.radial.RadialModelGrid.number_of_cells',
  'landlab.grid.radial.RadialModelGrid.number_of_cells_present_at_corner',
  'landlab.grid.radial.RadialModelGrid.number_of_cells_present_at_face',
  'landlab.grid.radial.RadialModelGrid.number_of_core_corners',
  'landlab.grid.radial.RadialModelGrid.number_of_core_patches',
  'landlab.grid.radial.RadialModelGrid.number_of_corners',
  'landlab.grid.radial.RadialModelGrid.number_of_corners_in_ring',
  'landlab.grid.radial.RadialModelGrid.number_of_faces',
  'landlab.grid.radial.RadialModelGrid.number_of_fixed_faces',
  'landlab.grid.radial.RadialModelGrid.number_of_links',
  'landlab.grid.radial.RadialModelGrid.open_boundary_corners',
  'landlab.grid.radial.RadialModelGrid.origin',
  'landlab.grid.radial.RadialModelGrid.patch_area_at_corner',
  'landlab.grid.radial.RadialModelGrid.patch_at_corner',
  'landlab.grid.radial.RadialModelGrid.perimeter_corners',
  'landlab.grid.radial.RadialModelGrid.radius_at_corner',
  'landlab.grid.radial.RadialModelGrid.radius_of_ring',
  'landlab.grid.radial.RadialModelGrid.reset_status_at_node',
  'landlab.grid.radial.RadialModelGrid.ring_at_corner',
  'landlab.grid.radial.RadialModelGrid.ring_at_node',
  'landlab.grid.radial.RadialModelGrid.shape',
  'landlab.grid.radial.RadialModelGrid.sort',
  'landlab.grid.radial.RadialModelGrid.spacing',
  'landlab.grid.radial.RadialModelGrid.status_at_corner',
  'landlab.grid.radial.RadialModelGrid.status_at_face',
  'landlab.grid.radial.RadialModelGrid.thaw',
  'landlab.grid.radial.RadialModelGrid.thawed',
  'landlab.grid.radial.RadialModelGrid.to_dict',
  'landlab.grid.radial.RadialModelGrid.to_json',
  'landlab.grid.radial.RadialModelGrid.to_netcdf',
  'landlab.grid.radial.RadialModelGrid.unit_vector_at_corner',
  'landlab.grid.radial.RadialModelGrid.unit_vector_at_face',
  'landlab.grid.radial.RadialModelGrid.unit_vector_at_link',
  'landlab.grid.radial.RadialModelGrid.unit_vector_at_node',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_xcomponent_at_corner',
  'landlab.grid.radial.RadialModelGrid.unit_vector_sum_ycomponent_at_corner',
  'landlab.grid.radial.RadialModelGrid.x_of_corner',
  'landlab.grid.radial.RadialModelGrid.xy_of_cell',
  'landlab.grid.radial.RadialModelGrid.xy_of_center',
  'landlab.grid.radial.RadialModelGrid.xy_of_corner',
  'landlab.grid.radial.RadialModelGrid.xy_of_face',
  'landlab.grid.radial.RadialModelGrid.xy_of_link',
  'landlab.grid.radial.RadialModelGrid.xy_of_reference',
  'landlab.grid.radial.RadialModelGrid.y_of_corner',
]

[grids.RasterModelGrid]
boundary-condition = [
  'landlab.grid.raster.RasterModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.active_faces',
  'landlab.grid.raster.RasterModelGrid.active_links',
  'landlab.grid.raster.RasterModelGrid.boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.closed_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.core_cells',
  'landlab.grid.raster.RasterModelGrid.core_nodes',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.fixed_links',
  'landlab.grid.raster.RasterModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.looped_neighbors_at_cell',
  'landlab.grid.raster.RasterModelGrid.node_at_core_cell',
  'landlab.grid.raster.RasterModelGrid.node_has_boundary_neighbor',
  'landlab.grid.raster.RasterModelGrid.node_is_boundary',
  'landlab.grid.raster.RasterModelGrid.number_of_active_faces',
  'landlab.grid.raster.RasterModelGrid.number_of_active_links',
  'landlab.grid.raster.RasterModelGrid.number_of_core_cells',
  'landlab.grid.raster.RasterModelGrid.number_of_core_nodes',
  'landlab.grid.raster.RasterModelGrid.number_of_fixed_links',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_link',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_node',
  'landlab.grid.raster.RasterModelGrid.open_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.second_ring_looped_neighbors_at_cell',
  'landlab.grid.raster.RasterModelGrid.set_closed_boundaries_at_grid_edges',
  'landlab.grid.raster.RasterModelGrid.set_fixed_value_boundaries_at_grid_edges',
  'landlab.grid.raster.RasterModelGrid.set_looped_boundaries',
  'landlab.grid.raster.RasterModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.raster.RasterModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.raster.RasterModelGrid.set_open_nodes_disconnected_from_watershed_to_closed',
  'landlab.grid.raster.RasterModelGrid.set_status_at_node_on_edges',
  'landlab.grid.raster.RasterModelGrid.set_watershed_boundary_condition',
  'landlab.grid.raster.RasterModelGrid.set_watershed_boundary_condition_outlet_coords',
  'landlab.grid.raster.RasterModelGrid.set_watershed_boundary_condition_outlet_id',
  'landlab.grid.raster.RasterModelGrid.status_at_link',
  'landlab.grid.raster.RasterModelGrid.status_at_node',
]
connectivity = [
  'landlab.grid.raster.RasterModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.active_link_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.cell_area_at_node',
  'landlab.grid.raster.RasterModelGrid.d8s_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonal_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonals_at_node',
  'landlab.grid.raster.RasterModelGrid.downwind_links_at_node',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_downwind',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_upwind',
  'landlab.grid.raster.RasterModelGrid.looped_neighbors_at_cell',
  'landlab.grid.raster.RasterModelGrid.node_at_core_cell',
  'landlab.grid.raster.RasterModelGrid.node_has_boundary_neighbor',
  'landlab.grid.raster.RasterModelGrid.second_ring_looped_neighbors_at_cell',
  'landlab.grid.raster.RasterModelGrid.upwind_links_at_node',
]
deprecated = [
  'landlab.grid.raster.RasterModelGrid.looped_neighbors_at_cell',
]
field-add = [
  'landlab.grid.raster.RasterModelGrid.add_empty',
  'landlab.grid.raster.RasterModelGrid.add_field',
  'landlab.grid.raster.RasterModelGrid.add_full',
  'landlab.grid.raster.RasterModelGrid.add_ones',
  'landlab.grid.raster.RasterModelGrid.add_zeros',
  'landlab.grid.raster.RasterModelGrid.delete_field',
  'landlab.grid.raster.RasterModelGrid.empty',
  'landlab.grid.raster.RasterModelGrid.new_field_location',
  'landlab.grid.raster.RasterModelGrid.ones',
  'landlab.grid.raster.RasterModelGrid.zeros',
]
field-io = [
  'landlab.grid.raster.RasterModelGrid.at_cell',
  'landlab.grid.raster.RasterModelGrid.at_corner',
  'landlab.grid.raster.RasterModelGrid.at_face',
  'landlab.grid.raster.RasterModelGrid.at_link',
  'landlab.grid.raster.RasterModelGrid.at_node',
  'landlab.grid.raster.RasterModelGrid.at_patch',
  'landlab.grid.raster.RasterModelGrid.field_values',
  'landlab.grid.raster.RasterModelGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_d8',
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_link',
  'landlab.grid.raster.RasterModelGrid.calc_flux_div_at_cell',
  'landlab.grid.raster.RasterModelGrid.calc_flux_div_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_grad_across_cell_corners',
  'landlab.grid.raster.RasterModelGrid.calc_grad_across_cell_faces',
  'landlab.grid.raster.RasterModelGrid.calc_grad_along_node_links',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_d8',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_link',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_net_flux_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normal_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normals_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normals_at_patch_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calculate_slope_aspect_at_nodes_burrough',
]
info-cell = [
  'landlab.grid.raster.RasterModelGrid.calc_aspect_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normals_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.cell_area_at_node',
  'landlab.grid.raster.RasterModelGrid.cell_grid_shape',
  'landlab.grid.raster.RasterModelGrid.cell_vector_to_raster',
  'landlab.grid.raster.RasterModelGrid.cells_at_corners_of_grid',
  'landlab.grid.raster.RasterModelGrid.core_cells',
  'landlab.grid.raster.RasterModelGrid.looped_neighbors_at_cell',
  'landlab.grid.raster.RasterModelGrid.map_node_to_cell',
  'landlab.grid.raster.RasterModelGrid.node_at_core_cell',
  'landlab.grid.raster.RasterModelGrid.number_of_cell_rows',
  'landlab.grid.raster.RasterModelGrid.number_of_core_cells',
  'landlab.grid.raster.RasterModelGrid.second_ring_looped_neighbors_at_cell',
]
info-corner = [
  'landlab.grid.raster.RasterModelGrid.calc_grad_across_cell_corners',
]
info-face = [
  'landlab.grid.raster.RasterModelGrid.active_faces',
  'landlab.grid.raster.RasterModelGrid.calc_grad_across_cell_faces',
  'landlab.grid.raster.RasterModelGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.raster.RasterModelGrid.field_units',
  'landlab.grid.raster.RasterModelGrid.has_field',
  'landlab.grid.raster.RasterModelGrid.has_group',
  'landlab.grid.raster.RasterModelGrid.keys',
  'landlab.grid.raster.RasterModelGrid.size',
]
info-grid = [
  'landlab.grid.raster.RasterModelGrid.axis_name',
  'landlab.grid.raster.RasterModelGrid.axis_units',
  'landlab.grid.raster.RasterModelGrid.cell_grid_shape',
  'landlab.grid.raster.RasterModelGrid.cell_vector_to_raster',
  'landlab.grid.raster.RasterModelGrid.cells_at_corners_of_grid',
  'landlab.grid.raster.RasterModelGrid.extent',
  'landlab.grid.raster.RasterModelGrid.from_dict',
  'landlab.grid.raster.RasterModelGrid.is_point_on_grid',
  'landlab.grid.raster.RasterModelGrid.node_axis_coordinates',
  'landlab.grid.raster.RasterModelGrid.node_vector_to_raster',
  'landlab.grid.raster.RasterModelGrid.number_of_cell_columns',
  'landlab.grid.raster.RasterModelGrid.number_of_cell_rows',
  'landlab.grid.raster.RasterModelGrid.number_of_elements',
  'landlab.grid.raster.RasterModelGrid.save',
  'landlab.grid.raster.RasterModelGrid.size',
]
info-link = [
  'landlab.grid.raster.RasterModelGrid.active_link_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.active_links',
  'landlab.grid.raster.RasterModelGrid.angle_of_link',
  'landlab.grid.raster.RasterModelGrid.angle_of_link_about_head',
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_d8',
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.calc_diff_at_link',
  'landlab.grid.raster.RasterModelGrid.calc_grad_along_node_links',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_d8',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_link',
  'landlab.grid.raster.RasterModelGrid.d8s_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonals_at_node',
  'landlab.grid.raster.RasterModelGrid.downwind_links_at_node',
  'landlab.grid.raster.RasterModelGrid.fixed_links',
  'landlab.grid.raster.RasterModelGrid.length_of_d8',
  'landlab.grid.raster.RasterModelGrid.length_of_link',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_downwind',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_upwind',
  'landlab.grid.raster.RasterModelGrid.links_at_patch',
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_link_head_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_link_tail_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_max_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.midpoint_of_link',
  'landlab.grid.raster.RasterModelGrid.number_of_active_links',
  'landlab.grid.raster.RasterModelGrid.number_of_fixed_links',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_link',
  'landlab.grid.raster.RasterModelGrid.patches_present_at_link',
  'landlab.grid.raster.RasterModelGrid.resolve_values_on_links',
  'landlab.grid.raster.RasterModelGrid.status_at_link',
  'landlab.grid.raster.RasterModelGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.raster.RasterModelGrid.active_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.active_link_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.all_node_azimuths_map',
  'landlab.grid.raster.RasterModelGrid.all_node_distances_map',
  'landlab.grid.raster.RasterModelGrid.boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.calc_aspect_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.raster.RasterModelGrid.calc_flux_div_at_cell',
  'landlab.grid.raster.RasterModelGrid.calc_flux_div_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_grad_along_node_links',
  'landlab.grid.raster.RasterModelGrid.calc_hillshade_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_net_flux_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_node',
  'landlab.grid.raster.RasterModelGrid.calculate_slope_aspect_at_nodes_burrough',
  'landlab.grid.raster.RasterModelGrid.cell_area_at_node',
  'landlab.grid.raster.RasterModelGrid.closed_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.core_nodes',
  'landlab.grid.raster.RasterModelGrid.d8s_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonal_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonals_at_node',
  'landlab.grid.raster.RasterModelGrid.downwind_links_at_node',
  'landlab.grid.raster.RasterModelGrid.find_nearest_node',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.fixed_value_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.grid_coords_to_node_id',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_downwind',
  'landlab.grid.raster.RasterModelGrid.link_at_node_is_upwind',
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_link_head_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_link_tail_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_max_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_node_to_cell',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.node_at_core_cell',
  'landlab.grid.raster.RasterModelGrid.node_at_link_head',
  'landlab.grid.raster.RasterModelGrid.node_at_link_tail',
  'landlab.grid.raster.RasterModelGrid.node_axis_coordinates',
  'landlab.grid.raster.RasterModelGrid.node_has_boundary_neighbor',
  'landlab.grid.raster.RasterModelGrid.node_is_boundary',
  'landlab.grid.raster.RasterModelGrid.node_vector_to_raster',
  'landlab.grid.raster.RasterModelGrid.nodes_around_point',
  'landlab.grid.raster.RasterModelGrid.nodes_at_link',
  'landlab.grid.raster.RasterModelGrid.nodes_at_patch',
  'landlab.grid.raster.RasterModelGrid.number_of_cell_columns',
  'landlab.grid.raster.RasterModelGrid.number_of_core_nodes',
  'landlab.grid.raster.RasterModelGrid.number_of_interior_nodes',
  'landlab.grid.raster.RasterModelGrid.number_of_nodes',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_node',
  'landlab.grid.raster.RasterModelGrid.open_boundary_nodes',
  'landlab.grid.raster.RasterModelGrid.patches_present_at_node',
  'landlab.grid.raster.RasterModelGrid.roll_nodes_ud',
  'landlab.grid.raster.RasterModelGrid.set_nodata_nodes_to_closed',
  'landlab.grid.raster.RasterModelGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.raster.RasterModelGrid.status_at_node',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.raster.RasterModelGrid.upwind_links_at_node',
  'landlab.grid.raster.RasterModelGrid.x_of_node',
  'landlab.grid.raster.RasterModelGrid.xy_of_node',
  'landlab.grid.raster.RasterModelGrid.y_of_node',
]
info-patch = [
  'landlab.grid.raster.RasterModelGrid.area_of_patch',
  'landlab.grid.raster.RasterModelGrid.calc_grad_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normal_at_patch',
  'landlab.grid.raster.RasterModelGrid.calc_unit_normals_at_patch_subtriangles',
  'landlab.grid.raster.RasterModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.number_of_patches',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_link',
  'landlab.grid.raster.RasterModelGrid.number_of_patches_present_at_node',
  'landlab.grid.raster.RasterModelGrid.patches_present_at_link',
  'landlab.grid.raster.RasterModelGrid.patches_present_at_node',
  'landlab.grid.raster.RasterModelGrid.xy_of_patch',
]
map = [
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_link_head_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_link_tail_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_link_vector_sum_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_max_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_max_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_horizontal_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_active_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_mean_of_vertical_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.raster.RasterModelGrid.map_min_of_node_links_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.raster.RasterModelGrid.map_node_to_cell',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_inlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_sum_of_outlinks_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.raster.RasterModelGrid.map_value_at_max_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_min_node_to_link',
  'landlab.grid.raster.RasterModelGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.raster.RasterModelGrid.all_node_azimuths_map',
  'landlab.grid.raster.RasterModelGrid.all_node_distances_map',
  'landlab.grid.raster.RasterModelGrid.angle_of_link_about_head',
  'landlab.grid.raster.RasterModelGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.raster.RasterModelGrid.extent',
  'landlab.grid.raster.RasterModelGrid.grid_coords_to_node_id',
  'landlab.grid.raster.RasterModelGrid.is_point_on_grid',
  'landlab.grid.raster.RasterModelGrid.length_of_d8',
  'landlab.grid.raster.RasterModelGrid.node_axis_coordinates',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [
  'landlab.grid.raster.RasterModelGrid.cells_at_corners_of_grid',
  'landlab.grid.raster.RasterModelGrid.find_nearest_node',
  'landlab.grid.raster.RasterModelGrid.grid_coords_to_node_id',
  'landlab.grid.raster.RasterModelGrid.is_point_on_grid',
  'landlab.grid.raster.RasterModelGrid.nodes_around_point',
  'landlab.grid.raster.RasterModelGrid.set_closed_boundaries_at_grid_edges',
  'landlab.grid.raster.RasterModelGrid.set_fixed_value_boundaries_at_grid_edges',
  'landlab.grid.raster.RasterModelGrid.set_looped_boundaries',
]
surface = [
  'landlab.grid.raster.RasterModelGrid.calc_aspect_at_cell_subtriangles',
  'landlab.grid.raster.RasterModelGrid.calc_aspect_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_hillshade_at_node',
  'landlab.grid.raster.RasterModelGrid.calc_slope_at_node',
  'landlab.grid.raster.RasterModelGrid.calculate_slope_aspect_at_nodes_burrough',
]
uncategorized = [
  'landlab.grid.raster.RasterModelGrid.BAD_INDEX',
  'landlab.grid.raster.RasterModelGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.raster.RasterModelGrid.BC_LINK_IS_FIXED',
  'landlab.grid.raster.RasterModelGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.raster.RasterModelGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.raster.RasterModelGrid.BC_NODE_IS_CORE',
  'landlab.grid.raster.RasterModelGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.raster.RasterModelGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.raster.RasterModelGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.raster.RasterModelGrid.VALID_LOCATIONS',
  'landlab.grid.raster.RasterModelGrid.active_adjacent_corners_at_corner',
  'landlab.grid.raster.RasterModelGrid.active_d8',
  'landlab.grid.raster.RasterModelGrid.active_d8_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.active_d8_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.active_diagonal_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.active_diagonal_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.active_diagonals',
  'landlab.grid.raster.RasterModelGrid.active_face_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.adjacent_corners_at_corner',
  'landlab.grid.raster.RasterModelGrid.adjacent_faces_at_face',
  'landlab.grid.raster.RasterModelGrid.adjacent_links_at_link',
  'landlab.grid.raster.RasterModelGrid.all_corner_azimuths_map',
  'landlab.grid.raster.RasterModelGrid.all_corner_distances_map',
  'landlab.grid.raster.RasterModelGrid.angle_of_face',
  'landlab.grid.raster.RasterModelGrid.angle_of_face_about_head',
  'landlab.grid.raster.RasterModelGrid.area_of_cell',
  'landlab.grid.raster.RasterModelGrid.as_dataarray',
  'landlab.grid.raster.RasterModelGrid.as_dataset',
  'landlab.grid.raster.RasterModelGrid.at_cell',
  'landlab.grid.raster.RasterModelGrid.at_corner',
  'landlab.grid.raster.RasterModelGrid.at_face',
  'landlab.grid.raster.RasterModelGrid.at_grid',
  'landlab.grid.raster.RasterModelGrid.at_layer',
  'landlab.grid.raster.RasterModelGrid.at_link',
  'landlab.grid.raster.RasterModelGrid.at_node',
  'landlab.grid.raster.RasterModelGrid.at_patch',
  'landlab.grid.raster.RasterModelGrid.boundary_corners',
  'landlab.grid.raster.RasterModelGrid.calc_net_face_flux_at_cell',
  'landlab.grid.raster.RasterModelGrid.cell_at_node',
  'landlab.grid.raster.RasterModelGrid.cells_at_corner',
  'landlab.grid.raster.RasterModelGrid.cells_at_face',
  'landlab.grid.raster.RasterModelGrid.cells_present_at_corner',
  'landlab.grid.raster.RasterModelGrid.cells_present_at_face',
  'landlab.grid.raster.RasterModelGrid.closed_boundary_corners',
  'landlab.grid.raster.RasterModelGrid.core_corners',
  'landlab.grid.raster.RasterModelGrid.core_patches',
  'landlab.grid.raster.RasterModelGrid.corner_at_core_patch',
  'landlab.grid.raster.RasterModelGrid.corner_at_face_head',
  'landlab.grid.raster.RasterModelGrid.corner_at_face_tail',
  'landlab.grid.raster.RasterModelGrid.corner_at_patch',
  'landlab.grid.raster.RasterModelGrid.corner_nodes',
  'landlab.grid.raster.RasterModelGrid.corner_x',
  'landlab.grid.raster.RasterModelGrid.corner_y',
  'landlab.grid.raster.RasterModelGrid.corners',
  'landlab.grid.raster.RasterModelGrid.corners_at_bottom_edge',
  'landlab.grid.raster.RasterModelGrid.corners_at_cell',
  'landlab.grid.raster.RasterModelGrid.corners_at_d8',
  'landlab.grid.raster.RasterModelGrid.corners_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.corners_at_face',
  'landlab.grid.raster.RasterModelGrid.corners_at_left_edge',
  'landlab.grid.raster.RasterModelGrid.corners_at_link',
  'landlab.grid.raster.RasterModelGrid.corners_at_nodes_of_grid',
  'landlab.grid.raster.RasterModelGrid.corners_at_right_edge',
  'landlab.grid.raster.RasterModelGrid.corners_at_top_edge',
  'landlab.grid.raster.RasterModelGrid.d8_adjacent_corners_at_corner',
  'landlab.grid.raster.RasterModelGrid.d8_adjacent_nodes_at_node',
  'landlab.grid.raster.RasterModelGrid.d8_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.d8_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.d8_status_at_corner',
  'landlab.grid.raster.RasterModelGrid.d8_status_at_node',
  'landlab.grid.raster.RasterModelGrid.d8s_at_corner',
  'landlab.grid.raster.RasterModelGrid.default_group',
  'landlab.grid.raster.RasterModelGrid.diagonal_adjacent_corners_at_corner',
  'landlab.grid.raster.RasterModelGrid.diagonal_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.diagonal_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonal_status_at_corner',
  'landlab.grid.raster.RasterModelGrid.diagonal_status_at_node',
  'landlab.grid.raster.RasterModelGrid.diagonals_at_corner',
  'landlab.grid.raster.RasterModelGrid.ds',
  'landlab.grid.raster.RasterModelGrid.dual',
  'landlab.grid.raster.RasterModelGrid.dx',
  'landlab.grid.raster.RasterModelGrid.dy',
  'landlab.grid.raster.RasterModelGrid.event_layers',
  'landlab.grid.raster.RasterModelGrid.face_at_link',
  'landlab.grid.raster.RasterModelGrid.face_dirs_at_corner',
  'landlab.grid.raster.RasterModelGrid.face_status_at_corner',
  'landlab.grid.raster.RasterModelGrid.faces_at_cell',
  'landlab.grid.raster.RasterModelGrid.faces_at_corner',
  'landlab.grid.raster.RasterModelGrid.fields',
  'landlab.grid.raster.RasterModelGrid.fixed_faces',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_corner_anchor_corner',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_corner_fixed_face',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_corners',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.raster.RasterModelGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.raster.RasterModelGrid.fixed_value_boundary_corners',
  'landlab.grid.raster.RasterModelGrid.freeze',
  'landlab.grid.raster.RasterModelGrid.from_dataset',
  'landlab.grid.raster.RasterModelGrid.from_file',
  'landlab.grid.raster.RasterModelGrid.from_netcdf',
  'landlab.grid.raster.RasterModelGrid.frozen',
  'landlab.grid.raster.RasterModelGrid.groups',
  'landlab.grid.raster.RasterModelGrid.horizontal_faces',
  'landlab.grid.raster.RasterModelGrid.horizontal_links',
  'landlab.grid.raster.RasterModelGrid.imshow',
  'landlab.grid.raster.RasterModelGrid.length_of_diagonal',
  'landlab.grid.raster.RasterModelGrid.length_of_face',
  'landlab.grid.raster.RasterModelGrid.link_at_face',
  'landlab.grid.raster.RasterModelGrid.link_dirs_at_node',
  'landlab.grid.raster.RasterModelGrid.link_status_at_node',
  'landlab.grid.raster.RasterModelGrid.link_with_angle',
  'landlab.grid.raster.RasterModelGrid.link_with_node_status',
  'landlab.grid.raster.RasterModelGrid.links_at_node',
  'landlab.grid.raster.RasterModelGrid.load',
  'landlab.grid.raster.RasterModelGrid.looped_neighbors_at_patch',
  'landlab.grid.raster.RasterModelGrid.map_link_vector_components_to_node',
  'landlab.grid.raster.RasterModelGrid.map_link_vector_components_to_node_raster',
  'landlab.grid.raster.RasterModelGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.raster.RasterModelGrid.map_node_to_link_linear_upwind',
  'landlab.grid.raster.RasterModelGrid.map_vectors_to_links',
  'landlab.grid.raster.RasterModelGrid.material_layers',
  'landlab.grid.raster.RasterModelGrid.merge',
  'landlab.grid.raster.RasterModelGrid.midpoint_of_face',
  'landlab.grid.raster.RasterModelGrid.ndim',
  'landlab.grid.raster.RasterModelGrid.node_at_cell',
  'landlab.grid.raster.RasterModelGrid.node_corners',
  'landlab.grid.raster.RasterModelGrid.node_x',
  'landlab.grid.raster.RasterModelGrid.node_y',
  'landlab.grid.raster.RasterModelGrid.nodes',
  'landlab.grid.raster.RasterModelGrid.nodes_at_bottom_edge',
  'landlab.grid.raster.RasterModelGrid.nodes_at_corners_of_grid',
  'landlab.grid.raster.RasterModelGrid.nodes_at_d8',
  'landlab.grid.raster.RasterModelGrid.nodes_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.nodes_at_edge',
  'landlab.grid.raster.RasterModelGrid.nodes_at_face',
  'landlab.grid.raster.RasterModelGrid.nodes_at_left_edge',
  'landlab.grid.raster.RasterModelGrid.nodes_at_right_edge',
  'landlab.grid.raster.RasterModelGrid.nodes_at_top_edge',
  'landlab.grid.raster.RasterModelGrid.number_of_cells',
  'landlab.grid.raster.RasterModelGrid.number_of_cells_present_at_corner',
  'landlab.grid.raster.RasterModelGrid.number_of_cells_present_at_face',
  'landlab.grid.raster.RasterModelGrid.number_of_core_corners',
  'landlab.grid.raster.RasterModelGrid.number_of_core_patches',
  'landlab.grid.raster.RasterModelGrid.number_of_corner_columns',
  'landlab.grid.raster.RasterModelGrid.number_of_corner_rows',
  'landlab.grid.raster.RasterModelGrid.number_of_corners',
  'landlab.grid.raster.RasterModelGrid.number_of_d8',
  'landlab.grid.raster.RasterModelGrid.number_of_diagonals',
  'landlab.grid.raster.RasterModelGrid.number_of_faces',
  'landlab.grid.raster.RasterModelGrid.number_of_fixed_faces',
  'landlab.grid.raster.RasterModelGrid.number_of_interior_corners',
  'landlab.grid.raster.RasterModelGrid.number_of_links',
  'landlab.grid.raster.RasterModelGrid.number_of_node_columns',
  'landlab.grid.raster.RasterModelGrid.number_of_node_rows',
  'landlab.grid.raster.RasterModelGrid.number_of_patch_columns',
  'landlab.grid.raster.RasterModelGrid.number_of_patch_rows',
  'landlab.grid.raster.RasterModelGrid.open_boundary_corners',
  'landlab.grid.raster.RasterModelGrid.orientation_of_face',
  'landlab.grid.raster.RasterModelGrid.orientation_of_link',
  'landlab.grid.raster.RasterModelGrid.origin',
  'landlab.grid.raster.RasterModelGrid.parallel_faces_at_face',
  'landlab.grid.raster.RasterModelGrid.parallel_links_at_link',
  'landlab.grid.raster.RasterModelGrid.patch_area_at_corner',
  'landlab.grid.raster.RasterModelGrid.patch_at_corner',
  'landlab.grid.raster.RasterModelGrid.patch_grid_shape',
  'landlab.grid.raster.RasterModelGrid.patches_at_link',
  'landlab.grid.raster.RasterModelGrid.patches_at_node',
  'landlab.grid.raster.RasterModelGrid.patches_at_nodes_of_grid',
  'landlab.grid.raster.RasterModelGrid.perimeter_corners',
  'landlab.grid.raster.RasterModelGrid.perimeter_nodes',
  'landlab.grid.raster.RasterModelGrid.reset_status_at_node',
  'landlab.grid.raster.RasterModelGrid.second_ring_looped_neighbors_at_patch',
  'landlab.grid.raster.RasterModelGrid.shape',
  'landlab.grid.raster.RasterModelGrid.sort',
  'landlab.grid.raster.RasterModelGrid.spacing',
  'landlab.grid.raster.RasterModelGrid.status_at_corner',
  'landlab.grid.raster.RasterModelGrid.status_at_d8',
  'landlab.grid.raster.RasterModelGrid.status_at_diagonal',
  'landlab.grid.raster.RasterModelGrid.status_at_face',
  'landlab.grid.raster.RasterModelGrid.thaw',
  'landlab.grid.raster.RasterModelGrid.thawed',
  'landlab.grid.raster.RasterModelGrid.to_dict',
  'landlab.grid.raster.RasterModelGrid.to_json',
  'landlab.grid.raster.RasterModelGrid.to_netcdf',
  'landlab.grid.raster.RasterModelGrid.unit_vector_at_corner',
  'landlab.grid.raster.RasterModelGrid.unit_vector_at_face',
  'landlab.grid.raster.RasterModelGrid.unit_vector_at_link',
  'landlab.grid.raster.RasterModelGrid.unit_vector_at_node',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_xcomponent_at_corner',
  'landlab.grid.raster.RasterModelGrid.unit_vector_sum_ycomponent_at_corner',
  'landlab.grid.raster.RasterModelGrid.vertical_faces',
  'landlab.grid.raster.RasterModelGrid.vertical_links',
  'landlab.grid.raster.RasterModelGrid.x_of_corner',
  'landlab.grid.raster.RasterModelGrid.xy_of_cell',
  'landlab.grid.raster.RasterModelGrid.xy_of_corner',
  'landlab.grid.raster.RasterModelGrid.xy_of_face',
  'landlab.grid.raster.RasterModelGrid.xy_of_link',
  'landlab.grid.raster.RasterModelGrid.xy_of_lower_left',
  'landlab.grid.raster.RasterModelGrid.xy_of_reference',
  'landlab.grid.raster.RasterModelGrid.y_of_corner',
]

[grids.VoronoiDelaunayGrid]
boundary-condition = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_adjacent_nodes_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.closed_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_cells',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_value_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_core_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_has_boundary_neighbor',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_is_boundary',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_active_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_active_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_cells',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_fixed_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.open_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.perimeter_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.set_nodata_nodes_to_closed',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_node',
]
connectivity = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_adjacent_nodes_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_link_dirs_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cell_area_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.downwind_links_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_downwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_upwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_core_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_has_boundary_neighbor',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.upwind_links_at_node',
]
deprecated = [

]
field-add = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.add_empty',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.add_field',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.add_full',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.add_ones',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.add_zeros',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.delete_field',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.empty',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.new_field_location',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.ones',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.zeros',
]
field-io = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.field_values',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.return_array_or_field_values',
]
gradient = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_diff_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_flux_div_at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_flux_div_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_grad_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_grad_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_net_flux_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_slope_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_slope_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_unit_normal_at_patch',
]
info-cell = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cell_area_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_cells',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_node_to_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_core_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_cells',
]
info-corner = [

]
info-face = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_active_faces',
]
info-field = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.field_units',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.has_field',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.has_group',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.keys',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.size',
]
info-grid = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.axis_name',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.axis_units',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_axis_coordinates',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_elements',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.save',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.size',
]
info-link = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_link_dirs_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.angle_of_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.angle_of_link_about_head',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_diff_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_grad_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.downwind_links_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.length_of_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_downwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_upwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.links_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.links_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_head_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_tail_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_vector_sum_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_max_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_min_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.midpoint_of_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_active_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_fixed_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_present_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.resolve_values_on_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.upwind_links_at_node',
]
info-node = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_adjacent_nodes_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_link_dirs_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.adjacent_nodes_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_node_azimuths_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_node_distances_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_aspect_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_flux_div_at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_flux_div_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_hillshade_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_net_flux_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_slope_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cell_area_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.closed_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.downwind_links_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_value_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_downwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_node_is_upwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_head_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_tail_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_node_to_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_max_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_min_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_upwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_core_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_link_head',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_link_tail',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_axis_coordinates',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_has_boundary_neighbor',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_is_boundary',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.nodes_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.nodes_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.open_boundary_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_present_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.perimeter_nodes',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.set_nodata_nodes_to_closed',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.set_nodata_nodes_to_fixed_gradient',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_ycomponent_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.upwind_links_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.x_of_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.y_of_node',
]
info-patch = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.area_of_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_grad_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_slope_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_unit_normal_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_vector_sum_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_patches_present_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_present_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patches_present_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_patch',
]
map = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_downwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_head_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_tail_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_vector_sum_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_max_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_mean_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_link_nodes_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_node_links_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_min_of_patch_nodes_to_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_node_to_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_upwind_node_link_mean_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_downwind_node_link_max_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_max_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_min_node_to_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_value_at_upwind_node_link_max_to_node',
]
quantity = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_node_azimuths_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_node_distances_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.angle_of_link_about_head',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_distances_of_nodes_to_point',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_axis_coordinates',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_xcomponent_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_ycomponent_at_node',
]
subset = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.perimeter_nodes',
]
surface = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_aspect_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_hillshade_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.calc_slope_at_node',
]
uncategorized = [
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BAD_INDEX',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_LINK_IS_ACTIVE',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_LINK_IS_FIXED',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_LINK_IS_INACTIVE',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_NODE_IS_CLOSED',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_NODE_IS_CORE',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_NODE_IS_FIXED_GRADIENT',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_NODE_IS_FIXED_VALUE',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.BC_NODE_IS_LOOPED',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.VALID_LOCATIONS',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_adjacent_corners_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.active_face_dirs_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.adjacent_corners_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.adjacent_faces_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.adjacent_links_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_corner_azimuths_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.all_corner_distances_map',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.angle_of_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.angle_of_face_about_head',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.area_of_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.as_dataarray',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.as_dataset',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_grid',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_layer',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.boundary_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cell_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cells_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cells_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cells_present_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.cells_present_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.closed_boundary_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.core_patches',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_at_core_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_at_face_head',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_at_face_tail',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_at_patch',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_x',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corner_y',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corners_at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corners_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.corners_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.default_group',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.ds',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.dual',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.event_layers',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.face_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.face_dirs_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.face_status_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.faces_at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.faces_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fields',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_corner_anchor_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_corner_fixed_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_node_anchor_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_gradient_boundary_node_fixed_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.fixed_value_boundary_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.freeze',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.from_dict',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.from_file',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.from_netcdf',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.frozen',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.groups',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.imshow',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.length_of_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_dirs_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_status_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_with_angle',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.link_with_node_status',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.load',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_link_vector_components_to_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_node_to_link_lax_wendroff',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_node_to_link_linear_upwind',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.map_vectors_to_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.material_layers',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.merge',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.midpoint_of_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.ndim',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_at_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_x',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.node_y',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.nodes_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_cells',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_cells_present_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_cells_present_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_core_patches',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_fixed_faces',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.number_of_links',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.open_boundary_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patch_area_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.patch_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.perimeter_corners',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.reset_status_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.sort',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.status_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.thaw',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.thawed',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.to_dict',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.to_json',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.to_netcdf',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_at_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_at_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_at_node',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_xcomponent_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.unit_vector_sum_ycomponent_at_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.x_of_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_cell',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_corner',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_face',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_link',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.xy_of_reference',
  'landlab.grid.voronoi.VoronoiDelaunayGrid.y_of_corner',
]



================================================
File: docs/make.bat
================================================
@ECHO OFF

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set BUILDDIR=_build
set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
set I18NSPHINXOPTS=%SPHINXOPTS% .
if NOT "%PAPER%" == "" (
	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
)

if "%1" == "" goto help

if "%1" == "help" (
	:help
	echo.Please use `make ^<target^>` where ^<target^> is one of
	echo.  html       to make standalone HTML files
	echo.  dirhtml    to make HTML files named index.html in directories
	echo.  singlehtml to make a single large HTML file
	echo.  pickle     to make pickle files
	echo.  json       to make JSON files
	echo.  htmlhelp   to make HTML files and a HTML help project
	echo.  qthelp     to make HTML files and a qthelp project
	echo.  devhelp    to make HTML files and a Devhelp project
	echo.  epub       to make an epub
	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
	echo.  text       to make text files
	echo.  man        to make manual pages
	echo.  texinfo    to make Texinfo files
	echo.  gettext    to make PO message catalogs
	echo.  changes    to make an overview over all changed/added/deprecated items
	echo.  xml        to make Docutils-native XML files
	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
	echo.  linkcheck  to check all external links for integrity
	echo.  doctest    to run all doctests embedded in the documentation if enabled
	goto end
)

if "%1" == "clean" (
	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
	del /q /s %BUILDDIR%\*
	goto end
)


%SPHINXBUILD% 2> nul
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

if "%1" == "html" (
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
	goto end
)

if "%1" == "dirhtml" (
	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
	goto end
)

if "%1" == "singlehtml" (
	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
	goto end
)

if "%1" == "pickle" (
	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the pickle files.
	goto end
)

if "%1" == "json" (
	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the JSON files.
	goto end
)

if "%1" == "htmlhelp" (
	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run HTML Help Workshop with the ^
.hhp project file in %BUILDDIR%/htmlhelp.
	goto end
)

if "%1" == "qthelp" (
	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run "qcollectiongenerator" with the ^
.qhcp project file in %BUILDDIR%/qthelp, like this:
	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\landlab.qhcp
	echo.To view the help file:
	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\landlab.ghc
	goto end
)

if "%1" == "devhelp" (
	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished.
	goto end
)

if "%1" == "epub" (
	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The epub file is in %BUILDDIR%/epub.
	goto end
)

if "%1" == "latex" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdf" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdfja" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf-ja
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "text" (
	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The text files are in %BUILDDIR%/text.
	goto end
)

if "%1" == "man" (
	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The manual pages are in %BUILDDIR%/man.
	goto end
)

if "%1" == "texinfo" (
	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
	goto end
)

if "%1" == "gettext" (
	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
	goto end
)

if "%1" == "changes" (
	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
	if errorlevel 1 exit /b 1
	echo.
	echo.The overview file is in %BUILDDIR%/changes.
	goto end
)

if "%1" == "linkcheck" (
	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
	if errorlevel 1 exit /b 1
	echo.
	echo.Link check complete; look for any errors in the above output ^
or in %BUILDDIR%/linkcheck/output.txt.
	goto end
)

if "%1" == "doctest" (
	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
	if errorlevel 1 exit /b 1
	echo.
	echo.Testing of doctests in the sources finished, look at the ^
results in %BUILDDIR%/doctest/output.txt.
	goto end
)

if "%1" == "xml" (
	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The XML files are in %BUILDDIR%/xml.
	goto end
)

if "%1" == "pseudoxml" (
	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
	goto end
)

:end



================================================
File: docs/requirements.in
================================================
furo
ipython
myst-parser
nbsphinx
numpy
sphinx-copybutton
sphinx-inline-tabs
sphinx-jinja
sphinx>=4
sphinx_design
sphinxcontrib.towncrier
towncrier



================================================
File: docs/source/conf.py
================================================
import os
import pathlib
import re
import sys
import tomllib
from datetime import date

import packaging


def get_version_from_file(path):
    with open(path) as fp:
        match = re.search(r'__version__\s*=\s*[\'"]([^\'"]+)[\'"]', fp.read())
        if match:
            version = match.group(1)
        else:
            raise ValueError(f"version string not found ({path})")
    return packaging.version.Version(version)


src_dir = os.path.abspath(
    os.path.join(os.path.dirname(__file__), os.pardir, os.pardir, "src")
)
sys.path.insert(0, src_dir)
docs_dir = pathlib.Path(__file__).parent
version_file = os.path.join(src_dir, "landlab", "_version.py")

# -- General configuration -----------------------------------------------------

extensions = [
    "myst_parser",
    "nbsphinx",
    "sphinx.ext.autodoc",
    "sphinx.ext.intersphinx",
    "sphinx.ext.viewcode",
    "sphinx.ext.todo",
    "sphinx.ext.mathjax",
    "sphinx.ext.napoleon",
    "sphinx.ext.autosummary",
    "sphinx_copybutton",
    "sphinx_design",
    "sphinx_inline_tabs",
    "sphinxcontrib.towncrier",
    "sphinx_jinja",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix of source filenames.
source_suffix = ".rst"

# The encoding of source files.
# source_encoding = 'utf-8-sig'

linkcheck_retries = 5

master_doc = "index"

project = "landlab"
copyright = str(date.today().year) + ", The Landlab Team"

v = get_version_from_file(version_file)
version = "master"
release = f"{v.major}.{v.minor}"

language = "en"

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build", "**/*.so", "**/*.pyd", "**/*.pyx", "**/*.c", "**/*.cpp"]

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = False

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = False

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"
pygments_dark_style = "monokai"

# A list of ignored prefixes for module index sorting.
modindex_common_prefix = ["landlab."]

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# The default highlight language
highlight_language = "none"

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# html_theme = "alabaster"
html_theme = "furo"
html_title = "landlab"
html_logo = "_static/landlab_logo.png"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "source_repository": "https://github.com/landlab/landlab/",
    "source_branch": "master",
    "source_directory": "docs/source",
    "sidebar_hide_name": True,
    "footer_icons": [
        {
            "name": "power",
            "url": "https://csdms.colorado.edu",
            "html": """
                <svg
                  stroke="currentColor"
                  fill="currentColor"
                  stroke-width="0"
                  version="1.1"
                  viewBox="0 0 16 16"
                  height="1em"
                  width="1em"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M6 0l-6 8h6l-4 8 14-10h-8l6-6z"
                  ></path>
                </svg>
                <b><i>Powered by CSDMS</i></b>
            """,
            "class": "",
        },
    ],
}

if "READTHEDOCS" in os.environ:
    html_theme_options["announcement"] = (
        "This documentation is hosted on Read the Docs only for testing. Please use"
        " <a href='https://landlab.csdms.io'>the main documentation</a>"
        " instead."
    )

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None
html_favicon = "_static/favicon.ico"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}


# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = "landlabdoc"


todo_include_todos = True
# latex_elements = dict(preamble='\\usepackage{amsmath}')

# -- Options for napoleon extension --------------------------------------------

napoleon_numpy_docstring = True
napoleon_google_docstring = False
napoleon_include_init_with_doc = True
napoleon_include_special_with_doc = True

# -- Options for towncrier_draft extension --------------------------------------------

# or: 'sphinx-release', 'sphinx-version'
towncrier_draft_autoversion_mode = "sphinx-release"
towncrier_draft_include_empty = True
towncrier_draft_working_directory = pathlib.Path(docs_dir).parent.parent

# -- Options for intersphinx extension ---------------------------------------

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    "python": ("https://docs.python.org/3", None),
    "numpy": ("https://numpy.org/doc/stable/", None),
    "scipy": ("https://docs.scipy.org/doc/scipy/", None),
    "xarray": ("https://docs.xarray.dev/en/stable/", None),
    "matplotlib": ("https://matplotlib.org/stable/", None),
}

with open("../index.toml", "rb") as fp:
    cats = tomllib.load(fp)
cats["grids"].pop("ModelGrid")

jinja_contexts = {"llcats": cats}

# -- Options for autodoc

# selects what content will be inserted into the main body of an autoclass
# directive: 'class'(default), 'both', or 'init'
autoclass_content = "both"
autodoc_typehints = "description"
autodoc_class_signature = "separated"

with open(os.path.join(src_dir, "../cython-files.txt")) as fp:
    cython_files = {fname.strip() for fname in fp.readlines()}

autodoc_mock_imports = [
    "richdem",
    "bmipy",
    "importlib-resources",
    "matplotlib",
    "netcdf4",
    "pandas",
    "pyshp",
    "pyyaml",
    "rich-click",
    "scipy",
    "statsmodels",
    "xarray",
    "shapefile",
    "mpl_toolkits",
    "rich_click",
    "pylab",
] + [path[4:-4].replace("/", ".") for path in cython_files]

autodoc_default_options = {
    "maxdepth": 2,
    "members": True,
    "undoc-members": True,
    "show-inheritance": True,
    "inherited-members": "int",
    "ignore-module-all": True,  # Ignore __all__ directives in modules
}

nbsphinx_execute = "never"
nbsphinx_thumbnails = (
    {}
    if os.getenv("GITHUB_ACTIONS")
    else {
        "teaching/**/*": "_static/favicon.ico",
        "teaching/*": "_static/favicon.ico",
        "tutorials/**/*": "_static/favicon.ico",
        "tutorials/*": "_static/favicon.ico",
    }
)

# This is processed by Jinja2 and inserted before each notebook
nbsphinx_prolog = """
{% set docname = 'docs/source/' + env.doc2path(env.docname, base=None) | string() %}

.. note::

    This page was generated from a jupyter notebook_.

.. _notebook: https://github.com/landlab/landlab/blob/{{ env.config.version|e }}/{{ docname|e }}
"""

nbsphinx_epilog = """
----

Generated by nbsphinx_ from a Jupyter_ notebook.

.. _nbsphinx: https://nbsphinx.readthedocs.io/
.. _Jupyter: https://jupyter.org/
"""

myst_enable_extensions = ["colon_fence", "deflist"]



================================================
File: docs/source/index.md
================================================
(landlab)=

# Landlab: A modular Earth Surface Dynamics modeling library

```{include} ../../README.md
:start-after: "<!-- start-intro -->"
:end-before: "<!-- end-intro -->"
```

## Projects that use Landlab

For a list of people that are using *Landlab*, please have a look at our
{ref}`Papers and Presentations <papers>` section.

## Citing Landlab

If you use any portion of Landlab, please cite our {ref}`Citing Landlab <citing>`
page.

## Tutorials

An overview of {ref}`tutorial content <tutorials>`.

Gallery of tutorial {ref}`notebooks <tutorials-gallery>`.

```{toctree}
:caption: Getting Started
:hidden: true
:maxdepth: 1

installation
Getting started <getting_started/index>
user_guide/index
Tutorials <tutorials/index>
Teaching with Landlab <teaching/index>
```

```{toctree}
:caption: Contributing
:hidden: true
:maxdepth: 1

install/index
development/index
API Reference <generated/api/landlab>
```

```{toctree}
:caption: About
:hidden: true
:maxdepth: 1

about/changes
about/contact_us
about/citing
about/funding
Contributors <about/authors>
License <about/license>
Used by <about/usedby>
```

```{toctree}
:caption: Project Links
:hidden: true
:maxdepth: 1

GitHub <https://github.com/landlab/landlab>
PyPI <https://pypi.org/project/landlab>
Conda-Forge <https://github.com/conda-forge/landlab-feedstock>
```



================================================
File: docs/source/installation.md
================================================
(basic-install)=

# Install

:::{important}
The following commands will install *landlab* into your current environment. Although
not necessary, we **highly recommend** you install landlab into its own
{ref}`virtual environment <virtual-environments>`.
:::

In order to use *landlab* you will first need Python. While not
necessary, we recommend using the
[Anaconda Python distribution](https://www.anaconda.com/download)
as it provides a large number of third-party packages useful for
scientific computing.

To install *Landlab*, simply run the following in your terminal of choice:

````{tab} mamba
```bash
mamba install landlab -c nodefaults -c conda-forge --override-channels
```
````

````{tab} conda
```bash
conda install landlab -c nodefaults -c conda-forge --override-channels
```
````

````{tab} pip
```bash
pip install landlab
```
````

If you would like the very latest development version of *landlab* or want to modify
or contribute code to the *landlab* project, you will need to do a
{ref}`developer installation <install>` of *landlab* from source.




================================================
File: docs/source/_templates/module.rst_t
================================================
{%- if show_headings %}
{{- basename | e | heading }}

{% endif -%}
.. automodule:: {{ qualname }}
{%- for option in automodule_options %}
   :{{ option }}:
{%- endfor %}



================================================
File: docs/source/_templates/package.rst_t
================================================
{%- macro automodule(modname, options) -%}
.. automodule:: {{ modname }}
{%- for option in options %}
   :{{ option }}:
{%- endfor %}
{%- endmacro %}

{%- macro toctree(docnames) -%}
.. toctree::
   :maxdepth: {{ maxdepth }}
{% for docname in docnames %}
   {{ docname.split('.')[-1] }} <{{ docname }}>
{%- endfor %}
{%- endmacro %}

{%- if is_namespace %}
{{- [pkgname, "namespace"] | join(" ") | e | heading }}
{% else %}
{{- pkgname | e | heading }}
{% endif %}

{%- if is_namespace %}
.. py:module:: {{ pkgname }}
{% endif %}

{%- if modulefirst and not is_namespace %}
{{ automodule(pkgname, automodule_options) }}
{% endif %}

{%- if subpackages %}
Subpackages
-----------

{{ toctree(subpackages) }}
{% endif %}

{%- if submodules %}
Submodules
----------
{% if separatemodules %}
{{ toctree(submodules) }}
{% else %}
{%- for submodule in submodules %}
{% if show_headings %}
{{- [submodule, "module"] | join(" ") | e | heading(2) }}
{% endif %}
{{ automodule(submodule, automodule_options) }}
{% endfor %}
{%- endif %}
{%- endif %}

{%- if not modulefirst and not is_namespace %}
Module contents
---------------

{{ automodule(pkgname, automodule_options) }}
{% endif %}



================================================
File: docs/source/_templates/sidebaroutro.html
================================================
<a href="https://csdms.colorado.edu">
  <img src="_static/powered-by-logo-header.png" alt="Powered by CSDMS"/>
</a>



================================================
File: docs/source/about/authors.md
================================================
```{include} ../../../AUTHORS.md
```



================================================
File: docs/source/about/changes.md
================================================
```{include} ../../../CHANGES.md
```



================================================
File: docs/source/about/citing.md
================================================
(citing)=

# Citing Landlab

If you use any portion of *Landlab*, please cite the following papers:

::::{tab-set}
:::{tab-item} APA

Hobley, D. E. J., Adams,
J. M., Nudurupati, S. S., Hutton, E. W. H., Gasparini, N. M., Istanbulluoglu,
E. and Tucker, G. E., 2017, Creative computing with Landlab: an open-source
toolkit for building, coupling, and exploring two-dimensional numerical models
of Earth-surface dynamics, Earth Surface Dynamics, 5(1), p 21-46,
[doi:10.5194/esurf-5-21-2017](https://www.earth-surf-dynam.net/5/21/2017/).

Barnhart, K. R.,
Hutton, E. W. H., Tucker, G. E., Gasparini, N. M., Istanbulluoglu, E.,
Hobley, D. E. J., Lyons, N. J., Mouchene, M., Nudurupati, S. S., Adams, J. M.,
and Bandaragoda, C., 2020, Short communication: Landlab v2.0: A software package for
Earth surface dynamics, Earth Surf. Dynam., 8(2), p 379-397,
[doi:10.5194/esurf-8-379-2020](https://doi.org/10.5194/esurf-8-379-2020).

Hutton, E., Barnhart, K., Hobley, D., Tucker, G., Nudurupati, S., Adams,
J., Gasparini, N., Shobe, C., Strauch, R., Knuth, J., Mouchene, M., Lyons,
N., Litwin, D., Glade, R., Giuseppecipolla95, Manaster, A., Abby, L., Thyng, K.,
& Rengers, F. (2020). landlab [Computer software],
[doi:10.5281/zenodo.595872](https://doi.org/10.5281/zenodo.595872).
:::

:::{tab-item} BibTeX
```bibtex
@article{hobley2017creative,
  title={
    Creative computing with Landlab: an open-source toolkit for building,
    coupling, and exploring two-dimensional numerical models of
    Earth-surface dynamics
  },
  author={
    Hobley, Daniel EJ and Adams, Jordan M and Nudurupati, Sai Siddhartha and
    Hutton, Eric WH and Gasparini, Nicole M and Istanbulluoglu, Erkan and
    Tucker, Gregory E
  },
  journal={Earth Surface Dynamics},
  volume={5},
  number={1},
  pages={21--46},
  year={2017},
  publisher={Copernicus GmbH},
  url={https://esurf.copernicus.org/articles/5/21/2017/},
  doi={10.5194/esurf-5-21-2017}
}

@article{barnhart2020landlab,
  title={Landlab v2. 0: a software package for Earth surface dynamics},
  author={
    Barnhart, Katherine R and Hutton, Eric WH and Tucker, Gregory E and
    Gasparini, Nicole M and Istanbulluoglu, Erkan and Hobley, Daniel EJ and
    Lyons, Nathan J and Mouchene, Margaux and Nudurupati, Sai Siddhartha and
    Adams, Jordan M and others
  },
  journal={Earth Surface Dynamics},
  volume={8},
  number={2},
  pages={379--397},
  year={2020},
  publisher={Copernicus GmbH},
  url={https://esurf.copernicus.org/articles/8/379/2020/},
  doi={10.5194/esurf-8-379-2020}
}

@software{Hutton_landlab_2020,
  author={
    Hutton, Eric and Barnhart, Katy and Hobley, Dan and Tucker, Greg
    and Nudurupati, Sai and Adams, Jordan and Gasparini, Nicole
    and Shobe, Charlie and Strauch, Ronda and Knuth, Jenny
    and Mouchene, Margaux and Lyons, Nathan and Litwin, David
    and Glade, Rachel and {Giuseppecipolla95} and Manaster, Amanda
    and Abby, Langston and Thyng, Kristen and Rengers, Francis
  },
  doi={10.5281/zenodo.595872},
  license={MIT},
  month={4},
  title={{landlab}},
  url={https://github.com/landlab/landlab},
  year={2020}
}
:::
::::

## Citing Landlab Components

If you are working with Landlab components and utilities, many of them have
their own publication. Please cite it to acknowledge the component authors.

Citation information for each component can be found as follows:

- Where relevant, software citation and general references, are listed in the
  Component API documentation under the References section.
- Software citations are included in component metadata. We have created a
  tool called the "Citation Registry" that creates a .bib file for software
  citations used in an application. See example usage below.

### Landlab Citation Registry

```{eval-rst}
.. automodule:: landlab._registry
    :members:
    :undoc-members:
    :show-inheritance:
```



================================================
File: docs/source/about/contact_us.md
================================================
(contact)=

# Contact

```{include} ../../../README.md
:start-after: "<!-- start-contact -->"
:end-before: "<!-- end-contact -->"
```



================================================
File: docs/source/about/funding.md
================================================
```{include} ../../../FUNDING.md
```



================================================
File: docs/source/about/license.md
================================================
```{include} ../../../LICENSE.md
```



================================================
File: docs/source/about/usedby.md
================================================
(papers)=

:::{note}
If you are using *Landlab* but don't see a reference to your work
in our list, please let us know either through an issue or as a
pull request (with your reference added to our `USEDBY.md` file).
:::

```{include} ../../../USEDBY.md
```



================================================
File: docs/source/development/index.md
================================================
(development)=

# Developer Guide

If you're intending to make changes to the Landlab code base, or want to
develop your own components, this set of pages will provide information you
need.

## Key Development Recommendations

The most important things to remember are to:

- Start by creating a fork of Landlab's repository;
- Make changes to the source code on a development branch, not the default
  `master` branch; and
- Keep your fork's `master` and development branches up to date with changes
  in the main Landlab repository.

## Supported Python Versions

*Landlab* supports the [current Python version](https://devguide.python.org/versions/)
plus the two previous versions.

If you need to introduce a new dependency, that dependency must be compatible
with the oldest supported Python version and be available on Linux, Mac, and Windows.

```{toctree}
:hidden: true
:maxdepth: 2

contribution/index
practices/index
package_organization
```

## Quick Links For Package Maintenance

There are a few pages that are particularly important for the maintenance of
the package. These are:

- {ref}`directory organization <organization>`
- {ref}`dependency organization <dependencies>`, and
- {ref}`release workflow <dev-releases>`

If package maintainers change any of these, the prior pages likely need
updating.



================================================
File: docs/source/development/package_organization.md
================================================
(organization)=

# Package Organization

Below is a tree view description of the key files and directories of the
Landlab package. Note that not all files are shown and that top level files
have been reorganized out of alphabetical order for clarity. Directories are
shown down to two levels.

```
landlab
|
| ## Top Level Files ##
|
| # Package Description
|
├── README.rst
├── CHANGELOG.md
├── CONTRIBUTING.md
├── LICENSE.txt
├── MANIFEST.in
|
| # Dependency Requirements
|
├── requirements.txt
├── requirements-dev.txt
├── requirements-notebooks.txt
├── requirements-testing.txt
|
| # Compilation
|
├── setup.cfg
├── setup.py
├── Makefile
|
| # Environment Specifications
|
├── environment-dev.yml # Developer conda environment
├── environment.yml # User/Notebook conda environment
├── readthedocs.yml # Documentation buidling conda environment
|
| # Continuous Integration
|
├── appveyor.yml # Specification for Appveyor Continuous Integration
├── conftest.py
|
|
| ## Directories ##
|
├── docs # The documentation
│   ├── scipy-sphinx-theme
│   └── source
|
├── joss # Files associated with JOSS publications
|
├── landlab # The core Landlab package
│   ├── bmi
│   ├── ca
│   ├── cmd
│   ├── components
│   ├── core
│   ├── data_record
│   ├── field
│   ├── framework
│   ├── graph
│   ├── grid
│   ├── io
│   ├── layers
│   ├── plot
│   ├── testing
│   ├── utils
│   └── values
|
├── notebooks # Jupyter notebooks
│   ├── teaching
│   └── tutorials
|
├── scripts
|
└── tests # The unit tests, structured to mirror landlab/landab
|   ├── ca
|   ├── components
|   ├── core
|   ├── data_record
|   ├── field
|   ├── graph
|   ├── grid
|   ├── io
|   ├── layers
|   ├── plot
|   ├── utils
|   └── values
├── END
```



================================================
File: docs/source/development/contribution/desired_contributions.md
================================================
(desired-contributions)=

# Desired Contributions to Landlab

When fully active, this page will list desired contributions to Landlab. It
will also include a link to issues the "good_first_issue" tag



================================================
File: docs/source/development/contribution/develop_a_component.md
================================================
(landlab-component-dev-page)=

# Develop your own component or utility

Landlab grows and improves thanks to user contributions. We encourage you to
develop your own component or utility!

Thank you to all who have contributed to landlab!

In addition to components, Landlab has many utilities useful in creating
components and doing model output post-processing. While this document
primarily discusses creating, documenting, and testing a components, most of
the steps are the same for developing a utility. Unlike a component, a utility
can just be a function. But like a component, we expect contributed utilities
to follow the landlab standard practices outlined in our documentation.

Once you have installed Landlab ({ref}`developer install <install>`)
and {ref}`created your own branch <landlab-develop-with-git>`, you can start
writing a Python script for your component.

See [this tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/making_components/making_components.ipynb)
for instructions on the structure and content of your component code. See also
[this example pull request](https://github.com/landlab/landlab/pull/678), which
shows you the common set of files (such as `__init__.py` and documentation
files) that get added or modified when a component is added to Landlab.

See the {ref}`Standard Naming conventions <component-standard-names>` for good practice
on parameters and variables naming.

The following pages describe the software development practices that Landlab
strives to follow. Our goal is to make the capabilities of Landlab
well-documented to support new users while not enforcing substantial burdens on
community contributors. If you have any questions about the process after you
have finished reading the documentation, consider making an
[Issue](https://github.com/landlab/landlab/issues/) to ask the
development team for help.

We recommend that you review the Landlab [development practices](/development/practices/index).

## Files structure

For your new component, you should create a folder in
`landlab/landlab/components` called `<my_component_name>` that contains:

- Your Python script `my_component_name.py`

- `_init_.py` which is structured as

  ```python
  from .my_component_name import MyComponent

  __all__ = [
      "MyComponent",
  ]
  ```

  Where

  > - `'.my_component_name'` is the name of the python script.
  > - `'MyComponent'` is as defined in the \_name header of your python script

  See [this tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/making_components/making_components.ipynb)
  on making a component for additional document requirements.

  In addition there are a number of recommendations and requirements for
  Landlab components {ref}`summarized here <dev-component-rules>`.

- a folder in the `landlab/tests/components/<my_component_name>` directory containing
  unit tests. The unit tests are run every time changes are pushed to the
  Landlab repository. They should go through every line of your code (e.g.
  test every possible scenario in if/else loops, exceptions, etc.). See
  [the tutorial on making a component](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/making_components/making_components.ipynb)
  for instructions about making docstring tests and the next section for more
  information about making the unit tests.

- a document in `docs/source/reference/components` called `my_component_name.rst`.
  Look at other documents in that folder to get a sense of the typical format.
  This document is what will put your component's documentation on the
  ReadTheDocs page. See more below.

Once everything is working, you can {ref}`create a pull request <landlab-develop-with-git>`
to have your branch merged into the master so that your component can be
included in the Landlab library and used by others.

This will trigger {ref}`continuous integration testing <dev-ci>` of your branch
(doc tests, unit tests, and lint) to ensure its compatibility on all supported
environments. You can find the results of these tests on the GitHub page of
your pull request. If the tests fail, edit your files and commit your changes
to re-run the tests (you don't need to make another pull request).

## Getting your component into the documentation

Landlab uses the third party Sphinx code documentation tool to automatically
build the {ref}`Reference section <api>` that list our user-facing components.
This means your new component won't appear on the webpages unless you also make
some changes to files you'll find in `landlab/docs/source`.

You need to modify `landlab/docs/source/reference/components/index.rst`, and
also create a new file in the folder
`landlab/docs/source/reference/components`, called
`[short_name_for_your_component].rst`.

The best advice for both of these is to follow an existing example.

For the new `.rst` file, use e.g. `diffusion.rst` as a template. The first line
with the path specification needs to be changed to give the same name as the
`.py` file in which your component lives; the rest of the code text stays the
same.

For the update to `index.rst`, just copy what has been done for the others,
where the path specification now points at the new `.rst` file you made, i.e.,
`[short_name_for_your_component]` (leaving off the `.rst`).

Note your component won't appear on the user-facing part of the website until
it's included in a Landlab release.

## Your component is accepted to Landlab. What's next?

Congrats on all your hard work! Once you know your component has been accepted
and is included in a Landlab release, please
[add it to the CSDMS Model Repository](https://csdms.colorado.edu/wiki/Contribute_model).
You can link directly to the source code on Github. Just fill out the questionnaire.

Have you written up some tutorials or Jupyter notebooks to help teach new users
about your component? Consider submitting a tutorial along with your component.

If you've presented a poster or submitted a paper about your Landlab component,
advertise your work on the {ref}`Landlab Papers and Presentations <papers>`
page. Make your request to a member of the Landlab development team via a
GitHub Issue. If you'd like, also attach an abstract or poster PDF.

## I'm still confused

The Landlab development team will be happy to hear from you.
[Create an issue](https://github.com/landlab/landlab/issues) and we'll try to
resolve your problem.



================================================
File: docs/source/development/contribution/index.md
================================================
(dev-contributing)=

# Guidelines for Contributing Code to Landlab

Please review the {ref}`development practices <development-practices>`.

```{toctree}
:maxdepth: 2

develop_a_component
recommendations
ongoing_development
desired_contributions
```

Contributions that change high level Landlab organization should update
{ref}`this page <organization>` in the documentation.

## Publication of Landlab Contributions

A number of researchers have used the Journal of Open Source Software (JOSS)
and Geoscientific Model Development as a journal outlet to publish their
contribution to Landlab. There are a few aspects of the submission workflow for
JOSS that are non-standard and are described below.

```{toctree}
:maxdepth: 2

joss_workflow
```

In addition, the JOSS editorial board and the Landlab core development team are
presently (Jan 2019) working on defining some guidelines regarding what
contributions to Landlab fit the scope of a JOSS submission. These will be
summarized here when finalized. If you have any questions regarding whether
your potential JOSS submission is appropriate, the best thing to do is to
make a pre-submission inquiry with JOSS.

## News Entries

The `CHANGES.rst` file is managed using [towncrier] and all non trivial changes
must be accompanied by a news entry.

To add an entry to the news file, first you need to have created an issue
describing the change you want to make. A Pull Request itself *may* function as
such, but it is preferred to have a dedicated issue (for example, in case the
PR ends up rejected due to code quality reasons).

Once you have an issue or pull request, you take the number and you create a
file inside of the `news/` directory, named after that issue number with a
"type" of `component`, `notebook`, `feature`, `bugfix`, `docs`, or `misc`
associated with it.

If your issue or PR number is `1234` and this change is fixing a bug,
then you would create a file `news/1234.bugfix.rst`. PRs can span multiple
categories by creating multiple files (for instance, if you added a new component
and an associated notebook that demonstrates how to use it, you would create
`news/NNNN.component.rst` and `news/NNNN.notebook.rst`).

If a PR touches multiple issues/PRs, you may create a file for each of them
with the exact same contents and Towncrier will deduplicate them.

[towncrier]: https://pypi.org/project/towncrier/



================================================
File: docs/source/development/contribution/joss_workflow.md
================================================
(joss-workflow)=

# Workflow to submit your Landlab contribution to Journal of Open Source Software

The [Journal of Open Source Software (JOSS)](https://joss.theoj.org) is a
venue for publications on open source software. If you are considering
preparing a contribution to Landlab for a JOSS publication, please make sure to
review the JOSS [submission requirements](https://joss.readthedocs.io/en/latest/submitting.html#submission-requirements)

Parts of Landlab have already been published by JOSS, and multiple parts of
Landlab may be under consideration at JOSS at the same time. Under these
circumstances there may be conflicts with the required `paper.md` file.

For this reason, the workflow below has been developed for those who choose to
submit their Landlab contribution (e.g., a Landlab component, utility) to this
journal.

- Create a pull request to merge the contribution into Landlab. See
  {ref}`Develop your own component or utility <landlab-component-dev-page>`.

- Following the above merge, create a new branch for the JOSS review process.
  Name the paper `paper.md`, which follows JOSS requirements, and place this
  file in a new folder, `/landlab/joss/<name_of_contribution>/` with your other
  JOSS submission materials (e.g., bib, figures if any).

- Submit to JOSS. The submitting author must comment on the pre-review issue
  that the paper is on a branch, and they should build the branch with this
  command

  ```bash
  $ @whedon prepare pdf from branch my-custom-branch-name
  ```

- Once the JOSS review is complete and if the paper is accepted:

- Create a pull request to merge the JOSS review branch into the `master`
  branch.

- Merge `master` into `release`, and update version number. See
  {ref}`Create a Landlab release <dev-releases>`.

- Ensure that the release is correctly created and distributed.

- Update the JOSS review pull request with the correct archive DOI and
  version number.

- JOSS publishes the paper.

- Once publication is complete, make another pull request to move and rename
  the `paper.md` to `landlab/joss/published/<name_of_module_or_component>/<new_paper_name>.md`.
  The paper can no longer be named `paper.md` because JOSS expects paper in
  review to have this name, and to avoid conflicts with other Landlab paper
  contributions in review. Note that the paper folder should be moved to
  within the `published` directory.



================================================
File: docs/source/development/contribution/ongoing_development.md
================================================
(ongoing-development)=

# Ongoing Development in Landlab

When fully active, this page will list known ongoing development in Landlab.



================================================
File: docs/source/development/contribution/recommendations.md
================================================
(dev-component-rules)=

# Recommendations and Rules for User-Contributed Components

First, thank you for considering contributing a component! The following are
some rules and recommendations.

## Rules

- `super` is called in the `__init__` method
- All public attributes are properties
- A component uses all required inputs fields and creates all required output fields.
- Components have complete metadata in `_info`.
- The component's `__init__` method takes a Landlab model grid as the first argument.
- The component has a main method that takes either `dt` or nothing. The name is descriptive but does not need to be standardized.
  : - Solution is that using setters and getters or making a grid scalar.
    - Some common name patterns include `update()`, `run_one_step()`, or `calculate_name_of_thing()`.
- A component raises a `ValueError` if unused keyword arguments are provided.
- A component raises a `ValueError` if a grid type the component does not support is passed.
- Component fields use consistent definition and dimensions (not necessarily units).

## Recommendations

- A component has a `run_one_step` method as its main method.
- Arguments and keyword arguments start with lower case letters.
- Keyword arguments have reasonable default values (and the grid is the only argument to `__init__`.
- Can return or not return information. Some recommendations, Nothing, grid, or a ... or a calculated value.
- If possible, we recommend that components are unit agnostic.



================================================
File: docs/source/development/practices/continuous_integration.md
================================================
(dev-ci)=

# Continuous Integration Practices

Before merging any changes into the Landlab trunk, *all* unit tests (including
doctests) should be passing. In addition, any new features added to Landlab
should have an associated set of unit tests to verify that the new features
are working properly.

Landlab uses [Travis](https://travis-ci.org) for continuous integration
testing on OSX and Linux. The [landlab page on Travis](https://travis-ci.org/landlab/landlab)
shows the latest testing results. A new set of tests are executed whenever
any changes are pushed to the Landlab repository and with every pull request.
We currently run test suites for Python versions 3.6 and 3.7 (soon to include 3.8).

Continuous integration for Windows is done on
[Appveyor](https://ci.appveyor.com) and also tests for the same
Python versions as OSX and Linux.

Once you send a pull request from GitHub, you will be taken to the Landlab
pull request page and all unit tests are run. You will see the status
of the unit tests next to your latest commit description. If you see a green
check, all tests passed and your changes can be merged! However, if you see
an ex there was a problem running the tests. If you believe your changes are
responsible for the failures, please fix them until the tests pass. Note that
you do not need to send a new pull request after committing for fixes. They
will be added to the current pull request and the tests automatically rerun.

You can also run unit tests locally in the top `landlab` directory and typing

```bash
$ pytest
```

Note that this will test whatever version of landlab you have installed,
which may or may not be the one you are working on in your current working
directory. These test will not work with numpy 1.14.

TODO: Add information about coverage here.



================================================
File: docs/source/development/practices/dependencies.md
================================================
(dependencies)=

# How Landlab Specifies Dependencies

The Landlab package dependencies are found in the top-level directory file
`requirements.txt`.

The `setup.py` file looks to this file and reads it when compiling the
package. In this way, we only state the dependencies in one location.

In addition to the core set of dependencies, development with Landlab, and
common use of Landlab (e.g., running the notebooks) may have additional
dependencies. These dependencies are described in the following files:

- `requirements-notebooks.txt` indicates dependencies for running the notebooks.
- `requirements-testing.txt` indicates dependencies for running tests.
- `requirements-dev.txt` indicates dependencies for development (less building the documentation).

We provide two convenience environment files that address the two most common
use cases.

- `environment.yml` specifies an environment which installs a Landlab binary
  and all of the notebook dependencies.
- `environment-dev.yml` specifies an environment with all development
  dependencies.

If a developer wants to build the documentation locally there are some
additional dependencies. We do not include these in `requirements-dev.txt`
because it is uncommon for developers to need to build the docs locally.

An environment specifying documentation-building requirements can be found at
`landlab/docs/environment.yml`.



================================================
File: docs/source/development/practices/dev_guide_releases.md
================================================
(dev-releases)=

# How to create a Landlab release

## The Release Checklist

1. Go to GitHub and use it to create a pull request that brings the
   changes associated with `landlab/landlab/master` into
   `landlab/landlab/release`.

2. Assuming the continuous integration from step 1 passes, merge the pull
   request into `landlab/landlab/release`.

3. Next, decide what new version number is appropriate
   based on [Semantic Versioning](https://semver.org/).

   This can either be done locally or on the GitHub website. Here are
   instructions to do this locally:

   In the `landlab/landlab` repository, checkout the `release` branch and tag it.

   ```bash
   $ git tag vX.X.X
   ```

   Then, push your tag on `landlab/landlab/release` to the remote.

   ```bash
   $ git push --tags
   ```

4. This will trigger both standard Landlab CI and a deploy stage that uploads
   wheels to PyPI. A new PR will be autogenerated in the landlab-feedstock on
   conda-forge.

   - Assuming its tests pass, merge the PR autogenerated in the landlab-feedstock.
   - Verify the builds on PyPI and on conda-forge.

5. Now tag the current version of `master` with a "-dev" and push the tag.

   ```bash
   $ git tag vX.X.X-dev
   $ git push --tags
   ```

## Notes

1. Although you can create such a tag on any branch, releases should **only**
   come from the `release` branch. Make sure that when you create a tag
   you are doing so on `release` (and all your changes are committed).
2. Landlab follows [Semantic Versioning](https://semver.org/)
   rules for version assignment and formatting. Please stick to them.

## Helpful links

1. [Using conda](https://docs.conda.io/en/latest/): What
   `conda` is and how to use it.
2. [git tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging): What git
   tags are and how to create them.
3. [The git tag command](https://git-scm.com/docs/git-tag): A description
   of all of the options for the `git tag` command (including `git tag
   --delete`).
4. [landlab on Travis](https://travis-ci.org/landlab/landlab): The latest
   Travis builds of landlab.
5. [landlab on Anaconda](https://anaconda.org/landlab/landlab): The
   conda packages for landlab releases.
6. [Semantic Versioning](https://semver.org/): Rules for assigning and
   formatting versions.



================================================
File: docs/source/development/practices/develop_with_git.md
================================================
(landlab-develop-with-git)=

# Develop with Git

*This information is intended to help users who have downloaded the
Landlab source code from Github, and intend to develop new components for
Landlab, or otherwise make changes to the code base. Here we illustrate
a few additional code management techniques using git and Github, which
we hope will help you develop for Landlab in a more efficient, faster,
more organised way.*

If you've installed Landlab from the source code, you've already
interacted with the git code management and version control systems, and
with Github, which is built onto the basic git framework. However, this
same framework offers you powerful ways to organise and track the change
you make to the code after install, and to plug any changes you make
back into the main code base for Landlab.

Your **fork** of Landlab is your starting point for all modifications to
the code. However, you can create *branches* from your master fork in
which you will actually modify code. The great advantage of this system
is that you can have several different branches running in parallel,
each aiming to complete a particular objective. The master version of
the code is not changed until you *merge* your completed branch back
into the master. If you decide that changes you're making are actually
unhelpful or redundant, you can easily roll them back - either by
individually reverting each committed change, or by deleting the whole
branch.

[This](http://rogerdudler.github.io/git-guide/) is a nice, simple
guide to the git command line tools. All this functionality is also
available through the Github app.

*Note: Github provides a nice GUI interface for using git called "Github
Desktop". This provides all the functionality described below in a form
that avoids the command line, if that sounds like something you'd
prefer.*

## Branching with git

### Making a new branch

Before making any changes to your code, you should create a new branch.

Update your mirror with any upstream changes you don't have:

```bash
$ git fetch upstream
```

If using git at the command line, make the new branch like this:

```bash
$ git branch name-of-branch upstream/master
$ git checkout name-of-branch
```

From the Github app, you can do the same thing with the "branching"
button in the top line. A nice feature of the app is it shows you
graphically how your active branch currently differs from the master
branch - when you branched it, and when changes were committed to both
branches.

You will probably want to choose a descriptive name for your new branch
so that you and others will remember what it is you are intending to do
with your branch (for example, bugfix-for-that-major-problem, or
add-that-cool-feature).

You can create branches from branches!

If changes appear in the master and you want to also have them in your
active branch, you can update your active branch from the master with

```bash
$ git pull
```

or with the "Update from master" button in the app.

### Pushing changes from your local machine to your fork on Github

If you want to keep a copy of the files you have modified or created on
your branches on your public GitHub page for Landlab (you probably do as
this will serve as a file backup) you need to tell git to push changes
to your github repo. This is done with the following command:

```bash
$ git push --set-upstream origin name-of-branch
```

In the app, the same functionality is achieved by first "publishing"
your branch (creating it on your page within the github.com central
repository), then using the "sync" button to send the files to the
central github.com servers.

On your Landlab GitHub page you will now be able to toggle between your
various branches to see the code you have committed. The app also lets
you see the structure of your branches on your local machine.

### Committing changes and merging branches back in

Changes you make to your code are "saved" in git when you commit them to
your branch. Save your files, then at the command line

```bash
$ git commit -m "Text describing the changes"
```

Again, the app provides the same functionality, but with the added bonus
that it shows you what the changes you've made since your last commit
actually are. Click on the "X Uncommitted Changes" button at the top
centre, and see which files have changed and what's happened. Pick the
files for which you want to store the changes as part of this commit,
type text describing the change in the boxes, then hit "Commit to
my-branch-name". If you go to History, you can see a record of all past
changes in the branch. You can then use git to travel "back in time" and
review what the code was like at any time in the past!

Note that files that you do not explicitly ask git to track (either by
clicking the checkbox next to the file in the GUI or by using
`git add`) are not tracked — and thus not sent to the github.com
central servers when you push changes.

Once you're happy with your branch, and the code is fully functional
again, it's time to merge it back into the master. This procedure
generally works best if you first pull any changes from the main Landlab
master branch (not just the master branch on your fork) into your active
branch, and resolve any conflicts there (so you don't mess up the
master).
Once you've done that pull, in git at the command line, make the master
your active branch again then *merge* the branch:

```bash
$ git checkout master
$ git merge my-branch-name
```

In the app, create the merge by making a "pull request" using the button
in the top right. The process is fairly self explanatory, and provides a
preview of whether there will be any conflicts. Once you've created the
merge, click through the hyperlink and merge it into the master on the
website using the prominent green button. On your local machine, sync
your master branch to pick up the changes locally.

## Pulling changes from your fork to the Landlab master fork

Once you've completed whatever modifications you were working on with
Landlab, we'd like to incorporate your changes back into the main code
of Landlab so everyone can benefit from your enhancements. This is done
by creating a *pull request* from your fork into the Landlab master
fork. This is basically the inverse process you use to update your fork
from the master fork
(but in this case, one of us will review your changes before it gets
merged in).

Perform this procedure through the Github website. Go to the github page
for your fork, and click the green "New pull request" button at the top.
The next page shows you which branch on which fork (the "head") will be
merged into which other branch and fork (the "base"). These details
should all be correct as shown. There may well be conflicts reported on
this page. If there are, consider
updating your fork from the master fork
before finalising the request. Once you're ready to go, click the next
"Create pull request" green button. You'll be redirected to a discussion
page for your request, and it will be visible to all of the admins for
the main Landlab fork - one of whom will review your changes and
actually make the merge (*please don't do this yourself!*).

If you're confused by this process, just create the request, and one of
us will see it and come to help you. You can create comments on your
request from the website at any time after you've made it.

## Troubleshooting

### What do I do if my pull request cannot be automatically merged?

Get the latest upstream/master and go to the `master` branch. Remember,
*do not develop here*.  Always develop in a feature branch. Merge the lastest
upstream master with your master

```bash
$ git fetch upstream
$ git checkout master
$ git merge upstream/master
```

Go to the branch on which you are developing and merge the lastest upstream
master with your branch

```bash
$ git checkout <branch_name>
$ git merge upstream/master
```

Fix the conflicts. Do this by hand or with a merge editor. This is where you
decide how to integrate the conflicting changes. Since only you know what and
why you made the changes you did, this can only be done by you

```bash
$ git mergetool
```

After everything has been fixed, commit the changes and push the changes to
the repository.  The pull request will automatically be updated

```bash
$ git commit
$ git push
```



================================================
File: docs/source/development/practices/index.md
================================================
(development-practices)=

# Software Development Practices

```{toctree}
:maxdepth: 2

develop_with_git
continuous_integration
style_conventions
writing_tests
dev_guide_releases
dependencies
```



================================================
File: docs/source/development/practices/style_conventions.md
================================================
(style-enforcement)=

# Style Guidelines and Enforcement

## General Coding Style

- Please stick to the coding style described by
  [PEP8](https://www.python.org/dev/peps/pep-0008/). PEP8 is one of
  the standard worldwide stylistic conventions for coding in Python.
- Class and function docstrings should follow the [numpydoc
  conventions](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard).
- Further, Landlab-specific advice for developing your own components
  can be found in the {ref}`component development guide <dev-contributing>`.

Many modern text editors, e.g., [Atom](https://atom.io), provide interactive tools to
examine your code as you edit it and highlight where it diverges from
standards.

## Style enforcement

All tools used for development are specified in our `environment-dev.yml` file.
If you followed the
{ref}`developer installation instructions <install>` you have
everything you need in the `landlab_dev` conda environment.

Currently we check for all the [flake8
violations](https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes)
and [pycodestyle
violations](http://flake8.pycqa.org/en/latest/user/error-codes.html)
except for (as defined in our `setup.cfg`)

- E203: whitespace before
- E501: line too long (n > 88 characters)
- W503: line break before binary operator

To format files to meet these standards, we recommend using
[isort](https://pypi.org/project/isort/) +
[black](https://github.com/psf/black).

You can run

```bash
$ make pretty
```

from the main landlab directory in a terminal to run both
[isort](https://pypi.org/project/isort/) and
[black](https://github.com/psf/black) on your code.

To check if your files meet the standards that are enforced under
continuous integration, we use
[flake8](http://flake8.pycqa.org/en/latest/). You can run

```bash
make lint
```

from the top level directory or

```bash
flake8 <file-to-check>
```



================================================
File: docs/source/development/practices/writing_tests.md
================================================
(writing-tests)=

# Writing docstring and unit tests for your component (or utility)

All contributed code should be well tested. This should be done through both
doctests and standard unit tests using [pytest](https://docs.pytest.org/en/latest/).

All public functions, classes, methods, etc. must have a docstring that follows
the [numpydoc](https://numpydoc.readthedocs.io/en/latest/format.html)
conventions. Docstring tests should be short, easy-to-read tests that are
instructive to a user. These tests are included as examples in the Landlab
{ref}`Reference Manual <landlab>`.

Every `.py` file must contain a module-level docstring at the top of the file
that describes what the purpose of the file is.

Unit tests should be more extensive than doctests and give your new code
thorough testing. Ideally your tests will cover what happens within every
`if`, `elif`, or `else`, and every `try` or `except` block. These
test will also verify that if a bad parameter value is passed, that the correct
type of error is raised.

Additionally, unless there is a specific reason your component or utility can
only work with one Landlab grid type, the tests should verify that it can work
with multiple model grid types (verifying that the model works with both \`
`` HexModelGrid` `` and `RasterModelGrid` is a good place to start).

Your unit tests should verify that the component or utility you are creating
does exactly what it is expected to do. This means you will probably want to
create a very small (e.g. 5x5) model grid and hand calculate what the correct
answer is. Then use *assertions* to ensure that your code reproduces that
answer exactly. It is very important to not just test that the code reproduces
the first answer you get. Instead you should construct the test so that you
**know** what the right answer is.

The [numpy testing](https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.testing.html)
functions are useful for making comparison between actual and expected results
(e.g. to assert that one array is equal to another array). The
[pytest testing tools](https://docs.pytest.org/en/latest/assert.html) are
useful for things like asserting that providing a particular set of values to
a function or component will raise a specific type of error.

Unit tests must be discoverable by [pytest](https://docs.pytest.org/en/latest/).
This means that the unit tests should be in folders within the `test`
directory, in `.py` files that start with the name `test`
and within functions with names that begin with the word `test`.

Thus, a file to provide the unit tests for your component would be called
`test_my_component_name.py` file, located in the directory
`tests\components\my_component_name\`. The inside of it might look like:

```python
# test_my_component_name.py
# numpy.testing and pytest are two modules commonly used
# for testing whether your code behaves as expected.
# import what you need from landlab


def test_something_about_my_component():
    """Make a one-line docstring that describes your unit test."""
    # do things to set up for your test like make a model grid.

    # make your test and assert that you get the right answer
```



================================================
File: docs/source/generated/.gitignore
================================================
*



================================================
File: docs/source/getting_started/index.md
================================================
(getting_started)=

# Getting Started

If you have access to [EarthscapeHub][earthscape-hub] through class or CSDMS membership,
you can run this tutorial on the [lab][lab-hub] and [jupyter][jupyter-hub]
instances (login required for each) using the *CSDMS* kernel.

(10min)=

## 10 minutes to Landlab

For a quick introduction to Landlab, please see the [fault scarp
tutorial][tutorial-fault-scarp] showing its major features in the
context of a 2D model for fault-scarp degradation.

(teach_yourself)=

## Self-study course for learning to use Landlab in your research

This course is entirely hosted in our Jupyter notebook tutorials. Here is a
link to the [syllabus][tutorial-start].

[earthscape-hub]: https://csdms.colorado.edu/wiki/JupyterHub
[jupyter-hub]: https://jupyter.openearthscape.org/
[lab-hub]: https://lab.openearthscape.org/
[tutorial-fault-scarp]: /tutorials/fault_scarp/landlab-fault-scarp.ipynb
[tutorial-start]: /tutorials/index



================================================
File: docs/source/install/developer_install.md
================================================
(install)=

# Developer Install

:::{important}
The following commands will install *landlab* into your current environment. Although
not necessary, we **highly recommend** you install landlab into its own
{ref}`virtual environment <virtual-environments>`.
:::

If you will be modifying code or contributing new code to *landlab*, you will first
need to get *landlab*'s source code and then install *landlab* from that code.

## Source Install

*Landlab* is actively being developed on GitHub, where the code is freely available.
If you would like to modify or contribute code, you can either clone our
repository

````{tab} ssh
```bash
git clone git@github.com:landlab/landlab.git
```
````

````{tab} https
```bash
git clone https://github.com/landlab/landlab.git
```
````

or download a [zip file](https://github.com/landlab/landlab/archive/refs/heads/master.zip):

```bash
curl -OL https://github.com/landlab/landlab/archive/refs/heads/master.zip
```

Once you have a copy of the source code, you can install it into your current
Python environment by first installing *Landlab* dependencies and then building
and installing *Landlab*.

### Install dependencies

*Landlab*'s dependencies are listed in *requirements.in*.

````{tab} mamba
```bash
cd landlab
mamba install --file=requirements.in -c nodefaults -c conda-forge --override-channels
```
````

````{tab} conda
```bash
cd landlab
conda install --file=requirements.in -c nodefaults -c conda-forge --override-channels
```
````

````{tab} pip
```bash
cd landlab
pip install -r requirements.in
```
````

### Build and install *Landlab*

*Landlab*'s build process includes compiling Python extensions, which requires
you to have a C++ compiler installed. *Linux* will usually already have one,
on *Mac* you can use *XCode*, and on *Windows* you will need to install *MSVC*.
For help on installing *MSVC*, you may want to refer to the *conda-forge* page
on [compiling code on Windows](https://conda-forge.org/docs/maintainer/knowledge_base/#particularities-on-windows)
or the [Python wiki page for Windows compilers](https://wiki.python.org/moin/WindowsCompilers).

If you are using *conda*/*mamba*, set up your compilers to build libraries
compatible with other installed packages,

````{tab} mamba
```bash
mamba install compilers -c nodefaults -c conda-forge --override-channels
```
````

````{tab} conda
```bash
conda install compilers -c nodefaults -c conda-forge --override-channels
```
````

With compilers set up and dependencies installed, build and install *Landlab*,

```bash
pip install -e .
```

## Developer Tools

Once you start developing with *Landlab*, we recommend that you use [nox]  to
automate common tasks such as, for example, running the tests, building the docs, and
finding lint.

```bash
pip install nox
```

The following list shows how to use [nox] for some of the more common tasks:

- Run the tests:

  ```bash
  nox -s test
  ```

- Run the tests on the notebooks:

  ```bash
  nox -s test-notebooks
  ```

- Build the docs:

  ```bash
  nox -s build-docs
  ```

- Run the linters:

  ```bash
  nox -s lint
  ```

- To get a complete list of the available targets:

  ```bash
  nox -l
  ```

[nox]: https://nox.thea.codes/en/stable/



================================================
File: docs/source/install/environments.md
================================================
(virtual-environments)=

# Virtual Environments

A virtual environment is a self-contained directory tree that contains a Python installation for a particular
version of Python along with additional packages. It solves the problem of one application's
package requirements conflicting with another's.

Two popular tools used for creating virtual environments are the built-in *venv* module and *conda*
(or the *much* faster and more reliable *mamba*). For virtual environments created using *conda*/*mamba*,
you can use either *conda*/*mamba* or *pip* to install additional packages, while *venv*-created environments
should stick with *pip*.

````{tab} mamba
```bash
conda install mamba -c conda-forge
mamba create -n landlab
mamba activate landlab
```
````

````{tab} conda
```bash
conda create -n landlab
conda activate landlab
```
````

````{tab} venv
```bash
python -m venv .venv
source .venv/bin/activate
```
````

Note that you will need to activate this environment every time you want to use it in a new shell.

Helpful links on managing virtual environments:

- [conda environments](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands).
- [venv environments](https://docs.python.org/3/tutorial/venv.html).



================================================
File: docs/source/install/index.md
================================================
```{include} developer_install.md
:start-after: "(install)="
```

% If you would like the very latest development version of *landlab* or want to modify
% or contribute code to the *landlab* project, you will need to do a
% :ref:`developer installation <install>` of *landlab* from source.
%
% If you are only wanting to *use* *landlab*, please see the installation instructions
% in the :ref:`getting started <basic_install>` section.

```{toctree}
:caption: Installing
:hidden: true
:maxdepth: 2

environments
update_uninstall
```



================================================
File: docs/source/install/update_uninstall.md
================================================
# Updating and uninstalling

You can update an existing *landlab* installation to a newer version
(if available) by running the following,

````{tab} conda
```bash
$ conda update landlab
```
````

````{tab} pip
```bash
$ pip -U install landlab
```
````

To uninstall *landlab*,

````{tab} conda
```bash
$ conda uninstall landlab
```
````

````{tab} pip
```bash
$ pip uninstall landlab
```
````



================================================
File: docs/source/user_guide/build_a_model.md
================================================
(build-a-model)=

# What goes into a Landlab model?

In the previous section, {ref}`Grid <grid-user-guide>` we showed you most of the core
functionality of the Landlab grid. In this section, we introduce you to how to
actually use it to build models and work with the Landlab component library.

Using Landlab requires that you build a Python script to import, instantiate,
and then run your landscape model. We describe such a script as a **driver**.
It's also possible to do the same set of processes on the fly in an interactive
Python environment like iPython.

Typically, a driver file will consist of six distinct sections:

- **Import** the Python and Landlab libraries you'll need to run your model
- **Instantiate** the Landlab elements (grid and, if using them, components)
- **Load** any necessary data into the grid fields
- Set the **boundary conditions**
- **Run** the model, typically by creating a for loop or using a Landlab generator (see below)
- **Finalize** and handle the data (e.g., plot, export)

Beyond the driver, if you're using Landlab components, you'll probably also need
a {ref}`parameter file<input-files>`. This file supplies the components with the additional
parameter and setup information they need. Landlab parameter files are text
files `.txt`, have fixed format, and for convenience (so you only have to
specify the minimum of path information in the file name) should be placed in
the same folder as the driver file. Find out more about parameter files
{ref}`here<input-files>`. However, if you're not using components, there's little need
to create a parameter file; you can just directly pass other parameters to the grid
in the driver.

## A brief introduction to components

A key strength of Landlab is that not only is it designed to make implementing
your own process simulations as simple as possible, but it also offers an
off-the-shelf library of pre-designed process descriptions that you can use in
your drivers. We call these process simulators Landlab **components**. The
intention is that each component be:

- Plug-and-play
- Interoperable with all other components
- Implementable in your driver in only one or two lines of code

By no means is using the component library necessary or even always
desirable when working with Landlab. However, we hope that components will dramatically reduce the time investment needed to implement
a wide variety of modeling scenarios. In particular, components should make
producing models that couple more than one process significantly easier because
existing, off-the-shelf components can be slotted in alongside novel process
descriptions.

A list of the current components is found within the Reference guide
{ref}`components section <api-components>`.

Note that not all components will run under all conditions, but any
limitations should be made clear in the documentation associated with
that component.

In particular, some components may demand you are running on a regular grid. It
should probably also be emphasized that most of these components are still under
active development within this beta release of Landlab, and may behave in
idiosyncratic ways or be subject to sudden changes with little or no warning. In
all cases, before setting out on any major research challenges using a
component, we'd recommend contacting the original coder of the component to let
them know they have external users to think about!

## Implementing a Landlab driver

As noted above, the process of creating a driver is essentially equivalent
whether you want to implement Landlab components, purely use your own code, or
combine some mixture of the two. Here we take a closer look at the various
steps.

### 1. Import the libraries and functions you need

Landlab handles a lot like NumPy, and like NumPy you'll need to import the
various libraries and functions that you'll want to use. At the very least, we
suspect you'll need from outside Landlab:

- *NumPy* itself
- rudimentary Pylab plotting routines: *plot*, *show*, *figure*

Also useful can be:

- the Python module *time*, to time various parts of your code elements
- from *SciPy*, the scientific computing library. Lots of useful methods (e.g.,
  matrix solutions, curve fitting) can be found in here, to avoid reinventing
  the wheel.

From inside Landlab, you'll also need:

- A **grid** class—choose from {py:class}`RasterModelGrid <landlab.grid.raster.RasterModelGrid>`,
  {py:class}`landlab.grid.voronoi.VoronoiDelaunayGrid <landlab.grid.voronoi.VoronoiDelaunayGrid>`,
  or some of the more specialized classes listed on the
  {ref}`grid documentation page <api-grid>`.
- Any **components** you want to run
- Any Landlab **utilities** you need, such as plotters (
  {py:func}`imshow_grid <landlab.plot.imshow>`) or
  {py:mod}`io functions <landlab.io>`.

A specific example might be:

```python
import numpy as np
from pylab import show, figure, plot
import time
from landlab import RasterModelGrid
from landlab.components import FlowAccumlator
from landlab.plot.imshow import imshow_node_grid
```

### 2. Instantiate objects

As noted in previous sections, Landlab is coded in an [object-oriented style](https://code.tutsplus.com/articles/python-from-scratch-object-oriented-programming--net-21476).
This means that we need to "instantiate" the various Landlab objects such as
the grid and the components that we will use to store data and run the model.

Note that most components require the grid object be passed to them as one of
their arguments during instantiation, so the first thing you'll want to
instantiate will be the grid.

Check the docstrings for each class (grid, component) you want to instantiate
for a detailed description of what you need to supply as arguments.

For a RasterModelGrid, this will be `((i, j), [node_spacing])`. Here, `(i, j)` is a tuple where *i* is the number of rows and *j* the number of columns, and `node_spacing` is an optional second tuple or float. If you want uniform node spacing in the *y* and *x* directions, use a float, otherwise use a tuple to specify `(dy, dx)` if you want them to be different (see example immediately below). Spacing will default to (1., 1.). \[Landlab also recognizes an older style of RasterModelGrid signature, which looks like `(number_of_node_rows, number_of_node_columns, node_spacing(optional))`, and is clever enough to work with this form.\] For a VoronoiDelaunayGrid, the signature will be `(array_of_node_x_coords, array_of_node_y_coords)`. For a generic component, it will typically be `(ModelGrid, 'path_to_parameter_file.txt')`, though there may be some variation, and optional inputs may also be available.

Give each object you instantiate a variable name. We like `mg` for ModelGrid
objects and some appropriate abbreviation for a component.

An example might be:

```python
mg = RasterModelGrid((10, 10), xy_spacing(1.0, 2.0))  # 100 nodes, dy=1., dx=2.
fr = FlowAccumlator(mg)
```

### 3. Load/create data in fields

({ref}`See this section<fields>` if you don't know what a Landlab field is.)

Now we need some data to work with. Here we'll assume that you're going to be
working with a DEM-style elevation map across the nodes of the grid, but similar
considerations would apply for any other type of data.

You will likely be in one of two situations regarding the initial data you want
to put on the grid—either you will have some external data source that you want
to load in and use as your initial conditions (e.g., a DEM of some basin, or
some other real topography), or you want to set up some simple analytical
initial condition like a flat surface with noise or an inclined surface.

In both cases, we advocate a two step process: creating a NumPy array of the
data, then loading it into the grid as a field. We can illustrate both of
the above cases:

```python
mg = RasterModelGrid((10, 10), 1.0)  # make a grid
z = np.zeros(100, dtype=float)  # make a flat surface, elev 0
# or…
z = mg.node_y * 0.01  # a flat surface dipping shallowly south
# add a little noise to the surface:
z += np.random.rand(100.0) / 10000.0
# create the field:
mg.add_field("node", "topographic__elevation", z, units="m")
```

Alternatively, we can use the specialized Landlab function
{py:func}`read_esri_ascii <landlab.io.esri_ascii.read_esri_ascii>`
to import an ascii raster that can be output from ARC. Note this function both
creates the grid for you and loads the data as a field if you provide `name`.
If not, you'll have to load the data output (*z*, below) manually

> ```python
> from landlab.io import read_esri_ascii
>
> mg, z = read_esri_ascii("my_ARC_output.asc", name="topographic__elevation")
> np.all(mg.at_node["topographic__elevation"] == z)
> ```

Note that if you don't want to use any Landlab components, you can continue to
work with data as "free floating" NumPy arrays, and can ignore the fields (e.g.,
see this [simple introductory tutorial](https://gist.github.com/jennyknuth/034e696d65aec808b70e)).

### 4. Set the boundary conditions

Once you have a grid and the initial condition data you'll need, it's time to
set the boundary conditions. If you're working with a raster, or some
pre-existing imported data, this is very straightforward using the built in
RasterModelGrid functions. For a raster where only the edges are to be boundary
nodes

> ```python
> mg.set_fixed_value_boundaries_at_grid_edges(False, True, False, True)
> mg.set_closed_boundaries_at_grid_edges(True, False, True, False)
> ```

This will give a grid with fixed value boundaries at the left and right edges,
and closed boundaries at the top and bottom.

If you're working with, say, an ARC imported array with a null value on the
closed nodes (e.g., -9999), you can do this

> ```python
> mg.set_nodata_nodes_to_closed(mg.at_node["topographic__elevation"], -9999)
> ```

(Be aware that you're still likely to have to reopen an outlet node manually!
In which case you'll also need to follow the instructions below.)

If you're working with individual node's boundary statuses, you'll need to set
the boundary conditions by hand. This means individually modifying the boundary
condition status of each node or link that you want to be of the new type.
Fortunately, Landlab uses some Python magic to make sure that when you update,
for example, the status of a node, the statuses of attached links and cells
change concomitantly. For example

> ```python
> # find the ID of the lowest elevation core node.
> # we'll make this a fixed gradient outlet:
> outlet_id = mg.core_nodes[
>     np.argmin(mg.at_node["topographic__elevation"][mg.core_nodes])
> ]
>
> # show there are no links with *mg.BC_LINK_IS_FIXED* boundary conditions
> # in the grid yet:
> np.any(mg.status_at_link == mg.BC_LINK_IS_FIXED)
>
> # update the outlet node:
> mg.status_at_node[outlet_id] = mg.BC_LINK_IS_FIXED
> np.any(mg.status_at_link == mg.BC_LINK_IS_FIXED)
>
> # the corresponding link has been automatically updated.
> ```

### 5. Run the model

We're now ready to actually implement a run of our model! Most things you might
want to do with Landlab are probably time-sensitive, so in almost all cases,
you'll probably be placing the guts of your simulation inside a loop of some
sort. In simple cases, you can just use some variation on a simple for loop or
while statement, either:

```python
dt = 10.0
for tstep in xrange(100):
    # ...do the thing for one timestep dt
    pass
```

or:

```python
dt = 10.0
accumulated_time = 0.0
while accumulated_time < 1000.0:
    # ...do the thing for one timestep dt
    accumulated_time += dt
```

Both produce 1000 time units of run, with an explicit timestep of 10. Notice
that the latter technique is particularly amenable to situations where your
explicit timestep is varying (e.g., a storm sequence). (For more on time steps in numerical models see the {ref}`Time Steps <time-steps>` page.)

Landlab also however has a built in storm generator component,
{py:class}`PrecipitationDistribution<landlab.components.uniform_precip.PrecipitationDistribution>`,
which (as its name suggests) acts as a true [Python generator](https://www.python-course.eu/generators.php). The main method is
{py:func}`yield_storm_interstorm_duration_intensity <landlab.components.uniform_precip.PrecipitationDistribution.yield_storm_interstorm_duration_intensity>`.
This means producing a storm series in Landlab is also very easy:

```python
from landlab.components.uniform_precip import PrecipitationDistribution

time_to_run = 500000.0
precip_perturb = PrecipitationDistribution(
    input_file=input_file_string, total_t=time_to_run
)
for (
    interval_duration,
    rainfall_rate,
) in precip_perturb.yield_storm_interstorm_duration_intensity():
    if rainfall_rate != 0.0:
        # ...do the thing, making sure to pass it the current
        # interval_duration and rainfall_rate
        pass
```

Notice that the advantage of the generator is that it just stops when the
desired number of events/time duration has expired! See the end of [this
tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/component_tutorial/component_tutorial.ipynb)
for an example of this generator in action.

What exactly "…do the thing" consists of is up to you. You can either design
your own operations to do in the loop for yourself, or you can implement
processes from Landlab's component library. See {ref}`here
<landlab-components-page>`
for more information on using the components.

### 6. Finalize and handle the data

Once the looping is complete, the model is effectively finished. However, you
will still need to output the data somehow! Some options include:

#### Save or export the data

If you're using a raster grid, you can easily save your grid output to either
ESRI ascii (i.e., ARCmap) or open source netCDF formats. netCDF in particular is
a powerful format, and allows easy subsequent re-loading of a Landlab modelgrid
and all its fields. Save your raster like this:

```python
rmg.save("my_savename.asc", names=["field1", "field2"])
# for esri ascii, only saving the fields 1 and 2
```

or:

```python
rmg.save("my_savename.nc")
# save as netCDF3, saving all fields by default
```

The former way will give two save files, `my_savename_field1.asc` and
`my_savename_field2.asc`. The latter will just give `my_savename.nc`.

To reload a netCDF file, use the Landlab io function
{py:func}`read_netcdf<landlab.io.netcdf.read.read_netcdf>`

```python
from landlab.io.netcdf import read_netcdf

mg = read_netcdf("my_savename.nc")
```

Note all the original fields you had will automatically be repopulated.

If you're using an irregular grid, the simple grid save function is not yet
operational (though is under development). Instead, we recommend using Pickle, a
native Python way of saving ("pickling") any Python object. It works like this:

```
>>> import cPickle as pickle
# cPickle is a lot faster than normal pickle
>>> pickle.dump(mg, open("my_savename.pickle", "wb"))
# ...save the grid, and all its fields
>>> mg = pickle.load(open("my_savename.pickle", "rb"))
# ...load the grid and fields back into a grid object
```

Unfortunately, the power of pickle comes somewhat at the expense of both disk
space and speed. Saves this way can be slow and, if the grid is big, memory
expensive (e.g., ~1 Gb for millions of nodes).

You can also use lower level, NumPy save routines to preserve just your data
(rather than the whole grid object). The NumPy methods `save` and `savetxt`
and `load` and `loadtxt` can be called on any NumPy array, including those
saved as fields. Save and load use the NumPy specific `.npy` file format;
`savetxt` and `loadtxt` use `textfiles`. Use them like this:

```
>>> np.save("savename.npy", mg.at_node["my_field"])
>>> mg.at_node["my_field"] = np.load("savename.npy")
>>> np.savetxt("savename.txt", mg.at_node["my_field"])
>>> mg.at_node["my_field"] = np.loadtxt("savename.txt")
```

#### Plot the data

Landlab has a fairly comprehensive suite of built in plotting functions; read
more about them {ref}`here<plotting-and-vis>`.

You also of course have the option of using the [matplotlib plotting library](https://matplotlib.org/) of Python for things like cross-sections.

If you're careful, you can also build plotting functions into the body of a run
loop for your model, so you can see how your output evolves through time. Note
however that all Python save and plot functions are considerably time expensive,
so it would probably be a bad idea to do this kind of thing every timestep.
Instead, you can try something like:

```python
import plot

dt = 10.0
accumulated_time = 0.0
last_accumulated_time_remainder = 0.0
while accumulated_time < 1000.0:
    # ...do the thing for one timestep dt
    accumulated_time += dt
if last_accumulated_time_remainder < accumulated_time % 100.0:  # output every 100.
    plot(
        mg.node_vector_to_raster(z)[mg.number_of_node_rows // 2, :]
    )  # a cross section
    last_accumulated_time_remainder = accumulated_time % 100.0
show()
```

Note that if you're running inside an interactive Python session like iPython,
all the variables and objects (both grid and component) that you've used in your
model will still be available in the environment. Thus, you can play with your
data for as long as you want!

#### Animating figures

Due to issues surrounding platform-dependent video codecs, Landlab does not currently
support native video or animated output. However, numerous effective hacks using free
third party software can be effective. We recommend saving your figure for animation
at the desired frame interval using the matplotlib `savefig` command, then
stitching these images together into a video file externally.

DEJH has had a lot of success doing this in Preview on a Mac (which has the great
advantage that it is always available). Simply open the first image, go to `Export...`
under file, then **while holding down alt** click on the `Format` button to gain
access to a list of extra formats, including `.gif`. Open your new gif file, also
in preview, then just drag the remaining image files into the sidebar onto the first
slide, where they will be appended to the gif as individual frames. Save, and you
will now have an animated gif of your output (note you'll have to open the file in a
browser or drag it into Powerpoint to get it to run - for mysterious reasons,
Preview always opens the frames as images, and cannot show the gif running!).



================================================
File: docs/source/user_guide/cell_lab_user_guide.md
================================================
(celllab)=

# CellLab-CTS User Guide

Created: August 2015, Greg Tucker

Last updated: April 2020 GT

## Introduction

CellLab-CTS is a Landlab module for building pairwise, continuous-time stochastic (CTS) cellular automata. Like other cellular automata, pairwise CTS models represent natural phenomena using a regular grid of cells; in the case of CellLab-CTS, the user can choose between square and hexagonal cells. Each cell has a given state, which is an integer code representing something about the nature or contents of that cell. Cells change state at random time intervals according to a user-defined transition rules. The transitions depend on the states of the neighboring cells, and in particular, of the states of each *pair* of adjacent cells. For example a pair with states 0 and 1 might undergo a transition to 1 and 1, or 3 and 0, etc.

This Users Manual provides instructions on how to write a model using CellLab-CTS, along with reference information about the classes and methods that CellLab-CTS provides. For further information about the theory, implementation, and design of CellLab-CTS, see Tucker et al. (2016). For background information on the theory of pairwise CTS models and example applications, see Narteau et al. (2001, 2009) and Rozier and Narteau (2014). For background on cellular automata in general, see Chopard and Droz (1998).

*Note on terminology:* In a CellLab-CTS model, the computational points—the objects that are normally called **cells** in a cellular automaton model—actually correspond with the **nodes** in a Landlab grid. Although Landlab grids also contain *cells*, which are defined as polygons that contain a node, Landlab grids do not have cells along the outmost ring of nodes around the grid. For example, a 4-row by 5-column Landlab raster grid has 20 nodes but only 6 cells (2 inner rows x 3 inner columns). For CellLab-CTS models, it is useful to include the perimeter nodes as "cells" for the purpose of handling boundary conditions. Therefore, CellLab-CTS treats all the **nodes** in the grid as if they were cells in a cellular automaton. This includes the perimeter nodes, for which Landlab does not formally define cells. For practical purposes, the distinction doesn't make much difference, but it is important to understand that CellLab-CTS works with arrays of grid nodes rather than the (shorter) arrays of grid cells. Henceforth, to avoid confusion, we will refer to **nodes**, which you should read as being synonymous with the usual meaning of "cell" in a cellular automaton.

*Prerequisites:* This manual assumes working knowledge of the Python programming language (any version), including basic familiarity with Python classes and objects. It also assumes a basic familiarity with Landlab grids. In addition, it will be helpful to have some familiarity with the Matplotlib and/or Pylab plotting libraries.

## Writing a CellLab-CTS model

### What is a CellLab-CTS model?

A CellLab-CTS model is a Python program that creates and initializes one of the four types of `CellLabCTSModel` object, defines the possible cell states and transition rules, and calls the `run` method to execute the model. A CellLab-CTS model can be written in one of two basic ways. The first option is to write a simple Python script that imports the necessary ingredients. This approach is easy and versatile, and is recommended for first-time users, and/or those who are relatively unfamiliar with Python classes. The second option is to write your model as a subclass of one of the four existing CellLabModel subclasses (more on these below). The subclass approach is useful when you wish to use the *dynamic property updating* capability of CellLab-CTS—that is, for example, when you want to attach some form of additional data to the grid, and update the data at each transition event according to the state of the grid. In this manual, we will focus on the example of a simple script-based model.

### Basic ingredients of a CellLab-CTS model

The basic steps in most CellLab-CTS models are as follows:

1. Import the necessary CTS classes (and any other necessary packages). These include: one of the four CellLab-CTS model classes (described below), the `Transition` class, and (optionally) the `CAPlotter` class for graphical display.
2. Create and initialize a Landlab `ModelGrid` object: either a `RasterModelGrid` or a `HexModelGrid`
3. Create a dictionary that defines the node states to be used
4. Create a list of Transition objects: one for each transition type in your model
5. Create an array with the initial state values in the grid
6. Instantiate and initialize one of the four CellLab-CTS classes
7. Set up plotting (if desired)
8. Run the model by calling the CellLab-CTS object's `run` method (perhaps pausing every so often to display the grid and/or write output to file)
9. Clean up

We will illustrate each of these steps using a simple example called `isotropic_turbulent_suspension.py`. This program simulates the random motion of neutrally buoyant sediment particles that are immersed in a turbulent fluid: think of tea leaves in a jar of tea that you are stirring with an invisible spoon. Each random motion is simulated by simply swapping a fluid state and a particle state.

:::{figure} images/transition_example.png
:align: center
:figwidth: 80 %

Figure 1: A CellLab-CTS model of suspended sediment particles in an isotropic turbulent fluid.
:::

Before diving into the example, however, it's useful to look at the four different types of CellLab-CTS model.

### Types of CellLab-CTS model

A CellLab-CTS grid can be either raster (regular grid of square cells) or hexagonal (trigonal grid of nodes with hexagonal cells). In addition, a CellLab-CTS model can be either *oriented* or *non-oriented*. An oriented model is one in which the spatial orientation of a node pair influences the types and/or of transition. For example, in an oriented raster model, a horizontal pair with states 0 and 1 might have a different set of potential transitions than a vertical pair with states 0 and 1. A non-oriented pair treats the sequence 0-1 the same regardless of whether the pair is vertical, horizontal, or (in the case of a hex grid) at any other angle.

With these different possibilities in mind, the four CellLab-CTS model types are:

1. `RasterCTS:` A non-oriented grid of square cells.
2. `OrientedRasterCTS:` An oriented grid of square cells, with two orientations (horizontal and vertical).
3. `HexCTS`: A non-oriented grid of hexagons.
4. `OrientedHexCTS:` An oriented grid of hexagons, with three orientations. These can be: (1) vertical, (2) +30 degrees from horizontal (angling down/left to up/right), and (3) -30 degrees from horizontal (angling up/left to down/right). Or, alternatively, the three axes can be horizontal and +/-30 degrees from vertical (one determines this when instantiating the grid object, as illustrated below).

These four types are implemented as subclasses of the base class `CellLabCTSModel`, as illustrated in Figure 2.

:::{figure} images/ca_class_hierarchy.png
:align: center

Figure 2: CellLab-CTS class hierarchy and main data structures. N = number of grid nodes, L = number of grid links, NL = number of possible link (node pair) states, NT = maximum number of transitions for any link state.
:::

### Step 1: Importing CellLab-CTS

A CellLab-CTS application normally starts by importing the appropriate type of CTS model class, along with any other packages needed. Thus, our suspended-sediment model starts out as follows:

```python
#!/usr/env/python

"""
isotropic_turbulent_suspension.py

Example of a continuous-time, stochastic, pair-based cellular automaton model,
which simulates the diffusion of suspended, neutrally buoyant particles in a
turbulent fluid.

Written by Greg Tucker, February 2015
"""

import time
import matplotlib
from numpy import where
from landlab import RasterModelGrid
from landlab.ca.celllab_cts import Transition, CAPlotter
from landlab.ca.raster_cts import RasterCTS
```

Here, we're using a raster model, so we import Landlab's `RasterModelGrid` class. It will be a non-oriented raster model, so we import the `RasterCTS` class (rather than  `OrientedRasterCTS`). We also import the `CAPlotter` class for help with graphical display (more on that below), as well as the `Transition` class. We need the Transition class to set up our pair transitions, which we explore next.

### Setting up transitions

#### Sequence matters!

A particular pair state is described by the two node states, and optionally by the pair's orientation. A key thing to understand here is that any particular pair sequence, such as 0 and 1, is *different from the sequence in reverse*. The pair 0-1 is not the same as the pair 1-0! This is true for all four types of model. So then which is which? To answer this question, we first need to recall that each pair corresponds to the two ends of a *link* in the Landlab grid. A link is simply a directed line segment that connects two neighboring nodes. Every link has a *tail* and a *head* (like the head of an arrow); the direction of the link is from tail to head. The rule for CellLab-CTS pairs is that the first number refers to the tail of the corresponding link, and the second refers to its head. Thus, the pair state 0-1 means that the tail node has state 0 and the head node has state 1.

By default, the links in a raster grid always run from down to up (for vertical links) or left to right (for horizontal links) (Figure 3). For example, with a 0-1 pair in a raster grid, the 0 is either the left-hand node (if it's a horizontal pair) or the bottom node (if the pair is vertical). In a default hex grid, the links point either (1) upward, (2) angling right and up 30 degrees, or (3) angling right and down 30 degrees. (Note that you also have the option of switching the grid orientation so that one of the principal axes is horizontal instead of vertical; in that case, the three orientations are horizontal, 30 degrees clockwise from vertical, and 30 degrees counter-clockwise from vertical).

:::{figure} images/grid_schematic2.png
:align: center

Figure 3: Illustration of nodes, links, and cells in a raster and hex grids. Note directions of links, which always "point" toward the upper-right hemisphere. The hex illustration shows a hex grid cell in vertical orientation; in horizontal orientation, links point rightward, up and right, and up and left.
:::

#### How transitions are represented

Each transition type is described by the states of the tail and head nodes, and by the orientation of the pair. This information is encoded in a 3-element tuple. Recall that each pair is associated with a link. The first number is the state of the link's tail node, the second is the state of the link's head node, and the third is an *orientation code* that represents the pair's spatial orientation (Figure 4). In a non-oriented model, the orientation code is always zero. In an oriented raster, the orientation code is either 0 (horizontal) or 1 (vertical). For example, the code (0, 1, 0) in an oriented raster model would represent a vertical pair in which the left node has state 0 and the right state 1.

:::{figure} images/cell_pair_orientation.png
:align: center

Figure 4: Pair orientation codes in a raster (top 2 panels) and vertical hex (bottom 3 panels) grid.
:::

In an oriented hex, the orientation codes depend on the orientation of the grid itself. A Landlab `HexModelGrid` can be oriented such that one of the three principal axes is either horizontal (the default) or vertical. The choice is controlled by the optional keyword argument `orientation` (either `'vertical'` or `'horizontal'`) in the `HexModelGrid` initialization function. For a vertically aligned hex grid, the CellLab-CTS orientation codes are: 0 for vertical, 1 for right and upward, and 2 for right and downward (Figure 4). For example, the code (1, 0, 2) would represent a down-and-right pair, with a state of 1 in the upper-left node and 0 in the lower-right node. For a horizontally aligned hex grid, the CellLab-CTS orientation codes are: 0 for upward and left, 1 for upward and right, and 2 for right. For example, the code (1, 0, 2) would represent a left-to-right pair, with a state of 1 in the left node and 0 in the right node.

#### Example of a transition setup function

It can be helpful to put the transition setup procedure inside a function of its own. Here is the transition setup function for our turbulent suspension example (notice that the function itself has only four lines of code; all the rest is documentation):

```python
def setup_transition_list():
    """
    Creates and returns a list of Transition() objects to represent state
    transitions for an unbiased random walk.

    Parameters
    ----------
    (none)

    Returns
    -------
    xn_list : list of Transition objects
            List of objects that encode information about the link-state transitions.

    Notes
    -----
    State 0 represents fluid and state 1 represents a particle (such as a
    sediment grain, tea leaf, or solute molecule).

    The states and transitions are as follows:

    Pair state      Transition to       Process             Rate (cells/s)
    ==========      =============       =======             ==============
    0 (0-0)         (none)              -                   -
    1 (0-1)         2 (1-0)             left/down motion    10.0
    2 (1-0)         1 (0-1)             right/up motion     10.0
    3 (1-1)         (none)              -                   -

    """

    # Create an empty transition list
    xn_list = []

    # Append two transitions to the list.
    # Note that the arguments to the Transition() object constructor are:
    #  - Tuple representing starting pair state
    #    (left/bottom cell, right/top cell, orientation)
    #  - Tuple representing new pair state
    #    (left/bottom cell, right/top cell, orientation)
    #  - Transition rate (cells per time step, in this case 1 sec)
    #  - Name for transition
    xn_list.append(Transition((0, 1, 0), (1, 0, 0), 10.0, "left/down motion"))
    xn_list.append(Transition((1, 0, 0), (0, 1, 0), 10.0, "right/up motion"))

    return xn_list
```

In this example, state 0 represents the fluid and state 1 represents a particle. Motion is represented by a transition from a 0-1 pair to a 1-0, or vice versa.

Your transition setup function should create and return a list of `Transition` objects. A Transition object contains (and is initialized with) the 3-element tuples for the starting and ending transitions, a transition rate (in units of cell-widths per time), and (optionally) a name. Two other optional parameters are used when you want to track properties associated with moving particles: a boolean flag (`swap_properties`) indicating whether the transition involves an exchange of properties, and the name of a user-defined callback function (`prop_update_fn`) to invoke whenever a transition of that type occurs.

(Note that it is also possible to specify a single-integer code for the link state, instead of 3-element tuple. This is a bit more of a headache, however, since it requires you to work out the link-state code corresponding to each pair, and is not recommended.)

### Defining parameters

Typical parameters in a CellLab-CTS model, in addition to the transitions and rates, include the dimensions of the grid, the duration of the run, and the time intervals for plotting, writing output to file, and/or reporting progress on screen. In the following example, we have defined these within a `main()` function. They could also be read in from a file, input on a command line, or specified by some other method.

```python
def main():
    # INITIALIZE

    # User-defined parameters
    nr = 80  # number of rows in grid
    nc = 50  # number of columns in grid
    plot_interval = 0.5  # time interval for plotting, sec
    run_duration = 20.0  # duration of run, sec
    report_interval = 10.0  # report interval, in real-time seconds

    # Remember the clock time, and calculate when we next want to report
    # progress.
    current_real_time = time.time()
    next_report = current_real_time + report_interval
```

### Step 2: Creating a grid

Depending on the type of CTS model to be used, your code will need to instantiate either a `RasterModelGrid` or a `HexModelGrid`. If you wish to modify the default boundary setup, this should be done right after the grid is created. In the example below, we create a raster grid and set each of its four boundaries to act like a wall:

```python
# Create grid
mg = RasterModelGrid(nr, nc, 1.0)

# Make the boundaries be walls
mg.set_closed_boundaries_at_grid_edges(True, True, True, True)
```

### Step 3: Create a node-state dictionary

The possible node states are defined by creating entries in a dictionary, in which each key is an integer and each value is a string that gives the name for that state. There should be one entry for each state in your model. For example, our isotropic turbulent suspension model defines just two states:

```python
ns_dict = {0: "fluid", 1: "particle"}
```

### Step 4: Create the transition list

If you've already defined a transition setup function, all you need to do here is call that function, as in the following example:

```python
xn_list = setup_transition_list()
```

### Step 5: Create an array containing the initial node-state values

The node state array should be a 1D numpy array of integers, with length equal to the number of grid rows times the number of grid columns. The easiest way to create such a grid is to use the grid's `add_zeros()` method (or, similarly, `add_ones` or `add_empty`). For example, for the suspended-sediment example we'll create an array of zeros, representing a container filled with fluid:

```python
# Create the node-state array and attach it to the grid
node_state_grid = mg.add_zeros("node", "node_state_map", dtype=int)
```

The first argument here is the name of the grid element to which values should be attached, the second is a name to give the array, and the third sets the data type to integer (instead of the default `float` type).

Depending on the nature of the model, the next step is to set the initial values of the node states. You can do this just as you would with any Landlab grid field. Remember that the coordinates of each node in a Landlab grid are available through the `node_x` and `node_y` arrays. For our working example, we'll set the lower 10% of nodes to state 1, indicating that we are starting with a pile of tea leaves at the bottom of the container:

```python
# Initialize the node-state array: here, the initial condition is a pile of
# resting grains at the bottom of a container.
bottom_rows = where(mg.node_y < 0.1 * nr)[0]
node_state_grid[bottom_rows] = 1

# For visual display purposes, set all boundary nodes to fluid
node_state_grid[mg.closed_boundary_nodes] = 0
```

Note the use of the numpy `where` function, which we imported in Step 1.

### Step 6: Instantiate a CellLab-CTS object

Our core model will be an object (a.k.a. *instance*) of one of the four CellLabCTS model classes. We create this just as we would any other Python object: by calling its constructor function, which is simply the name of the class followed by parentheses, with any necessary arguments within the parentheses. There are four required arguments: a grid object (which must be of the correct type, i.e., raster or hex), a dictionary of node states, a list of `Transition` objects, and the initial node state array. Here's what it looks like for our raster-based suspension model:

```python
# Create the CA model
ca = RasterCTS(mg, ns_dict, xn_list, node_state_grid)
```

### Step 7: Set up plotting

If you want to display your model's progress on screen, you can pause the run every once in a while and use pylab, matplotlib, or whatever your favorite graphics library may be to plot what's going on. For convenience, CellLab-CTS provides a `CAPlotter` class. CAPlotter is smart enough to find your node-state array, and to plot its contents in raster or hex form as appropriate. When you create the CAPlotter object, you pass it your CA model object and optionally a matplotlib colormap object. The CAPlotter has an `update_plot` method to plot the current state of your model, and a `finalize` method to clean up.

Here's an example of how to use a CAPlotter:

```python
# Set up colors for plotting
grain = "#5F594D"
fluid = "#D0E4F2"
clist = [fluid, grain]
my_cmap = matplotlib.colors.ListedColormap(clist)

# Create a CAPlotter object for handling screen display
ca_plotter = CAPlotter(ca, cmap=my_cmap)

# Plot the initial grid
ca_plotter.update_plot()
```

## Step 8: Run the model

Once a CTS model object has been instantiated, you run it forward in time with the `run` method. `run` takes one required argument: the future time to which to run. There are also three optional arguments:

- a node-state array (this is provided so that if you wish you can modify the array and re-run)
- a flag indicating whether to re-plot after each transition occurs
- a plotter object, which is required if the value of the flag is True

If you wish to pause occasionally to plot and/or write data to file, a natural approach is to place the call to the run method inside a loop, as in the following example:

```python
# RUN
current_time = 0.0
while current_time < run_duration:
    # Once in a while, print out simulation real time to let the user
    # know that the sim is running ok
    current_real_time = time.time()
    if current_real_time >= next_report:
        print(
            f"Current simulation time {current_time}"
            f" ({int(100.0 * current_time / run_duration)}%)"
        )
        next_report = current_real_time + report_interval

    # Run the model forward in time until the next output step
    ca.run(current_time + plot_interval, ca.node_state, plot_each_transition=False)
    current_time += plot_interval

    # Plot the current grid
    ca_plotter.update_plot()
```

### Step 9: Cleanup

There generally isn't much to clean up. If you are using a CAPlotter object, it can be helpful to call its `finalize` method, which turns off matplotlib's interactive mode and calls `show()` to make sure the plot is displayed on screen.

```python
ca_plotter.finalize()
```

## Reference information

### Main data structures in the CellLabCTSModel class

Each of the four types of CTS model inherits from the base class (CellLabCTSModel) the following data structures. These are also illustrated in Figure 2. (Note: some of the data structures and names have changed since the publication of Tucker et al. (2016); thus, the list below differs in some respects from the original paper and from Figure 2.)

`node_state`

: Node-based grid of node-state codes. This is the grid of cell (sic) states.

`node_pair`

: List of 3-element tuples representing all the various link states. Allows
  you to look up the node states and orientation corresponding to a particular
  link-state ID.

`priority_queue`

: Data structure that implements a priority queue. The queue contains all
  future transition events, sorted by time of occurrence (from soonest to latest).

`next_update`

: Time (in the future) at which the link will undergo its next transition.
  You might notice that the update time for every scheduled transition is also
  stored in each Event object in the event queue. Why store it twice? Because
  a scheduled event might be invalidated after the event has been scheduled
  (because another transition has changed one of a link's two nodes, for
  example). The way to tell whether a scheduled event is still valid is to
  compare its time with the corresponding transition time in the *next_update*
  array. If they are different, the event is discarded.

`link_orientation`

: Orientation code for each link.

`link_state`

: State code for each link.

`n_trn`

: Number of transitions ("xn" stands for "transition") from a given link
  state.

`trn_to`

: Stores the link-state code(s) to which a particular link state can
  transition.

`trn_rate`

: Rate associated with each link-state transition.

### Source Code Documentation for CellLab-CTS

- {py:class}`Methods and Internal Documentation for the base class: CellLabCTSModel <landlab.ca.celllab_cts.CellLabCTSModel>`
- {py:class}`Methods and Internal Documentation for the RasterCTS class <landlab.ca.raster_cts.RasterCTS>`
- {py:class}`Methods and Internal Documentation for the OrientedRasterCTS class <landlab.ca.oriented_raster_cts.OrientedRasterCTS>`
- {py:class}`Methods and Internal Documentation for the HexCTS class <landlab.ca.hex_cts.HexCTS>`
- {py:class}`Methods and Internal Documentation for the OrientedHexCTS class <landlab.ca.oriented_hex_cts.OrientedHexCTS>`

## References

Chopard, B., & Droz, M. (1998). Cellular automata. Cambridge University Press,
Cambridge, UK.

Narteau, C., Le Mouël, J. L., Poirier, J. P., Sepúlveda, E., & Shnirman, M.
(2001). On a small-scale roughness of the core–mantle boundary. Earth and
Planetary Science Letters, 191(1), 49-60.

Narteau, C., Zhang, D., Rozier, O., & Claudin, P. (2009). Setting the length
and time scales of a cellular automaton dune model from the analysis of
superimposed bed forms. Journal of Geophysical Research: Earth Surface
(2003–2012), 114(F3).

Rozier, O., & Narteau, C. (2014). A real‐space cellular automaton laboratory.
Earth Surface Processes and Landforms, 39(1), 98-109.

Tucker, G. E., Hobley, D. E., Hutton, E., Gasparini, N. M., Istanbulluoglu, E.,
Adams, J. M., & Nudurupati, S. S. (2016). CellLab-CTS 2015: continuous-time
stochastic cellular automaton modeling using Landlab. Geoscientific Model
Development, 9(2), 823-839,
[doi:10.5194/gmd-9-823-2016](https://www.geosci-model-dev.net/9/823/2016/).



================================================
File: docs/source/user_guide/component_list.md
================================================
# List of Components

````{jinja} llcats
```{{"{"}}list-table{{"}"}}
:widths: 50 50
:header-rows: 0

{% for name, component in components |dictsort %}
{% set parts = component['name'].split(".") %}
* - {{"{"}}class{{"}"}}`{{name}} <{{ component['name'] }}>`
  - {{ component['summary'] }}
{% endfor %}
```
````



================================================
File: docs/source/user_guide/components.md
================================================
(landlab-components-page)=

# The Component Library

Landlab offers an ever-growing library of components that aim to describe
individual or closely associated suites of surface processes. Components are
designed to be "plug-and-play" and to interact with each other with the minimum
of technical difficulties. Each component makes use of Landlab grid fields to
enable the sharing of data between the components, and we aim to have a
relatively standardized way of interacting with and using each different one.

Landlab components exist as classes, and can be imported from
`landlab.components`.

To develop your own Landlab component, see
{ref}`this page <dev-contributing>`
and
[this tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/making_components/making_components.ipynb).

## Component Library Tutorial

For a tutorial introduction to using the component library, see
[here](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/component_tutorial/component_tutorial.ipynb).

## Available Landlab components

For the complete list of Landlab components type the following command in a
command prompt:

`landlab list`

See the {ref}`Components section <api-components>` of the Landlab reference
manual for a list of all Landlab components currently available.

## Landlab component classes, their import, and their instantiation

Almost all Landlab components exist as Python classes. This means that to use
them, you must first import the class, then `instantiate` a Python instance
of that class, then call a method from the class to run the component. The way
this is done has now been almost totally standardised across Landlab.

A component class is imported from the library as

```python
from landlab.components import NameOfComponentToImport
```

e.g., to get the linear diffusion component, we would do:

```python
from landlab.components import LinearDiffuser
```

The available components are listed in the
{ref}`Components section <api-components>` of the Landlab Reference Manual.

Component classes always take a copy of the grid as their first argument. They
then take a sequence of additional keyword arguments that set the actual
parameters for the component. This means that the instantiation of a component
looks something like
this:

```python
dfn = LinearDiffuser(grid, linear_diffusivity=0.01)
```

These keywords can also be set by passing a Python dictionary, or using a text
input file (see below).

Here, `dfn` is now the `component object`—an "instance" of the component. We
can run it by calling its run method. The component's documentation will
explain how to do this for each individual case, but typically a component will
have a method called `run_one_step`, which can be called like this:

```python
dt = 100.0  # the timestep
dfn.run_one_step(dt)
```

If the component describes a time-varying process, the first argument of
`run_one_step` will be the duration for which to run the component in this
timestep. (If the component is not time sensitive, e.g., the `FlowRouter`,
it won't take `dt`). Some components may also allow/require additional input
parameters to their run method; see individual component documentation for more
details.

Running one of these methods will update the fields held in common by the
single grid object which you linked to all your components during component
instantiation. If you look inside the grid fields having run one of these
methods, you'll see the new fields it has created and populated. The docstrings
for the component should make it clear which fields the component needs to have
in the grid as inputs, and which it modifies and/or creates as outputs.

It should probably be emphasized here to **always read the documentation for
the component you are using**! You can get at this documentation either on this
website, or in a dynamic Python session by getting help for either the imported
class or the instantiated component object. i.e., in this case, any of the
following would work:

```
.. code-block:: pycon
```

> ```pycon
> >>> help(LinearDiffuser)
> >>> help(dfn)  # LinearDiffuser? or dfn? also works
> ```

Quit interactive help in iPython by pressing "q".

(input-files)=

## Inputs to components

Landlab components are initialized by passing a copy of the grid, then by
passing additional dynamic Python keyword arguments, almost all of which are
set to default values if a value is not provided. This means all of the ways
that you could call any other Python function using keywords also applies to
our components.

Most simply, components can be initialized by passing only the keyword values
that need to deviate from the defaults. So, for example, the default parameter
values for the `FastscapeEroder` are
`K_sp=None, m_sp=0.5, n_sp=1., threshold_sp=0., rainfall_intensity=1.`. So if
I want to set the `K_sp` to, say, `1.e-6`, but I am happy with these other
parameters, I can simply do:

```python
fsc = FastscapeEroder(grid, K_sp=1.0e-6)
```

Because Landlab components make use of Python's native `**kwargs` argument
syntax, we can also pass multiple keywords at once to a component using a
Python dictionary:

```python
sp_thresholds = grid.add_ones("node", "sp_thresholds")
myargs = {"K_sp": 1.0e-5, "rainfall_intensity": 0.5, "threshold_sp": sp_thresholds}
fsc = FastscapeEroder(grid, **myargs)
```

Note the "magic" `**` decorator that is placed on the dictionary when it is
passed to the component that makes this work. Also note that we can allow the
component default values to continue to set any keywords we still don't want to
supply, and that as long as the component permits it, we can pass in arrays or
field names like this too (see, e.g., `threshold_sp` above). You can have all
of your input parameters for all components in one dictionary if you so wish;
components will ignore any keywords they are passed that they don't recognize.

**Note that Landlab components will raise an error if they are passed
keyword arguments that they do not need.**

Landlab components always want to see a Python dictionary as their input, as
illustrated above. However, Landlab does offer a native file
reader called `load_params` that allows you to create dictionaries to pass to
components from input files. This function recognizes both
["yaml"](https://yaml.org/spec/1.2/) formatted data files, e.g.,

```yaml
K_sp: 0.3
m_sp: 0.5
n_sp: 1.
linear_diffusivity: 0.0001
```

The `load_params` method will figure out which to use by itself, and will do
any necessary typecasting automatically (i.e., floats will be floats, not
strings):

```python
from landlab import load_params

my_input_dict = load_params("./mytextinputfile.txt")
dfn = FastscapeEroder(grid, **my_input_dict)
```

## Component standard properties

All Landlab components offer a standardized interface. This provides automated information
on the fields, units, etc. that the component works with, creates, and/or modifies. For a
fully compliant component, you will find you can call the following methods and attributes.

| Property                                                                                             | Description                                            |
| ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| {py:meth}`Component.name <landlab.core.model_component.Component.name>`                              | a string                                               |
| {py:meth}`Component.input_var_names <landlab.core.model_component.Component.input_var_names>`        | a tuple giving input field names                       |
| {py:meth}`Component.output_var_names <landlab.core.model_component.Component.output_var_names>`      | a tuple giving output field names                      |
| {py:meth}`Component.var_loc <landlab.core.model_component.Component.var_loc>`                        | a tuple of (var_name, \['node', 'link', etc\])         |
| {py:meth}`Component.definitions <landlab.core.model_component.Component.definitions>`                | a tuple of pairs of (var_name, short description)      |
| {py:meth}`Component.units <landlab.core.model_component.Component.units>`                            | a tuple of (var_name, \['m', 'Pa', etc\])              |
| {py:meth}`Component.var_units('field') <landlab.core.model_component.Component.var_units>`           | method to return the unit of 'field'                   |
| {py:meth}`Component.var_definition('field') <landlab.core.model_component.Component.var_definition>` | method to return a short description of 'field'        |
| {py:meth}`Component.var_mapping('field') <landlab.core.model_component.Component.var_mapping>`       | method to return the element of 'field' (e.g., 'node') |
| {py:meth}`Component.var_type('field') <landlab.core.model_component.Component.var_type>`             | method to return dtype of 'field' (e.g., float)        |
| {py:meth}`Component.var_help('field') <landlab.core.model_component.Component.var_help>`             | a text summary of all of this information for 'field'  |

See {ref}`the tutorials <tutorials>` for
examples of use cases with one, two, and more coupled components.

You can also get an overview of field usage by all components through Landlab's
command line interface. See
{ref}`here <getting-info-about-fields>`
for more information.

(component-standard-names)=

## Landlab standard naming conventions

The Landlab component library attempts to make use of a relatively standardized set of names across
the various components, in order to maximize ease of component coupling. If you're familiar with
the concept of the [CSDMS standard naming conventions](https://csdms.colorado.edu/wiki/CSDMS_Standard_Names), note that we have tried to strike a balance
between the rigor and uniqueness of those names and a more user-friendly, succinct approach.
Nonetheless, you may recognize the basic style of the names:

> **thing_described\_\_what_is_described**

e.g., *topographic\_\_elevation*, *water_surface\_\_gradient*, *water\_\_volume_flux*

We compile three tables to assist users with the {ref}`Landlab standard names<standard-name-definitions>`.

- First is a list of all names with their definitions.
- Second is a table listing which components use each field.
- Third is a table listing which components provide each field.

### Dealing with nonstandard names

The large number of developers on Landlab and historical accident have meant that despite our
best efforts you'll inevitably find instances where different components use different names
for the same thing. In these cases, you need to make equivalent two fields in the grid which
have different names so that two components can talk to each other. This is actually easy;
you can just do:

```pycon
>>> mg.add_field("node", "second_name", mg.at_node["first_name"])
```

Note that we are making slow progress towards truly standardizing the component library, but
these kind of idiosyncrasies might yet persist for a while!



================================================
File: docs/source/user_guide/dupuit_theory.md
================================================
---
orphan: true
---

(dupuit-theory)=

# Theory and Implementation of GroundwaterDupuitPercolator

## Governing Equations

Variably-saturated groundwater flow is often assumed to be governed by
the Richards equation, which describes how water content and/or total
energy potential evolve in an idealized porous medium due to fluxes of
water driven by gradients in total potential, $h = z + p/ \gamma$,
where $z$ is the elevation head, $p$ is the gage pressure,
and $\gamma$ is the specific weight of water.

$$
\frac{\partial \theta}{\partial t} = \frac{\partial}{\partial x} \bigg( k \frac{\partial h}{\partial x} \bigg) + \frac{\partial}{\partial y} \bigg( k \frac{\partial h}{\partial y} \bigg) + \frac{\partial}{\partial z} \bigg( k \frac{\partial h}{\partial z} \bigg)
$$

Here $\theta$ is the volumetric water content of the aquifer and
$k$ is the hydraulic conductivity, which may be a function of
$\theta$. Here we use the widely applied Dupuit-Forcheimer
approximation, which is valid when the aquifer is laterally extensive in
comparison to its thickness, and the capillary fringe above the water
table is relatively thin. If this is the case, the component of the
hydraulic gradient normal to the aquifer base can be neglected, and the
water table can be treated as a free surface. Consequently, the total
head is equal to the water table elevation, $h=z$. With these
assumptions, an adjusted governing equation can be written for the time
evolution of the water table elevation:

$$
n \frac{\partial h}{\partial t} = \frac{\partial}{\partial x} \bigg( k_{sat} h \frac{\partial h}{\partial x} \bigg) + \frac{\partial}{\partial y} \bigg( k_{sat} h \frac{\partial h}{\partial y} \bigg)
$$

where $n$ is the drainable porosity, and $k_{sat}$ is the
saturated hydraulic conductivity.

:::{figure} images/water_table_schematic.png
:align: center
:alt: Aquifer schematic.
:scale: 50%

Aquifer schematic showing vertical aquifer thickness $h$, bed-normal
aquifer thickness $\eta$, and water table elevation $z$.
:::

When the aquifer base is sloping, the governing equations must be adjusted.
Childs (1971) provides the governing equation for the groundwater specific discharge as:

$$
q_{x'} = - k_{sat} \eta \frac{\partial z}{\partial x'}
$$

where $x'$ is the coordinate parallel to the impermeable base, and $\eta$
is the aquifer thickness perpendicular to the impermeable base ([^footnote-2]).
The `GroundwaterDupuitPercolator` treats two additional fluxes that affect
aquifer storage: groundwater return flow to the surface $q_s$, and
recharge from precipitation $f$. Implementations of the Dupuit-Forcheimer
model often encounter numerical instabilities as the water table intersects the
land surface. To alleviate this problem, we use the regularization approach
introduced by Marcais et al. (2017), which smooths the transition between
surface and subsurface flow ([^footnote-1]). The complete governing equations in the
base-parallel reference frame $(x',y')$ are:

$$
\begin{aligned}
n \frac{\partial \eta}{\partial t} &= f \cos(\alpha) - q_s \cos(\alpha) - \nabla' \cdot q \\
q &= -k_{sat} \eta \big( \nabla' z ) \\
q_s &= \mathcal{G}_r \bigg( \frac{\eta}{d'} \bigg) \mathcal{R} \big(-\nabla' \cdot q + f \cos(\alpha) \big) \\\end{aligned}
$$

where $\alpha$ is the slope angle of aquifer base, and $d'$ is the
permeable thickness normal to the aquifer base. The gradient operator
$\nabla'$ and divergence operator $\nabla' \cdot$ are calculated
with respect to the base-parallel coordinate system. Note that the surface runoff
is the sum of both groundwater return flow and precipitation on saturated area.

The expression for $q_s$ utilizes two regularization functions $\mathcal{G}_r$ and $\mathcal{R}$:

$$
\mathcal{G}_r(r,u) = \exp \bigg( - \frac{1-u}{r} \bigg)
$$

$$
\mathcal{R}(u) = u \mathcal{H}(u)
$$

where $r$ is a user-specified regularization factor and
$\mathcal{H}(u)$ is the Heaviside step function:

$$
\mathcal{H}(u) = \left\{
\begin{array}{ll}
     0 &  u<0 \\[8pt]
     1 &  u \geq 0
\end{array}
\right.
$$

:::{figure} images/GDP_regularization.png
:align: center
:alt: Regularization functions
:scale: 40%

Regularization functions
:::

To recast the problem in terms of the horizontal coordinate system used by Landlab,
we make the substitutions $\eta = h \cos(\alpha)$, $x = x' \cos(\alpha)$,
and $y = y' \cos(\alpha)$. In the horizontal coordinate system $(x,y)$, the
governing equations are:

$$
\begin{aligned}
n \frac{\partial h}{\partial t} &= f - q_s - \nabla \cdot q \\
q &= -k_{sat} \cos^2(\alpha) h \big( \nabla z ) \\
q_s &= \mathcal{G}_r \bigg( \frac{h}{d} \bigg) \mathcal{R} \big(f - \nabla \cdot q \big) \\\end{aligned}
$$

where $d$ is the vertical regolith thickness, and the gradient operator
$\nabla$ and divergence operator $\nabla \cdot$ are calculated with
respect to the horizontal coordinate system $(x,y)$.

## Numerical Implementation

We use an explicit, forward-in-time finite-volume method to solve the
governing equations. In this method, gradients are calculated at links
(between volume centers), and flux divergences are calculated at nodes
(at volume centers). The governing equation with timestep
$\Delta t$ is:

$$
n \bigg( \frac{h^{t+\Delta t} - h^t}{\Delta t} \bigg) = f^t - q_s^t - \nabla \cdot q^t
$$

Below is a description of the components needed to calculate the right
side of this equation. To calculate the groundwater flux $q$, the
gradients of aquifer base elevation $b$ and water table elevation
$z$ must be determined. The slope angle of the aquifer base is
calculated from the aquifer base elevation $b$:

$$
\begin{aligned}
    \alpha_{ij} =& \arctan \big( (\nabla b)_{ij} \big) \\
    \big( \nabla b \big)_{ij} =& \frac{b_{i} - b_{j}}{L_{ij}}\end{aligned}
$$

where the subscripts $i$ and $j$ indicate the nodes at the
head and tail of the link respectively, and $L_{ij}$ is the length
of the link. The gradient $\nabla z$ is calculated on link $ij$ as:

$$
\big( \nabla z \big)_{ij} = \frac{z_{i} - z_{j}}{L_{ij}}
$$

Flux divergence is calculated by summing the fluxes into an out of the
links that connect to a node. The divergence of the groundwater flux is:

$$
\big( \nabla \cdot q \big)_i = \frac{1}{A_i} \sum_{j \in S} \delta_{ij} q_{ij} \lambda_{ij}
$$

where $A_i$ is the area of node $i$, $S$ is the set of
nodes that have links that connect to node $i$, and
$\delta_{ij}$ is a function that is equal to +1 if the link points
away from the node (the tail of the link is at node $i$), and
equal to -1 if the link points toward the node (the head of the link is
at node $i$). The groundwater flux on the link is $q_{ij}$
and the width of the face through which $q_{ij}$ passes is
$\lambda_{ij}$.

References:

[^footnote-1]: Marçais, J., de Dreuzy, J. R. & Erhel, J. Dynamic coupling of subsurface and seepage flows solved within a regularized partition formulation.
    Advances in Water Resources 109, 94–105 (2017).

[^footnote-2]: Childs, E. C. Drainage of Groundwater Resting on a Sloping Bed. Water Resources Research 7, 1256–1263 (1971).



================================================
File: docs/source/user_guide/faq.md
================================================
(faq)=

# Frequently Asked Questions

## What is the difference between a cell and a node?

A cell is a polygon surrounding a node. Nodes on the grid perimeter do not have
cells. Cells have area, nodes have coordinates.

## Why is my node data a 1d array? I'm using a raster...

All Landlab data structures have to be compatible with both regular and
irregular grids. A 2d structure for node data might make sense for a raster,
but it wouldn't work for an irregular grid - and moreover, there is also no
sensible way to represent link data as a 2d raster either, even for a raster.
Thus, instead, Landlab stores all data in an order set by *node ID number*.
For a raster, IDs begin at zero in the bottom left corner of the grid, then
run along each row in turn. For links, the IDs also start in the bottom left
and run across then up, but in this case all vertical links are listed, then
all horizontal links. Here's a sketch summary of this scheme for a 4x5 raster:

```
NODES:                                    LINKS:
15------16------17------18------19        *--27-->*--28-->*--29-->*--30-->*
|       |       |       |       |         ^       ^       ^       ^       ^
|       |       |       |       |        22      23      24      25      26
|       |       |       |       |         |       |       |       |       |
10------11------12------13------14        *--18-->*--19-->*--20-->*--21-->*
|       |       |       |       |         ^       ^       ^       ^       ^
|       |       |       |       |        13      14      15      16      17
|       |       |       |       |         |       |       |       |       |
5-------6-------7-------8-------9         *---9-->*--10-->*--11-->*--12-->*
|       |       |       |       |         ^       ^       ^       ^       ^
|       |       |       |       |         4       5       6       7       8
|       |       |       |       |         |       |       |       |       |
0-------1-------2-------3-------4         *---0-->*---1-->*---2-->*---3-->*
```

## How do I set the boundary codes for the edges of a grid?

By default, the boundary nodes around the perimeter of a grid are all
open boundaries. For a raster grid, if you want to make one or more sides
closed boundaries, use the grid method
{py:func}`RasterModelGrid.set_closed_boundaries_at_grid_edges <RasterModelGrid.set_closed_boundaries_at_grid_edges>`.

The following code snippet sets the southern boundary nodes to be closed:

```python
import landlab

grid = landlab.RasterModelGrid(3, 4)
grid.set_closed_boundaries_at_grid_edges(True, False, False, False)
grid.status_at_node
array([4, 4, 4, 4, 1, 0, 0, 1, 1, 1, 1, 1], dtype=int8)
```

It's also possible to set the boundary conditions "by hand", if you know the ID of the element you're trying to change:
\:

```python
mynodes_to_close = z < 0.0  # if z is some elevation field
grid.status_at_node[mynodes_to_close] = grid.BC_NODE_IS_CLOSED
my_fixed_node = mg.find_nearest_node((1.2, 2.3))
my_fixed_node
9
grid.status_at_node[my_fixed_node] = (
    grid.BC_NODE_IS_FIXED_GRADIENT
)  # to fix the node closest to (1.2, 2.3)
```

See also:

> - {py:func}`RasterModelGrid.set_fixed_value_boundaries_at_grid_edges <landlab.grid.raster.RasterModelGrid.set_fixed_value_boundaries_at_grid_edges>`
> - {py:func}`ModelGrid.set_nodata_nodes_to_closed <landlab.grid.base.ModelGrid.set_nodata_nodes_to_closed>`

## Can I import Landlab output into ParaView or VisIt?

See {ref}`How do I get netCDF output? <how-do-i-get-netcdf-output>` below.

(how-do-i-get-netcdf-output)=

## How do I get netCDF output?

At present, Landlab can write output to a netCDF file if you are using a raster grid
(support for unstructured grids is coming later). To create netCDF output, use the function
{py:func}`landlab.io.netcdf.write_netcdf <landlab.io.netcdf.write_netcdf>`.
This function will write to file

1. the grid geometry, and
2. any data arrays that are linked to the grid

this will automatically include any arrays that you created with functions
such as
{py:func}`landlab.grid.base.ModelGrid.add_zeros <landlab.grid.base.ModelGrid.add_zeros>`,
as long as you provided a name for the array as one of the arguments.

## How do I assign values from nodes to links?

Suppose you have a set of values, such as water depths, that are defined at nodes. How do
you figure out what the corresponding values would be at the links, so you can multiply
these by some other quantity (such as water-surface slope) that is defined on links? Here
are some options:

1. assign the *average*
2. assign the upstream value
3. assign the downstream value

Look at this
[Tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/file=mappers/mappers.ipynb)
for all the Landlab mappers

## How do I test whether my grid is regular or irregular?

There are a number of cases when designing Landlab components where you'll want to do
something one way if the grid is a raster, or another if it's a Voronoi-derived type.
The way to do this is:

```python
from landlab import RasterModelGrid, VoronoiDelaunayGrid

# ...
if isinstance(mg, RasterModelGrid):
    print("Doing it one way")
elif isinstance(mg, VoronoiDelaunayGrid):
    print("Doing it the other way")
else:
    raise TypeError("Landlab did not recognize your grid type!")
```

## How do I modify boundary conditions for part of the grid where I know the coordinates?

See [this tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/boundary_conds/set_BCs_from_xy.ipynb).

## I am having trouble installing Landlab on Ubuntu without Anaconda. What is the fix?

Andy Wickert (5/16) suggests the following:

"The version of setuptools that comes standard on Ubuntu is out-of-date with respect to Landlab's Cython code. Here is the fix:"

```bash
sudo apt-get install python-setuptools # if you don't have it already
sudo easy_install pip
sudo apt-get remove python-setuptools
pip install setuptools # add "--upgrade" if needed
```

And then you can cd to landlab and this works:

```bash
pip install -e .
```

## Support: How can I ask more questions and get help?

File an issue at
[https://github.com/landlab/landlab](https://github.com/landlab/landlab/issues)
using the `New issue` button in the upper right.
Tell us about your issue, and we'll be in touch.

## How do I keep in touch with Landlab developments?

There are a few ways to follow Landlab developments. You can

- follow Landlab on [Twitter](https://mobile.twitter.com/landlabtoolkit)  @landlabtoolkit,
- "watch" Landlab's GitHub repository,
- file a pull request or an issue at [https://github.com/landlab/landlab](https://github.com/landlab/landlab),

## Why are there no other FAQs besides these few?

Because we need your questions. Please feel free to add your own questions by making a GitHub Issue.



================================================
File: docs/source/user_guide/field_definitions.md
================================================
(standard-name-definitions)=

# List of Landlab Fields

The following tables list all of the field names used by *landlab* components. The *Used By* tab lists
component that use a given field (i.e. it is an input for the component), while the *Provided By* tab lists
components that provide the field as output.

`````{jinja} llcats
````{{"{"}}tab{{"}"}} Description
``` {{"{"}}list-table{{"}"}}
:widths: 50 50
:header-rows: 0

{% for name, info in fields |dictsort %}
* - *{{name}}*
  - {{info['desc']}}
{% endfor %}
```
````

````{{"{"}}tab{{"}"}} Used By
``` {{"{"}}list-table{{"}"}}
:widths: 50 50
:header-rows: 0

{% for name, info in fields |dictsort %}
* - *{{name}}*
  - {% if info['used_by'] %}{% for cls in info['used_by'] %}{{"{"}}class{{"}"}}`~{{cls}}` {% endfor %}{% endif %}
{% endfor %}
```
````

````{{"{"}}tab{{"}"}} Provided By
``` {{"{"}}list-table{{"}"}}
:widths: 50 50
:header-rows: 0

{% for name, info in fields |dictsort %}
* - *{{name}}*
  - {% if info['provided_by'] %}{% for cls in info['provided_by'] %}{{"{"}}class{{"}"}}`~{{cls}}` {% endfor %}{% endif %}
{% endfor %}
```
````
`````



================================================
File: docs/source/user_guide/grid.md
================================================
(grid-user-guide)=

# Introduction to Landlab's Gridding Library

When creating a two-dimensional simulation model, often the most time-consuming and
error-prone task involves writing the code to set up the underlying grid. Irregular
(or "unstructured") grids are especially tricky to implement. Landlab's **ModelGrid**
package makes this process much easier, by providing a set of library routines for
creating and managing a 2D grid, attaching data to the grid, performing common input
and output operations, and  providing library functions that handle common numerical
operations such as calculating a field of gradients for a particular state variable.
By taking care of much of the overhead involved in writing grid-management code,
**ModelGrid** is designed to help you build 2D models quickly and efficiently, freeing you
to concentrate on the science behind the code.

Some of the things you can do with **ModelGrid** include:

- Create and configure a structured or unstructured grid in a one or a few lines of code
- Create various data arrays attached to the grid
- Easily implement staggered-grid finite-difference/finite-volume schemes
- Calculate gradients in state variables in a single line
- Calculate net fluxes in/out of grid cells in a single line
- Set up and run "link-based" cellular automaton models
- Switch between structured and unstructured grids without needing to change the rest of
  the code
- Develop complete, 2D numerical finite-volume or finite-difference models much more
  quickly and efficiently than would be possible using straight C, Fortran, Matlab, or
  Python code

Some of the Landlab capabilities that work with **ModelGrid** to enable easy numerical modeling include:

- Easily read in model parameters from a formatted text file
- Write grid and data output to netCDF files for import into open-source visualization
  packages such as ParaView and VisIt
- Create grids from ArcGIS-formatted ascii files
- Create models by coupling together your own and/or pre-built process components
- Use models built by others from process components

This document provides a basic introduction to building applications using Landlab's
**ModelGrid**. It covers: (1) how grids are represented, and (2) a set of tutorial examples
that illustrate how to build models using simple scripts.

## How a Grid is Represented

(basic-grid-elements)=

## Basic Grid Elements

:::{figure} images/grid_schematic_ab.png
:align: center
:figwidth: 80%

*Figure 1*: Elements of a model grid. The main grid elements are nodes, links, cells,
and faces.
Less commonly used elements include corners, patches, and junctions. In the
spring 2015 version of Landlab, **ModelGrid** can implement raster (a) and
Voronoi-Delaunay (b) grids. Ordered subtypes of Voronoi-Delaunay grids—radial
and hexagonal—are also available.
(Note that not all links and patches are shown, and only one representative cell is
shaded.)
:::

{ref}`Figure 1 <basic-grid-elements>` illustrates
how **ModelGrid** represents a simulation grid. The
grid contains a set of *(x,y)* points called **nodes**. In a typical
finite-difference or finite-volume model, nodes are the locations at which one tracks
scalar state variables, such as water depth, land elevation, sea-surface elevation,
or temperature.

Each adjacent pair of nodes is connected by a line segment known as
a **link**. A link has both a position in space, denoted
by the coordinates of the two bounding nodes, and a direction: a link
runs from one node (known as its **from-node** or **tail-node**) to another node
(known as its **to-node** or **head-node**).

Every node in the grid interior is associated with a polygon known as a **cell** (illustrated,
for example, by the shaded square region in {ref}`Figure 1a <basic-grid-elements>`). Each cell is
bounded by a set of line segments known as **faces**, which it shares with its neighboring
cells.

In the simple case of a regular (raster) grid, the cells are square, the nodes
are the center points of the cells ({ref}`Figure 1 <basic-grid-elements>`), and the links and faces have
identical length (equal to the node spacing). In a Voronoi-Delaunay grid, the
cells are Voronoi polygons (also known as Theissen polygons)
({ref}`Figure 1a <basic-grid-elements>`). In this case, each cell represents the surface area that
is closer to its own node than to any other node in the grid. The faces
represent locations that are equidistant between two neighboring nodes. Other grid
configurations are possible as well. The spring 2015 version of Landlab includes
support for hexagonal and radial grids, which are specialized versions of the
Voronoi-Delaunay grid shown in {ref}`Figure 1a <basic-grid-elements>`. Note that the node-link-cell-face
topology is general enough to represent other types of grid; for example, one could use
**ModelGrid's** data structures to implement a quad-tree grid,
or a Delaunay-Voronoi grid in which cells are triangular elements with
nodes at their circumcenters.

## Creating a Grid

Creating a grid is easy.  The first step is to import Landlab's
{py:class}`RasterModelGrid <landlab.grid.raster.RasterModelGrid>` class (this
assumes you have {ref}`installed Landlab <install>`)

```python
>>> from landlab import RasterModelGrid
```

Now, create a regular (raster) grid with 10 rows and 40 columns, with a node spacing (dx) of 5:

```python
>>> mg = RasterModelGrid((10, 40), 5.0)
```

*mg* is now a grid object with 400 `( 10*40 )` nodes and 750 `( 40*(10-1) + 10*(40-1) )` links.

```python
>>> mg.number_of_node_columns
40
>>> mg.number_of_nodes
400
>>> mg.number_of_links
750
```

(fields)=

## Adding Data to a Landlab Grid Element using Fields

Landlab has a data structure called *fields* that will store data associated with different types
of grid elements. Fields are convenient because 1) fields create data arrays of the proper length for
the associated grid element, and 2) fields attach these data to the grid, so that any piece of code that has
access to the grid also has access to the data stored in fields.

Suppose you would like like to
track the elevation at each node. The following code creates a data field
(array) called *elevation*. In this case, we'll use the grid method
*add_zeros* to create a field that initially sets all values in the field to
zero (we'll explain how to read in elevation values from a file in the section
on {ref}`DEMs below <importing-a-dem>`). The *add_zeros* method takes
two arguments: the name of the grid element (in this case, *node*, in the
singular) and a name we choose for the value in the data field (here we'll just
call it *elevation*). Each *elevation* value in the data field is then
associated with a specific grid node. The data field is just a NumPy array
whose length is equal to the number of nodes in the grid.

```python
>>> z = mg.add_zeros("elevation", at="node")
```

Here *z* is an array of zeros. We can verify that *z* has the same length as the number of nodes:

```python
>>> z.size  # or len(z)
400
```

Note that *z* is a reference to the data stored in the model field. This means that if you change z, you
also change the data in the ModelGrid's elevation field. Therefore, you can access and manipulate data in the field either through the variable *z* or through the grid, as in the following examples:

```python
>>> mg.at_node["elevation"][5] = 1000.0
```

or the alternative notation:

```python
>>> mg["node"]["elevation"][5]
1000.
```

Now the sixth element in the model's elevation field array, or in *z*, is equal to 1000.  (Remember that the first element of a Python array has an index of 0 (zero)).

You can see all of the field data available at the nodes on *mg* with the following:

```python
>>> mg.at_node.keys()
['elevation']
```

You may recognize this as a dictionary-type structure, where
the keys are the names (as strings) of the data arrays.

There are currently no data values (fields) assigned to the links, as shown by the following:

```python
>>> mg.at_link.keys()
[]
```

It is also possible, and indeed, often quite useful, to initialize a field from an
existing NumPy array of data. You can do this with the
{py:func}`add_field <landlab.field.grouped.ModelDataFields.add_field>` method.
This method allows slightly more granular control over how the field gets
created. In addition to the grid element and field name, this method takes an
array of values to assign to the field. Optional arguments include: `units=`
to assign a unit of measurement (as a string) to the value, `copy=` a boolean
to determine whether to make a copy of the data, and `clobber=` a boolean
that prevents accidentally overwriting an existing field.

```python
>>> import numpy as np
>>> elevs_in = np.random.rand(mg.number_of_nodes)
>>> mg.add_field(
...     "elevation", elevs_in, at="node", units="m", copy=True, clobber=True
... )
```

Fields can store data at nodes, cells, links, faces, patches, junctions, and corners (though the
latter two or three are very rarely, if ever, used). The grid element you select is
described in Landlab jargon as that field's *centering* or *group*, and you will
sometimes see these terms used as input parameters to various grid methods.

To access only the core nodes, core cells, active links, or some other subset of node values using the
properties available through the ModelGrid, you can specify a subset of the field data array. For example, if we wanted to determine the elevations at core nodes only we can do the following:

```python
>>> core_node_elevs = mg.at_node["elevation"][mg.core_nodes]
```

The first set of brackets, in this case *elevation*, indicates the field data array, and the second set of brackets, in this case *mg.core_nodes* (itself an array of core node IDs), is a NumPy filter that specifies which *elevation* elements to return.

Here is another example of initializing a field with the *add_ones* method. Note that when initializing a field, the singular of the grid
element type is provided:

```python
>>> veg = mg.add_ones("percent_vegetation", at="cell")
>>> mg.at_cell.keys()
['percent_vegetation']
```

Here *veg* is an array of ones that has the same length as the number of cells. Because there are
no cells around the edge of a grid, there are fewer cells than nodes:

```python
>>> mg.at_cell["percent_vegetation"].size
304
```

As you can see, fields are convenient because you don't have to keep track of how many nodes, links, cells, etc.
there are on the grid. It is easy for any part of the code to query what data are already associated with the grid and operate on these data.

You are free to call your fields whatever you want. However, field names are
more useful if standardized across components. If you are writing a Landlab component
you should use {ref}`Landlab's standard names <component-standard-names>`.
Standard names for fields in a particular component can be
accessed individually through the properties
*component_instance.\_input_var_names* and *component_instance.\_output_var_names*
(returned as dictionaries), and are listed in the docstring for each component.

```python
>>> from landlab.components.flexure import Flexure
>>> flexer = Flexure(rg)
>>> flexer._input_var_names
{'lithosphere__elevation',
 'lithosphere__overlying_pressure',
 'planet_surface_sediment__deposition_increment'}
>>> flexer._output_var_names
{'lithosphere__elevation', 'lithosphere__elevation_increment'}
```

We also maintain this list of all the
{ref}`Landlab standard names <component-standard-names>`.

Our fields also offer direct compatibility with [CSDMS's standard naming system for
variables](https://csdms.colorado.edu/wiki/CSDMS_Standard_Names).
However, note that, for ease of use and readability, Landlab standard
names are typically much shorter than CSDMS standard names. We anticipate that future
Landlab versions will be able to automatically map from Landlab standard names to CSDMS
standard names as part of Landlab's built-in [Basic Model Interface for CSDMS
compatibility](https://csdms.colorado.edu/wiki/BMI_Description).

The following gives an overview of the commands you can use to interact with the grid fields.

### Field initialization

- `grid.add_empty(name, at="group", units="-")`
- `grid.add_ones(name, at="group", units="-")`
- `grid.add_zeros(name, at="group", units="-")`

"group" is one of 'node', 'link', 'cell', 'face', 'corner', 'junction', 'patch'

"name" is a string giving the field name

"units" (optional) is a string denoting the units associated with the field values.

### Field creation from existing data

- `grid.add_field(name, value_array, at="group", units="-", copy=False, clobber=True)`

Arguments as above, plus:

"value_array" is a correctly sized numpy array of data from which you want to create the field.

"copy" (optional) if True adds a *copy* of value_array to the field; if False, creates a reference to value_array.

"clobber" (optional) if `False`, raises an exception if a field called name already exists.

### Field access

- `grid.at_node` or `grid['node']`
- `grid.at_cell` or `grid['cell']`
- `grid.at_link` or `grid['link']`
- `grid.at_face` or `grid['face']`
- `grid.at_corner` or `grid['corner']`
- `grid.at_junction` or `grid['junction']`
- `grid.at_patch` or `grid['patch']`

Each of these is then followed by the field name as a string in square brackets, e.g.,

```python
>>> grid.at_node["my_field_name"]  # or
>>> grid["node"]["my_field_name"]
```

You can also use these commands to create fields from existing arrays,
as long as you don't want to take advantage of the added control `add_field()` gives you.

(getting-info-about-fields)=

### Getting information about fields

Landlab offers a command line interface that lets you find out about all the fields that are in use across all the Landlab components. You can find out the following:

`$ landlab used_by [ComponentName]`  # What fields does ComponentName take as inputs?

`$ landlab provided_by [ComponentName]`  # What fields does ComponentName give as outputs?

`$ landlab uses [field__name]`  # What components take the field field\_\_name as an input?

`$ landlab provides [field__name]`  # What components give the field field\_\_name as an output?

`$ landlab list`  # list all the components

`$ (landlab provided_by && landlab used_by) | sort | uniq`  # some command line magic to see all the fields currently used in components

## Representing Gradients in a Landlab Grid

Finite-difference and finite-volume models usually need to calculate spatial
gradients in one or more scalar variables, and often these gradients are
evaluated between pairs of adjacent nodes. ModelGrid makes these calculations
easier for programmers by providing built-in functions to calculate gradients
along links and allowing applications to associate an array of gradient values
with their corresponding links or edges. The [tutorial examples](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/welcome.ipynb)
illustrate how this capability can be used to create models of processes
such as diffusion and overland flow.

Here we simply illustrate the method for
calculating gradients on the links.  Remember that we have already created the
elevation array z, which is also accessible from the elevation field on *mg*.

```python
>>> gradients = mg.calculate_gradients_at_active_links(z)
```

Now gradients have been calculated at all links that are active, or links on which
flow is possible (see boundary conditions below).

## Other Grid Elements

The cell vertices are called *corners* (`Figure 1, solid squares <basic-grid-elements>`).
Each face is therefore a line segment connecting two corners. The intersection
of a face and a link (or directed edge) is known as a *junction*
({ref}`Figure 1, open diamonds <basic-grid-elements>`). Often, it is useful to calculate scalar
values (say, ice thickness in a glacier) at nodes, and vector values (say, ice
velocity) at junctions. This approach is sometimes referred to as a
staggered-grid scheme. It lends itself naturally to finite-volume methods, in
which one computes fluxes of mass, momentum, or energy across cell faces, and
maintains conservation of mass within cells.  (In the spring 2015 version of Landlab,
there are no supporting functions for the use of junctions, but support is imminent.)

Notice that the links also enclose a set of polygons that are offset from the
cells. These secondary polygons are known as *patches* ({ref}`Figure 1,
dotted <basic-grid-elements>`). This means that any grid comprises two complementary tesselations: one
made of cells, and one made of patches. If one of these is a Voronoi
tessellation, the other is a Delaunay triangulation. For this reason, Delaunay
triangulations and Voronoi diagrams are said to be dual to one another: for any
given Delaunay triangulation, there is a unique corresponding Voronoi diagram.
With **ModelGrid,** one can
create a mesh with Voronoi polygons as cells and Delaunay triangles as patches
({ref}`Figure 1b <basic-grid-elements>`). Alternatively, with a raster grid, one simply has
two sets of square elements that are offset by half the grid spacing
({ref}`Figure 1a <basic-grid-elements>`). Whatever the form of the tessellation, **ModelGrid** keeps
track of the geometry and topology of the grid. patches can be useful for processes
like calculating the mean gradient at a node, incorporating influence from its
neighbors.

## Managing Grid Boundaries

An important component of any numerical model is the method for handling
boundary conditions. In general, it's up to the application developer to manage
boundary conditions for each variable. However, **ModelGrid** makes this task a bit
easier by tagging nodes that are treated as boundaries (*boundary nodes*)
and those that are treated as regular nodes belonging to the interior
computational domain (*core nodes*). It also allows you to de-activate ("close")
portions of the grid perimeter, so that they effectively act as walls.

Let's look first at how ModelGrid treats its own geometrical boundaries. The
outermost elements of a grid are nodes and links (as opposed to corners and
faces). For example, {ref}`Figure 2 <raster4x5>` shows a sketch of a regular
four-row by five-column grid created by RasterModelGrid. The edges of the grid
are composed of nodes and links. Only the inner six nodes have cells around
them; the remaining 14 nodes form the perimeter of the grid.

(raster4x5)=

:::{figure} images/example_raster_grid.png
:align: center
:figwidth: 80%

Figure 2: Illustration of a simple four-row by five-column raster grid created with
{py:class}`landlab.grid.raster.RasterModelGrid <landlab.grid.raster.RasterModelGrid>`.
By default, all perimeter
nodes are tagged as open (fixed value) boundaries, and all interior cells
are tagged as core. An active link is one that connects either
two core nodes, or one core node and one open boundary node.
:::

All nodes are tagged as either *boundary* or *core*. Those on the
perimeter of the grid are automatically tagged as boundary nodes. Nodes on the
inside are *core* by default, but it is possible to tag some of them as
*boundary* instead (this would be useful, for example, if you wanted to
represent an irregular region, such as a watershed, inside a regular grid). In the example
shown in {ref}`Figure 2 <raster4x5>`, all the interior nodes are *core*, and all
perimeter nodes are *open boundary*.

Boundary nodes are flagged as either *open* or *closed*, and links are tagged as
either *active* or *inactive* (Figure 3).

(raster4x5openclosed)=

:::{figure} images/example_raster_grid_with_closed_boundaries.png
:align: center
:figwidth: 80 %

Figure 3: Illustration of a simple four-row by five-column raster grid with a
combination of open and closed boundaries.
:::

A closed boundary is one at which no flux is permitted enter or leave, ever.
By definition, all links coming into or out of a closed boundary node must be inactive.
There is effectively no value assigned to a closed boundary; it will probably have a
grid.BAD_INDEX_VALUE or null value of some kind.
An open boundary is one at which flux can enter or leave, but whose value is controlled
by some boundary condition rule, updated at the end of each timestep.

An *active link*
is one that joins either two core nodes, or one *core* and one
*open boundary* node (Figure 3). You can use this
distinction in models to implement closed boundaries by performing flow
calculations only on active links, as seen in [this tutorial](https://mybinder.org/v2/gh/landlab/landlab/master?filepath=notebooks/tutorials/fault_scarp_notebook/landlab-fault-scarp.ipynb).

(bc-details)=

## Boundary condition details and methods

A call to mg.node_status returns the codes representing the boundary condition
of each node in the grid. There are 5 possible types, they are stored on the
model grid:

- mg.BC_NODE_IS_CORE (Type 0)
- mg.BC_NODE_IS_FIXED_VALUE (Type 1)
- mg.BC_NODE_IS_FIXED_GRADIENT (Type 2)
- mg.BC_NODE_IS_LOOPED (Type 3, used for looped boundaries)
- mg.BC_NODE_IS_CLOSED (Type 4)

A number of different methods are available to you to interact with (i.e., set and
update) boundary conditions at nodes. Landlab is smart enough to automatically
initialize new grids with fixed value boundary conditions at all perimeters and core
nodes for all interior nodes, but if you want something else, you'll need to modify
the boundary conditions.

If you are working with a simple Landlab raster where all interior nodes are core and
all perimeter nodes are boundaries, you will find useful the set of commands:

- `mg.set_closed_boundaries_at_grid_edges(right, top, left, bottom)`
- `mg.set_fixed_value_boundaries_at_grid_edges(right, top, left, bottom)`
- `mg.set_fixed_link_boundaries_at_grid_edges(right, top, left, bottom, link_value=None)`
- `mg.set_looped_boundaries(top_bottom_are_looped, left_right_are_looped)`

Where right, top, left, bottom are all booleans. See the relevant docstring for each
method for more detailed information.

If you are working with an imported irregularly shaped raster grid, you can close nodes
which have some fixed NODATA value in the raster using:

- `mg.set_nodata_nodes_to_closed(node_data, nodata_value)`

Note that all of these commands will treat the status of node links as slave to the
status of the nodes, as indicated in Figure 3.
Links will be set to active or inactive according to what you set the node boundary
conditions as, when you call each method.

If you are working on an irregular grid, or want to do something more complicated
with your raster boundary conditions, you will need to modify the
`grid.status_at_node` array by hand, using indexes to node IDs. Simply import the
boundary types from landlab then set the node statuses. The links will be updated
alongside these changes automatically:

```python
>>> grid = RasterModelGrid((5, 5))
>>> grid.set_closed_boundaries_at_grid_edges(False, True, False, True)
>>> grid.number_of_active_links
18
>>> grid.status_at_node[[6, 8]] = mg.BC_NODE_IS_CLOSED
>>> grid.status_at_node.reshape((5, 5))
array([[4, 4, 4, 4, 4],
       [1, 4, 0, 4, 1],
       [1, 0, 0, 0, 1],
       [1, 0, 0, 0, 1],
       [4, 4, 4, 4, 4]], dtype=int8)
>>> grid.number_of_active_links  # links were inactivated automatically when we closed nodes
12
```

Note that while setting Landlab boundary conditions on the grid is straightforward, it
is up to the individual developer of each Landlab component to ensure it is compatible
with these boundary condition schemes! Almost all existing components work fine with
core, closed, and fixed_value conditions, but some may struggle with fixed_gradient,
and most will struggle with looped. If you're working with the component library, take
a moment to check your components can understand your implemented boundary conditions!
See the {ref}`Component Developer's Guide <dev-contributing>` for more information.

## Using a Different Grid Type

As noted earlier, Landlab provides several different types of grid. Available grids
(as of this writing) are listed in the table below. Grids are designed using Python
classes, with more specialized grids inheriting properties and behavior from more
general types. The class hierarchy is given in the second column, **Inherits from**.

| Grid type             | Inherits from         | Node arrangement   | Cell geometry        |
| --------------------- | --------------------- | ------------------ | -------------------- |
| `RasterModelGrid`     | `ModelGrid`           | raster             | squares              |
| `VoronoiDelaunayGrid` | `ModelGrid`           | Delaunay triangles | Voronoi polygons     |
| `FramedVoronoiGrid`   | `VoronoiDelaunayGrid` | Delaunay triangles | Voronoi polygons     |
| `HexModelGrid`        | `VoronoiDelaunayGrid` | triagonal          | hexagons             |
| `RadialModelGrid`     | `VoronoiDelaunayGrid` | concentric         | Voronoi polygons     |
| `NetworkModelGrid`    | `ModelGrid`           | ad libitum         | No cells             |
| `IcosphereGlobalGrid` | `ModelGrid`           | spherical          | hexagons & pentagons |

{py:class}`landlab.grid.raster.RasterModelGrid <landlab.grid.raster.RasterModelGrid>`
gives a regular (square) grid, initialized
with *number_of_node_rows*, *number_of_node_columns*, and a *spacing*.
In a {py:class}`landlab.grid.voronoi.VoronoiDelaunayGrid <landlab.grid.voronoi.VoronoiDelaunayGrid>`,
a set of node coordinates
is given as an initial condition.
Landlab then forms a Delaunay triangulation, so that the links between nodes are the
edges of the triangles, and the cells are Voronoi polygons.
A {py:class}`landlab.grid.framed_voronoi.FramedVoronoiGrid <landlab.grid.framed_voronoi.FramedVoronoiGrid>`
is Voronoi grid where nodes coordinates are randomly moved from an initial rectangular regular grid.
A {py:class}`landlab.grid.hex.HexModelGrid <landlab.grid.hex.HexModelGrid>` is a
special type of VoronoiDelaunayGrid in which the Voronoi cells happen to be
regular hexagons.
In a {py:class}`landlab.grid.radial.RadialModelGrid <landlab.grid.radial.RadialModelGrid>`, nodes are created in concentric
circles and then connected to
form a Delaunay triangulation (again with Voronoi polygons as cells).
{py:class}`landlab.grid.network.NetworkModelGrid` represents a branching network of nodes and links,
without cells or patches.
An {py:class}`landlab.grid.icosphere.IcosphereGlobalGrid` represents the surface of a sphere.
The default configuration is a spherical grid of unit radius that
forms the spherical version an icosahedron (20 triangular patches,
12 nodes), with the dual complement representing a dodecahedron
(12 hexagonal cells, 20 corners). The mesh_densification_level
parameter allows you to densify this initial shape by subdividing
each triangular patch into four triangles, with corresponding
addition of nodes (as the triangle vertices), together with
corresponding cells and corners.

(importing-a-dem)=

## Importing a DEM

Landlab offers the methods
{py:func}`landlab.io.esri_ascii.read_esri_ascii <landlab.io.esri_ascii.read_esri_ascii>` and
{py:func}`landlab.io.netcdf.read_netcdf <landlab.io.netcdf.read_netcdf>` to allow ingestion of
existing digital elevation models as raster grids.

**read_esri_ascii** allows import of an ARCmap formatted ascii file (.asc or .txt)
as a grid.
It returns a tuple, containing the grid and the elevations in Landlab ID order.
Use the *name* keyword to add the elevation to a field in the imported grid.

```python
>>> from landlab.io import read_esri_ascii
>>> (mg, z) = read_esri_ascii("myARCoutput.txt", name="topographic__elevation")
>>> mg.at_node.keys()
['topographic__elevation']
```

**read_netcdf** allows import of the open source netCDF format for DEMs. Fields will
automatically be created according to the names of variables found in the file.
Returns a {py:class}`landlab.grid.raster.RasterModelGrid <landlab.grid.raster.RasterModelGrid>`.

```python
>>> from landlab.io.netcdf import read_netcdf
>>> mg = read_netcdf("mynetcdf.nc")
```

After import, you can use {py:func}`landlab.grid.base.ModelGrid.set_nodata_nodes_to_closed
<landlab.grid.base.ModelGrid.set_nodata_nodes_to_closed>`
to handle the boundary conditions in your imported DEM.

Equivalent methods for output are also available for both esri ascii
({py:func}`landlab.io.esri_ascii.write_esri_ascii <landlab.io.esri_ascii.write_esri_ascii>`)
and netCDF
({py:func}`landlab.io.netcdf.write_netcdf <landlab.io.netcdf.write_netcdf>`) formats.

(plotting-and-vis)=

## Plotting and Visualization

## Visualizing a Grid

Landlab offers a set of matplotlib-based plotting routines for your data. These exist
in the landlab.plot library. You'll also need to import some basic plotting functions
from pylab (or matplotlib) to let you control your plotting output: at a minimum **show**
and **figure**. The most useful function is called
{py:func}`landlab.plot.imshow.imshow_node_grid <landlab.plot.imshow.imshow_node_grid>`, and is imported
and used as follows:

```python
>>> from landlab.plot.imshow import imshow_node_grid
>>> from pylab import show, figure
>>> mg = RasterModelGrid((50, 50), 1.0)  # make a grid to plot
>>> z - mg.node_x * 0.1  # Make an arbitrary sloping surface
>>> mg.add_field(
...     "topographic_elevation", z, at="node", units="meters", copy=True
... )  # Create the data as a field
>>> figure("Elevations from the field")  # new fig, with a name
>>> imshow_node_grid(mg, "topographic_elevation")
>>> figure(
...     "You can also use values directly, not fields"
... )  # ...but if you, do you'll lose the units, figure naming capabilities, etc
>>> imshow_node_grid(mg, z)
>>> show()
```

Note that {py:func}`landlab.plot.imshow.imshow_node_grid <landlab.plot.imshow.imshow_node_grid>`
is clever enough to examine the grid object you pass it,
work out whether the grid is irregular or regular, and plot the data appropriately.

By default, Landlab uses a Python colormap called *'pink'*. This was a deliberate choice
to improve Landlab's user-friendliness to the colorblind in the science community.
Nonetheless, you can easily override this color scheme using the keyword *cmap* as an
argument to imshow_node_grid. Other useful built in colorschemes are *'bone'* (black
to white), *'jet'*, (blue to red, through green), *'Blues'* (white to blue), and
*'terrain'* (blue-green-brown-white) (note these names are case sensitive).
See [the matplotlib reference guide](https://matplotlib.org//examples/color/colormaps_reference.html) for more options.
Note that imshow_node_grid takes many of the same keyword arguments as, and is designed
to resemble, the standard matplotlib function [imshow](https://matplotlib.org//users/image_tutorial.html). See also the method help for more
details.
In particular, note you can set the maximum and minimum you want for your colorbar using
the keywords *vmin* and *vmax*, much as in similar functions in the matplotlib library.

**Note if using Anaconda**: there have been documented issues with resolution with default inline plotting within the Spyder IDE iPython console. To generate dynamic plots (e.g. Matlab-like plots), change the graphics settings in Spyder by following this work flow:

In *Spyder -> Preferences -> iPython console -> Graphics -> Graphics Backend -> Automatic -> Apply -> OK -> Make sure to restart Spyder to update the preferences.*

## Visualizing transects through your data

If you are working with a regular grid, it is trivial to plot horizontal and vertical
sections through your data. The grid provides the method
{py:func}`landlab.grid.raster.RasterModelGrid.node_vector_to_raster <landlab.grid.raster.RasterModelGrid.node_vector_to_raster>`,
which will turn a Landlab 1D node data array into a two dimensional rows\*columns NumPy array,
which you can then take slices of, e.g., we can do this:

```python
>>> from pylab import plot, show
>>> mg = RasterModelGrid((10, 10), 1.0)
>>> z = mg.node_x * 0.1
>>> my_section = mg.node_vector_to_raster(z, flip_vertically=True)[:, 5]
>>> my_ycoords = mg.node_vector_to_raster(mg.node_y, flip_vertically=True)[:, 5]
>>> plot(my_ycoords, my_section)
>>> show()
```

## Visualizing river profiles

See the {py:class}`ChannelProfiler <landlab.components.profiler.ChannelProfiler>`
component.

## Making Movies

Landlab does have an experimental movie making component. However, it has come to the
developers' attention that the matplotlib functions it relies on in turn demand that
your machine already has installed one of a small set of highly temperamental open
source video codecs. It is quite likely using the component in its current form is
more trouble than it's worth; however, the brave can take a look at the library
{py:mod}`landlab.plot.video_out <landlab.plot.video_out>`. We intend to improve
video out in future Landlab releases.

For now, we advocate the approach of creating an animation by saving separately
individual plots from, e.g., **plot()** or
{py:func}`landlab.plot.imshow.imshow_node_grid <landlab.plot.imshow.imshow_node_grid>`,
then stitching them together
into, e.g., a gif using external software. Note it's possible to do this directly from
Preview on a Mac.



================================================
File: docs/source/user_guide/grid_summary.md
================================================
(api-grid-grid-summary)=

# List of Grid Methods

## Getting Information about a Grid

The following attributes, properties, and methods provide data about the grid,
its geometry, and the connectivity among the various elements. Each grid
element has an ID number, which is also its position in an array that
contains information about that type of element. For example, the *x*
coordinate of node 5 would be found at `grid.x_of_node[5]`.

The naming of grid-element arrays is `<attribute>_at_<element>`, where
*attribute* is the name of the data in question, and *element* is the element
to which the attribute applies. For example, the property {meth}`~.RasterModelGrid.node_at_cell`
is an array of length *number_of_cells* where each element of the array
is the *ID* of the node associated with that cell.
(e.g. `node_at_cell[3]` is the *ID* of the node associated with cell 3).
In this case the *attribute* is singular since there is only one value per element.
Sometimes there are multiple attributes associated with each element. In this
case, the attribute is plural. For example, the {meth}`~.RasterModelGrid.faces_at_cell` array
contains multiple faces for each cell. Exceptions to these general rules are
functions that return indices of a subset of all elements of a particular type.
For example, you can obtain an array with *IDs* of only the core nodes using
{meth}`~.RasterModelGrid.core_nodes`, while {meth}`~.RasterModelGrid.active_links` provides an array
of *IDs* of active links (only). Finally, attributes that represent a measurement
of something, such as the length of a link or the surface area of a cell, are
described using `_of_` (e.g. {meth}`~.RasterModelGrid.area_of_cell`).

## Fields

{class}`~.ModelGrid` inherits from the {class}`~.GraphFields` class. This
provides {class}`~.ModelGrid`, and its subclasses, with the ability to, optionally,
store data values associated with the different types grid elements
(nodes, cells, etc.). In particular, as part of {meth}`~.ModelGrid.__init__`,
data field *groups* are added to the {class}`~.ModelGrid` that provide containers to
put data fields into. There is one group for each of the eight grid elements
(node, cell, link, face, core_node, core_cell, active_link, and active_face).

```{toctree}
:caption: Summary of grid methods
:glob: true
:hidden: true

grid_methods/*
```



================================================
File: docs/source/user_guide/index.md
================================================
(user-guide)=

# User Guide

The User Guide describes Landlab by topic area.

Users brand-new to Landlab should start with {ref}`10min`.

Further information on any specific method can be obtained in the
{ref}`api`.

The Landlab project creates an environment in which scientists can build a
numerical surface process model without having to code all of the individual
components. Surface process models compute flows of mass, such as water, sediment,
glacial ice, volcanic material, or landslide debris, across a gridded terrain
surface. Surface process models have a number of commonalities, such as operating
on a grid of points and routing material across the grid. Scientists who want
to use a surface process model often build their own unique model from the ground
up, re-coding the basic building blocks of their surface process model rather than
taking advantage of codes that have already been written.

A list of papers and presentations using Landlab can be found {ref}`here <papers>`.

```{toctree}
:caption: Grids and Components
:hidden: true
:maxdepth: 2

Grid & Component reference <reference/index>
component_list
field_definitions
grid_summary
```

```{toctree}
:caption: The Landlab Grid
:hidden: true
:maxdepth: 2

grid
```

```{toctree}
:caption: Model with Landlab and Components
:hidden: true
:maxdepth: 2

components
build_a_model
```

```{toctree}
:caption: Landlab and Units
:hidden: true
:maxdepth: 2

units
```

```{toctree}
:caption: Additional resources
:hidden: true
:maxdepth: 2

time_steps
faq
```

```{toctree}
:caption: Overland flow User Guide
:hidden: true
:maxdepth: 2

overland_flow_user_guide
```

```{toctree}
:caption: CellLab-CTS User Guide
:hidden: true
:maxdepth: 2

cell_lab_user_guide
```



================================================
File: docs/source/user_guide/move_files_to_rst.py
================================================
#!/usr/bin/env python3
"""
Created on Thu Sep 19 18:31:09 2019

@author: barnhark
"""

import glob
import os
import subprocess

files = glob.glob("*.md")
for file in files:
    args = [
        "pandoc",
        "--from=markdown",
        "--to=rst",
        "--output=" + file.replace("md", "rst"),
        file,
    ]
    subprocess.call(args)
    os.remove(file)

files = glob.glob("*.rest")
for file in files:
    os.rename(file, file.replace("rest", "rst"))



================================================
File: docs/source/user_guide/overland_flow_user_guide.md
================================================
(overland-flow-manual)=

# Overland Flow Component User Manual

## Background on OverlandFlow component

The Landlab OverlandFlow component implements a 2-D solution of the shallow water equations, following the algorithm of de Almeida et al., (2012). In this component, an explicit solution simulates a flood wave moving across a gridded terrain, capturing hydrodynamics throughout the system. At each point within the grid, surface water discharge is calculated based on physical properties. This component expands the hydrologic capabilities of Landlab by offering a nonsteady flow routing method as an alternative to the steady-state flow routing regimes found in many geomorphic or landscape evolution models
(such as the Landlab {py:class}`FlowAccumulator<landlab.components.flow_accum.FlowAccumulator>` component).

This User Manual describes how to instantiate, parameterize and plot data using the OverlandFlow component, using an example described in Adams et al., (in press, *Geoscientific Model Development*). For further information about the derivation of the algorithm used in this component, see: Bates et al., (2010) and de Almeida et al., (2012).

**Note**: Currently, the OverlandFlow component can only operate on a structured grid, and so all references to the grid below are specifically referring to the Landlab RasterModelGrid module.

*Prerequisites*: A working knowledge of the Python programming language (any version) and familiarity with the Python libraries NumPy and Matplotlib. A basic understanding of the Landlab modeling framework (Hobley et al., 2017) is also recommended.

## Model parameters and variables

**Input parameters**

Parameters listed here are easily tuned by the model user. For a complete list, see
{py:mod}`here<landlab.components.overland_flow>`.

- **Alpha** : Weight on the adaptive time step, ranging between 0.2 - 0.7. For more information, see Hunter et al., (2005).
- **Manning's n** : An empirical value describing surface roughness. See Chow (1959).
- **Theta** : A weighting factor in the de Almeida et al., (2012) equation, suggested value between 0.8 and 0.9

**Model variables**

Variables listed here are updated by the component at the grid locations listed.

- **surface_water\_\_discharge**, *link*, \[m^2 s^-1\] : At each link in grid, *surface_water\_\_discharge* is calculated using the de Almeida et al., (2012) equation. Discharge is a function of the water depth, adaptive time step, surface water slope and Manning's roughness coefficient.
- **surface_water\_\_depth**, *node*, \[m\] : At each node in the grid, *surface_water\_\_depth* is updated using the *surface_water\_\_discharge* on links connected to a given node.

## Basic steps of an OverlandFlow model

1. **Import the necessary libraries**: `OverlandFlow` is required. Optional libraries include the `SinkFiller` component, the Landlab plotting method `imshow__grid`. Additional packages mentioned here include `matplotlib.pyplot` and `numpy`.
2. **Defining the model domain**: The computational domain of an OverlandFlow model can only work on RasterModelGrid instances as of Landlab version 1.0.0.
3. **Setting the boundary conditions**: If a clipped watershed digital elevation model (DEM) from ArcGIS is imported in ASCII format, the method `set_watershed_boundary_condition()` can be used. Alternatively, `fixed_link` boundary conditions can be used for discharge inputs on links. Other boundary condition scenarios can be accommodated by setting individual nodes or edges of the grid using Landlab boundary condition handling.
4. **Pre-processing the DEM**: This step is *optional*. If a watershed DEM is used, ArcGIS "D8" pit-filling will not create a continuous network for the "D4" `OverlandFlow` algorithm. The `SinkFiller` component can pit fill for a "D4" network.
5. **Initializing the OverlandFlow component**: The instance of the `OverlandFlow` class is declared, and parameters are set by the user.
6. **Determining precipitation inputs**: A constant precipitation rate can be passed to the `OverlandFlow` class, where precipitation persists for the entire model run. Alternatively, a single event can be set within the time loop, and then water can drain from the system when the precipitation event is over.
7. **Time loop**: The main `OverlandFlow` methods are called, and grid variables are updated through time. Data can be saved for plotting or later analysis.

### Step 1. Import the necessary libraries

To build an OverlandFlow model, first the necessary Landlab components and utilities, as well as any necessary Python packages must be imported. Standard Python style dictates all import statements belong in the top of the driver file, after the module docstrings. In this simple example, the OverlandFlow model driver begins as follows:

```python
"""overland_flow_driver.py

OverlandFlow component example, initializing a 36 km^2 square watershed with a
grid resolution of 30 m, from an ESRI ASCII file, simulating a 5 mm/hr rainfall
intensity over 2 hours, the standard storm example from Adams et al.,
in prep for Geoscientific Model Development

Written by Jordan Adams, August 2016
"""

## Landlab components
from landlab.components import OverlandFlow, SinkFiller  # SinkFiller is optional

## Landlab utilities
from landlab.io import read_esri_ascii  # OR from landlab import RasterModelGrid
from landlab.plot import imshow_grid  # plotter functions are optional

## Additional Python packages
import numpy as np
from matplotlib import pyplot as plt  # plotter functions are optional
```

To run the test case presented here, two components are needed. First is the required `OverlandFlow` component, which will be used to calculate surface water discharge and surface water depth across the model grid. Also presented here is the `SinkFiller` component, which can be used optionally to pre-process the DEM. The `SinkFiller` component is described in more detail in **Step 4** of this Users Manual.

To create a model domain, a Landlab RasterModelGrid instance must be initialized. In this example, the Landlab input/output suite of tools is used to read in a DEM that is formatted as an ESRI ASCII file `read_esri_ascii`). Alternatively, a model domain can be manually created by the user. Both of these methods are described in detail in **Step 2** of this Users Manual.

Other Landlab utilities used in this example are the plotting library `imshow_grid`, which is a utility that can plot a Landlab grid instance and data field in map view, as described in the **Plotting and visualization** section in this Users Manual.

Finally, additional Python packages are imported. In this example, both packages are dependencies of Landlab, which means they are required for Landlab installation and as such, should already be present on the user's machine. The scientific computing library NumPy is used for mathematical operations, and the matplotlib library is used for plotting model output.

### Step 2. Defining the model domain

As previously stated, the algorithm used in the OverlandFlow component was derived to work on remotely-sensed data and, as such, only works on the RasterModelGrid instance in Landlab (e.g. Bates et al., 2010, de Almeida et al., 2012). Shown here is an example of a Landlab raster grid:

```{image} images/RasterGrid_Directions.png
:align: center
:width: 300px
```

**Figure** 1: Example of a Landlab RasterModelGrid instance. Each RasterModelGrid is composed of 3 core elements: nodes, which are points in (x, y) space; cells, a polygon with an area around a node; and links, ordered lines which connect neighboring pairs of node that store directionality.

There are two ways to implement a RasterModelGrid that work with Landlab: reading in remotely-sensed data from a DEM with `read_esri_ascii()`, or manually setting a generic structured grid using the RasterModelGrid library. Both of these methods are described in detail below.

#### Reading in a watershed DEM

Landlab can easily interact with DEM data output by ESRI's ArcGIS software. In this example, the DEM 'Square_TestBasin.asc' represents a single watershed. Reading in the data takes two lines of code, outlined here:

```python
watershed_dem = "Square_TestBasin.asc"
(rmg, z) = read_esri_ascii(watershed_dem, name="topographic__elevation")
```

In this example, the watershed DEM is read in by the `read_esri_ascii()` method, and the elevation data from the DEM is automatically assigned to the Landlab data field `topographic__elevation`, for use by the components.

#### Setting up a generic RasterModelGrid

The alternative to reading in a watershed DEM is to set the RasterModelGrid instance manually:

```python
rmg = RasterModelGrid((number_of_node_rows, number_of_node_columns), dx)
z = user_defined_elevation_data  # length of number_of_nodes
rmg["node"]["topographic__elevation"] = z
```

This example assumes that the model users knows the following information: the number of grid rows (`number_of_grid_rows`), the number of grid columns (`number_of_grid_columns`), the grid resolution (`dx`) and some elevation data for each node. Here, the user must manually set the elevation data. When passing elevation data to the  `topographic__elevation` field, the length of `user_defined_elevation_data` **must** be equal to the number of nodes in the grid (which can be found using a command such as: `rmg.number_of_nodes`.

### Step 3. Setting the boundary conditions

Landlab contains several methods which can set and update boundary conditions
at *node* and *link* grid elements. When modeling water flow across a grid, a
user needs to predetermine locations where water can and cannot flow. If a user
reads in a single watershed DEM, (as described in **Step 2**), there is a
utility within Landlab that can handle the specific boundary conditions needed
to control flow:

```python
rmg.set_watershed_boundary_condition(z, nodata_values=-9999.0)
```

By definition, a watershed has only one outlet, or open boundary location,
and therefore all other nodes surrounding the watershed will be closed, or
no flux, boundaries.
The `set_watershed_boundary_condition()` method reads the gridded elevation
data, (`z`), identifies the watershed outlet and sets it to an open boundary
(identified by the grid attribute `grid.BC_NODE_IS_FIXED_VALUE` in Landlab).
An open boundary allows flux to leave the modeling domain.  Additionally, this
methods also identifies all NODATA nodes (given a default value of -9999) and
sets them to closed, or no flux, boundaries.

**Note**: As of Landlab version 1.0.0., this method only works on single
watersheds, and so assumes that the watershed has been clipped in ArcGIS and
has only one outlet point.

#### Other boundary condition options

There are other options for boundary condition handling that are more
appropriate for non-DEM modeling domains. (For a complete review of boundary
condition handling in Landlab, review Hobley et al., in submission for
*Earth Surface Dynamics* or Landlab
{ref}`boundary <api-grid-grid-summary-bc>` condition documentation

Here, the `FIXED_GRADIENT` boundary condition is described. The
`set_nodata_nodes_to_fixed_gradient()` method sets all NODATA nodes to
`FIXED_GRADIENT`, and all boundary links (links that connect core nodes
within the model domain to a fixed gradient nodes) are set to `FIXED_LINK`
status. Then, boundary links can be updated with some input discharge value:

```python
rmg.set_nodata_nodes_to_fixed_gradient(z)
rmg.fixed_links = input_discharge_value
```

This boundary condition can be useful because of how the underlying algorithm in OverlandFlow (de Almeida et al., 2012) updates discharge at each time step. In this model, discharge is calculated as a function of the neighboring discharge values:

```{image} images/deAlmeidaGridExample.png
:align: center
:width: 300px
```

**Figure 2**: The algorithm from de Almeida et al., (2012) uses discharge information on neighboring links to calculate discharge. Fixed link boundary conditions allow the user to set discharge on links along the boundary, so that the interior discharges can be updated using those manually-set fluxes.

In this example, calculating discharge on q{sub}`x` requires discharge values q{sub}`x-1` and q{sub}`x+1`. If a link is along the boundary of the domain, the default value is 0. Fixed link boundary statuses allow the user to manually update the discharge value at a boundary link, to simulate some influx of water discharge into the model domain.

If the user desires, these fixed links can also be updated to contain flux value of their nearest interior neighbor. Following the earlier example, if discharge q{sub}`x-1` is at on a fixed boundary link, it can be updated to contain the value of its neighboring discharge q{sub}`x`. This is done exclusively in the OverlandFlow component. The user simply needs to call  `default_fixed_links = True` when initializing the `OverlandFlow` component, as described in **Step 5**. This method prevents flow from exiting the edge of the watershed onto NODATA nodes, and does not set an outlet node by default. If the user wants to set an outlet node to an open boundary, that must be done manually, not described here.

### Step 4. Pre-processing the DEM (*Optional*)

When modeling surface flow across a DEM and the user wants to ensure all water drains out of the system (that is, water is not trapped in pits or holes on the DEM surface), there must be a continuous flow path. In many applications, flow is allowed to exit a node in 8 directions ('D8'): the cardinal directions (East, North, West, South) and the diagonal directions (Northeast, Northwest, Southwest, Southeast). However, this model restricts flow to only the cardinal directions ('D4'). To create a continuous flow network, GIS applications often include a pit-filling regime to remove divots in the DEM surface so water can exit the pit and travel to the outlet. In ArcGIS, this pit-filling regime operates in 'D8':

```{image} images/D8_vs_D4.png
:align: center
:width: 300px
```

**Figure 3**: Comparison of 'D8' and 'D4' flow routing methods. The key difference: in 'D8' methods, flow can move diagonally out of a given node.

However, in Landlab version 1.0.0., the OverlandFlow component is limited to the 'D4' regime. If a watershed DEM has been processed in ArcGIS, the flow network most likely follows a 'D8' path. When using the OverlandFlow component on a 'D8' network, the flow path may not be continuous.

To address this discrepancy, the SinkFiller component in Landlab has been developed to accommodate both 'D8' or 'D4' pit-filling on a DEM. Running this component can take some time, particularly on large grids, so it is *optional* to run the OverlandFlow component. This component can be applied to our DEM in two lines of code, initializing the SinkFiller component and running the `fill_pits()` method:

```python
sf = SinkFiller(rmg, routing="D4", apply_slope=True, fill_slope=1.0e-5)
sf.fill_pits()
```

**Note**: For more information about the SinkFiller {py:class}`component <landlab.components.sink_fill.SinkFiller>`.

### Step 5. Initializing the OverlandFlow component

Most Landlab components are structured as a Python class. These classes are imported (as seen in **Step 1**) and then the user must create an instance of the class:

```python
of = OverlandFlow(rmg, mannings_n=0.03, steep_slopes=True)
```

When the instance of the class is created, parameters are passed as keywords to the class. All Landlab components take a grid as their first argument. All subsequent keywords are parameters used to control model behavior. Each Landlab component has documentation which lists the parameters. The OverlandFlow documentation is linked in the **Model description** section above. The example script shown here includes  parameters *Manning's n*, which takes a numerical value, and the stability criterion `steep_slopes` flag, which is passed a Boolean (`True` or `False`) value. Details about the stability criterion are provided in the next subsection.

#### Stability criteria

The OverlandFlow component is built off the de Almeida et al., (2012) algorithm for urban flood inundation, and is most stable in flat environments. Because of this, instabilities can arise when trying to apply the algorithm to steep landscapes. To adapt this model for use across a variety of terrains, stability criteria (following Coulthard et al., 2013) is implemented to using the `steep_slopes` flag. This method reduces flow discharge to keep flow subcritical according to the Froude number less than or equal to 1.0. For more information, see Adams et al., (in prep for *Geoscientific Model Development*).

### Step 6. Precipitation inputs

Often, the user will want to route a precipitation event or a series of precipitation events across a watershed.There are two methods for setting precipitation parameters in the OverlandFlow component.

**Note**: At the moment, only uniform precipitation events have been tested using this component.

#### Constant precipitation input

This is the simplest method, and is used when a constant precipitation intensity is routed for the entirety of a model run (model_run_time). In this example, rainfall\_\_intensity (units \[m s{sup}`-1`\]) is passed when the OverlandFlow component is initialized (**Step 5**):

```python
elapsed_time = 0.0
model_run_time = 86400.0
of = OverlandFlow(
    rmg, steep_slopes=True, rainfall_intensity=1.38889 * (10**-6)
)  # m/s
```

#### Single storm event

Alternatively, a user may decide to route an event where rainfall stops, and water drains from the system. The simplest case is a single storm event, presented here:

```python
elapsed_time = 0.0
model_run_time = 86400.0

storm_duration = 7200.0
rainfall_mmhr = 5.0
```

In this example, storm characteristics (duration and intensity) are set separately from the OverlandFlow component  initialization. These characteristics are used in a time loop within the model driver (seen in **Step 7**). While elapsed_time in a model is less than storm duration, the precipitation intensity is input across all nodes in the model domain. When the storm event ends, the precipitation intensity is reset to 0 \[m s{sup}`-1`\], allowing the water remaining in the system to drain out.

### Step 7. Iterate through time

The key part of any Landlab model driver is the time loop, where components recalculate the processes, and update their necessary data values. In the OverlandFlow component, during a time loop, at each time step, surface water discharge and surface water depth are recalculated. A simple example of an OverlandFlow time loop is presented here:

```python
while elapsed_time < model_run_time:
    of.dt = of.calc_time_step()  # Adaptive time step

    if elapsed_time < (storm_duration):
        of.rainfall_intensity = rainfall_mmhr * (2.777778 * 10**-7)
    else:
        of.rainfall_intensity = 0.0

    of.overland_flow()

    rmg.at_node["surface_water__discharge"] = of.discharge_mapper(
        of.q, convert_to_volume=True
    )

    elapsed_time += of.dt
```

This code snippet is described here:

- This OverlandFlow example loops through time as a `while` loop. After each time loop, `elapsed_time` is increased until it exceeds `model_run_time`.
- An adaptive time step is recommended, and is calculated here at the start of each time loop. (See the next subsection for more information about the adaptive time step).
- Inside the time loop, there is a test to see if the `elapsed_time` is less than the `storm_duration`. If so, the rainfall intensity property of OverlandFlow is updated to the rainfall intensity (here converted from \[mm hr{sup}`-1` to \[m s{sup}`-1`).
- If the `elapsed_time` is greater than the `storm_duration`, the rainfall intensity parameter of the OverlandFlow component is reset to 0 \[m s{sup}`-1`\].
- After the rainfall intensity is set, the actual process method `overland_flow()` is called. This method calculate discharge as a function of the de Almeida et al., (2012) algorithm and updates the Landlab data fields for `surface_water__discharge` and `surface_water__depth` on links and nodes respectively.
- To translate the discharge values calculated on Landlab links to nodes, values on links (`of.q`) are summed and mapped to their node neighbors using the method `of.discharge_mapper`. Using the `convert_to_volume` flag, these discharge values are converted from units of \[m{sup}`2` s{sup}`-1`\] to \[m{sup}`3` s{sup}`-1`\].
- At the end of each loop, `elapsed_time` is updated with the adaptive time step.

**Note**: If using the adaptive time step, it may be possible that both the storm duration and model run time may be exceeded if the calculated time step is too large. It is recommended the use add additional logic tests to ensure both the storm_duration and model_run_time are not exceeded. during the time loop.

#### Adaptive time step

de Almeida et al., (2012) implement an adaptive time step to maintain model stability and computational efficiency. This adaptive time step follows Hunter et al., (2005). By default, the OverlandFlow component calculates this adaptive time step. It is listed explicitly the **Step 7** code for clarity. If that lines was removed from that code, the component would still call `calc_time_step()` every time the `overland_flow()` method is called.

Alternatively, an explicit time step can be passed to the `overland_flow()` method. However, this method cannot guarantee model stability. Numerical instability in the model can drive surface water depth 'checkerboarding' patterns. Additionally, water mass imbalances can be linked to model instability. If an explicit time step must be used, a small time step is recommended to maintain model stability.

**Note**: Model behavior can vary across different parameter space and grid resolution. Stability testing is always recommended.

## Plotting and visualization

### Hydrographs

#### Before time loop:

To plot a hydrograph, the user simply needs to save the discharge value at a given link at each time step. This can be achieved using a Python list object. Before the time loop starts, the user initializes at least two loops, one to save the model time, and one to save the discharge value.

**Note**: Currently, this plotting solution assumes the user has identified a link to sample on. In this example, the active link connecting outlet node to its neighbor core node is selected. If, in other DEMs, more than one active link is identified on the outlet node, the link with the steepest topographic slope is recommended.

```python
hydrograph_time = []
discharge_at_outlet = []
```

#### During time loop:

The OverlandFlow component calculates discharge in units of \[m{sup}`2` s{sup}`-1`\]. In this example (and in Adams et al., *in prep. for Geoscientific Model Development*), discharge is plotted as a volumetric flux. To convert the calculated discharge (*q*) to a volumetric discharge (*Q*), it can be multiplied by the fact width, or grid resolution (*dx*) of the model grid. Similarly, time is converted from units of seconds (*s*) to hours (*hr*)

```python
hydrograph_time.append(elapsed_time / 3600.0)  # convert seconds to hours
discharge_at_outlet.append(
    np.abs(of.q[outlet_link]) * rmg.dx
)  # append discharge in m^3/s
```

#### After model run:

Once the model is done running, the hydrograph can be plotted using the matplotlib library. This is a simple example, for more customization options, we recommend the matplotlib [documentation].

```python
plt.plot(hydrograph_time, discharge_at_outlet)
plt.ylabel("Time (hr)")
plt.xlabel("Discharge, (cms)")
plt.title("Outlet Hydrograph, Rainfall: 5 mm/hr in 2 hr")
```

```{image} images/OverlandFlow_Manual_Hydrograph.png
:align: center
:width: 300px
```

**Figure 4**: Sample hydrograph from the test basin, after a storm with intensity of 5 mm/hr for a duration of 2 hr.

### Water depth maps

The Landlab plotting library includes a utility `imshow__grid` which can easily take a grid instance and plot data values from the grid in map view. This method also allows for customization of the plots. An example plotting water depth is shown here:

```python
imshow_grid(
    rmg,
    "surface_water__depth",
    plot_name="Water depth at time = 2 hr",
    var_name="Water Depth",
    var_units="m",
    grid_units=("m", "m"),
    cmap="Blues",
)
```

```{image} images/OverlandFlow_Manual_WaterDepth.png
:align: center
:width: 300px
```

**Figure 5**: Map of water depths at time = 2 hr, for the sample storm on the square basin (5 mm/hr over duration of 2 hr).

In this example, the water depths are plotted after 2 hours of model run time
`model_run_time` = 7200 s in **Step 6**). The method `imshow__grid` takes a
grid instance and data field by default. Optional methods displayed here
include plot title, color bar title (`var__name`), color bar units
(`var__units`), grid dimension units (`grid_units`), and
matplotlib color map (`cmap`).

**Note**: As of right now, `imshow__grid` plots data on nodes and cells.
If the user wants to plot data from link elements, a mapper from link to cell
or link to node must be used first. An extensive list of Landlab
{ref}`mapper <api-grid-grid-summary-mappers>` methods is available in the documentation.

## References

Adams, J. M., Gasparini, N. M., Hobley, D. E. J., Tucker, G. E., Hutton, E. W. H., Nudurupati, S. S. and Istanbulluoglu, E. (2017) The Landlab OverlandFlow component: a Python library for modeling the shallow water equations across watersheds, in press.

Bates, P. D., Horritt, M. S., & Fewtrell, T. J. (2010). A simple inertial formulation of the shallow water equations for efficient two-dimensional flood inundation modelling. *Journal of Hydrology*, 387(1), 33-45.

Chow, V.T., 1959, Open-channel hydraulics: New York, McGraw-Hill, 680 p.

Coulthard, T. J., Neal, J. C., Bates, P. D., Ramirez, J., Almeida, G. A., and Hancock, G. R. (2013). Integrating the LISFLOOD-FP 2D hydrodynamic model with the CAESAR model: implications for modelling landscape evolution. *Earth Surface Processes and Landforms*, 38(15), 1897-1906.

de Almeida, G. A., Bates, P., Freer, J. E., & Souvignet, M. (2012). Improving the stability of a simple formulation of the shallow water equations for 2‐D flood modeling. *Water Resources Research*, 48(5).

Hobley, D. E. J., Adams, J. M., Nudurupati, S. S., Gasparini, N. M.,  Hutton, E. W. H., Istanbulluoglu, E. and Tucker, G. E. (2017) Landlab: a new, open-source, modular, Python-based tool for modelling Earth surface dynamics. *Earth Surface Dynamics*, 5(1), 21–46.

Hunter, N. M., Horritt, M. S., Bates, P. D., Wilson, M. D., & Werner, M. G. (2005). An adaptive time step solution for raster-based storage cell modelling of floodplain inundation. *Advances in Water Resources*, 28(9), 975-991.

[documentation]: https://matplotlib.org//api/pyplot_api.html



================================================
File: docs/source/user_guide/time_steps.md
================================================
(time-steps)=

# Time steps

Anyone who has taken a numerical computing course knows the importance of
time-step size: choose too small a step and your calculation takes forever to
run; choose too big a step and it goes unstable. The details depend, of course,
on the particular equations and the numerical method used to solve them.

## Components and time steps

Landlab components are responsible for ensuring their own stability. This
means, for example, that if your code asks a component to run for 10 years, the
component needs to make sure 10 years isn't too big a step to handle. If it is,
the component should subdivide the 10 years into smaller steps that are stable
and accurate. For example, if the component determines that 1 year is the
biggest step it can get away with, then it should divide the requested 10-year
run into 10 steps of 1 year each. If the component uses variable-size time
steps, then it should subdivide the 10 years as it needs, and return when it
has used up exactly 10 years.

Even if each component ensures its own stability, it is still possible for a
multi-component model to get into trouble by using "global" time steps that
are too large. The risk arises because during each global time step, you are
effectively de-coupling the components for a small interval of time. For
example, suppose you have one component that calculates solar radiation on a
landscape and another that calculates the resulting evapotranspiration (ET).
When you run the ET component, you assume that the radiation is constant for
the duration of the time step—as if the sun's position in the sky became frozen
for that period of time. That's probably a reasonable assumption if your time
step is 5 minutes long, but obviously problematic if you time step is 12 hours!
The moral of the story: test your model with different global time-step sizes
to identify a time step that is small enough not to impact the solution in a
significant way.

To learn more about time steps, numerical stability, and solution accuracy, a
good source is [Numerical Recipes by Press et al](http://numerical.recipes/).
There are also plenty of textbooks on numerical computing available.



================================================
File: docs/source/user_guide/units.md
================================================
(unit-agnostic)=

# How Landlab Is/Is Not Unit Agnostic

This page describes how Landlab handles units. Our approach is intended to
balance usability, effective communication of component expectations to users,
and a low barrier for developers.

Component inputs and outputs with units may be fields (arrays stored on the
grid), or arguments/keyword arguments to the component instantiation and run
functions.

All components require that a user is consistent between the space/time/mass
units used within one and across multiple components. For example, if you were
to couple a `StreamPowerEroder` and a `LinearDiffuser` your x, y, and z
coordinates, the field `topographic__elevation` and all input parameters would
need to share a common length unit. Further, input parameters with units that
include time and your time step would need to share a common time unit.

Components that require that you are consistent with units but do not care
whether you use feet or meters for your length unit are called "unit agnostic".
You can find out if a component is unit agnostic by querying the attribute:
`Component.unit_agnostic` which will return `True` or `False`.

Unit agnostic components will provide specific units in the field and parameter
metadata. However, no computation within a unit agnostic component assumes a
specific unit. If you provide a consistent set of inputs, you can use whichever
units you prefer. Note that this may require specifying ALL keyword arguments
(e.g., if gravitational acceleration as 9.81 m/s^2 is a default value, you must
provide 32.2 ft/s^2 as an input if you want to use feet as your length unit).

In contrast to unit-agnostic components, non-unit-agnostic components REQUIRE
that a specific set of units be used. This typically occurs because built into
the source code of the computation are assumptions or conversions about the
units of inputs.

When it doubt, the best approach is to open a GitHub issue.

Below is a list of non-unit agnostic components:

```{jinja} llcats
{% for name, component in components |dictsort %}
{% if not component['unit_agnostic'] %}
* {{"{"}}class{{"}"}}`{{name}} <{{ component['name'] }}>`
{% endif %}
{% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/01_nodes_links_patches.md
================================================
# Nodes, Links, and Patches

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    {% for cat, label in [('info-node', 'Nodes'), ('info-link', 'Links'), ('info-patch', 'Patches')] %}

      .. tab:: {{label}}

        .. autosummary::
          :nosignatures:

          {% for func in grids[grid][cat] %}
            ~{{func | replace("landlab.", "")}}
          {% endfor %}
    {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/02_corners_faces_cells.md
================================================
# Corners, Faces, and Cells

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    {% for cat, label in [('info-corner', 'Corners'), ('info-face', 'Faces'), ('info-cell', 'Cells')] %}

      .. tab:: {{label}}

        .. autosummary::
          :nosignatures:

          {% for func in grids[grid][cat] %}
            ~{{func | replace("landlab.", "")}}
          {% endfor %}
    {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/03_boundary_conditions.md
================================================
(api-grid-grid-summary-bc)=

# Boundary conditions

These are the primary properties for getting and setting the grid boundary
conditions. Changes made to {meth}`~.ModelGrid.status_at_node` automatically
update the conditions defined at other grid elements.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    .. autosummary::
      :nosignatures:

      {% for func in grids[grid]['boundary-condition'] %}
        ~{{func | replace("landlab.", "")}}
      {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/04_element_subsets.md
================================================
# Subsets of elements

These methods are useful in identifying subsets of grid elements, e.g., closest node
to a point; nodes at edges.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    .. autosummary::
      :nosignatures:

      {% for func in grids[grid]['subset'] %}
        ~{{func | replace("landlab.", "")}}
      {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/05_element_mapping.md
================================================
(api-grid-grid-summary-mappers)=

# Mapping between elements

These methods allow mapping of values defined on one grid element onto a
second, e.g., mapping upwind node values onto links, or mean link values onto
nodes.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    .. autosummary::
      :nosignatures:

      {% for func in grids[grid]['map'] %}
        ~{{func | replace("landlab.", "")}}
      {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/06_gradients.md
================================================
# Gradients, fluxes, and divergences

Landlab is designed to easily calculate gradients in quantities across the
grid, and to construct fluxes and flux divergences from them. Because these
calculations tend to be a little more involved than property lookups, the
methods tend to start with `calc_`.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    .. autosummary::
      :nosignatures:

      {% for func in grids[grid]['gradient'] %}
        ~{{func | replace("landlab.", "")}}
      {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/07_surface_analysis.md
================================================
# Surface analysis

These methods permit the kinds of surface analysis that you might expect to
find in GIS software.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    .. autosummary::
      :nosignatures:

      {% for func in grids[grid]['surface'] %}
        ~{{func | replace("landlab.", "")}}
      {% endfor %}
  {% endfor %}
```



================================================
File: docs/source/user_guide/grid_methods/08_fields.md
================================================
# Fields

{class}`~.ModelGrid` inherits several useful methods for creating new data
fields and adding new data fields to a {class}`~.ModelGrid` instance. Methods to add or
create a new data array follow the `numpy` syntax for creating arrays. The
following methods create and, optionally, initialize new arrays. The size of the
new array is determined by the *at* keyword, which indicates on which element
the array is defined. Methods with the prefix `add_` will add the newly created
field to the grid, otherwise a newly-created array is **not** added to the grid.

```{eval-rst}
.. tab:: Create

    .. autosummary::
        :nosignatures:

        ~landlab.grid.base.ModelGrid.add_empty
        ~landlab.grid.base.ModelGrid.add_field
        ~landlab.grid.base.ModelGrid.add_ones
        ~landlab.grid.base.ModelGrid.add_zeros
        ~landlab.grid.base.ModelGrid.delete_field
        ~landlab.grid.base.ModelGrid.empty
        ~landlab.grid.base.ModelGrid.ones
        ~landlab.grid.base.ModelGrid.zeros
```

```{eval-rst}
.. tab:: Access

    .. autosummary::
        :nosignatures:

        ~landlab.grid.base.ModelGrid.at_cell
        ~landlab.grid.base.ModelGrid.at_corner
        ~landlab.grid.base.ModelGrid.at_face
        ~landlab.grid.base.ModelGrid.at_link
        ~landlab.grid.base.ModelGrid.at_node
        ~landlab.grid.base.ModelGrid.at_patch
        ~landlab.grid.base.ModelGrid.field_values
        ~landlab.grid.base.ModelGrid.return_array_or_field_values
```

```{eval-rst}
.. tab:: Info

    .. autosummary::
        :nosignatures:

        ~landlab.grid.base.ModelGrid.size
        ~landlab.grid.base.ModelGrid.keys
        ~landlab.grid.base.ModelGrid.has_group
        ~landlab.grid.base.ModelGrid.has_field
        ~landlab.grid.base.ModelGrid.field_units
        ~landlab.grid.base.ModelGrid.field_values
        ~landlab.grid.base.ModelGrid.groups
```



================================================
File: docs/source/user_guide/grid_methods/99_uncategorized.md
================================================
# Uncategorized or Deprecated

The following functions are either *uncategorized* or *deprecated*. Uncategorized functions are simply
those to which we have not yet assigned a category (but we will as we continue to improve the
documentation).
Although functions marked as deprecated are currently still available, **they will be removed** in
a future *Landlab* release and so their use is discouraged.

```{eval-rst}
.. jinja:: llcats

  .. currentmodule:: landlab

  {% for grid in ['RasterModelGrid'] + grids
    | reject('equalto', 'RasterModelGrid')
    | sort
  %}
  {% set label = grid.replace('ModelGrid', '').replace('Grid', '') %}

  .. tab:: {{ label }}

    {% for cat, label in [('uncategorized', 'Uncategorized'), ('deprecated', 'Deprecated')] %}

      .. tab:: {{label}}

        .. autosummary::
          :nosignatures:

          {% for func in grids[grid][cat] %}
            ~{{func | replace("landlab.", "")}}
          {% endfor %}
    {% endfor %}
  {% endfor %}
```




================================================
File: docs/source/user_guide/reference/components.md
================================================
(api-components)=

# Components

This section contains documentation and API reference information for the
following categories of components:

## Hillslope geomorphology

* {mod}`landlab.components.diffusion`
* {mod}`landlab.components.nonlinear_diffusion`
* {mod}`landlab.components.transport_length_diffusion`
* {mod}`landlab.components.taylor_nonlinear_hillslope_flux`
* {mod}`landlab.components.depth_dependent_taylor_soil_creep`
* {mod}`landlab.components.threshold_eroder`
* {mod}`landlab.components.concentration_tracker`

## Fluvial geomorphology

* {mod}`landlab.components.stream_power`
* {mod}`landlab.components.detachment_ltd_erosion`
* {mod}`landlab.components.erosion_deposition`
* {mod}`landlab.components.space`
* {mod}`landlab.components.network_sediment_transporter`
* {mod}`landlab.components.gravel_river_transporter`
* {mod}`landlab.components.area_slope_transporter`
* {mod}`landlab.components.gravel_bedrock_eroder`

## Flow routing

* {mod}`landlab.components.flow_director`
* {mod}`landlab.components.flow_accum`
* {mod}`landlab.components.depression_finder`
* {mod}`landlab.components.lake_fill`
* {mod}`landlab.components.priority_flood_flow_router`
* {mod}`landlab.components.sink_fill`

## Shallow water hydrodynamics

* {mod}`landlab.components.overland_flow`
* {mod}`landlab.components.tidal_flow`

## Land surface hydrology

* {mod}`landlab.components.radiation`
* {mod}`landlab.components.pet`
* {mod}`landlab.components.soil_moisture`

## Groundwater hydrology

* {mod}`landlab.components.groundwater`

## Landslides

* {mod}`landlab.components.bedrock_landslider`
* {mod}`landlab.components.landslides`
* {mod}`landlab.components.dimensionless_discharge`

## Vegetation

* {mod}`landlab.components.vegetation_dynamics`
* {mod}`landlab.components.plant_competition_ca`

## Biota

* {mod}`landlab.components.species_evolution`

## Precipitation

* {mod}`landlab.components.uniform_precip`
* {mod}`landlab.components.spatial_precip`

## Weathering

* {mod}`landlab.components.weathering`

## Subaqueous / Submarine Processes

* {mod}`landlab.components.carbonate`
* {mod}`landlab.components.marine_sediment_transport`

## Generic numerical components

* {mod}`landlab.components.advection`

## Terrain Analysis

* {mod}`landlab.components.steepness_index`
* {mod}`landlab.components.chi_index`
* {mod}`landlab.components.drainage_density`
* {mod}`landlab.components.profiler.channel_profiler`
* {mod}`landlab.components.profiler.trickle_down_profiler`
* {mod}`landlab.components.hack_calculator`
* {mod}`landlab.components.hand_calculator`

## Tectonics

* {mod}`landlab.components.flexure`
* {mod}`landlab.components.gflex`
* {mod}`landlab.components.normal_fault`
* {mod}`landlab.components.tectonics`

## Fire

* {mod}`landlab.components.fire_generator`

## Fracture Generation

* {mod}`landlab.components.fracture_grid`



================================================
File: docs/source/user_guide/reference/grid.md
================================================
(api-grid)=

# Landlab Grids

## Grid types

Landlab presently supports multiple grid types. The base class for all of these
grid types is {class}`~.ModelGrid`.

The following is an introduction to their properties and methods:

```{jinja} llcats
{% for name in grids|sort %}
* {{"{"}}class{{"}"}}`landlab.{{name}}`
{% endfor %}
```

## Additional Methods and Properties

* {mod}`landlab.grid.create`
* {mod}`landlab.grid.decorators`
* {mod}`landlab.grid.diagonals`
* {mod}`landlab.grid.divergence`
* {mod}`landlab.grid.gradients`
* {mod}`landlab.grid.grid_funcs`
* {mod}`landlab.grid.linkstatus`
* {mod}`landlab.grid.mappers`
* {mod}`landlab.grid.nodestatus`
* {mod}`landlab.grid.raster_aspect`
* {mod}`landlab.grid.raster_funcs`
* {mod}`landlab.grid.raster_gradients`
* {mod}`landlab.grid.raster_mappers`
* {mod}`landlab.grid.raster_set_status`
* {mod}`landlab.grid.warnings`

## API for each grid type

* {mod}`landlab.grid.base`
* {mod}`landlab.grid.raster`
* {mod}`landlab.grid.voronoi`
* {mod}`landlab.grid.framed_voronoi`
* {mod}`landlab.grid.hex`
* {mod}`landlab.grid.radial`
* {mod}`landlab.grid.network`
* {mod}`landlab.grid.icosphere`

## Additional Grid Base Classes

* {mod}`landlab.grid.unstructured`



================================================
File: docs/source/user_guide/reference/index.md
================================================
(api)=

# API reference

This page gives an overview of all public Landlab objects, functions and
methods.

## Grids

```{toctree}
:maxdepth: 2

grid
layers
values
components
```

## References

- {ref}`modindex`
- {ref}`search`



================================================
File: docs/source/user_guide/reference/layers.md
================================================
(api-layers)=

# Layers

Landlab has the ability to add layers to the grid. Two types of layers are
currently supported. First is {class}`~landlab.layers.eventlayers.EventLayers`
in which each event is preserved as an entry into the datastructure, even if no
deposition occurs. If you are interested in chronostratigraphy, this is probably what
you are interested in. Second is {class}`~landlab.layers.materiallayers.MaterialLayers`,
in which each layer must contain some material. If an entire layer is eroded in
{class}`~landlab.layers.materiallayers.MaterialLayers`, the layer is removed.
{class}`~landlab.layers.materiallayers.MaterialLayers` will likely use less memory
than {class}`~landlab.layers.eventlayers.EventLayers`.

* {class}`landlab.layers.eventlayers.EventLayers`
* {class}`landlab.layers.materiallayers.MaterialLayers`

## Lithology

Two objects based on the {class}`~landlab.layers.eventlayers.EventLayers` object exist
to make it easier to deal with spatially variable lithology and associated properties.
The {mod}`~landlab.components.lithology` components contain information about spatially
variable lithology and connect with the Landlab model grid so that when rock is eroded
or advected upward by rock uplift the values of rock propeties at the topographic
surface are updated.

First is the {class}`~landlab.components.lithology.lithology.Lithology` component,
which is a generic object for variable lithology.

* {class}`landlab.components.lithology.lithology.Lithology`

Second is {class}`~landlab.components.lithology.litholayers.LithoLayers` which makes
it easy to make layered rock.

* {class}`landlab.components.lithology.litholayers.LithoLayers`



================================================
File: docs/source/user_guide/reference/values.md
================================================
(api-values)=

# Values

Landlab includes a number of ways to create values for model grid fields.
As with the rest of Landlab, we welcome contributions to this package.

* {mod}`landlab.values`





================================================
File: notebooks/requirements.in
================================================
bmi-topography >=0.5,!=0.8.1
dask[array]
holoviews
jupyter
mesa[network] >1



================================================
File: notebooks/welcome.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
<a href="http://landlab.github.io"><img style="float: left" src="landlab_header.png"></a>
"""

"""
# Welcome to the Landlab Notebooks

This page is provides an index to the Landlab Jupyter Notebooks. 

If you are not certain where to start, consider either:
- [the Landlab Syllabus](tutorials/syllabus.ipynb) if you are interested in teaching yourself Landlab
- [the Landlab teaching notebooks](teaching/welcome_teaching.ipynb) if you are an educator looking for tutorials to use in the classroom. 

## Other useful links
- [The Landlab Documentation](https://landlab.csdms.io/)
- [The Landlab code base](https://github.com/landlab/landlab)
- [The Landlab user guide](https://landlab.csdms.io/user_guide/)

## Notebooks by topic

### Introduction to python
- [Introduction to Python and NumPy](tutorials/python_intro/Python_intro.ipynb) *Learn about:* The very basics of Python.

### Introduction to Landlab
- [Introduction to Landlab: example model of fault-scarp degradation](tutorials/fault_scarp/landlab-fault-scarp.ipynb) A short overview of some of the things Landlab can do. 
- [Where to get info about Landlab](tutorials/where_to_get_info.ipynb) 
- [Introduction to the model grid object](tutorials/grid_object_demo/grid_object_demo.ipynb) Grid topology; how landlab represents data; connectivity of grid elements.
- [Introduction to Landlab data fields](tutorials/fields/working_with_fields.ipynb) How Landlab stores spatial data on the grid; a little on naming conventions.
- [Introduction to plotting output with Landlab](tutorials/plotting/landlab-plotting.ipynb) The basics of plotting with Landlab; combining matplotlib and out plots; the all-powerful ``imshow_grid()`` function.
- [Introduction to using the Landlab component library](tutorials/component_tutorial/component_tutorial.ipynb) The basics of working with and coupling components, using *diffusion*, *stream power*, and a *storm generator* as examples.
- [Using the gradient and flux-divergence functions](tutorials/gradient_and_divergence/gradient_and_divergence.ipynb) Landlab as solving environment for staggered grid finite difference differential approximations; functions available to help you do this.
- [Mapping values from nodes to links](tutorials/mappers/mappers.ipynb) Options for getting data on links to nodes, nodes to links, etc.; min, max, and mean; upwinding and downwinding schemes; one-to-one, one-to-many, and many-to-one mappings.
- Setting boundary conditions on Landlab grids (several tutorials): How Landlab conceptualises boundary conditions; various ways to interact and work with them.
  - [Raster perimeter](tutorials/boundary_conds/set_BCs_on_raster_perimeter.ipynb)
  - [Based on X-Y values](tutorials/boundary_conds/set_BCs_from_xy.ipynb)
  - [Watersheds](tutorials/boundary_conds/set_watershed_BCs_raster.ipynb)
  - [Voronoi](tutorials/boundary_conds/set_BCs_on_voronoi.ipynb)
- [Reading DEMs into Landlab](tutorials/reading_dem_into_landlab/reading_dem_into_landlab.ipynb) Getting an ARC ESRI ASCII into Landlab; getting the boundary conditions set right.
- [How to write a Landlab component](tutorials/making_components/making_components.ipynb) What makes up a Landlab Component Standard Interface; how to make one for your process model.

### Notebooks about components, models, or utilities

- Flow Direction and Accumulation 
  - [Introduction to the FlowDirector Components](tutorials/flow_direction_and_accumulation/the_FlowDirectors.ipynb)
  - [Introduction to the FlowAccumulator Component](tutorials/flow_direction_and_accumulation/the_FlowAccumulator.ipynb)
  - [Comparison of FlowDirector Components](tutorials/flow_direction_and_accumulation/compare_FlowDirectors.ipynb)
- Flexure
  - [Introduction](tutorials/flexure/flexure_1d.ipynb)
  - [Multiple loads](tutorials/flexure/lots_of_loads.ipynb)
- [OverlandFlow](tutorials/overland_flow/overland_flow_driver.ipynb)
- [Coupled rainfall runoff model with OverlandFlow](tutorials/overland_flow/coupled_rainfall_runoff.ipynb)
- [Diffusion, stream power, and the storm generator](tutorials/component_tutorial/component_tutorial.ipynb)
- Ecohydrology (these components not yet updated for v2.0)
  - [Ecohydrology Model on Flat Domain](tutorials/ecohydrology/cellular_automaton_vegetation_flat_surface/cellular_automaton_vegetation_flat_domain.ipynb)
  - [Ecohydrology Model on Actual Landscape](tutorials/ecohydrology/cellular_automaton_vegetation_DEM/cellular_automaton_vegetation_DEM.ipynb)
- [Spatially variable lithology: Lithology and Litholayers](tutorials/lithology/lithology_and_litholayers.ipynb)
- [NormalFault](tutorials/normal_fault/normal_fault_component_tutorial.ipynb)
- [Flow distance utility](tutorials/flow__distance_utility/application_of_flow__distance_utility.ipynb)
- [TransportLengthHillslopeDiffuser](tutorials/transport-length_hillslope_diffuser/TLHDiff_tutorial.ipynb)
- [Groundwater Hydrology](tutorials/groundwater/groundwater_flow.ipynb)
- NetworkSedimentTransporter
  - [Getting started with a simple synthetic grid](tutorials/network_sediment_transporter/network_sediment_transporter.ipynb)
  - [Using a shapefile of a real river network](tutorials/network_sediment_transporter/network_sediment_transporter_shapefile_network.ipynb)
  - [Plotting the network and parcels](tutorials/network_sediment_transporter/network_plotting_examples.ipynb)
  - [Explore scaling of the NetworkSedimentTransporter](tutorials/network_sediment_transporter/nst_scaling_profiling.ipynb)
  
### Teaching Notebooks

- [Quantifying river channel evolution with Landlab](teaching/geomorphology_exercises/channels_streampower_notebooks/stream_power_channels_class_notebook.ipynb)
- [Modeling Hillslopes and Channels with Landlab](teaching/geomorphology_exercises/drainage_density_notebooks/drainage_density_class_notebook.ipynb)
- [Linear diffusion exercise with Landlab](teaching/geomorphology_exercises/hillslope_notebooks/hillslope_diffusion_class_notebook.ipynb)
- [Using Landlab to explore a diffusive hillslope in the piedmont of North Carolina](teaching/geomorphology_exercises/hillslope_notebooks/north_carolina_piedmont_hillslope_class_notebook.ipynb)
- [Exploring rainfall driven hydrographs with Landlab](teaching/surface_water_hydrology_exercises/overland_flow_notebooks/hydrograph_class_notebook.ipynb)
"""



================================================
File: docs/source/teaching/index.md
================================================
(teaching_tutorials)=

[jupyter-summary]: https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/execute.html
[github-issues]: https://github.com/landlab/landlab/issues

# Teaching

## Landlab teaching tools

This page describes the Jupyter Notebooks that implement Landlab for use in
teaching undergraduate and graduate courses. Jupyter Notebooks combine formatted
text with code that can be run. Students can run small parts of code bit by bit
as they follow along with the text.

The notebooks illustrate examples of physical processes implemented numerically.
These notebooks are designed to teach about processes. The notebooks are not
designed to teach students to code, or to teach students to use Landlab. No
coding experience is needed to successfully carry out these activities - just
the ability to read and a classroom introduction of the specific processes being
illustrated.

The notebooks are primarily designed for use as homework assignments or
laboratory assignments. However, they can be used to illustrate concepts
on-the-fly in the classroom.

```{note}
For an introduction to using Jupyter Notebooks locally, see this
[webpage][jupyter-summary].

*TLDR*: The way to launch a Jupyter notebook is to enter ``jupyter notebook``
from a command line prompt. Jupyter notebooks can also be launched from within
Anaconda.
```

## More information

If you have suggestions on improving these notebooks and developing new ones,
or are having trouble running them, please leave us a question in our
[GitHub Issues page][github-issues]. Please make
sure you include that you are working with a Landlab Teaching Notebook and
include the name of the notebook and as much information as possible. If you
are getting an error, please taking a screenshot and upload it.

The development of these Notebooks has been made possible by the Landlab
project funded by the National Science Foundation (OAC 1450338 to N. Gasparini,
OAC 1450409 to G. Tucker, OAC 1450412 to E. Istanbulluoglu).


```{toctree}
:caption: Gallery
:hidden:
:glob:

Getting started <welcome_teaching>
Gallery </generated/teaching/index>
```



================================================
File: docs/source/teaching/welcome_teaching.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Landlab Teaching Notebooks

Find information about how to use these notebooks in your classroom [on our documentation page](https://landlab.csdms.io/teaching/).
## Index of Teaching Notebooks

- [Quantifying river channel evolution with Landlab](geomorphology_exercises/channels_streampower_notebooks/stream_power_channels_class_notebook.ipynb)
- [Modeling Hillslopes and Channels with Landlab](geomorphology_exercises/drainage_density_notebooks/drainage_density_class_notebook.ipynb)
- [Linear diffusion exercise with Landlab](geomorphology_exercises/hillslope_notebooks/hillslope_diffusion_class_notebook.ipynb)
- [Using Landlab to explore a diffusive hillslope in the piedmont of North Carolina](geomorphology_exercises/hillslope_notebooks/north_carolina_piedmont_hillslope_class_notebook.ipynb)
- [Exploring rainfall driven hydrographs with Landlab](surface_water_hydrology_exercises/overland_flow_notebooks/hydrograph_class_notebook.ipynb)
"""



================================================
File: docs/source/teaching/geomorphology_exercises/channels_streampower_notebooks/stream_power_channels_class_notebook.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Quantifying river channel evolution with Landlab
These exercises are based on a project orginally designed by Kelin Whipple at Arizona State University. This notebook was created by Nicole Gasparini at Tulane University.
"""

"""
<hr>
<small>For tutorials on learning Landlab, click here: <a href="https://github.com/landlab/landlab/wiki/Tutorials">https://github.com/landlab/landlab/wiki/Tutorials</a></small>
<hr>
"""

"""
**What is this notebook?**

This notebook illustrates the evolution of detachment-limited channels in an actively uplifting landscape. The landscape evolves according to the equation:

$$\frac{d z}{d t} = -K_\text{sp} A^{m_{sp}} S^{n_{sp}} + U$$

Here, $K_{sp}$ is the erodibility coefficient on fluvial incision, which is thought to be positively correlated with climate wetness, or storminess (this is hard to quantify) and to be negatively correlated with rock strength (again, rock strength is hard to quantify). $m_{sp}$ and $n_{sp}$ are positive exponents, usually thought to have a ratio, $m_{sp}/n_{sp} \approx 0.5$. $A$ is drainage area and $S$ is the slope of steepest descent ($-\frac{dz}{dx}$) where $x$ is horizontal distance (positive in the downslope direction) and $z$ is elevation. (If slope is negative there is no fluvial erosion.) $U$ is an externally-applied rock uplift field.

The fluvial erosion term is also known as the stream power equation. Before using this notebook you should be familiar with this equation from class lectures and reading. 

For a great overview of the stream power equation, see: 

- Whipple and Tucker, 1999, Dynamics of the stream-power river incision model: Implications for height limits of mountain ranges, landscape response timescales, and research needs, Journal of Geophysical Research.

For some great illustrations of modeling with the sream power equation, see:

- Tucker and Whipple, 2002, Topographic outcomes predicted by stream erosion models: Sensitivity analysis and intermodel comparison, Journal of Geophysical Research.

Helpful background on landscape sensitivity to rock uplift rates and patterns can be found here:

- Kirby and Whipple, 2012, Expression of active tectonics in erosional landscapes, Journal of Structural Geology.

**What will you do?**

In this exercise you will modify the code to get a better understanding of how rock uplift rates and patterns and the erodibility coefficient control fluvial channel form.

Start at the top by reading each block of text and sequentially running each code block (shift - enter OR got to the _Cell_ pulldown menu at the top and choose _Run Cells_). 

If you just change one code block and rerun only that code block, only the parts of the code in that code block will be updated. (E.g. if you change parameters but don't reset the code blocks that initialize run time or topography, then these values will not be reset.) 

**STUDENTS: Questions to answer before starting this assignment.**

Answer these questions before running the notebook.

1. What do you think will happen to total relief (defined as the maximum minus the minimum elevation, here area is fixed) and channel slope at steady state if $K_{sp}$ is uniformly increased?
2. What do you think will happen to total relief and channel slope at steady state if $U$ is uniformly increased?
3. How do you think a steady-state landscape with a uniform low rock uplift rate will respond if rock uplift is uniformly increased (relative to a steady base level)? How will channel slopes change through time?
"""

"""
**Now on to the code...**

First we have to import the parts of Python and Landlab that are needed to run this code. You should not have to change this first code block.
"""

# Code block 1

import numpy as np
from matplotlib import pyplot as plt
from tqdm.notebook import tqdm

from landlab import RasterModelGrid
from landlab.components import (
    ChannelProfiler,
    ChiFinder,
    FlowAccumulator,
    SteepnessFinder,
    StreamPowerEroder,
)

"""
Make a grid and set boundary conditions. 
"""

# Code Block 2

number_of_rows = 50  # number of raster cells in vertical direction (y)
number_of_columns = 100  # number of raster cells in horizontal direction (x)
dxy = 200  # side length of a raster model cell, or resolution [m]

# Below is a raster (square cells) grid, with equal width and height
mg1 = RasterModelGrid((number_of_rows, number_of_columns), dxy)

# Set boundary conditions - only the south side of the grid is open.
# Boolean parameters are sent to function in order of
# east, north, west, south.
mg1.set_closed_boundaries_at_grid_edges(True, True, True, False)

"""
Here we make the initial grid of elevation of zeros with a very small amount of noise to make a more pleasing network.
"""

# Code Block 3

np.random.seed(35)  # seed set so our figures are reproducible

# intial noise on elevation grid
mg1_noise = np.random.rand(mg1.number_of_nodes) / 1000.0

# set up the elevation on the grid
z1 = mg1.add_zeros("topographic__elevation", at="node")
z1 += mg1_noise

"""
Set parameters related to time.
"""

# Code Block 4

tmax = 5e5  # time for the model to run [yr] (Original value was 5E5 yr)
dt = 1000  # time step [yr] (Original value was 100 yr)

"""
Set parameters for incision and intializing all of the process components that do the work. We also initialize tools for quantifying the landscape.
"""

# Code Block 5

# Original K_sp value is 1e-5
K_sp = 1.0e-5  # units vary depending on m_sp and n_sp
m_sp = 0.5  # exponent on drainage area in stream power equation
n_sp = 1.0  # exponent on slope in stream power equation

frr = FlowAccumulator(mg1, flow_director="FlowDirectorD8")  # intializing flow routing

# initializing stream power incision
spr = StreamPowerEroder(mg1, K_sp=K_sp, m_sp=m_sp, n_sp=n_sp, threshold_sp=0.0)

theta = m_sp / n_sp
# initialize the component that will calculate channel steepness
sf = SteepnessFinder(mg1, reference_concavity=theta, min_drainage_area=1000.0)
# initialize the component that will calculate the chi index
cf = ChiFinder(
    mg1, min_drainage_area=1000.0, reference_concavity=theta, use_true_dx=True
)

"""
Initialize rock uplift rate. This will need to be changed later.
"""

# Code Block 6

#  uplift_rate [m/yr] (Original value is 0.0001 m/yr)
uplift_rate = np.ones(mg1.number_of_nodes) * 0.0001

"""
Now for the code loop. 

Note that you can rerun Code Block 7 many times, and as long as you don't reset the elevation field (Code Block 3), it will take the already evolved landscape and evolve it even more. If you want to change parameters in other code blocks (e.g. Code Block 5 or 6), you can do that too, and as long as you don't reset the elevation field (Code Block 3) the new parameters will apply on the already evolved topography. 
"""

# Code Block 7

total_time = 0.0
with tqdm(total=tmax) as pbar:
    while total_time < tmax:
        z1[mg1.core_nodes] += uplift_rate[mg1.core_nodes] * dt  # uplift the landscape
        frr.run_one_step()  # route flow
        spr.run_one_step(dt)  # fluvial incision
        total_time += dt

        pbar.update(dt)

"""
Plot the topography.
"""

# Code Block 8

mg1.imshow("topographic__elevation", grid_units=("m", "m"), var_name="Elevation (m)")
title_text = f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m"
plt.title(title_text)

max_elev = np.max(z1)
print(f"Maximum elevation is {np.max(z1)}")

"""
Plot the slope and area data at each point on the landscape (in log-log space). We will only plot the core nodes because the boundary nodes have slopes that are influenced by the boundary conditions. 
"""

# Code Block 9

plt.loglog(
    mg1.at_node["drainage_area"][mg1.core_nodes],
    mg1.at_node["topographic__steepest_slope"][mg1.core_nodes],
    "b.",
)
plt.ylabel("Topographic slope")
plt.xlabel("Drainage area (m^2)")
title_text = f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m"

plt.title(title_text)

"""
It is slightly easier to interpret slope-area data when we look at a single channel, rather than the entire landscape. Below we plot the profile and slope-area data for the three largest channels on the landscape.
"""

# Code Block 10

# profile the largest channels, set initially to find the mainstem channel in the three biggest watersheds
# you can change the number of watersheds, or choose to plot all the channel segments in the watershed that
# have drainage area below the threshold (here we have set the threshold to the area of a grid cell).
prf = ChannelProfiler(
    mg1,
    number_of_watersheds=3,
    main_channel_only=True,
    minimum_channel_threshold=dxy**2,
)
prf.run_one_step()

# plot the elevation as a function of distance upstream
plt.figure(1)
title_text = f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m"
prf.plot_profiles(
    xlabel="distance upstream (m)", ylabel="elevation (m)", title=title_text
)

# plot the location of the channels in map view
plt.figure(2)
prf.plot_profiles_in_map_view()

# slope-area data in just the profiled channels
plt.figure(3)
for i, outlet_id in enumerate(prf.data_structure):
    for j, segment_id in enumerate(prf.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        color = segment["color"]
        plt.loglog(
            mg1.at_node["drainage_area"][profile_ids],
            mg1.at_node["topographic__steepest_slope"][profile_ids],
            ".",
            color=color,
            label=label,
        )

plt.legend(loc="lower left")
plt.xlabel("drainage area (m^2)")
plt.ylabel("channel slope [m/m]")
title_text = f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m"
plt.title(title_text)

"""
The chi index is a useful way to quantitatively interpret fluvial channels. Below we plot the chi index in the three largest channels and also a chi map across the entire landscape. 
"""

# Code Block 11

# calculate the chi index
cf.calculate_chi()

# chi-elevation plots in the profiled channels
plt.figure(4)

for i, outlet_id in enumerate(prf.data_structure):
    for j, segment_id in enumerate(prf.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        color = segment["color"]
        plt.plot(
            mg1.at_node["channel__chi_index"][profile_ids],
            mg1.at_node["topographic__elevation"][profile_ids],
            color=color,
            label=label,
        )

plt.xlabel("chi index (m)")
plt.ylabel("elevation (m)")
plt.legend(loc="lower right")
title_text = (
    f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m; concavity={theta}"
)
plt.title(title_text)

# chi map
plt.figure(5)
mg1.imshow(
    "channel__chi_index",
    grid_units=("m", "m"),
    var_name="Chi index (m)",
    cmap="jet",
)
title_text = (
    f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m; concavity={theta}"
)
plt.title(title_text)

"""
The channel steepness index is another useful index to quantify fluvial channels. Below we plot the steepness index in the same three largest channels, and also plot steepness index across the grid.
"""

# Code Block 12

# calculate channel steepness
sf.calculate_steepnesses()

# plots of steepnes vs. distance upstream in the profiled channels
plt.figure(6)

for i, outlet_id in enumerate(prf.data_structure):
    for j, segment_id in enumerate(prf.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        distance_upstream = segment["distances"]
        color = segment["color"]
        plt.plot(
            distance_upstream,
            mg1.at_node["channel__steepness_index"][profile_ids],
            "x",
            color=color,
            label=label,
        )

plt.xlabel("distance upstream (m)")
plt.ylabel("steepness index")
plt.legend(loc="upper left")
plt.title(f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m; concavity={theta}")

# channel steepness map
plt.figure(7)
mg1.imshow(
    "channel__steepness_index",
    grid_units=("m", "m"),
    var_name="Steepness index ",
    cmap="jet",
)
title_text = (
    "$K_{sp}$="
    + str(K_sp)
    + "; $time$="
    + str(total_time)
    + "yr; $dx$="
    + str(dxy)
    + "m"
    + "; concavity="
    + str(theta)
)
plt.title(f"$K_{{sp}}$={K_sp}; $time$={total_time} yr; $dx$={dxy} m; concavity={theta}")

"""
If you have a grid that you want to export, uncomment and edit the appropriate lines below and run the code block.
"""

# Code Block 13

## Below has the name of the file that data will be written to.
## You need to change the name of the file every time that you want
## to write data, otherwise you will get an error.
## This will write to the directory that you are running the code in.
# write_file_name = 'data_file.txt'
## Below is writing elevation data in the ESRI ascii format so that it can
## easily be read into Arc GIS or back into Landlab.
# with open(write_file_name, "w") as fp:
#     dump(fp, mg1, name="topographic__elevation", at="node")

"""
After running every code block once, has the landscape reached steady state? Answer: NO! How do you know? After you think about this, you are ready to complete this project.

Answer the following questions using the code above and below. All answers should be typed, and supporting figures (produced using the code) should be embedded in one document that you hand in. Code Blocks 8-12 and 18-21 produce different figures that you may find useful. You can use any or all of these different figures to help you with the questions below. (Download or screenshoot the figures.) 

Anything with a question mark should be answered in the document that you hand in. Make sure your write in full sentences and proofread the document that you hand in.

1. **Steady state with low uplift rate.** Using the parameters provided in the initial notebook, run the landscape to steady state. (Note that you can keep running the main evolution loop - Code Block 7 - and the different plotting blocks without running the code blocks above them. You may also want to change $tmax$ in Code Block 4.) How did you know that the landscape reached steady state? Note the approximate time that it took to reach steady state for your own reference. (This will be usefull for later questions.) Include appropriate plots. (If you want to analyze these landscapes outside of Landlab or save for later, make sure you save the elevation data to a text file (Code Block 13).)

**NOTE, For the rest of the questions you should use Code Blocks 14 - 21. These will allow you to use the steady-state landscape created for question 1 - referred to here as the 'base landscape' - as the initial condition. Start by editing what you need to in Code Blocks 14 - 16. Run these each once, sequentially. You can run Code Block 17, the time loop, as many times as you need to, along with Code Blocks 18-21, which produce plots.**

2. **Transient landscape responding to an increase in rock uplift.** Use the base landscape and increase rock uplift uniformly by a factor of 4 to 0.0004 m/yr. Make sure you update the rock uplift rate (Code Block 16) and ensure that $tmax$ is 1e5 yrs and $dt$ is 500 yrs (Code Block 15). Run this until the maximum elevation in the grid is ~ 170 m and observe how the landscape gets to this elevation, i.e. plot intermediate steps. What patterns do you see in the supporting plots that illustrate this type of transient? Which patterns, if any, are diagnostic of a landscape response to uniform increase in rock uplift rate? (You may need to answer this after completing all of the questions.)

3. **Steady-state landscape with increased rock uplift.** Now run the landscape from question 2 until it reaches steady state. (I.e. run the time loop, Code Block 17, a bunch of times. You can increase $tmax$ and $dt$ to make this run faster.) Provide a plot that illustrates that the landscape is in steady state. What aspects of the landscape have changed in comparison with the base landscape from question 1?

4. **Increase erodibility.** Start again from the base landscape, but this time increase $K_{sp}$ to 2E-5 (Code Block 14). Make sure rock uplift rate is set to the original value of 0.0001 m/yr (Code Block 16). Set $tmax$ to 1e5 yrs (Code Block 15). Run for 1e5 yrs and save the plots that you think are diagnostic. Run for another 1e5 yrs and save plots again. Now run for 5e5 yrs and save plots again. Quantitatively describe how the landscape evolves in response to the increase in erodibility and provide supporting plots. What could cause a uniform increase in erodibility?

5. **Spatially varible uplift - discrete, massive earthquake.** Start again from the base landscape, and make sure that $K_{sp}$ = 1E-5 (Code Block 14). Now add a seismic event to this steady state landscape - a fault that runs horizontally across the landscape at y = 4000 m, and instantaneously uplifts half the landscape by 10 meters (Code Block 16). In this case, we will keep background uplift uniform at 0.0001 m/yr. Set $tmax$ to 1e5 yrs and $dt$ to 500 yrs (Code Block 15) before evolving the landscape after the fault. Now run the time loop four times and look at the different plots after each loop. How does the landscape respond to this fault? What patterns do you see in the supporting plots that illustrate this type of transient? Which patterns, if any, are diagnostic of a channel response to an earthquake? (You may need to answer this after completing all of the questions.)

6. **Spatially Varible Rock Uplift - discrete fault with two different uplift rates.** Start again from the base landscape, and make sure that $K_{sp}$ = 1E-5 (Code Block 14). Now we will add a fault (at y = 4000 m) to this landscape. In this case the uplift rate on the footwall is higher (0.0004 m/yr) than on the hanging wall (uplift rate = 0.0001 m/yr). (Edit Code Block 16.) Set $tmax$ to 1e5 yrs and $dt$ to 500 yrs (Code Block 15). Now run the time loop four separate times and look at the different plots after each loop. How does the landscape respond to this fault? What patterns do you see in the supporting plots that illustrate this type of transient? Which patterns, if any, are diagnostic of a channel response to a this type of gradient in rock uplift rates? (You may need to answer this after completing all of the questions.)

7. **Spatially Varible Rock Uplift - gradient in uplift across the range.** Start again from the base landscape, and make sure that $K_{sp}$ = 1E-5 (Code Block 14). Now we will add a linear gradient in uplift rate across the entire range (edit Code Block 16). The maximum uplift rate will be 0.0004 m/yr at the core of the range, and 0.0001 m/yr at the front of the range. Set $tmax$ to 1e5 yrs (Code Block 4) and $dt$ to 500 yrs before you start running the time loop for the fault before you start running the time loop with the rock uplift gradient. Now run the time loop four separate times and look at the different plots after each loop. How does the landscape respond to this gradient in uplift rate? What patterns do you see in the supporting plots that illustrate this type of transient? Which patterns, if any, are diagnostic of a channel response to this type of gradient in rock uplift rates? (You may need to answer this after completing all of the questions.)

8. **Final Reflection.** Was your initial insight into how parameters would affect the landscape correct? Discuss in 6 sentences or less.
"""

# Code Block 14

number_of_rows = 50  # number of raster cells in vertical direction (y)
number_of_columns = 100  # number of raster cells in horizontal direction (x)
dxy2 = 200  # side length of a raster model cell, or resolution [m]

# Below is a raster (square cells) grid, with equal width and height
mg2 = RasterModelGrid((number_of_rows, number_of_columns), dxy2)

# Set boundary conditions - only the south side of the grid is open.
# Boolean parameters are sent to function in order of
# east, north, west, south.
mg2.set_closed_boundaries_at_grid_edges(True, True, True, False)

z2 = z1.copy()  # initialize the elevations with the steady state
# topography produced for question 1
z2 = mg2.add_field("topographic__elevation", z2, at="node")

# K_sp value for base landscape is 1e-5
K_sp2 = 1e-5  # units vary depending on m_sp and n_sp
m_sp2 = 0.5  # exponent on drainage area in stream power equation
n_sp2 = 1.0  # exponent on slope in stream power equation

frr2 = FlowAccumulator(mg2, flow_director="FlowDirectorD8")  # intializing flow routing

# initializing stream power incision
spr2 = StreamPowerEroder(mg2, K_sp=K_sp2, m_sp=m_sp2, n_sp=n_sp2, threshold_sp=0.0)

theta2 = m_sp2 / n_sp2
# initialize the component that will calculate channel steepness
sf2 = SteepnessFinder(mg2, reference_concavity=theta2, min_drainage_area=1000.0)
# initialize the component that will calculate the chi index
cf2 = ChiFinder(
    mg2, min_drainage_area=1000.0, reference_concavity=theta2, use_true_dx=True
)

# Code Block 15

tmax = 1e5  # time for the model to run [yr] (Original value was 5E5 yr)
dt = 500  # time step [yr] (Original value was 500 yr)

# Code Block 16

#  uplift_rate [m/yr] (value was 0.0001 m/yr for base landscape)
uplift_rate = np.ones(mg2.number_of_nodes) * 0.0001

## If you want to add a one-time event that uplifts only part of the
## landscape, uncomment the 3 lines below
# fault_location = 4000  # [m]
# uplift_amount = 10 # [m]
# z2[np.nonzero(mg2.node_y>fault_location)] += uplift_amount

## IMPORTANT! To use the below fault generator, comment the one-time
## uplift event above if it isn't already commented out.
## Code below creates a fault horizontally across the grid.
## Uplift rates are greater where y values  > fault location.
## To use, uncomment the 5 code lines below and edit to your values
# fault_location = 4000  # [m]
# low_uplift_rate = 0.0001 # [m/yr]
# high_uplift_rate = 0.0004 # [m/yr]
# uplift_rate[np.nonzero(mg2.node_y<fault_location)] = low_uplift_rate
# uplift_rate[np.nonzero(mg2.node_y>fault_location)] = high_uplift_rate

## IMPORTANT! To use below rock uplift gradient, comment the two
## uplift options above if they aren't already commented out.
## If you want a linear gradient in uplift rate
## (increasing uplift into the range),
## uncomment the 4 code lines below and edit to your values.
# low_uplift_rate = 0.0001 # [m/yr]
# high_uplift_rate = 0.0004 # [m/yr]
## below is uplift gradient per node row index, NOT row value in meters
# uplift_rate_gradient = (high_uplift_rate - low_uplift_rate)/(number_of_rows-3)
# uplift_rate = low_uplift_rate + ((mg2.node_y / dxy)-1) * uplift_rate_gradient

# Code Block 17

total_time = 0.0
with tqdm(total=tmax) as pbar:
    while total_time < tmax:
        z2[mg2.core_nodes] += uplift_rate[mg2.core_nodes] * dt  # uplift the landscape
        frr2.run_one_step()  # route flow
        spr2.run_one_step(dt)  # fluvial incision
        total_time += dt  # update time keeper

        pbar.update(dt)

# Code Block 18
# Plot topography

plt.figure(8)
mg2.imshow("topographic__elevation", grid_units=("m", "m"), var_name="Elevation (m)")
plt.title(f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m")

max_elev = np.max(z2)
print(f"Maximum elevation is {np.max(z2)}")

# Code Block 19
# Plot Channel Profiles and slope-area data along the channels

prf2 = ChannelProfiler(
    mg2,
    number_of_watersheds=3,
    main_channel_only=True,
    minimum_channel_threshold=dxy**2,
)
prf2.run_one_step()

# plot the elevation as a function of distance upstream
plt.figure(9)
title_text = f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy} m"
prf2.plot_profiles(
    xlabel="distance upstream (m)", ylabel="elevation (m)", title=title_text
)

# plot the location of the channels in map view
plt.figure(10)
prf2.plot_profiles_in_map_view()

# slope-area data in just the profiled channels
plt.figure(11)
for i, outlet_id in enumerate(prf2.data_structure):
    for j, segment_id in enumerate(prf2.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf2.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        color = segment["color"]
        plt.loglog(
            mg2.at_node["drainage_area"][profile_ids],
            mg2.at_node["topographic__steepest_slope"][profile_ids],
            ".",
            color=color,
            label=label,
        )

plt.legend(loc="lower left")
plt.xlabel("drainage area (m^2)")
plt.ylabel("channel slope [m/m]")
title_text = f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m"
plt.title(title_text)

# Code Block 20
# Chi Plots

# calculate the chi index
cf2.calculate_chi()

# chi-elevation plots in the profiled channels
plt.figure(12)
for i, outlet_id in enumerate(prf2.data_structure):
    for j, segment_id in enumerate(prf2.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf2.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        color = segment["color"]
        plt.plot(
            mg2.at_node["channel__chi_index"][profile_ids],
            mg2.at_node["topographic__elevation"][profile_ids],
            color=color,
            label=label,
        )

plt.xlabel("chi index (m)")
plt.ylabel("elevation (m)")
plt.legend(loc="lower right")
title_text = (
    f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m; concavity={theta2}"
)
plt.title(title_text)

# chi map
plt.figure(13)
mg2.imshow(
    "channel__chi_index",
    grid_units=("m", "m"),
    var_name="Chi index (m)",
    cmap="jet",
)
plt.title(
    f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m; concavity={theta2}"
)

# Code Block 21
# Plot channel steepness along profiles and across the landscape

# calculate channel steepness
sf2.calculate_steepnesses()

# plots of steepnes vs. distance upstream in the profiled channels
plt.figure(14)

for i, outlet_id in enumerate(prf2.data_structure):
    for j, segment_id in enumerate(prf2.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf2.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        distance_upstream = segment["distances"]
        color = segment["color"]
        plt.plot(
            distance_upstream,
            mg2.at_node["channel__steepness_index"][profile_ids],
            "x",
            color=color,
            label=label,
        )

plt.xlabel("distance upstream (m)")
plt.ylabel("steepness index")
plt.legend(loc="upper left")
plt.title(
    f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m; concavity={theta2}"
)

# channel steepness map
plt.figure(15)
mg2.imshow(
    "channel__steepness_index",
    grid_units=("m", "m"),
    var_name="Steepness index ",
    cmap="jet",
)
plt.title(
    f"$K_{{sp}}$={K_sp2}; $time$={total_time} yr; $dx$={dxy2} m; concavity={theta2}"
)



================================================
File: docs/source/teaching/geomorphology_exercises/drainage_density_notebooks/drainage_density_class_notebook.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Modeling Hillslopes and Channels with Landlab
The original version of this exercise was donated by Andy Wickert at the University of Minnesota. This notebook was created by Nicole Gasparini at Tulane University.
"""

"""
<hr>
<small>For tutorials on learning Landlab, click here: <a href="https://github.com/landlab/landlab/wiki/Tutorials">https://github.com/landlab/landlab/wiki/Tutorials</a></small>
<hr>
"""

"""
**What is this notebook?**

This notebook illustrates a landscape evolution model in which the landscape evolves according to the equation:

$$\frac{\partial z}{\partial t} = -K_\text{sp} A^{m_{sp}} S^{n_{sp}} + K_\text{hs} \frac{\partial^2 z}{\partial x^2} + U$$

Here, $K$ are coefficients on the fluvial ($sp$) and hillslope ($hs$) parts of the equation, and $m_{sp}$ and $n_{sp}$ are positive exponents, usually thought to have a ratio, $m_{sp}/n_{sp} \approx 0.5$. $A$ is drainage area and $S$ is the slope of steepest descent ($-\frac{dz}{dx}$) where $x$ is horizontal distance (positive in the downslope direction) and $z$ is elevation. (If slope is negative there is no fluvial erosion.) $U$ is an externally-applied uplift field.

The first term on the right hand side of the equation is the fluvial erosion term, which is also known as the stream power equation. The second term on the right hand side of the equation is elevation changes via linear diffusion, and linear diffusion is one way in which to describe hillslope sediment transport.

For more information on the fluvial erosion term, please see:

- Whipple, K.X. and Tucker, G.E., 1999. Dynamics of the stream‐power river incision model: Implications for height limits of mountain ranges, landscape response timescales, and research needs. Journal of Geophysical Research: Solid Earth.

For more information on linear diffusion applied to hillslopes (and other fun hillslope models) see:

- Roering, J.J., 2008. How well can hillslope evolution models “explain” topography? Simulating soil transport and production with high-resolution topographic data. Geological Society of America Bulletin.

The ideas behind what this notebook does are presented nicely in the two papers below. Neither of them is exactly the same as this notebook, but they discuss drainage density and transitions from hillslope to fluviall processes.

- Tucker, G.E. and Bras, R.L., 1998. Hillslope processes, drainage density, and landscape morphology. Water Resources Research.

- Perron, J.T., Kirchner, J.W. and Dietrich, W.E., 2009. Formation of evenly spaced ridges and valleys. Nature.

**What will you do?**

In this exercise you will modify the code to get a better understanding of how different processes and forces control landscape evolution, landscape form and drainage density (as interpreted from slope-area data). It is expected that you have already learned the basics about fluvial bedrock incision (and the stream power equation) and sediment transport through creep on hillslopes (and the diffusion equation). (See references above.)

Start by sequentially running each code block without changing anything. To run an individual code cell, put the cursor in the cell and type shift-enter, or got to the _Cell_ pulldown menu at the top and choose _Run Cells_. At the end of the notebook you will see the questions that you need to answer by changing parts of the code and rerunning it. 

Remember that you can always go to the _Kernel_ pulldown menu at the top and choose _Restart & Clear Output_ or _Restart & Run All_ if you change things and want to start afresh. If you just change one code block and rerun only that code block, only the parts of the code in that code block will be updated. (E.g. if you change parameters but don't reset the code blocks that initialize run time or topography, then these values will not be reset.)  

**Questions to answer before starting this assignment.**

1. If hillslope diffusivity ($K_{hs}$) is fixed, but fluvial erodibility ($K_{sp}$) increases, what do you think will happen to the total relief and drainage density of a landscape?
2. If fluvial erodibility ($K_{sp}$) is fixed but hillslope diffusivity ($K_{hs}$) increases, what do you think will happen to the total relief and drainage density of a landscape?
3. If parameters stay fixed ($K_{hs}$ and $K_{sp}$), but the uplift rate increases, what do you think will happen to the total relief and drainage density of a landscape?
"""

"""
**Now on to the code...**

First we have to import the parts of Python and Landlab that are needed to run this code. You should not have to change this first code block.
"""

# below is to make plots show up in the notebook
%matplotlib inline

# Code Block 1

import numpy as np
from matplotlib import pyplot as plt

from landlab import RasterModelGrid, imshow_grid
from landlab.components import FlowAccumulator, LinearDiffuser, StreamPowerEroder

"""
Now we set parameters

**This part you will need to change for the different exercises.** 

Note that Landlab does not impose units, but it assumes that all units are consistent. We will assume that everything is given in _meters_ (m) and _years_ (yr).
"""

# Code Block 2

uplift_rate = 0.001  # [m/yr], initially set at 0.001
K_sp = 1.0e-5  # units vary depending on m_sp and n_sp, initially set at 1e-5
m_sp = 0.5  # exponent on drainage area in stream power equation, initially 0.5
n_sp = 1.0  # exponent on slope in stream power equation, initially 1.
K_hs = 0.05  # [m^2/yr], initially 0.05

"""
**Make a grid.**

This part you may want to change.
"""

# Code Block 3

ncells_side = 150  # number of raster cells on each side, initially 150
dxy = 50  # side length of a raster model cell, or resolution [m], initially 50

# Below is a raster (square cells) grid, with equal width and height
mg = RasterModelGrid((ncells_side, ncells_side), dxy)

"""
Set some variables related to time. 
"""

# Code Block 4

dt = 1000  # time step [yr], initially 5000
total_time = 0  # amount of time the landscape has evolved [yr]
tmax = 1e6  # time for the model loop to run [yr], initially 1e6

t = np.arange(0, tmax, dt)  # each of the time steps that the code will run

"""
Here we make the initial grid of elevation. 
"""

# Code Block 5

np.random.seed(0)  # seed set to zero so our figures are reproducible
mg_noise = np.random.rand(mg.number_of_nodes) / 1000.0  # intial noise on elevation grid

# set up the elevation on the grid
zr = mg.add_zeros("topographic__elevation", at="node")
zr += mg_noise

"""
Intializing all of the process components that do the work.
"""

# Code Block 6

# intialize flow routing
frr = FlowAccumulator(mg)
# initialize stream power incision
spr = StreamPowerEroder(mg, K_sp=K_sp, m_sp=m_sp, n_sp=n_sp, threshold_sp=0.0)
# initialize linear diffusion
dfn = LinearDiffuser(mg, linear_diffusivity=K_hs, deposit=False)

"""
Now for the code loop. Note that you can rerun this code block many times, and as long as you don't rerun any of the code boxes above, it will take the already evolved landscape and evolve it even more.
"""

# Code Block 7

for ti in t:
    zr[mg.core_nodes] += uplift_rate * dt  # uplift the landscape
    dfn.run_one_step(dt)  # diffuse the landscape
    frr.run_one_step()  # route flow
    # df.map_depressions()
    spr.run_one_step(dt)  # fluvial incision
    total_time += dt  # update time keeper
    print(total_time)

"""
Plot the topography.
"""

# Code Block 8

plt.figure(1)
imshow_grid(
    mg, "topographic__elevation", grid_units=("m", "m"), var_name="Elevation (m)"
)
title_text = f"$K_{{sp}}$={K_sp}; $K_{{hs}}$={K_hs}; $time$={total_time}; $dx$={dxy}"

plt.title(title_text)

max_elev = np.max(zr)
suptitle_text = "Maximum elevation is " + str(max_elev)
plt.suptitle(suptitle_text)

print("Maximum elevation is ", np.max(zr))

"""
Plot the slope and area data at each point (in log-log space).
"""

# Code Block 9

plt.figure(2)
indices = np.where(mg.status_at_node[mg.at_node["flow__receiver_node"]] == 0)
plt.loglog(
    mg.at_node["drainage_area"][indices],
    mg.at_node["topographic__steepest_slope"][indices],
    "b.",
)

plt.ylabel("Topographic slope")
plt.xlabel("Drainage area (m^2)")
plt.title(title_text)

"""
Has the landscape reached steady state yet? 


Answer: Not quite. At perfect steady state, there will be no scatter in the fluvial part of the slope-area relationship (given this model set-up).

**What to do.**

Answer the following questions using the code above. All solutions should be typed, and supporting figures (produced using the code) should be embedded in your final document. (Download or screenshoot the figures.) You may want to make other plots with the data you collect using this model. You are free to make those plots using whatever software you choose.

In parts of this exercise you need to work with your classmates. You are encouraged to discuss how to use the model and model results with your classmates, however the write-up that you hand in must be your own work.

1. **Hillslope vs. Fluvial Processes.** Using the parameters provided in the initial notebook, run the landscape to steady state, or the point at which the topography and the slope-area relationship stop changing (i.e. erosion equals rock uplift). (You can keep rerunning Code Block 7 until steady state is reached. Steady state is reached asymptotically, so exact steady state is less important than very close.) Use the plots of slope and area to estimate where the hillslope–fluvial transition is (or in otherwords, the threshold drainage area for channel heads. There is usually a range of values. You should be consistent in your method to determine drainage density and describe how you determined it in your write-up). Also record the maximum elevation. Now try keeping $K_{sp}$ the same but increase and decrease $K_{hs}$ (change and run Code Block 2, then rerun Code Blocks 6 and 7). How do the maximum elevation and the transition from hillslope to channel change with changes in $K_{hs}$? Now try keeping $K_{hs}$ the same but increase and decrease $K_{sp}$ (change and run Code Block 2, then rerun Code Blocks 6 and 7). How do the maximum elevation and transition from hillslope to channel change with changes in $K_{sp}$? You can work in teams with your classmates so that you can explore more parameter combinations. Produce a relationship between the different values of $K_{sp}$, $K_{hs}$ and the threshold drainage area and maximum elevation. Remember to run all of your experiments with different parameter values to steady state before estimating the threshold drainage area and maximum elevation. Describe how the different parameters affect drainage density in words, and how this is seen in the relationship that you generate. You do not have to include plots of every single run, but include plots to illustrate at least three landscapes with different drainage densities.

2. **Uplift and erosion.** Now, perform a similar set of exercises as you did in exercise 1, but also systematically vary uplift rate (Code Block 2). Work in teams, and each person should choose two combinations of $K_{sp}$ and $K_{hs}$ and three uplift rates (for a total of 6 runs). Make sure the parameter values that you choose do not overlap with your group members. Make sure you document the transition from hillslope to fluvial process (make sure all of the team members are using the same method to determine threshold area for drainage density), and also note the maximum steady-state elevation for each combination of uplift, $K_{sp}$ and $K_{hs}$. Produce relationships to show how the area threshold and maximum elevation change with the different variables. Describe how uplift rate affects drainage density in words, and how this is seen in the relationship that you generate. You do not have to include plots of every single run, but include some plots to illustrate the changes that you describe. (Note whom your group members were in your write-up.)

3. **Free-form exploration. (Optional)** Try changing the grid type (Code Block 3), grid size (Code Block 3), stream power exponents (Code Block 2), distribution of uplift rate (e.g., what happens if you have just part of the landscape experience uplift, a bit trickier, as uplift in Code Block 2 will need to be changed to an array), etc. Based on what you observe, create a consistent geomorphic history of the system. Creativity is expected here!

4. **Final reflection.** Was your initial insight into how parameters would affect the landscape correct? Discuss in less than 5 sentences.
"""



================================================
File: docs/source/teaching/geomorphology_exercises/hillslope_notebooks/hillslope_diffusion_class_notebook.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Linear diffusion exercise with Landlab

This notebook is adapted from *Landscape Evolution Modeling with CHILD* by Gregory Tucker and Stephen Lancaster. This notebook was created by Nicole Gasparini at Tulane University.
"""

"""
<hr>
For tutorials on learning Landlab, click here: <a href="https://github.com/landlab/landlab/wiki/Tutorials">https://github.com/landlab/landlab/wiki/Tutorials</a>
<hr>

"""

"""
**What is this notebook?**

This notebook illustrates the evolution of landforms dominated by processes that result in linear diffusion of sediment. In other words, the downhill flow of soil is proportional to the (downhill) gradient of the land surface multiplied by a transport coefficient.

The notebook first illustrates a simple example of a diffusing hillslope. We then provide a number of exercises for students to do on their own. This set of exercises is recomended for students in a quantitative geomorphology class, who have been introduced to the linear diffusion equation in class. 

**Application of linear diffusion transport law:**

For relatively gentle, soil-mantled slopes, there is reasonably strong support for a transport law of the form:
\begin{equation}
q_s = -D \nabla z
\end{equation}
where ${q}_s$ is the transport rate with dimensions of L$^2$T$^{-1}$;  $D$ is a transport coefficient with dimensions of L$^2$T$^{-1}$; and $z$ is elevation. $\nabla z$ is the gradient in elevation. If distance is increasing downslope, $\nabla z$ is negative downslope, hence the negative in front of $D$. 
 
Changes in elevation, or erosion, are calculated from conservation of mass:
\begin{equation}
\frac{dz}{dt} = U-\nabla q_s
\end{equation}
where $U$ is the rock uplift rate, with dimensions LT$^{-1}$.

**How will we explore this with Landlab?**

We will use the Landlab component *LinearDiffuser*, which implements the equations above, to explore how hillslopes evolve when linear diffusion describes hillslope sediment transport. We will explore both steady state, here defined as erosion rate equal to rock uplift rate, and also how a landscape gets to steady state.

The first example illustrates how to set-up the model and evolve a hillslope to steady state, along with how to plot some variables of interest. We assume that you have knowledge of how to derive the steady-state form of a uniformly uplifting, steady-state, diffusive hillslope. For more information on hillslope sediment transport laws, this paper is a great overview:

Roering, Joshua J. (2008) "How well can hillslope evolution models “explain” topography? Simulating soil transport and production with high-resolution topographic data." Geological Society of America Bulletin.

Based on the first example, you are asked to first think about what will happen as you change a parameter, and then you explore this numerically by changing the code.

Start at the top by reading each block of text and sequentially running each code block (shift - enter OR got to the _Cell_ pulldown menu at the top and choose _Run Cells_). 

Remember that you can always go to the _Kernel_ pulldown menu at the top and choose _Restart & Clear Output_ or _Restart & Run All_ if you change things and want to start afresh. If you just change one code block and rerun only that code block, only the parts of the code in that code block will be updated. (E.g. if you change parameters but don't reset the code blocks that initialize run time or topography, then these values will not be reset.) 
"""

"""
**Now on to the code example**

Import statements. You should not need to edit this.
"""

# below is to make plots show up in the notebook
%matplotlib inline

# Code Block 1

import numpy as np
from matplotlib.pyplot import figure, legend, plot, title, xlabel, ylabel, ylim

from landlab.plot.imshow import imshow_grid

"""
We will create a grid with 41 rows and 5 columns, and dx is 5 m (a long, narrow, hillslope). The initial elevation is 0 at all nodes.

We set-up boundary conditions so that material can leave the hillslope at the two short ends.
"""

# Code Block 2

# setup grid
from landlab import RasterModelGrid

mg = RasterModelGrid((41, 5), 5.0)
z_vals = mg.add_zeros("topographic__elevation", at="node")

# initialize some values for plotting
ycoord_rast = mg.node_vector_to_raster(mg.node_y)
ys_grid = ycoord_rast[:, 2]

# set boundary condition.
mg.set_closed_boundaries_at_grid_edges(True, False, True, False)

"""
Now we import and initialize the *LinearDiffuser* component. 
"""

# Code Block 3

from landlab.components import LinearDiffuser

D = 0.01  # initial value of 0.01 m^2/yr
lin_diffuse = LinearDiffuser(mg, linear_diffusivity=D)

"""
We now initialize a few more parameters.
"""

# Code Block 4

# Uniform rate of rock uplift
uplift_rate = 0.0001  # meters/year, originally set to 0.0001

# Total time in years that the model will run for.
runtime = 1000000  # years, originally set to 1,000,000

# Stability criteria for timestep dt.  Coefficient can be changed
# depending on our tolerance for stability vs tolerance for run time.
dt = 0.5 * mg.dx * mg.dx / D

# nt is number of time steps
nt = int(runtime // dt)

# Below is to keep track of time for labeling plots
time_counter = 0

# length of uplift over a single time step, meters
uplift_per_step = uplift_rate * dt

"""
Now we figure out the analytical solution for the elevation of the steady-state profile.
"""

# Code Block 5

ys = np.arange(mg.number_of_node_rows * mg.dx - mg.dx)

# location of divide or ridge crest -> middle of grid
# based on boundary conds.
divide_loc = (mg.number_of_node_rows * mg.dx - mg.dx) / 2

# half-width of the ridge
half_width = (mg.number_of_node_rows * mg.dx - mg.dx) / 2

# analytical solution for elevation under linear diffusion at steady state
zs = (uplift_rate / (2 * D)) * (np.power(half_width, 2) - np.power(ys - divide_loc, 2))

"""
Before we evolve the landscape, let's look at the initial topography. (This is just verifying that it is flat with zero elevation.)
"""

# Code Block 6

figure(1)
imshow_grid(mg, "topographic__elevation")
title("initial topography")
figure(2)
elev_rast = mg.node_vector_to_raster(mg.at_node["topographic__elevation"])
plot(ys_grid, elev_rast[:, 2], "r-", label="model")
plot(ys, zs, "k--", label="analytical solution")
ylim((-5, 50))  # may want to change upper limit if D changes
xlabel("horizontal distance (m)")
ylabel("vertical distance (m)")
legend(loc="lower center")
title("initial topographic cross section")

"""
Now we are ready to evolve the landscape and compare it to the steady state solution.

Below is the time loop that does all the calculations. 
"""

# Code Block 7

for i in range(nt):
    mg["node"]["topographic__elevation"][mg.core_nodes] += uplift_per_step
    lin_diffuse.run_one_step(dt)
    time_counter += dt

    # All landscape evolution is the first two lines of loop.
    # Below is simply for plotting the topography halfway through the run
    if i == int(nt // 2):
        figure(1)
        imshow_grid(mg, "topographic__elevation")
        title(f"topography at time {time_counter}, with D = {D}")
        figure(2)
        elev_rast = mg.node_vector_to_raster(mg.at_node["topographic__elevation"])
        plot(ys_grid, elev_rast[:, 2], "k-", label="model")
        plot(ys, zs, "g--", label="analytical solution - SS")
        plot(ys, zs * 0.75, "b--", label="75% of analytical solution")
        plot(ys, zs * 0.5, "r--", label="50% of analytical solution")
        xlabel("horizontal distance (m)")
        ylabel("vertical distance (m)")
        legend(loc="lower center")
        title(f"topographic__elevation at time {time_counter}, with D = {D}")

"""
Now we plot the final cross-section.
"""

# Code Block 8

elev_rast = mg.node_vector_to_raster(mg.at_node["topographic__elevation"])
plot(ys_grid, elev_rast[:, 2], "k-", label="model")
plot(ys, zs, "g--", label="analytical solution - SS")
plot(ys, zs * 0.75, "b--", label="75% of analytical solution")
plot(ys, zs * 0.5, "r--", label="50% of analytical solution")
xlabel("horizontal distance (m)")
ylabel("vertical distance (m)")
legend(loc="lower center")
title(f"topographic cross section at time {time_counter}, with D = {D}")

"""
Now we plot the steepest slope in the downward direction across the landscape.

(To calculate the steepest slope at a location, we need to route flow across the landscape.)
"""

# Code Block 9

from landlab.components import FlowAccumulator

fr = FlowAccumulator(mg)  # intializing flow routing
fr.run_one_step()
plot(
    mg.node_y[mg.core_nodes],
    mg.at_node["topographic__steepest_slope"][mg.core_nodes],
    "k-",
)
xlabel("horizontal distance (m)")
ylabel("topographic slope (m/m)")
title(f"slope of the hillslope at time {time_counter}, with D = {D}")

"""
Has the landscape reached steady state yet? How do you know?







Answer: Not quite, but it is getting close. Go back and rerun Code Blocks 7, 8 and 9 (time loop and plotting). (Remember you can rerun a cell with shift-return, or from the cell pull-down menu.) Has it reached steady state yet?  
"""

"""
**What to do and hand in:**
1. In the example illustrated here ($D$ = 0.01 m$^2$yr$^{-1}$ and $U$ = 0.0001 m yr$^{-1}$). Restart everything, and use the model to determine how long it takes for the landscape to go from a flat to reach 50%, 75% and 100% of its steady-state morphology. Does the landscape approach steady state linearly in time? (You can run the time loop (Code Block 7) multiple times without running other code blocks again to continually evolve the landscape. You will initially want to rerun all the code blocks and change the value of **run_time** (Code Block 4). Determining the correct value of **run_time** to use will take some iteration.)
2. What do you think will happen when you increase $D$ (Code Block 3) by a factor of 10? Will the time to steady state differ? If yes, how? Will the topography be different? If yes, how and why? What does it mean physically, about processes, if $D$ increases? Answer these questions before running any code. 
3. Now set $D$ = 0.1 m$^2$yr$^{-1}$ and rerun landscape evolution from an initial flat. Illustrate the final steady state topography and record the time to steady state. Discuss how the landscape differs from the results in question 1. Discuss how the results are similar to or different from your intuition. It is OK if your intuition was wrong! 
4. What do you think will happen when you increase **uplift_rate** (Code Block 4) by a factor of 10? Will the time to steady state differ? If yes, how? Will the topography be different? If yes, how and why? Answer these questions first, and then rerun the code with **uplift_rate** = 0.001 m yr$^{-1}$. (Make sure you change $D$ - Code Block 3 - back to the original value of 0.01 m$^2$yr$^{-1}$ and restart from a flat surface.) Illustrate the final steady state topography. Discuss how these results differ from the results in question 1 and how the results match (or do not) your intuition. It is OK if your intuition was wrong.

You should hand in a typed document that answers the above questions with supporting plots. Plots should be embedded in the text, or, if they all fall at the end, they need to be clearly labeled, e.g. each plot has a figure number and plots are referred to by figure number in the text.

Other questions you can explore.

1. What happens to time to steady state as you increase the length of your hillslope? 
2. Does grid resolution affect your answers? If so, how?

"""



================================================
File: docs/source/teaching/geomorphology_exercises/hillslope_notebooks/north_carolina_piedmont_hillslope_class_notebook.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using Landlab to explore a diffusive hillslope in the piedmont of North Carolina 

This notebook was developed in collaboration with Karl Wegmann at North Carolina State University. This notebook was coded by Nicole Gasparini at Tulane University.
"""

"""
<hr>
For tutorials on learning Landlab, click here: <a href="https://github.com/landlab/landlab/wiki/Tutorials">https://github.com/landlab/landlab/wiki/Tutorials</a>
<hr>

"""

"""
**What is this notebook?**

This notebook is designed to be an exercise for students in a quantative geomorphology class. This notebook is meant to illustrate to students how a model can be used to understand and interpret real landscapes. This notebook is not designed to teach students how to code, nor is it designed to teach students how to use Landlab.

This notebook provides data from a real landscape in North Carolina (below) in order to compare the shape of this hillslope with those produced by models using linear diffusion. A group of students at NC State have collected elevation data along the yellow transect in the image of the landscape below. This notebook uses that transect data and compares it  with model output.
 
![alt text](nc_image_with_transect.png)

This notebook steps students through exercises to quantify the diffusivity on this hillslope, assuming that sediment transport on this hillslope follows a linear diffusion law. Students should be introduced to the linear diffusion transport law _before_ using this notebook.

**Application of linear diffusion transport law:**

The tranport law applied here is of the form:

\begin{equation}
q_s = -D \nabla z
\end{equation}

where ${q}_s$ is the transport rate with dimensions of L$^2$T$^{-1}$;  $D$ is a transport coefficient with dimensions of L$^2$T$^{-1}$; and $z$ is elevation. $\nabla z$ is the gradient in the landscape, or change in elevation with change in distance. Landscape slope is $-\nabla z$ (assuming distance increases downhill), hence the negative in the above equation. 
 
Changes in elevation, or erosion, are calculated from conservation of mass:
\begin{equation}
\frac{dz}{dt} = U-\nabla q_s
\end{equation}
where $U$ is the rock uplift rate (relative to a fixed elevation at the boundary), with dimensions LT$^{-1}$, and $t$ is time.

Note that at steady state the rock uplift rate sets the erosion rate. If the erosion rate in a landscape is a known, a modeling scenario in which the landscape is uplifting at the same rate as the known erosion rate will eventually lead to a landscape that is also eroding at that rate. 

Although we call $U$ the rate of rock uplift rate, we would get the same solution if $U$ is the rate of river erosion in the river at the base of a hillslope. For this example, it might easier to think of $U$ as a base-level lowering rate.

**What will we do with Landlab?**

Here we will use the Landlab component *LinearDiffuser*, to explore whether hillslopes evolved according to a linear diffusion rule look like the example North Carolina hillslope. We will just be eye-balling similarities. No rigorous comparison between the real and modeled hillslope is performed.

More general background on applying hillslope process models to real landscapes can be found in this paper:

Roering, Joshua J. (2008) "How well can hillslope evolution models “explain” topography? Simulating soil transport and production with high-resolution topographic data." Geological Society of America Bulletin.

This paper has a nice compilation of measured landscape diffusivity values that can help put the values you get from this exercise in context:

Perron, J. T., (2017) "Climate and the pace of erosional landscape evolution" Annual Review of Earth and Planetary Sciences.

**What do you need to know about this Landscape?**

General information on this landscape can be found in this reference:

Wegmann, K. W., Lewis, R. Q., & Hunt, M. C. (2012). "Historic mill ponds and piedmont stream water quality: Making the connection near Raleigh, North Carolina". The Geological Society of America, Field Guide 29.

For now the following information is provided.

- The site is in the Piedmont near Raleigh, North Carolina.
- The site is in the W.B. Umstead State Park which is in the Sycamore Creek watershed. Sycamore Creek drains into the Neuse River.
- The area gets ~ 1.25 m/yr of rainfall.
- The site is currently forested.
- Basin average erosion rates from the area are on the order of 10 m/million years, or 1e-5 m/yr. These rates are averaged over approximately 100,000 years. These rates are from a nearby area similar to this, but not exactly this study area.
- The site has been heavily impacted from agriculture due to European settlers, beginning in the 1600s. 

**STUDENTS - Step 0 - What you need to do:**

You will start out by making the assumption that the landscape is eroding at a rate of 1e-5 m/yr. 

As you will see, the study area hillslope profile has a form similar to what one would expect from a uniformly eroding diffusive profile. **Your first goal is to find the diffusivity and time required for the profile to reach steady state given the background erosion rate of 1e-5 m/yr.** You can do that by running the code below. **Take special note of Code Block 4 where you set the diffusivity. Make sure choose a resonable initial value, and record what your initial value was.** Code Block 5 will allow you to see the analytical solution for hillslope form using different $D$ Values. You can play with the analystical solution to find the best $D$. Also be prepared to change model run time (Code Block 4) for your initial experiments. Once you iterate to a modeled profile that you feel reasonably matches the DEM profile (just eye-ball the similarity), you will be ready to answer the questions that follow all of the code. 

**How to run a Jupyter notebook:**

Read the text boxes and sequentially run each code block (shift - enter OR got to the _Cell_ pulldown menu at the top and choose _Run Cells_). While a code block is running there is a * in the brackets next to it. Once it has completed running there will be a number in the brackets next to it

Remember that you can always go to the _Kernel_ pulldown menu at the top and choose _Restart & Clear Output_ or _Restart & Run All_ if you change things and want to start afresh. If you just change one code block and rerun only that code block, only the parts of the code in that code block will be updated. (E.g. if you change parameters but don't reset the code blocks that initialize run time or topography, then these values will not be reset.) 
"""

"""
**Now on to the code...**

We start by importing libraries that we will need to run the code. You should not need to edit this code block.
"""

# Code Block 1

import matplotlib.pyplot as plt
import numpy as np

from landlab.plot.imshow import imshow_grid

# below is to make plots show up in the notebook
%matplotlib inline

"""
Now we will use the survey data from the NC State students and compare it to model output. Below is the information from the survey. You should not need to edit this code block.
"""

# Code Block 2

# distance and elevation data along the survey line

field_dist = np.array(
    [
        0,
        1,
        2,
        3,
        4,
        4.99,
        5.99,
        6.99,
        7.99,
        8.99,
        9.99,
        10.99,
        11.99,
        12.99,
        13.99,
        14.98,
        15.98,
        16.98,
        17.98,
        18.98,
        19.98,
        20.98,
        21.98,
        22.98,
        23.98,
        24.97,
        25.97,
        26.97,
        27.97,
        28.97,
        29.97,
        30.97,
        31.97,
        32.97,
        33.97,
        34.96,
        35.96,
        36.96,
        37.96,
        38.96,
        39.96,
        40.96,
        41.96,
        42.96,
        43.95,
        44.95,
        45.95,
        46.95,
        49.95,
        50.95,
        51.95,
        52.95,
        53.94,
        54.94,
        55.94,
        56.94,
        57.94,
        58.94,
        59.94,
        60.94,
        61.94,
        62.94,
        63.93,
        64.93,
        65.93,
        66.93,
        67.93,
        68.93,
        69.93,
        70.93,
        71.93,
        72.92,
        73.92,
        74.92,
        75.92,
        76.92,
        77.92,
        78.92,
        79.92,
        80.92,
        81.92,
        82.91,
        83.91,
        84.91,
        85.91,
        86.91,
        87.91,
        88.91,
    ]
)
field_z = np.array(
    [
        0,
        0.03,
        0.3,
        0.47,
        0.62,
        0.83,
        1.09,
        1.31,
        1.54,
        1.8,
        2.14,
        2.38,
        2.55,
        2.84,
        3.15,
        3.49,
        3.78,
        4.05,
        4.41,
        4.57,
        4.77,
        5.05,
        5.29,
        5.46,
        5.68,
        5.96,
        6.4,
        6.81,
        6.99,
        7.21,
        7.45,
        7.63,
        7.79,
        7.87,
        8.06,
        8.24,
        8.4,
        8.51,
        8.65,
        8.68,
        8.82,
        8.98,
        9.01,
        9.04,
        9.05,
        9.09,
        9.07,
        9.07,
        9.02,
        8.93,
        8.9,
        8.83,
        8.73,
        8.62,
        8.47,
        8.28,
        8.22,
        8,
        7.82,
        7.75,
        7.39,
        7.2,
        7.04,
        6.79,
        6.6,
        6.39,
        6.1,
        5.77,
        5.5,
        5.3,
        5.11,
        4.89,
        4.64,
        4.5,
        4.32,
        4.1,
        3.96,
        3.6,
        3.19,
        2.92,
        2.73,
        2.41,
        2.12,
        1.76,
        1.21,
        0.95,
        0.56,
        0.06,
    ]
)

"""
We will create a grid for our model using Landlab's *RasterModelGrid* class, which we need to import. We make a grid with *dx* = *dy* = 1.0 m (same resolution as the survey data). We make a grid that has 5 columns and 90 rows, to match the length of the profile from the real landscape.
"""

# Code Block 3

from landlab import RasterModelGrid

mg = RasterModelGrid((90, 5), 1.0)  # make grid
z_vals = mg.add_ones("topographic__elevation", at="node")  # initialize z values

# Set initial conditions
initial_elevation = np.multiply(
    z_vals, -1.0
)  # this line and next set elevation to 87. m
z_vals += initial_elevation

# Set boundary conditions
mg.set_closed_boundaries_at_grid_edges(True, False, True, False)

# Initialize values for plotting variables down the middle of the hillslope

ycoord_rast = mg.node_vector_to_raster(mg.node_y)
ys_grid = ycoord_rast[:, 2]

"""
Now we import and initialize the *LinearDiffuser* component. In this case the units on our diffusivity coefficient, or transport coefficient, are m$^2$yr$^{-1}$.

**NOTE to Students:** You need to chose a reasonable initial value for D (diffusivity). Remember you need to justify your initial guess for D. Supplied references should help with this.

We also initialize a few more parameters.
"""

# Code Block 4

from landlab.components import LinearDiffuser

D = 0.005  # value in m^2/yr
lin_diffuse = LinearDiffuser(mg, linear_diffusivity=D)

# Uniform rate of rock uplift, which drives uniform erosion at steady state
uplift_rate = 0.00001  # m/year, start with 1e-5 m/yr

# Total time in years that the model will run for.
runtime = 500000  # years

# Stability criteria for timestep dt.  Coefficient can be changed
# depending on our tolerance for stability vs tolerance for run time.
# Do not change this.
dt = 0.5 * mg.dx * mg.dx / D

print("dt", dt)

# nt is number of time steps
nt = int(runtime // dt)

# Below is to keep track of time for labeling plots
time_counter = 0

# length of uplift over a single time step, meters
uplift_per_step = uplift_rate * dt

"""
Now we figure out the analytical solution for the elevation of the steady-state profile.

Before we evolve the landscape, we look at the model initial topography, the analytical solution, and the field profile.
"""

# Code Block 5

# ANALYTICAL SOLUTION
ys = np.arange(mg.number_of_node_rows * mg.dx - mg.dx)

# location of divide or ridge crest -> middle of grid
# based on boundary conds.
divide_loc = (mg.number_of_node_rows * mg.dx - mg.dx) / 2

# half-width of the ridge
half_width = (mg.number_of_node_rows * mg.dx - mg.dx) / 2

# analytical solution for elevation under linear diffusion at steady state
zs = (uplift_rate / (2 * D)) * (np.power(half_width, 2) - np.power(ys - divide_loc, 2))

# PLOTTING
plt.figure()
imshow_grid(mg, "topographic__elevation")
plt.title("initial topography, at right is the colorbar")
plt.figure()
elev_rast = mg.node_vector_to_raster(mg.at_node["topographic__elevation"])
plt.figure()
plt.plot(ys_grid, elev_rast[:, 2], "r-", label="model")
plt.plot(ys, zs, "k--", label="analytical solution")
plt.plot(field_dist, field_z, "b:", label="field data")
plt.xlabel("horizontal distance (m)")
plt.ylabel("elevation (m)")
plt.legend(loc="lower center")
# plt.title('before running model')

"""
Now you can update the values of $D$ in Code Block 4 and rerun Code Block 5 to fit the analytical solution to the field data. 

Once you have done that, run the model and evolve the landscape to make sure it also fits the analytical solution. You may need to update $runtime$ in Code Block 4 if the model does not match the analytical solution. Remember that you need to find the $D$ value and approximate time that it takes for the landscape to reach steady state.

Below is the time loop that does all the calculations. 
"""

# Code Block 6

for i in range(nt):
    mg["node"]["topographic__elevation"][mg.core_nodes] += uplift_per_step
    lin_diffuse.run_one_step(dt)
    time_counter += dt

print("time evolved for ", time_counter, " years")

"""
Now we plot the evolved cross-section.
"""

# Code Block 7
plt.figure()
elev_rast = mg.node_vector_to_raster(mg.at_node["topographic__elevation"])
plt.plot(ys_grid, elev_rast[:, 2], "r-", label="model")
plt.plot(ys, zs, "k--", label="analytical solution")
plt.plot(field_dist, field_z, "b:", label="field data")
plt.xlabel("horizontal distance (m)")
plt.ylabel("vertical elevation (m)")
plt.legend(loc="lower center")
plt.title(f"topographic cross section at time {time_counter}, with D = {D} m^2/yr")

"""
**Questions to answer and further model experiments:**

_NOTE_ You should hand in a typed, electronic document that has figures embedded in the document. The document can be any type of readable file. Please include your name in the file name that you turn in.

**Questions:**
1. Your first task was to find the diffusivity and time to steady state required for the model to produce a landscape similar to the field area near Raleigh, NC. (Time to steady state can be approximate, as in within 500,000 years.) What was your initial guess for a diffusivity? What information did you use to choose that initial value? What was the value that produced a good match between the modeled and real hillslope form? (Again, you can eye-ball the match. Just get close visually.) Compared with other values of diffusivity that have been reported in the literature, how does your value compare? Given what you know about this landscape, does this seem like a reasonable diffusivity? Explain.
2. What was the estimated time to steady state using the model? Compare the time to steady state with the time over which erosion rates were measured and the time period over which settlers have dramatically impacted this landscape. What are the implications of the differences among the time to steady state, the time over which erosion rates were measured, and time over which settlers have impacted this system?
3. It is possible that settlers accelerated erosion rates (from the background, pre-settlement rate, which here we can assume is set from "background rock uplift" as 1e-5 m/yr) by almost 500 times. If that happened, the pre-settlement profile likely had a higher peak elevation (and higher total relief), and accelerated erosion would have removed soil and lowered elevations across the profile. This has implications for your estimated diffusivity. 
    - Develop a scenario in which you evolve a 'pre-settlement' hillslope to steady state (should have higher relief than the current profile) with a different diffusivity. Think about whether the diffusivity should be higher or lower to create higher relief, using the same background erosion/rock uplift rate. Change Code Block 4 and create this new pre-settlement steady state landscape using Code Blocks 6 and 7. 
    - Use this landscape as the initial condition to evolve the landscape another 400 years with a new diffusivity to simulate the impact of settlers. (Once you get your pre-settlement hillslope, go back to Code Block 4 and change $D$ and $runtime$ accordingly, then rerun Code Blocks 6 & 7). 
    - You should end up with a simulated hillslope that matches the current topography, but you got there in a different way than you did for the first part of this exercise. Provide plots and describe in detail exactly what you did to simulate the pre- and post-settler landscape. Are there noticeable changes in the landscape? Does this have implications for future evolution of this hillslope?
"""



================================================
File: docs/source/teaching/surface_water_hydrology_exercises/overland_flow_notebooks/hydrograph_class_notebook.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Exploring rainfall driven hydrographs with Landlab
This notebook was developed from code written by Jordan Adams as part of her PhD disseration at Tulane University. This notebook was created by Nicole Gasparini at Tulane University.
"""

"""
<hr>
<small>For tutorials on learning Landlab, click here: <a href="https://github.com/landlab/landlab/wiki/Tutorials">https://github.com/landlab/landlab/wiki/Tutorials</a></small>
<hr>
"""

"""
**What is this notebook?**

This notebook illustrates the importance of watershed shape and rainfall intensity and duration on the characteristics of hydrographs. 

To clearly contrast landscape shape, this notebook uses two synthetic landscapes, or landscapes produced using a landscape evolution model. One landscape is square (length = width) and one is rectangular (length = 4*width). Both landscapes have a drainage area of 36 km$^2$ and a cell size of 30 m.

Overland flow is modeled as a diffusive approximation of the shallow water equation. (If you do not understand what that means, you can still learn from this notebook.) No infiltration is modeled. Rain falls on the landscape and flows downhill, driving overland flow and a hydrograph at every location on the landscape. In this notebook, we track the hydrograph at three points in the watershed.

Before using this notebook you should have learned about overland flow and a hydrograph. You should know the terms rainfall intensity and duration, as well as peak discharge, hydrograph time to peak, rising limb, and falling limb. For example, these concepts are covered in Chapter 10 of:

Dingman, S.L., 2015. Physical hydrology, third edition. Waveland press.

More background on the model used here and the results presented can be found in:

Adams, J.M., Gasparini, N.M., Hobley, D.E., Tucker, G.E., Hutton, E.W., Nudurupati, S.S. and Istanbulluoglu, E., 2017. The Landlab v1. 0 OverlandFlow component: a Python tool for computing shallow-water flow across watersheds. Geoscientific Model Development.

The code used in this exercise is taken from the above Adams et al., (2017) reference.

**What will you do?** 

You will run this model several times, changing the rainfall characteristics or watershed on which flow is routed. You will generate hydrographs and learn how different parameters affect hydrograph characteristics.

Start at the top by reading each block of text and sequentially running each code block (put your curser in a code block and type shift - enter OR got to the _Cell_ pulldown menu at the top and choose _Run Cells_). 

Remember that you can always go to the _Kernel_ pulldown menu at the top and choose _Restart & Clear Output_ or _Restart & Run All_ if you change things and want to start afresh. 

**Questions to answer before running this notebook.**

1. Do you think that watershed shape affects hydrograph shape? Consider two watersheds, one that is square and one that is rectangular with a width to length ratio of 1 to 4. Both watersheds have the same drainage area. If the same amount of rain falls uniformly across each landscape, will it affect the time to peak and peak discharge at the outlet?
2. Do you think that the rainfall intensity impacts the time to peak and peak discharge at a watershed outlet? If so, how?
3. Do you think that the rainfall duration impacts the time to peak and peak discharge at a watershed outlet? If so, how?
"""

"""
**Now on to the code.**
* Below we import Landlab components, functions for importing data, numpy and plotting tools. You should not need to change this.
"""

## Code Block 1
import numpy as np
from matplotlib import pyplot as plt
from tqdm.notebook import tqdm

from landlab.components import FlowAccumulator, OverlandFlow
from landlab.io import esri_ascii

"""
Now we import the data for the watershed we want to route flow on. **You will want to change this code block for the different scenarios. Initially you do not need to change anything.**

* The user can change the `basin_flag` to equal `Square` or `Long` depending on the watershed to run.
  * The outlet link for each watershed was pretermined for plotting purposes.
* The user can also choose which storm to run. 
  * `Base` has an intensity of 5.0 mm/hr, with a duration of 2 hr.
  * `HigherIntensity` has an intensity of 10.0 mm/hr, with a duration of 1 hr.
  * `LongerDuration` has an intensity of 2.5 mm/hr, with a duration of 4 hr.
"""

## Code Block 2

basin_flag = "Square"  # 'Square' or Long'
storm_flag = "Base"  # 'Base' or'HigherIntensity' or 'LongerDuration'

## If the basin flag matches one of the two select basins,
## below will set the filename which to read the DEM from and
## the outlet link and upstream link to sample discharge values
## from for plotting.

if basin_flag == "Square":
    watershed_dem = "Square_TestBasin.asc"
    ## Reading in the DEM given the filename from above
    with open(watershed_dem) as fp:
        rmg = esri_ascii.load(fp, name="topographic__elevation", at="node")
    outlet_node_to_sample = 300
    outlet_link_to_sample = rmg.links_at_node[outlet_node_to_sample][3]
    upstream_node_to_sample = 28689
    upstream_link_to_sample = rmg.links_at_node[upstream_node_to_sample][3]
    midstream_node_to_sample = 9102
    midstream_link_to_sample = rmg.links_at_node[midstream_node_to_sample][3]
else:
    watershed_dem = "Long_TestBasin.asc"
    ## Reading in the DEM given the filename from above
    with open(watershed_dem) as fp:
        rmg = esri_ascii.load(fp, name="topographic__elevation", at="node")
    outlet_node_to_sample = 150
    outlet_link_to_sample = rmg.links_at_node[outlet_node_to_sample][3]
    upstream_node_to_sample = 33859
    upstream_link_to_sample = rmg.links_at_node[upstream_node_to_sample][3]
    midstream_node_to_sample = 14658
    midstream_link_to_sample = rmg.links_at_node[midstream_node_to_sample][2]

## The Flow Router calculates drainage area, which is helpful for
## calculating equilibrium discharge, which we illustrate later.
fr = FlowAccumulator(rmg)  # Instantiate flow router
fr.run_one_step()  # Drainage area calculated

"""
Now we set the boundary conditions, initialize the process components, and set the appropriate storm parameters.
"""

## Code Block 3

## Set boundary coditions on the grid
rmg.set_watershed_boundary_condition(rmg.at_node["topographic__elevation"])

## instantiate OverlandFlow object
rmg.add_zeros("surface_water__depth", at="node")
of = OverlandFlow(rmg, alpha=0.45, steep_slopes=True)

## Assign storm conditions based on flag in Code Block 2
if storm_flag == "Base":
    starting_precip_mmhr = 5.0
    starting_precip_ms = starting_precip_mmhr * (2.77778 * 10**-7)
    storm_duration = 7200.0
elif storm_flag == "HigherIntensity":
    starting_precip_mmhr = 10.0
    starting_precip_ms = starting_precip_mmhr * (2.77778 * 10**-7)
    storm_duration = 3600.0
elif storm_flag == "LongerDuration":
    starting_precip_mmhr = 2.5
    starting_precip_ms = starting_precip_mmhr * (2.77778 * 10**-7)
    storm_duration = 14400.0

"""
Before we go further, let's pause to look at the landscape that we will be routing flow over.
"""

## Code Block 4

# plt.figure(1)
# imshow_grid(rmg, z)  # plot the DEM
rmg.imshow("topographic__elevation")
plt.plot(rmg.node_x[outlet_node_to_sample], rmg.node_y[outlet_node_to_sample], "yo")
plt.plot(rmg.node_x[upstream_node_to_sample], rmg.node_y[upstream_node_to_sample], "bo")
plt.plot(
    rmg.node_x[midstream_node_to_sample], rmg.node_y[midstream_node_to_sample], "go"
)

"""
Initialize a few more parameters, and getting ready to run the time loop and save data for plotting.
  * Note that time is in *seconds*
"""

## Code Block 5

elapsed_time = 1.0  # s
model_run_time = 43200.0  # s

## Lists for saving data
discharge_at_outlet = []
discharge_upstream = []
discharge_midstream = []
hydrograph_time = []

## Setting initial fields...
rmg.at_node["surface_water__discharge"] = np.zeros(rmg.number_of_nodes)

"""
Now the time loop that generates overland flow.

_Note_ On a 2016 MacBook Pro laptop the following code block can take ~ 5 minutes depending on the model set-up. It could take longer if multiple users are running at the same time using the Hydroshare platform.
"""

## Code Block 6

with tqdm(total=model_run_time) as pbar:
    while elapsed_time < model_run_time:
        # Setting the adaptive time step
        of.dt = of.calc_time_step()

        ## The storm starts when the model starts. While the elapsed time is less
        ## than the storm duration, we add water to the system as rainfall.
        if elapsed_time < (storm_duration):
            of.rainfall_intensity = starting_precip_ms
        else:  # elapsed time exceeds the storm duration, rainfall ceases.
            of.rainfall_intensity = 0.0

        of.run_one_step()  # Generating overland flow based on the deAlmeida solution.

        ## Append time and discharge to their lists to save data and for plotting.
        hydrograph_time.append(elapsed_time)
        q = rmg.at_link["surface_water__discharge"]
        discharge_at_outlet.append(np.abs(q[outlet_link_to_sample]) * rmg.dx)
        discharge_upstream.append(np.abs(q[upstream_link_to_sample]) * rmg.dx)
        discharge_midstream.append(np.abs(q[midstream_link_to_sample]) * rmg.dx)

        elapsed_time += of.dt

        pbar.update(of.dt)

"""
Let's look at the data.
"""

## Code Block 7

## Calculate equilibrium discharge at each point for reference
outlet_eq_q = starting_precip_ms * rmg.at_node["drainage_area"][outlet_node_to_sample]
midstream_eq_q = (
    starting_precip_ms * rmg.at_node["drainage_area"][midstream_node_to_sample]
)
upstream_eq_q = (
    starting_precip_ms * rmg.at_node["drainage_area"][upstream_node_to_sample]
)


## Plotting hydrographs and equilibrium discharge
plt.figure(2)
plt.plot(hydrograph_time, discharge_at_outlet, "y-", label="outlet")
plt.plot(
    [np.min(hydrograph_time), np.max(hydrograph_time)],
    [outlet_eq_q, outlet_eq_q],
    "y--",
    label="outlet eq Q",
)
plt.plot(hydrograph_time, discharge_midstream, "g-", label="midstream")
plt.plot(
    [np.min(hydrograph_time), np.max(hydrograph_time)],
    [midstream_eq_q, midstream_eq_q],
    "g--",
    label="midstream eq Q",
)
plt.plot(hydrograph_time, discharge_upstream, "b-", label="upstream")
plt.plot(
    [np.min(hydrograph_time), np.max(hydrograph_time)],
    [upstream_eq_q, upstream_eq_q],
    "b--",
    label="upstream eq Q",
)

## Plot storm end and center of storm for reference
plt.plot(
    [storm_duration, storm_duration], [0, 100], "k-", linewidth=2, label="storm end"
)
plt.plot(
    [storm_duration / 2, storm_duration / 2], [0, 100], "k:", label="storm mid point"
)

plt.ylabel("Discharge (cms)")
plt.xlabel("Time (seconds)")
plt.legend(loc="upper right")
title_text = "Hydrographs, Storm is " + storm_flag + ", Watershed is " + basin_flag
plt.title(title_text)
plt.axis([0, np.max(hydrograph_time), 0, 100])

"""
If you have reached this point, you should have produced a plot of three hydrographs from different points on the square watershed, produced from overland flow driven by the base storm.

There are six scenarios to explore: two different watersheds and three different storms. Run all six scenarios by systematically changing the *basin_flag* and *storm_flag* in Code Block 2 and rerunning all of the following code blocks sequentially. Save the hydrograph plots for each scenario. Include those plots in a document that also contains your typed answers to each of the questions below. Answer all of the questions with complete sentences. Try to be as specific and as quantitative as you can. (e.g. You can compare times to peak discharge and peak discharge values among the scenarios.) You are encouraged to discuss the results of the models with your classmates, but the text you turn in must be your own thoughts and words.

1. Consider only the three stroms run on the square watershed. What aspects of the hydrograph change at the outlet as the storm gets longer or more intense? Are there aspects of the outlet hydrograph that are not sensitive to the storm duration or intensity? Do the midstream and upstream hydrographs exhibit the same sensitivity to storm duration and intensity? If yes, why? If no, why not?

2. Now, consider only the three stroms run on the long watershed. What aspects of the hydrograph change at the outlet as the storm gets longer or more intense? Are there aspects of the outlet hydrograph that are not sensitive to the storm duration or intensity? Do the midstream and upstream hydrographs exhibit the same sensitivity to storm duration and intensity? If yes, why? If no, why not?

3. Now compare the results between the two different basin shapes. Compare only between similar points (e.g. square outlet to long outlet) and between the same storm characteristics. Does watershed shape affect hydrograph shape? If so, how? If so, does it impact all locations in the same manner? Do different storm charactersitics exaggerate the differences between the different watersheds?

4. Go back and look at your answers to the questions you answered before running the models. Do the model results match your intuition? If not, do you think your intuition was wrong, or the model was wrong, or both? Remember, models are helpful for learning but they are highly simplified representations of the real world. Wihtout knowing the details of the model, does it seem like something is missing from your model results?
"""



================================================
File: docs/source/tutorials/index.md
================================================
(tutorials)=

# The Landlab tutorials

Two papers have been written describing Landlab, both are open access:
* [Creative computing with Landlab: an open-source toolkit for building,
  coupling, and exploring two-dimensional numerical models of Earth-surface
  dynamics][esurf-2017]
* [Short communication: Landlab v2.0: a software package for Earth
  surface dynamics][esurf-2020]

[esurf-2017]: https://esurf.copernicus.org/articles/5/21/2017/
[esurf-2020]: https://esurf.copernicus.org/articles/8/379/2020/
[reference-guide]: /user_guide/reference/index
[tutorial-bc-perimeter]: boundary_conditions/set_BCs_on_raster_perimeter.ipynb
[tutorial-bc-voronoi]: boundary_conditions/set_BCs_on_voronoi.ipynb
[tutorial-bc-watersheds]: boundary_conditions/set_watershed_BCs_raster.ipynb
[tutorial-bc-xy]: boundary_conditions/set_BCs_from_xy.ipynb
[tutorial-components]: component_tutorial/component_tutorial.ipynb
[tutorial-div-grad]: gradient_and_divergence/gradient_and_divergence.ipynb
[tutorial-fault-scarp]: fault_scarp/landlab-fault-scarp.ipynb
[tutorial-fields]: fields/working_with_fields.ipynb
[tutorial-grid-objects]: grids/grid_object_demo.ipynb
[tutorial-mappers]: mappers/mappers.ipynb
[tutorial-plotting]: plotting/landlab-plotting.ipynb
[tutorial-reading-dem]: reading_dem_into_landlab/reading_dem_into_landlab.ipynb
[user-guide]: /user_guide/index
[user-guide-components]: /user_guide/components
[user-guide-grids]: /user_guide/reference/grid


```{note}
We highly recommend reading both before starting on the steps below.
```

##  1. Format and Outline

You will alternate between reading documentation on the [User Guide][user-guide]
finding information in the [Reference Manual][reference-guide], and working
through the tutorials.

The tutorials are presented as Jupyter notebooks, which contain a mixture of text,
images, and code blocks. When you look at the tutorials, don't just read them. Start
by clearing the results by selecting ``Kernel`` → ``Restart & Clear Output``, then go
ahead and try running each code block as you come to it.

### 1.1 A motivating example

- [Notebook: Introduction to Landlab: example model of fault-scarp
  degradation][tutorial-fault-scarp]

### 1.2 Using the Documentation

The Landlab Reference Manual contains documentation for most functions in the
Landlab package. It is the comprehensive counterpart to the anecdotal tutorials.

- Spend some time clicking around in the [User Guide][user-guide] and
[Reference Manual][reference-guide] to get a sense for what is there. Tip: to
find a particular command, click on Index and use your browser's search function
to search for a command by name or keyword. For example, look at the
{class}`~.LinearDiffuser`, which you just used in the prior tutorial.

### 1.3 Introduction to the Landlab Grid and Fields

First, lets look at the [User Guide page on Landlab grids][user-guide-grids].

- [Notebook: Introduction to the model grid object][tutorial-grid-objects]
  Grid topology; how landlab represents data; connectivity of grid elements.
- [Notebook: Introduction to Landlab data fields][tutorial-fields]
How Landlab stores spatial data on the grid; a little on naming conventions.

Extra credit: Go back to the [Hobley et al. 2017 publication][esurf-2017]
and identify the ordering conventions of nodes, links, and other grid elements.

### 1.4 Working with Digital Elevtion Models (DEMs)

- [Notebook: Reading DEMs into Landlab][tutorial-reading-dem] Getting an ARC
  ESRI ASCII into Landlab; getting the boundary conditions set right.

### 1.5 Plotting

- [Notebook: Introduction to plotting output with Landlab][tutorial-plotting]
  The basics of plotting with Landlab; combining matplotlib and out plots; the
  {func}`~.imshow_grid` function.

### 1.6 Boundary conditions

- Setting boundary conditions on Landlab grids (several tutorials): How Landlab
  conceptualises boundary conditions; various ways to interact and work with them.
  - [Notebook: Raster perimeter][tutorial-bc-perimeter]
  - [Notebook: Based on X-Y values][tutorial-bc-xy]
  - [Notebook: Watersheds][tutorial-bc-watersheds]
  - [Notebook: Voronoi][tutorial-bc-voronoi]

### 1.7 Introduction to Components

- Read the [Task: Component page in the User Guide][user-guide-components]
- [Notebook: Introduction to using the Landlab component library][tutorial-components]
  The basics of working with and coupling components, using {class}`~.LinearDiffuser`,
  {class}`~.FastscapeEroder`, and {class}`~.PrecipitationDistribution`.

### 1.8 Advanced Grid and Fields: Gradients, Flux-Divergence, Mapping

In addition to having lots of important information about adjacency of nodes, links,
and other grid elements, the Landlab Grid object has a number of built-in functions
for calculating quantities like gradients and flux-divergence, and for mapping
quantities from nodes to links and so forth. Work through these tutorials to get a
sense of this functionality:

- [Notebook: Using the gradient and flux-divergence functions][tutorial-div-grad]
  Landlab as solving environment for staggered grid finite difference differential
  approximations; functions available to help you do this.
- [Notebook: Mapping values from nodes to links][tutorial-mappers] Options
  for getting data on links to nodes, nodes to links, etc.; min, max, and mean;
  upwinding and downwinding schemes; one-to-one, one-to-many, and many-to-one mappings.


```{toctree}
:caption: Gallery
:hidden:
:glob:

Gallery </generated/tutorials/index>
```



================================================
File: docs/source/tutorials/advection/overview_of_advection_solver.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# TVD advection solver and related functions

*(Greg Tucker, first version April 2023)*

This notebook reviews Landlab tools for solving advection equations numerically. The tools include the `AdvectionSolverTVD` component and several related functions. `AdvectionSolverTVD` provides a second-order, total variation diminishing (TVD) numerical finite-volume solution to the 2D advection equation. The component requires a structured grid (raster or hex). The component can advect any node-based field or array. The user needs to provide a link-based advection velocity field.

## Overview of new functions

Second-order TVD methods require evaluation of gradients "upwind" of a given location, where "upwind" means in the direction opposite to the advection direction. To facilitate this, Landlab's `components.advection` package includes the following functions:

- `find_upwind_link_at_link`: for each link, identifies the adject parallel link that lies in the upwind direction. This function makes use of the raster- and hex-based property `parallel_links_at_link`, which is a (number-of-links x 2) data structure that records the IDs of adjacent parallel links that lie in the tail-wise (elements [:,0]) and head-wise (elements [:,1]) directions. The `find_upwind_link_at_link` function is called directly by `AdvectionSolverTVD`, but it is also available as a public function for custom-built applications.
- `upwind_to_local_grad_ratio`: for each link, calculates the ratio of gradient of given node scalar at the upwind link (if it exists) to the gradient at local link. For links that lack an upwind link (e.g., upwind would be beyond the grid boundary), or those where the local gradient is zero, a value of 1 is assigned. (Note that links along a grid boundary are considered not to have an upwind link.) Again, the function is called directly by `AdvectionSolverTVD`, but it is also available as a public function for custom-built applications.

TVD methods also require the use of a "flux limiter" function, which takes the upwind-to-local gradient ratio as an input, and returns a weighting factor that sets the relative contribution of high-order to low-order terms (see below). Many flux limiter functions have been proposed. As of this writing, Landlab's advection package includes just one: `flux_lim_vanleer`, which can be imported from `landlab.advection.flux_limiters`. As of this writing, `AdvectionSolverTVD` uses the Van Leer flux limiter (future versions might provide other flux limters as user options).

"""

"""
## Theory

The `AdvectionSolverTVD` and related support functions provide second-order TVD models for 2D advection. Here we briefly review the theory using a 1D advection equation with state variable $z$:

$$\frac{\partial z}{\partial t} = -u \frac{\partial z}{\partial x}$$

where $t$ is time, $x$ is spatial position in 1D, and $u$ is advection velocity (positive in the $x$ direction). This type of equation comes in up in numerous contexts in Earth and environmental sciences. The right-hand side is an *advection term*; often such terms appear in combination with other terms, such as diffusion or source. (See for example Slingerland and Kump *Mathematical Modeling of Earth's Dynamical Systems* (2011)).

To learn more about numerical solutions to advection problems, I highly recommend a series of online videos by Dr. Hilary Weller in the Meteorology Department at the University of Reading.


### Discretizing the advection equation

A common discretization involves solving $z$ at a set of *nodes*, which we'll indicate with a subscript $j$, so that $z_j$ refers to the value of $z$ at node $j$. We'll use superscripts to denote time step, so that $z_j^n$ means the value of $z$ at node $j$ and time step $n$. Using a first-order forward-difference time discretization, the discretized 1D advection equation can be written as:

$$\frac{z_j^{n+1}-z_j^n}{\Delta t} = -u \frac{z_{j+1/2} - z_{j-1/2}}{\Delta x}$$

where $\Delta x$ is the spacing between nodes. Note that we've omitted the time-step superscript on the right side; for purposes of this example, we'll assume it is $n$, indicating an explicit solution, where not otherwise noted.

We can rearrange this equation to solve for the future quantity as:

$$z_j^{n+1} = z_j -c( z_{j+1/2} - z_{j-1/2} )$$

where $c$ is a dimensionless parameter known as the Courant number:

$$c = \frac{u\Delta t}{\Delta x}$$

Note that $c$ has the same sign as $u$.

### Defining the "in between" values

One of the challenges in solving advection problems discretized as above is defining what $j+1/2$ or $j-1/2$ means. If we imagine that each node sits inside a cell of width $\Delta x$, then index $j+1/2$ refers to the interface between the cells that contain nodes $j$ and $j+1$. The sketch below shows two nodes (indicated by a dot), labeled $j$ and $j+1$, with the ^ mark showing the interface at location $j+1/2$:

```
-------------
|  .  |  .  |
-------------
   j  ^ j+1
    j+1/2
```

To solve the equation, we need a way of mapping values from one or both adjacent nodes onto the interface between them. One approach is to use a *first-order upwind* method, in which we assign to location $z_{j+1/2}$ either the value $z_j$ or $z_{j+1}$, depending on which is "upwind" (in the direction opposite to that implied by $u$). If $u>0$, we would assign $z_j$; if $u<0$, we would assign $z_{j+1}$. Mathematically, this can be written:

$$z_{j+1/2} = z_j \text{ if } c\ge0, z_{j+1} \text{otherwise}$$

### Second-order Total Variation Diminishing scheme

The problem with first-order upwind schemes is that they tend to produce excessive smoothing. One solution is to use a *linear second-order advection scheme*. One such scheme is the well-known Lax-Wendroff method, which assigns a weighted average of $z_j$ and $z_{j+1}$ based on the Courant number:

$$z_{j+1/2} = \frac{1}{2}(1+c)z_j + \frac{1}{2} (1-c)z_{j+1}$$

However, linear second-order methods generate spurious oscillations in the solution. Lax-Wendroff solutions tend to be smooth ahead of a discontinuity but generate oscillations behind it. The Warming and Beam method:

$$z_{j+1/2} = \frac{1}{2}(3-c)z_j - \frac{1}{2} (1-c)z_{j-1}$$

has the opposite problem, with smoothness behind but oscillations ahead.

These oscillation represent an increase in the *total variation*, which in this discrete formulation is the sum of $|z_j - z_{j+1}|$, i.e., the sum of all variations in adjacent values of $z$.

To ensure *Total Variation Diminishing*, we can calculate $z_{j+1/2}$ as a weighted average of a *high-order flux* $z_H$ and a *low-order flux* $z_L$:

$$z_{j+1/2} = \Psi_{j+1/2} z_H + (1-\Psi_{j+1/2}) z_L$$

The low-order flux is just the linear upwind solution:

$$z_{L,j+1/2} = z_j \text{ if } c\ge0, z_{j+1} \text{otherwise}$$

For the high-order flux, Lax-Wendroff is a good choice:

$$z_{H,j+1/2} = \frac{1}{2}(1+c)z_j + \frac{1}{2} (1-c)z_{j+1}$$

$\Psi$ is called a *flux limiter* function. The idea is to use $z_H$ as much as possible. In particular, we want to have $\Psi$ approach 1 where the solution is smooth, and approach zero where the solution is changing fast. This is a nonlinear method because $\Psi$ depends on $z$.

It turns out to be useful to define $\Psi$ in terms of a variable called $r$, which represents the ratio of the upwind gradient to the local gradient. For $u>0$,

$$r_{j+1/2} = \frac{z_j - z_{j-1}}{z_{j+1}-z_j}$$

and for $u<0$

$$r_{j+1/2} = \frac{z_{j+2} - z_{j+1}}{z_{j+1}-z_j}$$

(Note: I have not found a source that describes what to do when the denominator is zero. From Campforts et al. (2017) it looks as they set $r=1$ when that happens.)

One can cast $\Psi$ as a function of $r$. There are constraints on doing this to ensure TVD (summarized [here](https://en.wikipedia.org/wiki/Flux_limiter)). There are lots of these flux limiter functions. As of this writing, the one used in `AdvectionSolverTVD` is called Van Leer:

$$\Psi(r) = \frac{r+|r|}{1+|r|}$$

Practically speaking, one needs to compute gradients locally and at the upwind locations in order to calculate $r$, and then calculate the flux limiter $\Psi$ for each pair of adjacent nodes. After computing $z_H$ and $z_L$ for each pair of nodes, you calculate the weighted averages using $\Psi$. Once that's done, you calculate the solution to the difference equation above to get the value of $z$ at each node for the new time step. As described below, the `AdvectionSolverTVD` takes advantage of Landlab's node-link geometry to do these calculations.
"""

"""
## Numerical implementation on a Landlab grid

In translating the second-order TVD scheme above onto a Landlab structured grid, it's important to note that the discretized advection equation can be cast as a conservation-law problem. If the horizontal flux of a quantity $z$ is $q = uz$, then we can re-write the advection equation as:

$$\frac{\partial z}{\partial t} = -\frac{\partial q}{\partial x}$$

This equation has the form of a 1D mass (or volume) conservation equation with specific mass (or volume) flux $q$.

For the sake of a concrete example, suppose we are interested in the tectonic advection of topography (with height = $z(x,t)$) through a fixed grid. The volume of material inside a grid cell $j$ with projected surface area $a_j$ is its average height, $z_j$, times the area. Along each face $k$ of the cell, material is being advected in at a rate of $Q_k$ cubic meters per year. If $Q_k$ is negative, it means that material is being carried out of the cell at that face. The rate of change of volume is:

$$\frac{\partial a_jz_j}{\partial t} = \sum_{k=1}^{N_j} Q_k$$

where $N_j$ is the number of faces in cell $j$ (4 if it is a rectangle, 6 if it is a hexagon, etc.). Let $\lambda$ represent the length of a cell *face*. We can use this to express volume flux in terms of specific volume flux, $q_k$, times $\lambda$:

$$\frac{\partial a_jz_j}{\partial t} = \sum_{k=1}^{N_j} \lambda_k q_k$$

Assuming the cell areas don't change with time,

$$\frac{\partial z_j}{\partial t} = \frac{1}{a_j} \sum_{k=1}^{N_j} \lambda_k q_k$$

Landlab already has a built-in function to calculate the right-hand side of this equation: `calc_flux_div_at_node`. The user just needs to provide an array of $q$ values defined at links, and the function then uses the grid geometry ($\lambda$ and $a$) to calculate the resulting rate.

(By the way, when we are dealing with a raster grid, the above equation gets even simpler: $N_j=4$, $\lambda_k$ is the grid spacing $\Delta x$, and $a_j=\Delta x^2$. For a hex grid, $N_j=6$, and $\lambda_k$ and $a_j$ are the length of a hexagon face and the area of a hexagon cell, respectively. But we don't need to worry about these implementation details, because the `calc_flux_div_at_node` takes care of them.)

For the topographic advection problem, $q_k$ for any given cell face is the product of $z_k$ and the face-perpendicular advection velocity $u_k$. Because each cell face also has a matching *link* that connects the two nodes in question, the approach used by `AdvectionSolverTVD` is to calculate and store $z_k$, $u_k$, and $q_k$ at the links. Among other things, this means that the user needs to provide face-perpendicular (link-parallel) advection velocities $u_k$.

### Setting up face-perpendicular advection velocities

For a `RasterModelGrid`, assigning face-perpendicular velocities is straightforward. Assuming you know the $x$ and $y$ velocity components, you can simply assign the $x$ component to horizontal links, and the $y$ component to vertical links. For example, if `vel` is an at-link velocity array (a required input; see below), `grid` is a `RasterModelGrid`, and `ux` and `uy` are spatially uniform velocity components, then you can assign the correct link-parallel velocities with:

```
vel[grid.horizontal_links] = ux
vel[grid.vertical_links] = uy
```

For a `HexModelGrid`, it is a bit more complicated, because the faces don't all align with Cartesian directions. Fortunately, Landlab provides a mapping function called `map_vectors_to_links` to take care of this, illustrated by this example:

```
vel = grid.add_zeros('advection__velocity', at='link')
grid.map_vectors_to_links(ux, uy, out=vel)
```

This function will calculate and assign the vector projection of `(ux, uy)` onto each link. (The function works with raster grids too: it simply assigns `ux` to horizontal links and `uy` to vertical links.)

### How `AdvectionSolverTVD` calculates its solution

To calculate a rate of vertical change at each grid node, the solution algorithm involves these steps:

1. If the advection field is changing in sign/direction, re-identify the link that lies directly upwind of every link. This calculation makes use of the `find_upwind_link_at_link` function, which in turn relies on the `parallel_links_at_link` data structure of raster and hex grids (which is only created when needed). A value of -1 is assigned to links that have no upwind neighbor.

2. Use the function `map_node_to_link_linear_upwind` to assign a "low order" value of the advected quantity at each link (corresponding to $z_L$ in the preceding math).

3. For each link, use the function `map_node_to_link_lax_wendroff` to calculate a "high order" value, $z_H$, of the advected quantity at each link.

4. Use the function `upwind_to_local_grad_ratio` to calculate the ratio $r$ of upwind to local gradient in the advected quantity at each link (applying a value of unity where an upwind link does not exist or the local gradient is zero).

5. From the gradient ratio, use the function `flux_lim_vanleer` to calculate the weighting factor $\Psi$.

6. Using the weighting factor, calculate a value of the advected quantity at the links using a weighted average of the low-order and high-order values. This corresponds to the "in between" values that were denoted as $z_{j+1/2}$ in the preceding math.

7. Calculate a specific flux at each *active* link by multiplying the link-based value of the advected quantity by the link-perpendicular advection velocity. These are the $q_k$ values.

8. Use the `calc_flux_div_at_node` function to calculate the flux divergence, and return the (negative) value of this as the time rate of change of the advected variable at each (non-perimeter) node. This corresponds to $\partial q / \partial x$ in the 1D advection equation above, except that here it is implemented in 2D.

Calling `update(dt)` or `run_one_step(dt)` (they are synonyms) computes this rate of change and then updates the advected quantity using a forward-Euler step with the given time-step duration `dt`. If you want to get the rate of change without immediately updating the state variable $z$, the component provides a `calc_rate_of_change_at_nodes` function. The function still requires a time-step duration `dt` as an input argument, because this is needed to evaluate the Courant number $c$.

### Parameters to `AdvectionSolverTVD`

Like nearly all Landlab components, `AdvectionSolverTVD` takes a `ModelGrid` object as its first argument. As of this writing, it must be a `RasterModelGrid` or `HexModelGrid` (unstructured grids don't have parallel connected links, so there's no natural "upwind" connectivity ... BUT, if someone wants to figure out how to extend this capability to unstructured grids, please go ahead!)

Other parameters include:

- `fields_to_advect`: specifies which field or fields should be advected. This parameter can be given either as the name of a node-based field (string), or the array itself. Alternatively, if there is more than one field that should be advected with a given velocity, the parameter can be a list of either field names or arrays. For example, in a contaminant-transport problem the field to be advected would be contaminant concentration; for a topographic advection problem it would be the topographic elevation field; for water-wave propagation it would be the water-surface height.

- `advection_direction_is_steady`: a boolean that defaults to `False`. If you know that the advection direction is not going to change over time, set this to `True` to skip the overhead of re-identifying the upwind links at each time step.


"""

"""
## Examples

### Advection of a step function in 1d

#### Raster grid
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import HexModelGrid, RasterModelGrid, imshow_grid
from landlab.components import AdvectionSolverTVD

# Parameters
u = 1.0  # advection velocity in x direction
c = 0.2  # Courant number
nnodes = 100  # number of grid columns
ntimesteps = 100  # number of time steps

# Setup
dx = 1.0 / (nnodes - 1)
dt = c * dx / u

# Create grid
grid = RasterModelGrid((3, nnodes), xy_spacing=dx)

# Create field for the advected quantity (here topographic elevation)
elev = grid.add_zeros("topographic__elevation", at="node")

# Initial condition: a step function from x = 0.4 to 0.6
step_exists = np.logical_and(grid.x_of_node >= 0.4, grid.x_of_node <= 0.6)
elev[step_exists] = 1.0

# Create field for advection velocity
vel = grid.add_zeros("advection__velocity", at="link")
vel[grid.horizontal_links] = u

# Instantiate component
# (Note: set advection_direction_is_stead to False so we can run it
# in reverse too)
advector = AdvectionSolverTVD(
    grid, fields_to_advect="topographic__elevation", advection_direction_is_steady=False
)

# For plotting convenience
midrow = np.arange(nnodes, 2 * nnodes, dtype=int)
x = grid.x_of_node[midrow]

plt.plot(x, elev[midrow], label="Step 0")
plt.xlabel("Distance")
plt.ylabel("Height")
for i in range(ntimesteps):
    advector.update(dt)
    if (i + 1) % 20 == 0:
        plt.plot(x, elev[midrow], label="Step " + str(i + 1))
plt.legend()

"""
Now we'll try reversing the direction and running it for some more time (that's why we set `advection_direction_is_steady=False` above):
"""

vel[grid.horizontal_links] = -u  # change direction

plt.plot(x, elev[midrow], label="Step 0")
plt.xlabel("Distance")
plt.ylabel("Height")
for i in range(ntimesteps):
    advector.update(dt)
    if (i + 1) % 20 == 0:
        plt.plot(x, elev[midrow], label="Step " + str(i + 1))
plt.legend()

"""
...and presto, we're back in the middle again (albeit with some numerical diffusion).
"""

"""
#### Raster grid, rotated coordinates

This is the same example as above, but with the grid's long axis and advection direct both aligned with the $y$ axis.
"""

# Create grid
grid = RasterModelGrid((nnodes, 3), xy_spacing=dx)

# Create field for the advected quantity (here topographic elevation)
elev = grid.add_zeros("topographic__elevation", at="node")

# Initial condition: a step function from x = 0.4 to 0.6
step_exists = np.logical_and(grid.y_of_node >= 0.4, grid.y_of_node <= 0.6)
elev[step_exists] = 1.0

# Create field for advection velocity
vel = grid.add_zeros("advection__velocity", at="link")
vel[grid.vertical_links] = u

# Instantiate component
advector = AdvectionSolverTVD(
    grid, fields_to_advect="topographic__elevation", advection_direction_is_steady=True
)

# For plotting convenience
midrow = np.arange(1, 3 * nnodes - 1, 3, dtype=int)
x = grid.y_of_node[midrow]

plt.plot(x, elev[midrow], label="Step 0")
plt.xlabel("Distance")
plt.ylabel("Height")
for i in range(ntimesteps):
    advector.update(dt)
    if (i + 1) % 20 == 0:
        plt.plot(x, elev[midrow], label="Step " + str(i + 1))
plt.legend()

"""
#### Hex grid in horizontal orientation

For a hex grid in quasi-1d, we have to be a bit more careful. We have to close the two long sides, because otherwise there would be flux outward to those boundaries along the angling links. We also have to multiply the magnitude the remaining horizontal flux by 1.5x to account for the fact that the face width is only 2/3 of the effective width of the cells. (This illustrates that a hex grid is not a good choice for these quasi-1d problems; it's included here to show that the code works on a hex grid, and to demonstrate the use of the `map_vectors_to_links` function.)
"""

# create grid
grid = HexModelGrid((3, nnodes - 1), spacing=dx)
grid.status_at_node[grid.y_of_node == 0.0] = grid.BC_NODE_IS_CLOSED
grid.status_at_node[grid.y_of_node > dx] = grid.BC_NODE_IS_CLOSED

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")

# initialize fields
step_exists = np.logical_and(grid.x_of_node >= 0.4, grid.x_of_node <= 0.6)
elev[step_exists] = 1.0

# Create field for advection velocity
vel = grid.add_zeros("advection__velocity", at="link")
grid.map_vectors_to_links(1.5 * u, 0.0, out=vel)

# Instantiate component
advector = AdvectionSolverTVD(
    grid, fields_to_advect="topographic__elevation", advection_direction_is_steady=True
)

# misc
midrow = np.arange(nnodes - 1, (2 * nnodes) - 1, dtype=int)
x = grid.x_of_node[midrow]

plt.plot(x, elev[midrow], label="Step 0")
plt.xlabel("Distance")
plt.ylabel("Height")
for i in range(ntimesteps):
    advector.update(dt)
    if (i + 1) % 20 == 0:
        plt.plot(x, elev[midrow], label="Step " + str(i + 1))
plt.legend()

"""
### Advection of a Gaussian "bump" in 2d

We start by defining a function to make the initial bump, and a function to report the cumulative translation of the peak of the bump.
"""

def make_gaussian_bump(grid, field, width):
    midx = 0.5 * np.amax(grid.x_of_node)
    midy = 0.5 * np.amax(grid.y_of_node)
    dist_sq = (grid.x_of_node - midx) ** 2 + (grid.y_of_node - midy) ** 2
    field[:] = np.exp(-0.5 * dist_sq / bump_width)

def calc_translation_distance(grid, elev, x0, y0, u, dt, nt):
    highest_node = np.argmax(elev)
    distance = np.sqrt(
        (grid.x_of_node[highest_node] - x0) ** 2
        + (grid.y_of_node[highest_node] - y0) ** 2
    )
    print("Velocity magnitude is", u)
    print("Duration is", dt * nt)
    print("Predicted distance is", u * dt * nt)
    print("Modeled distance is", distance)

"""
#### Raster grid with advection to the east

Note that when we instantiate the component, we will leave its value of `advection_direction_is_steady` at the default of `False`. We do this because we are going to reuse the component several times with different advection directions, so we want it to recompute the upwind links.
"""

# Parameters
nrows = 51
ncols = 51
ux = 1.0
uy = 0.0
c = 0.2
nnodes = 100
ntimesteps = 50
bump_width = 0.01  # width of Gaussian bump

# Setup
dx = 1.0 / (nrows - 1)
u = (ux * ux + uy * uy) ** 0.5
dt = c * dx / u

# create grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")
vel = grid.add_zeros("advection__velocity", at="link")

# initialize fields
make_gaussian_bump(grid, elev, bump_width)
maxnode = np.argmax(elev)
x0 = grid.x_of_node[maxnode]
y0 = grid.y_of_node[maxnode]
vel[grid.horizontal_links] = ux
vel[grid.vertical_links] = uy

# Instantiate component
adv = AdvectionSolverTVD(grid, fields_to_advect="topographic__elevation")

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(adv.grid, elev)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
Test that we can run it back in the 
"""

"""
#### Raster grid with advection to the north

This time we'll show the *change* in value.
"""

# Re-initialize and run again, this time with y-directed motion
ux = 0.0
uy = 1.0
vel[grid.horizontal_links] = ux
vel[grid.vertical_links] = uy

# Re-initialize the Gaussian bump
make_gaussian_bump(grid, elev, bump_width)
elev0 = elev.copy()

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(adv.grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Raster grid with advection to the southwest
"""

# Re-initialize and run again, this time with anti-x-directed motion
ux = -(2.0**0.5)
uy = -(2.0**0.5)
u = (ux * ux + uy * uy) ** 0.5

make_gaussian_bump(grid, elev, bump_width)
vel[grid.horizontal_links] = ux
vel[grid.vertical_links] = uy

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(adv.grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Raster grid with a non-uniform advection field

This example tests the component with a non-uniform advection field. For this test, we will shear the Gaussian bump by having $x$-directed motion that accelerates in the $y$ direction.
"""

# Re-initialize and run again, this time with anti-x-directed motion
ux_max = 2.0
uy = 0.0
u = ux_max

make_gaussian_bump(grid, elev, bump_width)
vel[grid.horizontal_links] = (
    ux_max * grid.y_of_node[grid.node_at_link_tail[grid.horizontal_links]]
)
vel[grid.vertical_links] = 0.0

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(adv.grid, elev)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
##### Case of divergent velocity

Here the velocity field diverges around $x=1/2$, which produces a rift in the midst of our Gaussian bump: a bit like Iceland might be without the volcanoes ...
"""

# Identify places with positive vs. negative x-wise velocity
make_gaussian_bump(grid, elev, bump_width)
vel_is_neg = grid.x_of_node[grid.node_at_link_head] <= 0.5
vel[:] = 1.0
vel[vel_is_neg] = -1.0
vel[grid.vertical_links] = 0.0

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(adv.grid, elev)

"""
#### Hex grid with tests of advection in several different directions

The last few examples use a hex grid. Note the use of `map_vectors_to_links` to assign link-parallel advection speeds to the links on the basis of their orientation relative to the advection direction and magnitude.
"""

"""
##### Case of right-ward motion
"""

# Parameters
ux = 1.0
uy = 0.0
u = (ux * ux + uy * uy) ** 0.5

ncols = 51
nrows = int(ncols / (0.5 * 3.0**0.5))

# Setup
dx = 1.0 / (ncols - 1)
dt = c * dx / u

# Create grid
grid = HexModelGrid((nrows, ncols), spacing=dx, node_layout="rect")

# Create fields
elev = grid.add_zeros("topographic__elevation", at="node")
vel = grid.add_zeros("advection__velocity", at="link")

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
maxnode = np.argmax(elev)
x0 = grid.x_of_node[maxnode]
y0 = grid.y_of_node[maxnode]
grid.map_vectors_to_links(ux, uy, out=vel)

# Instantiate component
adv = AdvectionSolverTVD(grid, fields_to_advect="topographic__elevation")

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
##### Case of upward (northward) motion

This time showing the differences after advection.
"""

# Parameters
ux = 0.0
uy = 1.0

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

# Remember the starting elevation field
elev0 = elev.copy()

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of leftward (westward) motion
"""

# Parameters
ux = -1.0
uy = 0.0

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of downward (southward) motion
"""

# Parameters
ux = 0.0
uy = -1.0

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of nne motion
"""

# Parameters
ux = np.cos(np.degrees(60))
uy = np.sin(np.degrees(60))
u = np.sqrt(ux * ux + uy * uy)

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of nnw motion
"""

# Parameters
ux = -np.cos(np.degrees(60))
uy = np.sin(np.degrees(60))
u = np.sqrt(ux * ux + uy * uy)

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of ssw motion
"""

# Parameters
ux = -np.cos(np.degrees(60))
uy = -np.sin(np.degrees(60))
u = np.sqrt(ux * ux + uy * uy)

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case of sse motion
"""

# Parameters
ux = np.cos(np.degrees(60))
uy = -np.sin(np.degrees(60))
u = np.sqrt(ux * ux + uy * uy)

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
grid.map_vectors_to_links(ux, uy, out=vel)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
#### Case with vertically oriented grid, rightward (eastward) motion
"""

# Parameters
ux = 1.0
uy = 0.0
u = np.sqrt(ux * ux + uy * uy)
nrows = 51
ncols = int(nrows / (0.5 * 3.0**0.5))

# Setup
dx = 1.0 / (nrows - 1)
dt = c * dx / u

# Create grid
grid = HexModelGrid(
    (nrows, ncols), spacing=dx, node_layout="rect", orientation="vertical"
)

# Create fields
elev = grid.add_zeros("topographic__elevation", at="node")
vel = grid.add_zeros("advection__velocity", at="link")

# Initialize fields
make_gaussian_bump(grid, elev, bump_width)
elev0 = elev.copy()
maxnode = np.argmax(elev)
x0 = grid.x_of_node[maxnode]
y0 = grid.y_of_node[maxnode]
grid.map_vectors_to_links(ux, uy, out=vel)

# Instantiate component
adv = AdvectionSolverTVD(
    grid, fields_to_advect="topographic__elevation", advection_direction_is_steady=True
)

for _ in range(ntimesteps):
    adv.update(dt)
imshow_grid(grid, elev - elev0)
calc_translation_distance(grid, elev, x0, y0, u, dt, ntimesteps)

"""
## Tiny unit tests

It's helpful to have small, simple unit tests. Here is a description of such a test, applied to single and multiple fields. A quantity advects from left to right, such that in the wake of the advection front the values should be equal (or close to) to the starting value at the left side of the grid. In the test, there are 5 core nodes; the idea is that after advection over a total distance of 3 nodes, the value at the middle node should be within a percent or so of the maximum starting value (unity in the first two tests, and for the 3rd test, which advects two different quantities called C1 and C2, it should be unity for C2 and 10 for C1).
"""

grid = RasterModelGrid((3, 7))
C = grid.add_zeros("advected__quantity", at="node")
C[grid.x_of_node < 2.5] = 1.0
u = grid.add_zeros("advection__velocity", at="link")
u[grid.horizontal_links] = 1.0
print("Before:", C[grid.core_nodes])

advector = AdvectionSolverTVD(grid, advection_direction_is_steady=True)

for _ in range(15):
    advector.run_one_step(0.2)

print("After:", C[grid.core_nodes])

grid = RasterModelGrid((3, 7))
C = grid.add_zeros("only_advected__quantity", at="node")
C[grid.x_of_node < 2.5] = 1.0
u = grid.add_zeros("advection__velocity", at="link")
u[grid.horizontal_links] = 1.0
print("Before:", C[grid.core_nodes])

advector = AdvectionSolverTVD(
    grid, fields_to_advect="only_advected__quantity", advection_direction_is_steady=True
)

for _ in range(15):
    advector.run_one_step(0.2)

print("After:", C[grid.core_nodes])

grid = RasterModelGrid((3, 7))
C1 = grid.add_zeros("first_advected__quantity", at="node")
C1[grid.x_of_node < 2.5] = 10.0
C2 = grid.add_zeros("second_advected__quantity", at="node")
C2[grid.x_of_node < 2.5] = 1.0
u = grid.add_zeros("advection__velocity", at="link")
u[grid.horizontal_links] = 1.0
print("Before:")
print(" C1:", C1[grid.core_nodes])
print(" C2:", C2[grid.core_nodes])

advector = AdvectionSolverTVD(
    grid,
    fields_to_advect=["first_advected__quantity", "second_advected__quantity"],
    advection_direction_is_steady=True,
)

for _ in range(15):
    advector.run_one_step(0.2)

print("After:")
print(" C1:", C1[grid.core_nodes])
print(" C2:", C2[grid.core_nodes])

"""
## Summary

The `AdvectionSolverTVD` component provides a second-order, nonlinear, Total Variation Diminishing (TVD) solution to the 2D advection equation. The component can be used with any user-supplied node field as the quantity to be advected. The advection field can be unsteady and/or nonuniform. The component works with either a raster or hex grid.
"""

"""
## References and further reading

Campforts, B., Schwanghart, W., & Govers, G. (2017). Accurate simulation of transient landscape evolution by eliminating numerical diffusion: the TTLEM 1.0 model. Earth Surface Dynamics, 5(1), 47-66.

Press, W. H., Teukolsky, S. A., Vetterling, W. T., & Flannery, B. P. (2007). Numerical recipes 3rd edition: The art of scientific computing. Cambridge university press.

Slingerland, R., & Kump, L. (2011). Mathematical modeling of Earth's dynamical systems: A primer. Princeton University Press.

Weller, Hilary (various dates). Short videos on numerical methods for atmospheric modelling. Available on YouTube.
"""



================================================
File: docs/source/tutorials/agent_based_modeling/README.md
================================================
# Agent-based modeling with Landlab and Mesa

The tutorials in this collection illustrate how to combine Landlab components
and capabilities with the agent-based modeling (ABM) package Mesa to create
integrated simulations that combine ABMs and grid-based continuum-type models.
The examples are deliberately simple, and are designed to show how integrated
models can be built rather than to demonstrate any particular application.



================================================
File: docs/source/tutorials/agent_based_modeling/groundwater/landlab_mesa_groundwater_pumping.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Coupling a Landlab groundwater with a Mesa agent-based model

This notebook shows a toy example of how one might couple a simple groundwater model (Landlab's `GroundwaterDupuitPercolator`, by [Litwin et al. (2020)](https://joss.theoj.org/papers/10.21105/joss.01935)) with an agent-based model (ABM) written using the [Mesa](https://mesa.readthedocs.io/en/latest/) Agent-Based Modeling (ABM) package.

The purpose of this tutorial is to demonstrate the technical aspects of creating an integrated Landlab-Mesa model. The example is deliberately very simple in terms of the processes and interactions represented, and not meant to be a realistic portrayal of water-resources decision making. But the example does show how one might build a more sophisticated and interesting model using these basic ingredients.

(Greg Tucker, November 2021; created from earlier notebook example used in May 2020
workshop)
"""

"""
## Running the groundwater model

The following section simply illustrates how to create a groundwater model using the `GroundwaterDupuitPercolator` component.
"""

"""
Imports:
"""

import matplotlib.pyplot as plt
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components import GroundwaterDupuitPercolator

"""
Set parameters:
"""

base_depth = 22.0  # depth of aquifer base below ground level, m
initial_water_table_depth = 2.0  # starting depth to water table, m
dx = 100.0  # cell width, m
pumping_rate = 0.001  # pumping rate, m3/s
well_locations = [800, 1200]
K = 0.001  # hydraulic conductivity, (m/s)
n = 0.2  # porosity, (-)
dt = 3600.0  # time-step duration, s
background_recharge = 0.1 / (3600 * 24 * 365.25)  # recharge rate from infiltration, m/s

"""
Create a grid and add fields:
"""

# Raster grid with closed boundaries
# boundaries = {'top': 'closed','bottom': 'closed','right':'closed','left':'closed'}
grid = RasterModelGrid((41, 41), xy_spacing=dx)  # , bc=boundaries)

# Topographic elevation field (meters)
elev = grid.add_zeros("topographic__elevation", at="node")

# Field for the elevation of the top of an impermeable geologic unit that forms
# the base of the aquifer (meters)
grid.at_node["aquifer_base__elevation"] = elev - base_depth

# Field for the elevation of the water table (meters)
grid.at_node["water_table__elevation"] = elev - initial_water_table_depth

# Field for the groundwater recharge rate (meters per second)
recharge = grid.add_full("recharge__rate", background_recharge, at="node")

# pumping rate, in terms of recharge
recharge[well_locations] -= pumping_rate / (dx * dx)

"""
Instantiate the component (note use of an array/field instead of a scalar constant for `recharge_rate`):
"""

gdp = GroundwaterDupuitPercolator(
    grid,
    hydraulic_conductivity=K,
    porosity=n,
    recharge_rate=recharge,
    regularization_f=0.01,
)

"""
Define a couple of handy functions to run the model for a day or a year:
"""

def run_for_one_day(gdp, dt):
    num_iter = int(3600.0 * 24 / dt)
    for _ in range(num_iter):
        gdp.run_one_step(dt)

def run_for_one_year(gdp, dt):
    num_iter = int(365.25 * 3600.0 * 24 / dt)
    for _ in range(num_iter):
        gdp.run_one_step(dt)

"""
Run for a year and plot the water table:
"""

for _ in trange(365):
    run_for_one_day(gdp, dt)

grid.imshow("water_table__elevation", colorbar_label="Water table elevation (m)")

"""
### Aside: calculating a pumping rate in terms of recharge

The pumping rate at a particular grid cell (in volume per time, representing pumping from a well at that location) needs to be given in terms of a recharge rate (depth of water equivalent per time) in a given grid cell. Suppose for example you're pumping 16 gallons/minute (horrible units of course). That equates to:

16 gal/min x 0.00378541 m3/gal x (1/60) min/sec =
"""

Qp = 16.0 * 0.00378541 / 60.0
print(Qp)

"""
...equals about 0.001 m$^3$/s. That's $Q_p$. The corresponding negative recharge in a cell of dimensions $\Delta x$ by $\Delta x$ would be

$R_p = Q_p / \Delta x^2$
"""

Rp = Qp / (dx * dx)
print(Rp)

"""
## A very simple ABM with farmers who drill wells into the aquifer

For the sake of illustration, our ABM will be extremely simple. There are $N$ farmers, at random locations, who each pump at a rate $Q_p$ as long as the water table lies above the depth of their well, $d_w$. Once the water table drops below their well, the well runs dry and they switch from crops to pasture.
"""

"""
### Check that Mesa is installed

For the next step, we must verify that Mesa is available. If it is not, use one of the installation commands below to install, then re-start the kernel (Kernel => Restart) and continue.
"""

try:
    from mesa import Model
except ModuleNotFoundError:
    print(
        """
Mesa needs to be installed in order to run this notebook.

Normally Mesa should be pre-installed alongside the Landlab notebook collection.
But it appears that Mesa is not already installed on the system on which you are
running this notebook. You can install Mesa from a command prompt using either:

`conda install -c conda-forge mesa`

or

`pip install mesa`
    """
    )
    raise

"""
### Defining the ABM

In Mesa, an ABM is created using a class for each Agent and a class for the Model. Here's the Agent class (a Farmer). Farmers have a grid location and an attribute: whether they are actively pumping their well or not. They also have a well depth: the depth to the bottom of their well. Their action consists of checking whether their well is wet or dry; if wet, they will pump, and if dry, they will not.
"""

from mesa import Agent
from mesa.space import MultiGrid
from mesa.time import RandomActivation

class FarmerAgent(Agent):
    """An agent who pumps from a well if it's not dry."""

    def __init__(self, unique_id, model, well_depth=5.0):
        # super().__init__(unique_id, model)
        super().__init__(model)
        self.pumping = True
        self.well_depth = well_depth

    def step(self):
        x, y = self.pos
        print(f"Farmer {self.unique_id}, ({x}, {y})")
        print(f"    Depth to the water table: {self.model.wt_depth_2d[x, y]}")
        print(f"    Depth to the bottom of the well: {self.well_depth}")
        if self.model.wt_depth_2d[x, y] >= self.well_depth:  # well is dry
            print("    Well is dry.")
            self.pumping = False
        else:
            print("    Well is pumping.")
            self.pumping = True

"""
Next, define the model class. The model will take as a parameter a reference to a 2D array (with the same dimensions as the grid) that contains the depth to water table at each grid location. This allows the Farmer agents to check whether their well has run dry.
"""

import random


class FarmerModel(Model):
    """A model with several agents on a grid."""

    def __init__(self, N, width, height, well_depth, depth_to_water_table, seed=None):
        super().__init__()

        self.num_agents = N
        self.grid = MultiGrid(width, height, True)
        self.depth_to_water_table = depth_to_water_table
        self.schedule = RandomActivation(self)
        self.random = random.Random(seed)

        # Create agents
        for i in range(self.num_agents):
            a = FarmerAgent(i, self, well_depth)
            self.schedule.add(a)
            # Add the agent to a random grid cell (excluding the perimeter)
            x = self.random.randrange(self.grid.width - 2) + 1
            y = self.random.randrange(self.grid.width - 2) + 1
            self.grid.place_agent(a, (x, y))

    def step(self):
        self.wt_depth_2d = self.depth_to_water_table.reshape(
            (self.grid.width, self.grid.height)
        )
        self.schedule.step()

"""
### Setting up the Landlab grid, fields, and groundwater simulator
"""

base_depth = 22.0  # depth of aquifer base below ground level, m
initial_water_table_depth = 2.8  # starting depth to water table, m
dx = 100.0  # cell width, m
pumping_rate = 0.004  # pumping rate, m3/s
well_depth = 3  # well depth, m
background_recharge = 0.002 / (365.25 * 24 * 3600)  # recharge rate, m/s
K = 0.001  # hydraulic conductivity, (m/s)
n = 0.2  # porosity, (-)
dt = 3600.0  # time-step duration, s
num_agents = 12  # number of farmer agents
run_duration_yrs = 5  # run duration in years

grid = RasterModelGrid((41, 41), xy_spacing=dx)

elev = grid.add_zeros("topographic__elevation", at="node")

grid.at_node["aquifer_base__elevation"] = elev - base_depth
grid.at_node["water_table__elevation"] = elev - initial_water_table_depth
grid.add_full("water_table__depth_below_ground", initial_water_table_depth, at="node")
recharge = grid.add_full("recharge__rate", background_recharge, at="node")

# pumping rate, in terms of recharge
recharge[well_locations] -= pumping_rate / (dx * dx)

gdp = GroundwaterDupuitPercolator(
    grid,
    hydraulic_conductivity=K,
    porosity=n,
    recharge_rate=recharge,
    regularization_f=0.01,
)

"""
### Set up the Farmer model
"""

farmer_model = FarmerModel(
    num_agents,
    grid.number_of_node_columns,
    grid.number_of_node_rows,
    well_depth,
    # depth_to_wt.reshape(grid.shape),
    grid.at_node["water_table__depth_below_ground"].reshape(grid.shape),
    seed=1945,
)

"""
Check the spatial distribution of wells:
"""

import numpy as np


def get_well_count(model):
    well_count = np.zeros(grid.shape, dtype=int)
    pumping_well_count = np.zeros(grid.shape, dtype=int)
    for cell in model.grid.coord_iter():
        cell_content, (x, y) = cell
        well_count[x][y] = len(cell_content)
        for agent in cell_content:
            if agent.pumping:
                pumping_well_count[x][y] += 1
    return well_count, pumping_well_count


well_count, p_well_count = get_well_count(farmer_model)
grid.imshow(well_count)

"""
#### Set the initial recharge field
"""

recharge[:] = -(pumping_rate / (dx * dx)) * p_well_count.flatten()
grid.imshow(-recharge * 3600 * 24, colorbar_label="Pumping rate (m/day)")

"""
### Run the model
"""

depth_to_wt = grid.at_node["water_table__depth_below_ground"]

for i in trange(run_duration_yrs):
    # Run the groundwater simulator for one year
    run_for_one_year(gdp, dt)

    # Update the depth to water table
    depth_to_wt[:] = (
        grid.at_node["topographic__elevation"] - grid.at_node["water_table__elevation"]
    )

    # Run the farmer model
    farmer_model.step()

    # Count the number of pumping wells
    well_count, pumping_well_count = get_well_count(farmer_model)
    total_pumping_wells = np.sum(pumping_well_count)
    print(f"In year {i + 1} there are {total_pumping_wells} pumping wells")
    print(f" and the greatest depth to water table is {np.amax(depth_to_wt)} meters.")

    # Update the recharge field according to current pumping rate
    recharge[:] = (
        background_recharge - (pumping_rate / (dx * dx)) * pumping_well_count.flatten()
    )
    print(f"Total recharge: {np.sum(recharge)}")
    print("")

    plt.figure()
    grid.imshow("water_table__elevation")
    plt.show()

# Display the area of water table that lies below the well depth
too_deep = (
    grid.at_node["topographic__elevation"] - grid.at_node["water_table__elevation"]
    > well_depth
)

grid.imshow(too_deep)



================================================
File: docs/source/tutorials/agent_based_modeling/wolf_sheep/wolf_sheep_with_soil_creep.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Wolf-Sheep-Grass Model with Soil Creep

This notebook demonstrates coupling of an ABM implemented in Mesa and a grid-based numerical model written in Landlab. The example is the canonical "wolf-sheep-grass" example of an agent-based model. Here we add an additional twist: when sheep eat grass, the soil beneath becomes more easily mobile. This then influences soil transport: the transport efficiency is higher where the grass is "damaged". An additional feedback lies in the thickness of the soil: grass will not grow if the soil is too thin.

The rules in this example are deliberately simple. The main goal of this tutorial is to illustrate the mechanics of building an integrated model that combines agent-based elements (via Mesa) with continuum-based elements (via Landlab) on a shared grid.

*(Greg Tucker, June 2020; most recent update November 2021)*
"""

"""
## Running the Mesa Wolf-Sheep-Grass model by itself

To start, here's an example of how to run a Mesa model in a notebook. First, we'll run a check to make sure Mesa is installed and available; if it is not, follow the instructions in the message to install it, then re-start the kernel (Kernel => Restart) and continue.
"""

try:
    import mesa

    print("Mesa version", mesa.__version__)
except ModuleNotFoundError:
    print(
        """
Mesa needs to be installed in order to run this notebook.

Normally Mesa should be pre-installed alongside the Landlab notebook collection.
But it appears that Mesa is not already installed on the system on which you are
running this notebook. You can install Mesa from a command prompt using either:

`conda install -c conda-forge mesa`

or

`pip install mesa`
"""
    )
    raise

"""
Next, we'll import the Mesa example Wolf-Sheep-Grass model from the *examples* collection ([more info here](https://mesa.readthedocs.io/stable/examples/advanced/wolf_sheep.html).
"""

from mesa.examples.advanced.wolf_sheep.agents import GrassPatch
from mesa.examples.advanced.wolf_sheep.model import WolfSheep
from mesa.experimental.devs import ABMSimulator

"""
Create an instance of the WolfSheep model, with the `grass` option set to `True`:
"""

simulator = ABMSimulator()
ws = WolfSheep(simulator=simulator, grass=True)

"""
Define a function to set up an array representing the growth status of grass on the model grid (in other words, extract the information from the model's GrassPatch agents), as well as a function to plot the current grass status. This is really a translation of data structures: the Mesa model stores data inside agents, which themselves reside at particular grid cells. Here we want to extract the information pertaining to the status of each cell's GrassPatch---is it fully grown or "damaged"---and store that information in a simple 2D numpy array.
"""

import copy

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

ground_cover_cmap = copy.copy(mpl.colormaps["YlGn"])


def generate_grass_map(model):
    grass_map = np.zeros((model.grid.width, model.grid.height))
    for cell in model.grid:
        (x, y) = cell.coordinate
        cell_content = cell.agents
        for agent in cell_content:
            if type(agent) is GrassPatch:
                if agent.fully_grown:
                    grass_map[x][y] = 2
                else:
                    grass_map[x][y] = 1
    return grass_map


def plot_grass_map(grass_map):
    plt.imshow(grass_map, interpolation="nearest", cmap=ground_cover_cmap)
    plt.colorbar()

"""
Run the model and display the results:
"""

for _ in range(25):
    ws.step()

gm = generate_grass_map(ws)
plot_grass_map(gm)

"""
## One-way coupling: using the grass cover in a soil-creep model

Here we initialize and run the W-S-G model for a short duration. We then extract its map of fully grown versus damaged grass, and use that to set the soil creep coefficient in a model of downslope soil creep. The point here is just to show that it's pretty easy to use a grid from a Mesa model as input to a Landlab-built model.
"""

simulator = ABMSimulator()
ws = WolfSheep(simulator=simulator, grass=True)

for _ in range(3):
    ws.step()

gm = generate_grass_map(ws)
plot_grass_map(gm)

"""
Import from Landlab a `RasterModelGrid` (which will be Landlab's version of the model grid), the `imshow_grid` function (for plotting Landlab grid fields), and the `LinearDiffuser` component (which will implement down-slope soil creep).
"""

import copy

import matplotlib as mpl

from landlab import RasterModelGrid, imshow_grid
from landlab.components import LinearDiffuser

# Create a grid the same size as the W-S-G model's grid
rmg = RasterModelGrid((ws.grid.width, ws.grid.height))

# Create elevation field and have it slope down to the south at 10% gradient
elev = rmg.add_zeros("topographic__elevation", at="node")
elev[:] = 0.1 * rmg.y_of_node

# Have one open boundary on the south side
rmg.set_closed_boundaries_at_grid_edges(True, True, True, False)

# Remember the starting elevation so we can calculate cumulative erosion/deposition
initial_elev = np.zeros(rmg.number_of_nodes)
initial_elev[:] = elev

# Create a field for the creep coefficient, and set parameters for two
# rates: slow (full grass cover) and fast (partial or "eaten" grass cover)
creep_coef = rmg.add_zeros("creep_coefficient", at="node")
fast_creep = 0.1
slow_creep = 0.001

# Assign the higher creep coefficient to cells where the grass has
# been eaten and not yet recovered; the slower value is assigned to
# "fully grown" grass patches.
creep_coef[gm.flatten() == 1] = fast_creep
creep_coef[gm.flatten() == 2] = slow_creep

# Instantiate a LinearDiffuser (soil creep) Landlab component
diffuser = LinearDiffuser(rmg, linear_diffusivity=creep_coef)

# Set the time step duration
dt = 0.2 * rmg.dx * rmg.dx / fast_creep
print(f"Time step duration is {dt} years.")

# Run the soil creep model
for i in range(50):
    diffuser.run_one_step(dt)

# Calculate and plot the erosion/deposition patterns
ero_dep = elev - initial_elev
maxchange = np.amax(np.abs(ero_dep))
imshow_grid(
    rmg,
    ero_dep,
    vmin=-maxchange,
    vmax=maxchange,
    cmap=copy.copy(mpl.colormaps["coolwarm_r"]),
    colorbar_label="Cumulative deposition (+) or erosion (-), m",
)

# Plot the grass cover again
imshow_grid(
    rmg, gm, cmap=ground_cover_cmap, colorbar_label="Ground cover (1 = bare, 2 = grass)"
)

imshow_grid(
    rmg,
    elev,
    cmap=copy.copy(mpl.colormaps["pink"]),
    colorbar_label="Elevation above base of slope (m)",
)

"""
Interestingly, erosion tends to occur at locations where grass cover upslope captures incoming soil.

So far, however, this is just one-way feedback: the previously damaged grass patches, as calculated in the wolf-sheep-grass ABM, become susceptible to erosion, but this does not (yet) feed back into future grass growth or erosional loss. Let's turn to that next.
"""

"""
## Two-way feedback

Here, we explore two-way feedback by running the two models iteratively. We track soil thickness, and "damage" any grass where the soil is thinner than a given amount. We also limit soil flux according to its thickness, so that absent soil cannot move.

These rules are deliberately simple. One could make the model more realistic by, for example, setting the grass regrowth time (a property of the GrassPatch agents in the ABM) to a value that depends on the thickness of the soil (a Landlab field).
"""

simulator = ABMSimulator()
ws = WolfSheep(
    simulator=simulator,
    initial_sheep=20,
    initial_wolves=10,
    grass=True,
    grass_regrowth_time=15,  # give grass a fighting chance...
)

initial_soil_depth = 0.3
min_depth_for_grass = 0.2
hstar = 0.2
fast_creep = 0.1
slow_creep = 0.001

# Create a grid the same size as the W-S-G model's grid
rmg = RasterModelGrid((ws.grid.width, ws.grid.height))

# Create elevation field and have it slope down to the south at 10% gradient
elev = rmg.add_zeros("topographic__elevation", at="node")
elev[:] = 0.1 * rmg.y_of_node

# Have one open boundary on the south side
rmg.set_closed_boundaries_at_grid_edges(True, True, True, False)

# Remember the starting elevation so we can calculate cumulative erosion/deposition
initial_elev = np.zeros(rmg.number_of_nodes)
initial_elev[:] = elev

# Also remember the elevation of the prior time step, so we can difference
prior_elev = np.zeros(rmg.number_of_nodes)

# Create a field for the creep coefficient, and set parameters for two
# rates: slow (full grass cover) and fast (partial or "eaten" grass cover)
creep_coef = rmg.add_zeros("creep_coefficient", at="node")

# Create a soil-thickness field
soil = rmg.add_zeros("soil__depth", at="node")
soil[:] = initial_soil_depth

# Instantiate a LinearDiffuser (soil creep) Landlab component
diffuser = LinearDiffuser(rmg, linear_diffusivity=creep_coef)

# Set the time step duration
dt = 0.2 * rmg.dx * rmg.dx / fast_creep
print("Time step duration is {dt} years.")

"""
Next we define a new function `limit_grass_by_soil` that will render any GrassPatches "non-fully-grown" if the soil is thinner than a specified minimum value. In other words, we represent soil limitation with a simple threshold in which the grass in any cell with soil thinner than the threshold can never be fully grown. Again, a more realistic way to do this might be to reduce the regrowth rate, but our simple threshold treatment will serve for the purpose of showing how we can use data from a Landlab field to influence data associated with spatially distributed agents in a Mesa model:
"""

def limit_grass_by_soil(wsg_model, soil, min_soil_depth):
    soilmatrix = soil.reshape((wsg_model.width, wsg_model.height))
    for cell in wsg_model.grid:
        (x, y) = cell.coordinate
        cell_content = cell.agents
        if soilmatrix[x][y] < min_soil_depth:
            for agent in cell_content:
                if type(agent) is GrassPatch:
                    agent.fully_grown = False

"""
Run the integrated model in a time loop. Our algorithm performs the following sequence of calculations in each iteration:

- Get a copy of the current grass status as a 2D array
- Update the soil-creep coefficient Landlab field according to the grass status and the soil thickness
- Run soil creep for one time step and update the soil thickness (we could have used a DepthDependentLinearDiffuser for this, but here a simpler approach will suffice)
- Set grass in any cells with insufficient soil to be non-fully-grown
- Run the wolf-sheep-grass model for one time step

The data exchange happens in two function calls. `generate_grass_map` translates grass status data from the Mesa model's data structure to a Landlab field, and `limit_grass_by_soil` translates Landlab's soil thickness field into a restriction on grass status in the Mesa model's GrassPatch agents.
"""

# Main loop
for _ in range(50):
    # Assign the higher creep coefficient to cells where the grass has
    # been eaten and not yet recovered; the slower value is assigned to
    # "fully grown" grass patches.
    gm = generate_grass_map(ws)
    creep_coef[gm.flatten() == 1] = fast_creep
    creep_coef[gm.flatten() == 2] = slow_creep

    # Adjust the creep coefficient to account for soil depth
    creep_coef *= 1.0 - np.exp(-soil / hstar)

    # Run the soil-creep model
    prior_elev[:] = elev
    diffuser.run_one_step(dt)

    # Update the soil cover
    soil += elev - prior_elev

    # Update the grass cover
    limit_grass_by_soil(ws, soil, min_depth_for_grass)

    # Run the W-S-G model
    ws.step()

"""
The next few plots examine the results to illustrate how the interaction of soil creep and grass consumption by mobile agents (sheep) has influenced the landscape:
"""

# Calculate and plot the erosion/deposition patterns
ero_dep = elev - initial_elev
maxchange = np.amax(np.abs(ero_dep))
imshow_grid(
    rmg,
    ero_dep,
    vmin=-maxchange,
    vmax=maxchange,
    cmap="coolwarm_r",
    colorbar_label="Depth of soil accumulation (+) or loss (-), m",
)

# Soil thickness
imshow_grid(rmg, soil, colorbar_label="Soil thickness, m")

# Ground cover
imshow_grid(
    rmg, gm, cmap=ground_cover_cmap, colorbar_label="Ground cover (1 = bare, 2 = grass)"
)

"""
Here soil erosion at the top of the slope inhibits grass cover, while soil accumulation at the base of the slope allows grass to continue to grow.
"""



================================================
File: docs/source/tutorials/boundary_conditions/set_BCs_from_xy.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Setting Boundary Conditions: interior rectangle

This tutorial illustrates how to modify the boundary conditions of an interior rectangle in the grid if you know the x and y coordinates of the rectangle.
"""

import numpy as np

from landlab import RasterModelGrid

mg = RasterModelGrid((10, 10))

"""
Known coordinates of rectangle:
"""

min_x = 2.5
max_x = 5.0
min_y = 3.5
max_y = 7.5

"""
Define the area inside x and y coordinates:
"""

x_condition = np.logical_and(mg.x_of_node < max_x, mg.x_of_node > min_x)
y_condition = np.logical_and(mg.y_of_node < max_y, mg.y_of_node > min_y)
my_nodes = np.logical_and(x_condition, y_condition)

"""
Define boundaries as CLOSED:
"""

mg.status_at_node[my_nodes] = mg.BC_NODE_IS_CLOSED

"""
Make a new elevation field for display:
"""

z = mg.add_zeros("topographic__elevation", at="node")

mg.imshow(z, at="node")



================================================
File: docs/source/tutorials/boundary_conditions/set_BCs_on_raster_perimeter.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Setting Boundary Conditions on the Perimeter of a Raster.

## This tutorial illustrates how to modify the boundary conditions along the perimeter of a rectangular raster.
"""

from landlab import RasterModelGrid

"""
- Instantiate a grid.
"""

mg = RasterModelGrid((4, 4))

"""
The node boundary condition options are:

- mg.BC_NODE_IS_CORE (status value = 0; all operations are performed on a mg.BC_NODE_IS_CORE)
- mg.BC_NODE_IS_FIXED_VALUE (status value = 1; a boundary node with a fixed value)
- mg.BC_NODE_IS_FIXED_GRADIENT (status value = 2; a boundary node with a fixed gradient)
- mg.BC_NODE_IS_LOOPED (status value = 3; a boundary node that is wrap-around)
- mg.BC_NODE_IS_CLOSED (status value = 4; closed boundary, or no flux can cross this node, or more accurately, can cross the faces around the node)

(Note that these options are designed for the convenience in writing Landlab applications, and  are not "automatically enforced" in internal Landlab functions. For example, if you add two node fields together, as in `my_field1 + my_field2`, *all* values will be added, not just core nodes; to take advantage of boundary coding, you would use a syntax like `my_field1[grid.core_nodes] + my_field2[grid.core_nodes]`.)

Check the status of boundaries immediately after instantiating the grid:
"""

mg.status_at_node

"""
The default conditions are for the perimeter to be fixed value (status of 1) and the interior nodes to be core (status of 0).

This is a bit easier to see graphically.
"""

mg.imshow(mg.status_at_node)

"""
Now let's choose one node on the perimeter to be closed.  

Note that `imshow` by default does not illustrate values for closed nodes, so we override that below and show them in blue.
"""

mg.status_at_node[2] = mg.BC_NODE_IS_CLOSED
mg.imshow(mg.status_at_node, color_for_closed="blue")

"""
We could set the boundary condition at each node individually, or at groups of nodes (e.g. where the `x_of_node` value is greater than some specified value). But in many cases we just want to set the edges in one way or another. There are some functions for setting the boundary conditions around the perimeter of a raster.  (Remember that initially all of the perimeter nodes are mg.BC_NODE_IS_FIXED_VALUE by default.)

A generic way to do this is to use **set_status_at_node_on_edges**.

Note that this method takes the node status for whether a boundary should be closed.  The order is **right, top, left, bottom**.

You could send it, for example, mg.BC_NODE_IS_CLOSED, or 4, which is the value for mg.BC_NODE_IS_CLOSED status.

Below we set the right and left edges as closed and the top and bottom as fixed_value.
"""

mg.set_status_at_node_on_edges(
    right=mg.BC_NODE_IS_CLOSED,
    top=mg.BC_NODE_IS_FIXED_VALUE,
    left=mg.BC_NODE_IS_CLOSED,
    bottom=mg.BC_NODE_IS_FIXED_VALUE,
)
# the same thing could be done as ...
# mg.set_status_at_node_on_edges(right=4, top=1, left=4, bottom=1)
mg.imshow(mg.status_at_node, color_for_closed="blue")

"""
There are multiple ways to set edge boundary conditions.  If above isn't intuitive to you, keep reading.

Now let's set the right and left edges as closed boundaries using **set_closed_boundaries_at_grid_edges.**

Note that this method takes boolean values for whether a boundary should be closed.  The order is 
**right, top, left, bottom**.

Note that here we instantiate a new grid.
"""

mg1 = RasterModelGrid((4, 4), 1.0)
mg1.set_closed_boundaries_at_grid_edges(True, False, True, False)
mg1.imshow(mg1.status_at_node, color_for_closed="blue")

"""
Now let's try setting looped boundaries using **set_looped_bondaries.**

Note that this method takes boolean values for whether the top and bottom (first) or right and left (second) are looped.

We will set the top and bottom to be looped (status value of 3)
"""

mg2 = RasterModelGrid((4, 4), 1.0)
mg2.set_looped_boundaries(True, False)
mg2.imshow(mg2.status_at_node)

"""
Note that this has the right and left edges as mg.BC_NODE_IS_FIXED_VALUE (status value of 1).  

We can change those to closed if we want.
"""

mg2.set_closed_boundaries_at_grid_edges(True, False, True, False)
mg2.imshow(mg2.status_at_node, color_for_closed="Blue")

"""
Note that there are not methods for setting mg.BC_NODE_IS_FIXED_GRADIENT conditions on the boundary edges.  But we can do that.  We could use **set_status_at_node_on_edges**.  Below is another way to do this.

Remember that mg.BC_NODE_IS_FIXED_GRADIENT has a status value of 2.
We will set the top and bottom to be fixed gradient.
"""

mg3 = RasterModelGrid((4, 4), 1.0)
mg3.status_at_node[mg3.y_of_node == 0] = mg.BC_NODE_IS_FIXED_GRADIENT
mg3.status_at_node[mg3.y_of_node == 3] = mg.BC_NODE_IS_FIXED_GRADIENT
mg3.imshow(mg3.status_at_node, color_for_closed="Blue")
# there are no closed boundaries so we didn't need the color_for_closed option,
# but no problem if you accidentally include it!



================================================
File: docs/source/tutorials/boundary_conditions/set_BCs_on_voronoi.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Setting Boundary Conditions on a Voronoi.

## This tutorial illustrates how to modify the boundary conditions on a voronoi grid.
"""

import numpy as np

from landlab import VoronoiDelaunayGrid

"""
- Instantiate a grid.
"""

np.random.seed(1234)
x, y = np.random.rand(25), np.random.rand(25)
vg = VoronoiDelaunayGrid(x, y)

"""
The node boundary condition options are:

- vg.BC_NODE_IS_CORE (status value = 0; all operations are performed on a mg.BC_NODE_IS_CORE)
- vg.BC_NODE_IS_FIXED_VALUE (status value = 1; a boundary node with a fixed value)
- vg.BC_NODE_IS_FIXED_GRADIENT (status value = 2; a boundary node with a fixed gradient)
- vg.BC_NODE_IS_LOOPED (status value = 3; a boundary node that is wrap-around)
- vg.BC_NODE_IS_CLOSED (status value = 4; closed boundary, or no flux can cross this node, or more accurately, can cross the faces around the node)

(Note that these options are designed for the convenience in writing Landlab applications, and  are not "automatically enforced" in internal Landlab functions. For example, if you add two node fields together, as in `my_field1 + my_field2`, *all* values will be added, not just core nodes; to take advantage of boundary coding, you would use a syntax like `my_field1[grid.core_nodes] + my_field2[grid.core_nodes]`.)

Check the status of boundaries immediately after instantiating the grid:
"""

vg.status_at_node

"""
The default conditions are for the perimeter to be fixed value (status of 1) and the interior nodes to be core (status of 0).

This is not actually much easier to see graphically, because the perimeter nodes are not colored.  Note that they have a value of 1, so it seems they should be shown as purple, but the plotter does not color them because they don't have a defined cell size.
"""

vg.imshow(vg.status_at_node, cmap="cool", show_elements=True)

"""
Now suppose we want closed nodes on the boundary, instead of fixed value nodes.

We can change this by accessing the nodes that are currently fixed value and changing their status.
"""

vg.status_at_node[vg.status_at_node == vg.BC_NODE_IS_FIXED_GRADIENT] = (
    vg.BC_NODE_IS_CLOSED
)
vg.imshow(
    vg.status_at_node,
    cmap="cool",
    limits=(-0.01, 4),
    color_for_closed="red",
    show_elements=True,
)
vg.status_at_node

"""
Now all of the nodes that had a status value of 1 have a status value of 4, but again viewing this graphically is not very helpful.  The array values have appropriately changed.

Now let's instantiate a new grid and give it some elevation values.  In this case any node that has an x value < 0.5 will have an elevation of -1.  Othewise, the nodes have a value of 1.
"""

np.random.seed(4321)
x, y = np.random.rand(25), np.random.rand(25)
vg2 = VoronoiDelaunayGrid(x, y)
vg2.add_ones("topographic__elevation", at="node")
vg2.at_node["topographic__elevation"][vg2.x_of_node < 0.5] = -1.0

"""
Illustrate the topography and show the values.
"""

vg2.imshow(vg2.at_node["topographic__elevation"], cmap="cool", show_elements=True)
vg2.at_node["topographic__elevation"]

"""
Now we can illustrate the grid and see at least some of the closed elements by using the `imshow` option color_for_closed.  Again remember that some of the nodes that are plotting in white areas are closed as well - that is, the ones that have an x value less than 0.5 are closed.
"""

vg2.set_nodata_nodes_to_closed(vg2.at_node["topographic__elevation"], -1.0)
vg2.imshow(
    vg2.status_at_node,
    color_for_closed="red",
    cmap="cool",
    limits=(-0.01, 1),
    show_elements=True,
)
vg2.status_at_node



================================================
File: docs/source/tutorials/boundary_conditions/set_watershed_BCs_raster.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Setting watershed boundary conditions on a raster grid

- This tutorial ilustrates how to set watershed boundary conditions on a raster grid.
- Note that a watershed is assumed to have a ring of nodes around the core nodes that are closed boundaries (i.e. no flux can cross these nodes, or more correctly, no flux can cross the faces around the nodes).
- This means that automatically the nodes on the outer perimeter of the grid will be set to be closed boundary.
- By definitation a watershed also has one outlet through which fluxes can pass.  Here the outlet is set as the node that has the lowest value, is not a nodata_value node, and is adjacent to at least one closed boundary node.  
- This means that an outlet can be on the outer perimeter of the raster.  However, the outlet does not need to be on the outer perimeter of the raster.
"""

"""
## The first example uses set_watershed_boundary_condition, which finds the outlet for the user.
- First import what we need.
"""

from landlab import RasterModelGrid

"""
- Now we create a 5 by 5 grid with a spacing (dx and dy) of 1.
- We also create an elevation field with value of 1. everywhere, except at the outlet, where the elevation is 0.  In this case the outlet is in the middle of the bottom row, at location (0,2), and has a node id of 2.
"""

mg1 = RasterModelGrid((5, 5), 1.0)
z1 = mg1.add_ones("topographic__elevation", at="node").reshape(mg1.shape)
z1[0, 2] = 0.0
z1

"""
- The set_watershed_boundary_condition in RasterModelGrid will find the outlet of the watershed.
- This method takes the node data, in this case z, and, optionally the no_data value.
- This method sets all nodes that have no_data values to closed boundaries.
- This example does not have any no_data values, which is fine.  
- In this case, the code will set all of the perimeter nodes as BC_NODE_IS_CLOSED(boundary status 4) in order to create this boundary around the core nodes. 
- The exception on the perimeter is node 2 (with elevation of 0).  Although it is on the perimeter, it has a value and it has the lowest value.  So in this case node 2 will be set as BC_NODE_IS_FIXED_VALUE (boundary status 1).
- The rest of the nodes are set as a CORE_NODE (boundary status 0)
"""

mg1.set_watershed_boundary_condition(mg1.at_node["topographic__elevation"])

"""
- Check to see that node status were set correctly.
- `imshow` will default to not plot the value of BC_NODE_IS_CLOSED nodes, which is why we override this below with the option color_for_closed
"""

mg1.imshow(mg1.status_at_node, color_for_closed="blue")

"""
## The second example uses set_watershed_boundary_condition_outlet_coords 
- In this case the user knows the coordinates of the outlet node.
- First instantiate a new grid, with new data values.
"""

mg2 = RasterModelGrid((5, 5), 10.0)
z2 = mg2.add_ones("topographic__elevation", at="node").reshape(mg2.shape)
z2[0, 1] = 0.0
z2

"""
- Note that the node with zero elevation, which will be the outlet, is now at location (0,1).
- Note that even though this grid has a dx & dy of 10., the outlet coords are still (0,1).
- Set the boundary conditions.
"""

mg2.set_watershed_boundary_condition_outlet_coords(
    (0, 1), mg2.at_node["topographic__elevation"]
)

"""
- Plot grid of boundary status information
"""

mg2.imshow(mg2.status_at_node, color_for_closed="blue")

"""
## The third example uses set_watershed_boundary_condition_outlet_id 
- In this case the user knows the node id value of the outlet node.
- First instantiate a new grid, with new data values.
"""

mg3 = RasterModelGrid((5, 5), 5.0)
z3 = mg3.add_ones("topographic__elevation", at="node").reshape(mg3.shape)
z3[1, 0] = 0.0
z3

"""
- Set boundary conditions with the outlet id.
- Note that here we know the id of the node that has a value of zero and choose this as the outlet.  But the code will not complain if you give it an id value of a node that does not have the smallest data value.
"""

mg3.set_watershed_boundary_condition_outlet_id(5, mg3.at_node["topographic__elevation"])

"""
- Another plot to illustrate the results.
"""

mg3.imshow(mg3.status_at_node, color_for_closed="blue")

"""
## The final example uses set_watershed_boundary_condition on a watershed that was exported from Arc.

- First import ``esri_ascii.lazy_load`` and then import the DEM data.
- The ``add_halo`` function add a ring of no-data values around the data.
- This is done just in case there are data values on the edge of the raster.  These would have to become closed to set watershed boundary conditions, but in order to avoid that, we add a perimeter to the data.
"""

from landlab.io import esri_ascii
from landlab.utils.add_halo import add_halo

with open("west_bijou_gully.asc") as fp:
    info, data = esri_ascii.lazy_load(fp, name="topographic__elevation", at="node")

data_with_halo = add_halo(data.reshape(info.shape), halo=1, halo_value=0)

grid_bijou = RasterModelGrid(data_with_halo.shape, xy_spacing=info.xy_spacing)
grid_bijou.at_node["topographic__elevation"] = data_with_halo

"""
- Let's plot the data to see what the topography looks like.
"""

grid_bijou.imshow(grid_bijou.at_node["topographic__elevation"])

"""
- In this case the nodata value is zero.  This skews the colorbar, but we can at least see the shape of the watershed.
- Let's set the boundary condition.  Remember we don't know the outlet id.
"""

grid_bijou.set_watershed_boundary_condition(
    grid_bijou.at_node["topographic__elevation"], 0
)

"""
- Now we can look at the boundary status of the nodes to see where the found outlet was.
"""

grid_bijou.imshow(grid_bijou.status_at_node, color_for_closed="blue")

"""
- This looks sensible.
- Now that the boundary conditions ae set, we can also look at the topography. 
- `imshow` will default to show boundaries as black, as illustrated below.  But that can be overwridden as we have been doing all along.
"""

grid_bijou.imshow(grid_bijou.at_node["topographic__elevation"])



================================================
File: docs/source/tutorials/carbonates/carbonate_producer.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The Carbonate Producer component
"""

"""
## Overview

This notebook demonstrates the `CarbonateProducer` Landlab component. The component computes the creation of carbonate rocks, such as carbonate platforms and coral reefs, given a particular bathymetry. The component can be used either to calculate the rate of carbonate production (in terms of a vertical deposition rate), or to progressively add to a field representing carbonate thickness. The model does not distinguish among different types of carbonate material, or species of carbonate-producing organism.

### Theory

#### Carbonate production rate

The `CarbonateProducer` uses the mathematical model of Bosscher and Schlager (1992), which represents the local carbonate growth rate, $G(x,y,t)$ (thickness per time) as a function of local water depth. The carbonate production rate is calculated as

$$G(x,y,t) = G_m \tanh \left( I_0 e^{-kd} / I_k \right)$$

where:

- $G_m$ is the maximum production rate
- $I_0$ is the surface light intensity
- $I_k$ is the saturating light intensity
- $d$ is water depth
- $k$ is the light extinction coefficient

By default the production rate is zero where $d<0$, but as noted below the user can invoke an option that allows for carbonate production within the tidal range.

Bosscher and Schlager (1992) suggest plausible values or ranges for these parameters as follows: $G_m$ = 0.010 to 0.015 m/y, $I_0$ = 2,000 to 2,250 micro Einsteins per square meter per second in the tropics, $I_k$ = 50 to 450 micro Einsteins per square meter per second, and $k$ = 0.04 to 0.16 m$^{-1}$ (corresponding to a decay depth of 6.25 to 16 m).

#### Smoothing near sea level using tidal range

The default form of the model involves a mathematical discontinuity at zero water depth. The user has the option of smoothing out this discontinuity by passing a positive value for the `tidal_range` parameter. If this parameter is given, the growth function is modified as follows:

$$G' = H(d) G$$

where $G$ is the growth rate calculated by the growth function shown above, and $H(d)$ is a smoothed Heaviside step function of local water depth that is defined as:

$$H(d) = \begin{cases}
\frac{1}{1 + \exp(-2 / R_t d)} & \text{if } d > -2R_t \\
0 & \text{otherwise.}
\end{cases}$$

Essentially, the $H(d)$ function allows a limited amount of growth above mean sea level, while reducing the growth rate somewhat within the tidal zone.

### Numerical methods

The component's `calc_carbonate_production_rate` method can be used to return the current rate of production given the water depths (calculated by subtracting the `topographic__elevation` node field from the `sea_level__elevation` grid field). In this case, no numerical methods are needed. This approach might be useful, for example, when modeling simultaneous carbonate and siliciclastic sedimentation, and the user wishes to generate depositional layers that contain some fractional amount of both.

Alternatively, the user can calculate the accumulation of carbonate thickness (in node field `carbonate_thickness`) by calling either `produce_carbonate` or `run_one_step` (the latter simply calls the former). In this case, simple forward Euler differencing is used to add to carbonate thickness, $C$, via

$$C_i^{k+1} = C_i^k + G_i^k \Delta t$$

where $i$ refers to node number and $k$ to time-step number, and $\Delta t$ is the duration of the time step (passed as an argument to `produce_carbonate` or `run_one_step`).
"""

import numpy as np

from landlab import RasterModelGrid
from landlab.components import CarbonateProducer
from landlab.plot import plot_layers

"""
## Information about the component

Passing the class name to the `help` function returns descriptions of the various methods and parameters:
"""

help(CarbonateProducer)

"""
## Examples

### Example 1: carbonate growth on a rising continental margin under sinusoidal sea-level variation

In this example, we consider a sloping ramp that rises tectonically while sea level oscillates.
"""

# Parameters and settings
nrows = 3  # number of grid rows
ncols = 101  # number of grid columns
dx = 1000.0  # node spacing, m
sl_range = 120.0  # range of sea-level variation, m
sl_period = 40000.0  # period of sea-level variation, y
run_duration = 200000.0  # duration of run, y
dt = 100.0  # time-step size, y
initial_shoreline_pos = 25000.0  # starting position of the shoreline, m
topo_slope = 0.01  # initial slope of the topography/bathymetry, m/m
uplift_rate = 0.001  # rate of tectonic uplift, m/y
plot_ylims = [-1000.0, 1000.0]

# Derived parameters
num_steps = int(run_duration / dt)
sin_fac = 2.0 * np.pi / sl_period  # factor for sine calculation of sea-level
middle_row = np.arange(ncols, 2 * ncols, dtype=int)

# Grid and fields
#
# Create a grid object
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)

# Create sea level field (a scalar, a.k.a. a "grid field")
sea_level = grid.add_field("sea_level__elevation", 0.0, at="grid")

# Create elevation field and initialize as a sloping ramp
bedrock_elevation = topo_slope * (initial_shoreline_pos - grid.x_of_node)
elev = grid.add_field("topographic__elevation", bedrock_elevation.copy(), at="node")
# elev[:] = topo_slope * (initial_shoreline_pos - grid.x_of_node)

# Remember IDs of middle row of nodes, for plotting
middle_row = np.arange(ncols, 2 * ncols, dtype=int)

plot_layers(
    bedrock_elevation[middle_row],
    x=grid.x_of_node[middle_row],
    sea_level=grid.at_grid["sea_level__elevation"],
    x_label="Distance (km)",
    y_label="Elevation (m)",
    title="Starting condition",
    legend_location="upper right",
)

# Instantiate component
cp = CarbonateProducer(grid)

# RUN
for i in range(num_steps):
    cp.sea_level = sl_range * np.sin(sin_fac * i * dt)
    cp.produce_carbonate(dt)
    elev[:] += uplift_rate * dt

plot_layers(
    [
        elev[middle_row] - grid.at_node["carbonate_thickness"][middle_row],
        elev[middle_row],
    ],
    x=grid.x_of_node[middle_row],
    sea_level=grid.at_grid["sea_level__elevation"],
    color_layer="Blues",
    x_label="Distance (km)",
    y_label="Elevation (m)",
    title="Carbonate production",
    legend_location="upper right",
)

"""
### Example 2: tracking stratigraphy

Here we repeat the same example, except this time we use Landlab's `MaterialLayers` class to track stratigraphy.
"""

# Track carbonate strata in time bundles of the below duration:
layer_time_interval = 20000.0

# Derived parameters and miscellaneous
next_layer_time = layer_time_interval
time_period_index = 0
time_period = "0 to " + str(int(layer_time_interval) // 1000) + " ky"

# Grid and fields
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
sea_level = grid.add_field("sea_level__elevation", 0.0, at="grid")
base_elev = grid.add_zeros("basement__elevation", at="node")
base_elev[:] = topo_slope * (initial_shoreline_pos - grid.x_of_node)
elev = grid.add_zeros("topographic__elevation", at="node")
middle_row = np.arange(ncols, 2 * ncols, dtype=int)
middle_row_cells = np.arange(0, ncols - 2, dtype=int)
carbo_thickness = grid.add_zeros("carbonate_thickness", at="node")
prior_carbo_thickness = np.zeros(grid.number_of_nodes)

# Instantiate component
cp = CarbonateProducer(grid)

# RUN
for i in range(num_steps):
    cp.sea_level = sl_range * np.sin(sin_fac * i * dt)
    cp.produce_carbonate(dt)
    base_elev[:] += uplift_rate * dt
    elev[:] = base_elev + carbo_thickness
    if (i + 1) * dt >= next_layer_time:
        time_period_index += 1
        next_layer_time += layer_time_interval
    added_thickness = np.maximum(
        carbo_thickness - prior_carbo_thickness, 0.00001
    )  # force a tiny bit of depo to keep layers consistent
    prior_carbo_thickness[:] = carbo_thickness
    # grid.material_layers.add(added_thickness[grid.node_at_cell], age=time_period_index)
    grid.event_layers.add(added_thickness[grid.node_at_cell], age=time_period_index)

"""
First get the layers we want to plot. In this case, plot the bottom and top layers as well as layers that correspond to sea level high stands. For the sinusoidal sea level curve we used, high stands occur every 400 time steps, with the first one being at time step 100.
"""

layers = (
    np.vstack(
        [
            grid.event_layers.z[0],
            grid.event_layers.z[100::400],
            grid.event_layers.z[-1],
        ]
    )
    + grid.at_node["basement__elevation"][grid.node_at_cell]
)

plot_layers(
    layers,
    x=grid.x_of_node[grid.node_at_cell],
    sea_level=grid.at_grid["sea_level__elevation"],
    color_layer="Oranges_r",
    legend_location="upper right",
    x_label="Distance (km)",
    y_label="Elevation (m)",
    title="Carbonates colored by age of deposition (darkest = oldest)",
)

"""
## References

Bosscher, H., & Schlager, W. (1992). Computer simulation of reef growth. Sedimentology, 39(3), 503-512.

Galewsky, J. (1998). The dynamics of foreland basin carbonate platforms: tectonic and eustatic controls. Basin Research, 10(4), 409-416.
"""



================================================
File: docs/source/tutorials/component_tutorial/component_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Getting to know the Landlab component library
"""

"""
This notebook walks you through the stages of creating and running a Landlab model using the Landlab component library.

We are going to create three models: firstly, a single-component driver implementing just linear diffusion; then a three-component driver implementing linear diffusion, flow routing, and stream power incision; and finally a similar model, but implementing a storm-interstorm sequence.

## The basics: one component

Let's begin with the one-component diffusion model.

Firstly, import the library elements we'll need. The component classes can all be imported from the `landlab.components` library. They're all formatted in CamelCaseLikeThis. Anything you see in that folder that isn't formatted like this isn't a component!
"""

import matplotlib as mpl
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components import LinearDiffuser

"""
Let's start by creating the grid that we'll do the first part of this exercise with, and putting some data into its fields. Note that you need to create the fields that a component takes as inputs *before* instantiating a component - though you can put values into the arrays later if you need to (as illustrated below). For more info on working with fields, see the *fields* tutorial.
"""

mg = RasterModelGrid((80, 80), xy_spacing=5.0)
z = mg.add_zeros("topographic__elevation", at="node")

"""
How did we know this was a field we needed as an input? Well, firstly because we read the component documentation (**always do this!**), but secondly we can get a reminder using the Landlab Component Standard Interface:
"""

LinearDiffuser.input_var_names

"""
Note we didn't have to instantiate the component to be able to do this! Other standard properties are `output_var_names` and `optional_var_names`; pass an input or output name to `var_loc`, `var_type`, `var_units`, and `var_definition` to get the centering ('node', 'link', etc.), array dtype (float, int), units (meters, etc.), and a descriptive string, respectively. `var_help` will give you a lot of this information at once:
"""

LinearDiffuser.var_help("topographic__elevation")

"""
It's also a good idea to set the grid boundary conditions before component instantiation. Let's have fixed value top and bottom and closed left and right (see the *boundary conditions* tutorial):
"""

for edge in (mg.nodes_at_left_edge, mg.nodes_at_right_edge):
    mg.status_at_node[edge] = mg.BC_NODE_IS_CLOSED
for edge in (mg.nodes_at_top_edge, mg.nodes_at_bottom_edge):
    mg.status_at_node[edge] = mg.BC_NODE_IS_FIXED_VALUE

"""
You will find that all components within landlab share a similar interface. We'll examine how it looks first on the diffusion component.

Landlab components have a standardised instantiation signature. Inputs to the component can be fed in as arguments to the constructor (i.e., the function that gets called when you create a new instances of a component), rather than being fed in as strings from a text input file (though note, you an still do this, see below). This has two major advantages: firstly, components now have plainly declared default values, which are visible just as they would be in, say, a numpy function; secondly, because the inputs are now Python objects, it's a lot easier to work with spatially variable inputs that need to be passed in as arrays, and also to feed dynamically changing inputs into a component.

The standard signature to instantiate a component looks like this:

```python
MyComponent(grid, input1=default1, input2=default2, input3=default3, ...)
```

Because defaults are provided, you can instantiate a component with default values very simply. The diffuser, for example, requires only that a `linear_diffusity` be supplied:
"""

lin_diffuse = LinearDiffuser(mg, linear_diffusivity=0.2)

"""
We'll see some other ways of initializing (e.g., from an input file) below.

Now we're ready to run the component! Run methods are also standardized. Most Landlab components have a standard run method named `run_one_step`, and it looks like this:

```python
my_comp.run_one_step(dt)
```

If the component is time-dependent, `dt`, the timestep, will be the first argument. (In Landlab 1.x, some components have subsequent keywords, which will typically be flags that control the way the component runs, and usually can be left as their default values; these extra keywords are absent in Landlab 2.x). Note that nothing is returned from a run method like this, but that nonetheless *the grid fields are updated*.

This `dt` is properly thought of as the *external model timestep*; it controls essentially the frequency at which the various Landlab components you're implementing can exchange information with each other and with the driver (e.g., frequency at which uplift steps are added to the grid). If your model has a stability condition that demands a shorter timestep, the external timestep will be subdivided internally down to this shorter timescale.

So let's do it. It's up to you as the component designer to make sure your driver script accounts properly for the total time the model runs. Here, we want to run for 200000 years with a timestep of 1000 years, with an uplift rate of 0.001 m/y. So:
"""

total_t = 200000.0
dt = 1000.0
uplift_rate = 0.001
nt = int(total_t // dt)
# ^note if we didn't know a priori that there are a round number of steps dt in the
# total time, we'd have to take care to account for the "extra" time (see example below)
for i in trange(nt):
    lin_diffuse.run_one_step(dt)
    z[mg.core_nodes] += uplift_rate * dt  # add the uplift

"""
Note that we're using `z` to input the uplift here, which we already bound to the Landlab field `mg.at_node['topographic__elevation]` when we instantiated that field. This works great, but always be careful to update the values *inside* the array, not to reset the variable as equal to something else, i.e., to put new values in the field do::

```python
z[:] = new_values  # values copied into the existing field
```

not
```python
z = new_values  # z is now "new_values", not the field!
```

Now plot the output!
"""

mg.imshow("topographic__elevation", grid_units=["m", "m"], var_name="Elevation (m)")

elev_rast = mg.node_vector_to_raster(z)
ycoord_rast = mg.node_vector_to_raster(mg.node_y)
ncols = mg.number_of_node_columns
plt.plot(ycoord_rast[:, int(ncols // 2)], elev_rast[:, int(ncols // 2)])
plt.xlabel("horizontal distance (m)")
plt.ylabel("vertical distance (m)")
plt.title("topographic__elevation cross section")

"""
Now, let's repeat this exercise, but illustrating the way we can input fields as some parameters for components. We're going to make the diffusivity spatially variable, falling by a factor of ten as we move across the grid.
"""

z[:] = 0.0  # reset the elevations to zero
k_diff = mg.zeros(at="node", dtype=float)
k_diff.fill(1.0)
k_diff *= (mg.node_x.max() - 0.9 * mg.x_of_node) / mg.x_of_node.max()
k_field = mg.add_field("linear_diffusivity", k_diff, at="node", clobber=True)
mg.imshow(k_diff, var_name="k_diff", cmap="winter")  # check it looks good

"""
Now we re-initialize the component instance to bind the k_diff field to the component:
"""

lin_diffuse = LinearDiffuser(mg, linear_diffusivity="linear_diffusivity")
# we could also have passed in `k_diff` in place of the string

"""
...and run just as before. Note this will be slower than before; the internal timestep is shorter because we've modified the diffusivities.
"""

for i in trange(nt):
    lin_diffuse.run_one_step(dt)
    z[mg.core_nodes] += uplift_rate * dt  # add the uplift

im = mg.imshow(
    "topographic__elevation", grid_units=["m", "m"], var_name="Elevation (m)"
)

"""
## Running two or more components

Now we're going to take a similar approach but this time combine the outputs of three distinct Landlab components: the diffuser, the monodirectional flow router, and the stream power incisor. For clarity, we're going to repeat the whole process from the start.

So first, let's import everything we don't already have:
"""

from landlab import load_params
from landlab.components import FastscapeEroder, FlowAccumulator

"""
More components means more input parameters. So this time, we're going to make our lives easier by instantiating our components from an [input file](./coupled_params.txt). Note also that we've now switched length units to km from m.

We're going to handle our input file using the very powerful `load_params` Landlab function. This function can read input text files formatted in a variety of different ways, including  the yaml standard. It automatically types the values it finds in the input file (i.e., makes them int, float, string, etc.), and returns them as a Python dictionary. This dictionary is the model parameter dictionary (MPD). However, feel free to use your own way of reading in a text file. The important thing is that you end up with a **dictionary** that contains `'input_parameter_name': parameter_value` pairs. Note that the file format has subsets of parameters grouped, using indentation:

```yaml
stream_power:
  K_sp: 0.3
  m_sp: 0.5
linear_diffuser:
  linear_diffusivity: 0.0001
```

When read into a dictionary, this forms two sub-dictionaries, with the keys *stream_power* and *linear_diffuser*. We will pass these two sub-dictionaries as `**kwargs` arguments to the FastscapeEroder and LinearDiffuser components, respectively.
"""

input_file = "./coupled_params.txt"
inputs = load_params(input_file)  # load the data into a dictionary

nrows = inputs["nrows"]
ncols = inputs["ncols"]
dx = inputs["dx"]
uplift_rate = inputs["uplift_rate"]
total_t = inputs["total_time"]
dt = inputs["dt"]

nt = int(total_t // dt)  # this is how many loops we'll need
uplift_per_step = uplift_rate * dt

# illustrate what the MPD looks like:
print(inputs)

"""
Now instantiate the grid, set the initial conditions, and set the boundary conditions:
"""

mg = RasterModelGrid((nrows, ncols), dx)
z = mg.add_zeros("topographic__elevation", at="node")
# add some roughness, as this lets "natural" channel planforms arise
initial_roughness = np.random.rand(z.size) / 100000.0
z += initial_roughness
for edge in (mg.nodes_at_left_edge, mg.nodes_at_right_edge):
    mg.status_at_node[edge] = mg.BC_NODE_IS_CLOSED
for edge in (mg.nodes_at_top_edge, mg.nodes_at_bottom_edge):
    mg.status_at_node[edge] = mg.BC_NODE_IS_FIXED_VALUE

"""
So far, so familiar.

Now we're going to instantiate all our components, using the MPD. We can do this using a bit of Python magic that lets you pass dictionaries into functions as sets of keywords. We do this by passing the dictionary as the final input, with to asterisks - `**` in front of it:
"""

fr = FlowAccumulator(mg)
sp = FastscapeEroder(mg, **inputs["stream_power"])
lin_diffuse = LinearDiffuser(mg, **inputs["linear_diffuser"])

"""
What's happening here is that the component is looking inside the dictionary for any keys that match its keywords, and using them. Values in the dictionary will override component defaults, but note that you cannot provide a keyword manually that is also defined in a supplied dictionary, i.e., this would result in a TypeError:

```python
>>> lin_diffuse = LinearDiffuser(mg, linear_diffusivity=1.,
                                 **{'linear_diffusivity': 1.})
TypeError
```

A note on the `FlowAccumulator`. This component provides a variety of options for the flow direction method used (e.g., D4/SteepestDescent, D8, MFD etc.). By default it uses D4 flow routing and does not deal with depression finding and routing.

In order to use the `DepressionFinderAndRouter` inside the `FlowAccumulator` specify `depression_finder = 'DepressionFinderAndRouter'`.

**If you are using the FlowAccumulator in additional projects or using this notebook as a starting place for additional work, work through the three tutorials on the `FlowDirectors` and the `FlowAccumulator` first.**

And now we run! We're going to run once with the diffusion and once without.
"""

for i in trange(nt):
    # lin_diffuse.run_one_step(dt) no diffusion this time

    # run_one_step isn't time sensitive, so it doesn't take dt as input
    fr.run_one_step()
    sp.run_one_step(dt)

    # add the uplift
    mg.at_node["topographic__elevation"][mg.core_nodes] += uplift_per_step

"""
You'll need to give the above code a few seconds to run.
"""

mg.imshow("topographic__elevation", grid_units=["km", "km"], var_name="Elevation (km)")

"""
And now let's reset the grid elevations and do everything again, but this time, with the diffusion turned *on*:
"""

z[:] = initial_roughness
for i in trange(nt):
    lin_diffuse.run_one_step(dt)  # no diffusion this time

    # run_one_step isn't time sensitive, so it doesn't take dt as input
    fr.run_one_step()
    sp.run_one_step(dt)
    # add the uplift
    mg.at_node["topographic__elevation"][mg.core_nodes] += uplift_per_step

mg.imshow("topographic__elevation", grid_units=["km", "km"], var_name="Elevation (km)")

"""
Beautiful! We've smoothed away the fine-scale channel roughness, as expected, and produced some lovely convex-up hillslopes in its place. Note that even though the initial conditions were identical in both cases, including the roughness, the channel positions have been moved significantly by the hillslope diffusion into the channel.
"""

"""
As a final step, we're going to show off some of Landlab's fancier functionality. We're going to repeat the above coupled model run, but this time we're going to plot some evolving channel profiles, and we're going to drive the simulation with a sequence of storms, not just a fixed timestep. We'll also produce a slope-area plot for the final conditions.

Working with timesteps of varying length requires a bit more bookkeeping, but the principle is the same as what we've seen before.

So, load the new landlab objects we'll need, then reset the initial conditions:
"""

from matplotlib.pyplot import loglog

from landlab.components import ChannelProfiler, PrecipitationDistribution

z[:] = initial_roughness

"""
Instantiate the storm generator. This time, we're going to mix an input file for some components with manual definition of others (that we already defined above).
"""

dt = 0.1
total_t = 250.0

storm_inputs = load_params("./coupled_params_storms.txt")
precip = PrecipitationDistribution(total_t=total_t, delta_t=dt, **storm_inputs)
print(storm_inputs)

# make a color mapping appropriate for our time duration
norm = mpl.colors.Normalize(vmin=0, vmax=total_t)
map_color = cm.ScalarMappable(norm=norm, cmap="viridis")

"""
Now run:
"""

out_interval = 100
# last_trunc = total_t  # we use this to trigger taking an output plot

storms = list(precip.yield_storm_interstorm_duration_intensity())
elapsed_time = 0.0

for storm in trange(len(storms)):
    interval_duration, rainfall_rate = storms[storm]

    # note diffusion also only happens when it's raining...
    if rainfall_rate > 0.0:
        fr.run_one_step()
        sp.run_one_step(interval_duration)
        lin_diffuse.run_one_step(interval_duration)

    z[mg.core_nodes] += uplift_rate * interval_duration

    elapsed_time += interval_duration

    if storm % out_interval == 0:
        cp = ChannelProfiler(mg)
        cp.run_one_step()
        cp.plot_profiles(color=map_color.to_rgba(elapsed_time))


plt.xlabel("Distance upstream (km)")
plt.ylabel("Elevation (km)")
plt.title("Long profiles evolving through time")
mpl.pyplot.colorbar(map_color, ax=mpl.pyplot.gca())

"""
Note that the "wobbles" in the long profile here are being created by the stochastic storm sequence. We could reduce their impact by reducing the storm-interstorm timescales, or allowing diffusion while it's not raining, but we've chosen not to here to show that the storms are having an effect.
"""

mg.imshow("topographic__elevation", grid_units=["km", "km"], var_name="Elevation (km)")

"""
We can also plot the location of the channels in map view. 

Here we plot all channel segments with drainage area greater than 0.01 square kilometers in the seven biggest drainage basins. 
"""

cp = ChannelProfiler(
    mg, number_of_watersheds=7, minimum_channel_threshold=0.01, main_channel_only=False
)
cp.run_one_step()
cp.plot_profiles_in_map_view()

"""
Next we make a slope area plot. 
"""

loglog(mg.at_node["drainage_area"], mg.at_node["topographic__steepest_slope"], ".")
plt.xlabel("Drainage area (km**2)")
plt.ylabel("Local slope")
plt.title("Slope-Area plot for whole landscape")



================================================
File: docs/source/tutorials/component_tutorial/coupled_params.txt
================================================
nrows: 100
ncols: 100
dx: 0.02
dt: 0.5
total_time: 100.
uplift_rate: 0.001
stream_power:
  K_sp: 0.3
  m_sp: 0.5
linear_diffuser:
  linear_diffusivity: 0.0001



================================================
File: docs/source/tutorials/component_tutorial/coupled_params_storms.txt
================================================
#these are for the storm generator:
mean_storm_duration: 0.1
mean_storm_depth: 0.2
mean_interstorm_duration: 0.4



================================================
File: docs/source/tutorials/data_record/DataRecord_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# DataRecord Tutorial
"""

"""
This tutorial illustrates how to record variables of a Landlab model using DataRecord.

## What is DataRecord?
DataRecord is a data structure that can hold data variables relating to a Landlab model or to items living on the [Landlab grid](../grids/grid_object_demo.ipynb).

DataRecord is built on [xarray](http://xarray.pydata.org/en/stable/)'s Dataset structure: a multi-dimensional, in memory, array database. Dataset implements the mapping interface with keys given by variable names and values given by DataArray objects for each variable name. DataRecord inherits all the methods and attributes from xarray.Dataset.

A DataRecord can have one or both (or none) of the following dimensions:
- `time`: The simulated time in the model.
- `item_id`: An identifier of a generic item in the model.

Coordinates are one dimensional arrays used for label-based indexing.  

The examples below illustrate different use cases for DataRecord.  

We start by importing the necessary libraries:
"""

import matplotlib.pyplot as plt
import numpy as np
import xarray as xr
from matplotlib.pyplot import figure, legend, plot, subplot, title, xlabel, ylabel

from landlab import RasterModelGrid, imshow_grid
from landlab.data_record import DataRecord

%matplotlib inline

"""
## Case 1. DataRecord with 1 dimension: time
Let's start with an example where we set DataRecord to have only `time` as a dimension.
An example variable that varies over time and relates to the Landlab grid could be the mean elevation of the topographic surface. We will store this example variable in DataRecord.

We create a Raster grid, create a field (at nodes) called `topographic__elevation` and populate it with random values.
"""

grid_1 = RasterModelGrid((10, 10), (1.0, 1.0))
z = np.random.rand(100)
_ = grid_1.add_field("topographic__elevation", z, at="node")

"""
Print the current mean elevation.
"""

current_mean = np.mean(grid_1.at_node["topographic__elevation"])
print(current_mean)

"""
Now we will create a DataRecord that will hold the data variable `mean_elevation` relating to `grid_1`. The first value, at time=0 is the current mean elevation on the grid.
"""

dr_1 = DataRecord(
    grid_1,
    time=[0.0],
    items=None,
    data_vars={"mean_elevation": (["time"], ([current_mean]))},
    attrs={"mean_elevation": "y"},
)

"""
The input arguments passed in this case are: the grid, time (as a 1-element list), a data variable dictionary and an attributes dictionary. Note that `items` is not filled, we will see its use in other cases below.

Note the format of the `data_vars` dictionary:  
```python
    {'variable_name_1' : (['dimensions'], variable_data_1),
     'variable_name_2' : (['dimensions'], variable_data_2),
     ...}
```

The attributes dictionary `attrs` can be used to store metadata about the variables: in this example, we use it to store the variable units.

So far, our DataRecord `dr_1` holds one variable `mean_elevation` with one record at time=0.

"""

dr_1

"""
We can visualise this data structure as a [pandas dataframe](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html):
"""

dr_1.dataset.to_dataframe()

"""
Now we will run a simple model where the grid surface is uplifted several times and the mean elevation is recorded at every time step. We use the method `add_record` to put the new value in the DataRecord `dr_1`:
"""

total_time = 100
dt = 20

uplift_rate = 0.01  # m/y

for t in range(20, total_time, dt):
    grid_1.at_node["topographic__elevation"] += uplift_rate * dt
    dr_1.add_record(
        time=[t],
        new_record={
            "mean_elevation": (
                ["time"],
                ([np.mean(grid_1.at_node["topographic__elevation"])]),
            )
        },
    )

"""
Let's see what was recorded:
"""

dr_1.dataset["mean_elevation"].values

"""
The corresponding time coordinates are:
"""

dr_1.dataset.time.values

"""
Notice the different syntax used here: 
- `time` is a **dimension** and can be called by `dr_1.time` (or `dr_1['time']`)
- whereas `mean_elevation` is a **variable** and must be called by `dr_1['mean_elevation']`

DataRecord also has the handy property `time_coordinates` that returns these values as a list:



"""

dr_1.time_coordinates

"""
You can use the methods `get_data` and `set_data` to access and change the data:
"""

dr_1.get_data(time=[20.0], data_variable="mean_elevation")

dr_1.set_data(time=[80.0], data_variable="mean_elevation", new_value=1.5)

dr_1.dataset["mean_elevation"]

"""
## Case 2. DataRecord with 1 dimension: item_id
An important feature of DataRecord is that it allows to create **items** that live on grid elements, and variables describing them. For instance, we can create *boulders* and store information about their *size* and *lithology*.

To create items, we need to instantiate a DataRecord and pass it a dictionary describing where each item lives on the Landlab grid. The format of this dictionary is:  
```python
    {'grid_element' : [grid_element],
     'element_id' : [element_id]}
```
  
where:
- `grid_element` is a str or number-of-items-long array containing strings of the grid element(s) on which the items live (e.g.: node, link). Valid locations depend on the grid type (`my_grid.groups` gives the valid locations for your grid). If `grid_element` is provided as a string, it is assumed that all items live on the same type of grid element.
- `element_id` is an array of integers identifying the grid element IDs on which each item resides. For each item, `element_id` must be less than the number of this item's `grid_element` that exist on the grid. For example, if the grid has 10 links, no item can live at link 10 or link -3 because only links 0 to 9 exist in this example.

"""

grid_2 = RasterModelGrid((5, 5), (2, 2))

boulders = {"grid_element": "node", "element_id": np.array([6, 11, 12, 17, 12])}

initial_boulder_sizes = np.array([1, 1.5, 3, 1, 2])
boulder_lithologies = np.array(
    ["sandstone", "granite", "sandstone", "sandstone", "limestone"]
)

dr_2 = DataRecord(
    grid_2,
    time=None,
    items=boulders,
    data_vars={
        "boulder_size": (["item_id"], initial_boulder_sizes),
        "boulder_litho": (["item_id"], boulder_lithologies),
    },
    attrs={"boulder_size": "m"},
)
dr_2.dataset.to_dataframe()

"""
Each *item* (in this case, each boulder) is designated by an `item_id`, its position on the grid is described by a `grid_element` and an `element_id`.

We can use the method `add_item` to add new boulders to the record:
"""

dr_2.add_item(
    new_item={
        "grid_element": np.array(["link", "node"]),
        "element_id": np.array([24, 8]),
    },
    new_item_spec={"boulder_size": (["item_id"], np.array([1.2, 2.0]))},
)

dr_2.dataset.to_dataframe()

"""
Notice that we did not specify the lithologies of the new boulders, their recorded values are thus set as `NaN`. We can use the `set_data` method to report the boulder lithologies: 
"""

dr_2.set_data(
    data_variable="boulder_litho", item_id=[5, 6], new_value=["sandstone", "granite"]
)
dr_2.dataset.to_dataframe()

"""
We can use the method `calc_aggregate_value` to apply a function to a variable aggregated at grid elements. For example, we can calculate the mean size of boulders on each node:
"""

mean_size = dr_2.calc_aggregate_value(
    func=xr.Dataset.mean, data_variable="boulder_size"
)
mean_size

"""
Notice that boulder #5 is on a link so it is not taken into account in this calculation.
"""

# replace nans with 0:
mean_size[np.isnan(mean_size)] = 0

# show unfiltered mean sizes on the grid:
imshow_grid(grid_2, mean_size)

"""
Before doing this calculation we could filter by lithology and only use the 'sandstone' boulders in the calculation:
"""

# define a filter array:
filter_litho = dr_2.dataset["boulder_litho"] == "sandstone"

# aggregate by node and apply function numpy.mean on boulder_size
filtered_mean = dr_2.calc_aggregate_value(
    func=xr.Dataset.mean,
    data_variable="boulder_size",
    at="node",
    filter_array=filter_litho,
)

filtered_mean

"""
## Case 3. DataRecord with 2 dimensions: item_id and time

We may want to record variables that have both dimensions `time` *and* `item_id`.

In the previous example, some variables that characterize the items (boulders) may not vary with time, such as `boulder_lithology`. Although it can be interesting to keep track of the change in size through time. We will redefine the DataRecord such that the variable `boulder_size` varies among the items/boulders (identified by `item_id`) and through `time`. The variable `boulder_litho` varies only among the items/boulders and this lithogy variable does not vary through time.
"""

grid_3 = RasterModelGrid((5, 5), (2, 2))

initial_boulder_sizes_3 = np.array([[10], [4], [8], [3], [5]])
# boulder_lithologies = np.array(['sandstone', 'granite', 'sandstone', 'sandstone', 'limestone']) #same as above, already run

boulders_3 = {
    "grid_element": "node",
    "element_id": np.array([[6], [11], [12], [17], [12]]),
}

dr_3 = DataRecord(
    grid_3,
    time=[0.0],
    items=boulders_3,
    data_vars={
        "boulder_size": (["item_id", "time"], initial_boulder_sizes_3),
        "boulder_litho": (["item_id"], boulder_lithologies),
    },
    attrs={"boulder_size": "m"},
)
dr_3

"""
Note that the syntax to define the `initial_boulder_sizes_3` (as well as `element_id`) has changed: they are  number-of-items-by-1 arrays because they vary along both `time` and `item_id` (compared to `boulder_lithologies` which is just number-of-items long as it only varies along `item_id`).
"""

boulder_lithologies.shape, initial_boulder_sizes.shape, initial_boulder_sizes_3.shape

"""
Let's define a very simple erosion law for the boulders:

$$
\begin{equation}
\frac{dD}{dt} = -k_{b} . D
\end{equation}
$$

where $D$ is the boulder diameter $[L]$ (this value represents the `boulder_size` variable), $t$ is time, and $k_{b}$ is the block erodibility $[L.T^{-1}]$.

We will now model boulder erosion and use DataRecord to store their size through time.
"""

dt = 100
total_time = 100000

time_index = 1

for t in range(dt, total_time, dt):
    # create a new time coordinate:
    dr_3.add_record(time=np.array([t]))

    # this propagates grid_element and element_id values forward in time (instead of the 'nan' default filling):
    dr_3.ffill_grid_element_and_id()

    for i in range(0, dr_3.number_of_items):
        # value of block erodibility:
        if dr_3.dataset["boulder_litho"].values[i] == "limestone":
            k_b = 10**-5
        elif dr_3.dataset["boulder_litho"].values[i] == "sandstone":
            k_b = 3 * 10**-6
        elif dr_3.dataset["boulder_litho"].values[i] == "granite":
            k_b = 3 * 10**-7
        else:
            print("Unknown boulder lithology")

        dr_3.dataset["boulder_size"].values[i, time_index] = (
            dr_3.dataset["boulder_size"].values[i, time_index - 1]
            - k_b * dr_3.dataset["boulder_size"].values[i, time_index - 1] * dt
        )

    time_index += 1

print("Done")

figure(figsize=(15, 8))

time = range(0, total_time, dt)
boulder_size = dr_3.dataset["boulder_size"].values

subplot(121)
plot(time, boulder_size[1], label="granite")
plot(time, boulder_size[3], label="sandstone")
plot(time, boulder_size[-1], label="limestone")
xlabel("Time (yr)")
ylabel("Boulder size (m)")
legend(loc="lower left")
title("Boulder erosion by lithology")

# normalized plots
subplot(122)
plot(time, boulder_size[1] / boulder_size[1, 0], label="granite")
plot(time, boulder_size[2] / boulder_size[2, 0], label="sandstone")
plot(time, boulder_size[-1] / boulder_size[-1, 0], label="limestone")
xlabel("Time (yr)")
ylabel("Boulder size normalized to size at t=0 (m)")
legend(loc="lower left")
title("Normalized boulder erosion by lithology")
plt.show()

"""
## Other properties provided by DataRecord
"""

dr_3.variable_names

dr_3.number_of_items

dr_3.item_coordinates

dr_3.number_of_timesteps

dr_1.time_coordinates

dr_1.earliest_time

dr_1.latest_time

dr_1.prior_time

"""
## More on DataRecord

DataRecord is the data structure on which the following Landlab components are based:
- ClastTracker (coming soon)
- SpeciesEvolver (coming soon)
"""



================================================
File: docs/source/tutorials/ecohydrology/cellular_automaton_vegetation_DEM/Inputs_Vegetation_CA_DEM.txt
================================================

### All inputs for Vegetation Cellular Automaton Model built on The Landlab
### can be given here.
### 14Feb2015 - Sai Nudurupati & Erkan Istanbulluoglu
### 15Jul2016 - Updated to comply with Landlab Version 1 naming conventions.

### There are some rules to use this input file:
###    1) The variable's identifier should not be changed, for e.g. 'mean_storm_dry'  is
###       the model input parameter. The code only understands this variable this way.
###       Anything following '#' can be changed (commented part).
###    2) A separator ':'  is used to define the end of the variable name.
###    3) Input value/string should be entered in the following (immediate) line of the variable name.
###    4) Nothing other than the input values should  be entered in this line (where value is entered).
###    5) A float value should always have a number in front of the decimal '.', e.g  '0.1' instead of '.1'
###       If not, the input will be read as a string value.
###    6) Any numeric input will be identified as a float if it contains '.'  . If a decimal point is not present,
###       the input will be read in as an int.
###    7) String inputs are also recognized.

### Vegetation Cellular Automaton Model Input File:

n_short:                 # Number of storms for short simulation that plots hydrologic parameters
6600
n_long_DEM:              # Number of storms for long simulation that operates on single grid for sloped surface
1320
n_long_flat:             # Number of storms for long simulation that operates on two grids - flat surface
660000

## Initial Plant Functional Types (PFT) distribution
percent_bare_initial:   # Initial percentage of cells occupied by bare soil
0.7
percent_grass_initial:  # Initial percentage of cells occupied by grass
0.1
percent_shrub_initial:  # Initial percentage of cells occupied by shrubs
0.1
percent_tree_initial:   # Initial percentage of cells occupied by trees
0.1

## Precipitation:

# Dry Season
mean_storm_dry:          # Mean storm duration (hours)
2.016
mean_interstorm_dry:     # Mean interstorm duration (hours)
159.36
mean_storm_depth_dry:    # Mean storm depth (mm)
3.07
# Wet Season
mean_storm_wet:          # Mean storm duration (hours)
1.896
mean_interstorm_wet:     # Mean interstorm duration (hours)
84.24
mean_storm_depth_wet:    # Mean storm depth (mm)
4.79
doy__start_of_monsoon:   # Day of the year when the monsoon starts
182
doy__end_of_monsoon:     # Day of the year when the monsoon ends
273

## PotentialEvapotranspiration:
# Cosine Method
PET_method:
Cosine
LT:                     # Lag between peak TmaxF estimated by cosine method and solar forcing (days)
0
DeltaD:                 # Calibrated difference between
7.
ND:                     # Number of days in the year (days)
365.
MeanTmaxF_grass:        # Mean annual rate of TmaxF (mm/d)
5.15
MeanTmaxF_shrub:        # Mean annual rate of TmaxF (mm/d)
3.77
MeanTmaxF_tree:         # Mean annual rate of TmaxF (mm/d)
4.96

# TmaxF - Estimated maximum evapotranspiration as a function of DOY using Penman Monteith method for historical weather

## Soil Moisture:

runon:                  # Runon from higher elevations (mm)
0.
f_bare:                 # Fraction to partition PET for bare soil (None)
0.7

# Grass

VEGTYPE_grass:          # Integer value to infer Vegetation Type
0
intercept_cap_grass:    # Full canopy interception capacity  (mm)
1.
zr_grass:               # Root depth (m)
0.3
I_B_grass:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_grass:              # Infiltration capacity of vegetated soil (mm/h)
24.
pc_grass:               # Soil porosity (None)
0.43
fc_grass:               # Soil saturation degree at field capacity (None)
0.56
sc_grass:               # Soil saturation degree at stomatal closure (None)
0.33
wp_grass:               # Soil saturation degree at wilting point (None)
0.13
hgw_grass:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_grass:             # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Shrub

VEGTYPE_shrub:          # Integer value to infer Vegetation Type
1
intercept_cap_shrub:    # Full canopy interception capacity  (mm)
1.5
zr_shrub:               # Root depth (m)
0.5
I_B_shrub:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_shrub:              # Infiltration capacity of vegetated soil (mm/h)
40.
pc_shrub:               # Soil porosity (None)
0.43
fc_shrub:               # Soil saturation degree at field capacity (None)
0.56
sc_shrub:               # Soil saturation degree at stomatal closure (None)
0.24
wp_shrub:               # Soil saturation degree at wilting point (None)
0.13
hgw_shrub:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_shrub:             # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Tree

VEGTYPE_tree:           # Integer value to infer Vegetation Type
2
intercept_cap_tree:     # Full canopy interception capacity  (mm)
2.
zr_tree:                # Root depth (m)
1.3
I_B_tree:               # Infiltration capacity of bare soil (mm/h)
20.
I_V_tree:               # Infiltration capacity of vegetated soil (mm/h)
40.
pc_tree:                # Soil porosity (None)
0.43
fc_tree:                # Soil saturation degree at field capacity (None)
0.56
sc_tree:                # Soil saturation degree at stomatal closure (None)
0.22
wp_tree:                # Soil saturation degree at wilting point (None)
0.15
hgw_tree:               # Soil saturation degree at hygroscopic point (None)
0.1
beta_tree:              # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Bare Soil

VEGTYPE_bare:          # Integer value to infer Vegetation Type
3
intercept_cap_bare:    # Full canopy interception capacity  (mm)
1.
zr_bare:               # Root depth (m)
0.15
I_B_bare:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_bare:              # Infiltration capacity of vegetated soil (mm/h)
20.
pc_bare:               # Soil porosity (None)
0.43
fc_bare:               # Soil saturation degree at field capacity (None)
0.56
sc_bare:               # Soil saturation degree at stomatal closure (None)
0.33
wp_bare:               # Soil saturation degree at wilting point (None)
0.13
hgw_bare:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_bare:             # Deep percolation constant
13.8


## Vegetation Dynamics:

Blive_init:
102.
Bdead_init:
450.
PET_growth_threshold:    # PET threshold for growing season (mm/d)
3.8
PET_dormancy_threshold:  # PET threshold for dormant season (mm/d)
6.8
Tdmax:					# Constant for dead biomass loss adjustment (mm/d)
10.
w:						# Conversion factor of CO2 to dry biomass (Kg DM/Kg CO2)
0.55

# Grass

WUE_grass:              # Water use efficiency KgCO2Kg-1H2O
0.01
cb_grass:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.0047
cd_grass:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.009
ksg_grass:              # Senescence coefficient of green/live biomass (d-1)
0.012
kdd_grass:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_grass:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_grass:          # Maximum leaf area index (m2/m2)
2.
LAIR_max_grass:         # Reference leaf area index (m2/m2)
2.88

# Shrub

WUE_shrub:              # Water use efficiency KgCO2Kg-1H2O
0.0025
cb_shrub:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.004
cd_shrub:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.01
ksg_shrub:              # Senescence coefficient of green/live biomass (d-1)
0.002
kdd_shrub:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_shrub:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_shrub:          # Maximum leaf area index (m2/m2)
2.
LAIR_max_shrub:         # Reference leaf area index (m2/m2)
2.

# Tree

WUE_tree:               # Water use efficiency KgCO2Kg-1H2O
0.0045
cb_tree:                # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.004
cd_tree:                # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.01
ksg_tree:               # Senescence coefficient of green/live biomass (d-1)
0.002
kdd_tree:               # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_tree:               # Maximum drought induced foliage loss rate (d-1)
0.01
LAI_max_tree:          # Maximum leaf area index (m2/m2)
4.
LAIR_max_tree:          # Reference leaf area index (m2/m2)
4.

# Bare

WUE_bare:              # Water use efficiency KgCO2Kg-1H2O
0.01
cb_bare:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.0047
cd_bare:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.009
ksg_bare:              # Senescence coefficient of green/live biomass (d-1)
0.012
kdd_bare:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_bare:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_bare:          # Maximum leaf area index (m2/m2)
0.01
LAIR_max_bare:         # Reference leaf area index (m2/m2)
0.01


## Cellular Automaton Vegetation:

# Grass

Pemaxg:                 # Maximal establishment probability
0.35
ING:                    # Parameter to define allelopathic effect on grass from cresotebush
2
ThetaGrass:             # Drought resistant threshold
0.5
PmbGrass:               # Background mortality probability
0.05

# Shrub

Pemaxsh:                # Maximal establishment probability
0.001
ThetaShrub:             # Drought resistant threshold
0.6
PmbShrub:               # Background mortality probability
0.05
tpmaxShrub:             # Maximum age (yr)
600

# Tree

Pemaxtr:                # Maximal establishment probability
0.25
ThetaTree:              # Drought resistant threshold
0.6
PmbTree:                # Background mortality probability
0.01
tpmaxTree:              # Maximum age (yr)
350

# ShrubSeedling

ThetaShrubSeedling:     # Drought resistant threshold
0.54
PmbShrubSeedling:       # Background mortality probability
0.03
tpmaxShrubSeedling:     # Maximum age (yr)
18

# TreeSeedling

ThetaTreeSeedling:      # Drought resistant threshold
0.45
PmbTreeSeedling:        # Background mortality probability
0.03
tpmaxTreeSeedling:      # Maximum age (yr)
18



================================================
File: docs/source/tutorials/ecohydrology/cellular_automaton_vegetation_DEM/cellular_automaton_vegetation_DEM.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
WARNING: This tutorial has not been updated to work with Landlab 2.0 and is thus not tested to verify that it will run. 

# Tutorial For Cellular Automaton Vegetation Model Coupled With Ecohydrologic Model
"""

"""
This tutorial demonstrates implementation of the Cellular Automaton Tree-GRass-Shrub Simulator (CATGRaSS) [Zhou et al., 2013] on a digital elevation model (DEM). This model is built using components from the Landlab component library. CATGRaSS is a spatially explicit model of plant coexistence. It simulates local ecohydrologic dynamics (soil moisture, transpiration, biomass) and spatial evolution of tree, grass, and shrub Plant Functional Types (PFT) driven by rainfall and solar radiation. 

Each cell in the model grid can hold a single PFT or remain empty. Tree and shrub plants disperse seeds to their neighbors. Grass seeds are assumed to be available at each cell. Establishment of plants in empty cells is determined probabilistically based on water stress for each PFT. Plants with lower water stress have higher probability of establishment. Plant mortality is simulated probabilistically as a result of aging and drought stress. Fires and grazing will be added to this model soon.  

This model (driver) contains:
- A local vegetation dynamics model that simulates storm and inter-storm water balance and ecohydrologic fluxes (ET, runoff), and plant biomass dynamics by coupling the following components:
    - PrecipitationDistribution
    - Radiation
    - PotentialEvapotranspiration
    - SoilMoisture
    - Vegetation

- A spatially explicit probabilistic cellular automaton component that simulates plant competition by tracking establishment and mortality of plants based on soil moisture stress:
    - VegCA
    
To run this Jupyter notebook, please make sure that the following files are in the same folder:
 - cellular_automaton_vegetation_DEM.ipynb (this notebook)
 - Inputs_Vegetation_CA.txt (Input parameters for the model)
 - Ecohyd_functions_DEM.py (Utility functions)
    
[Ref: Zhou, X, E. Istanbulluoglu, and E.R. Vivoni. "Modeling the ecohydrological role of aspect-controlled radiation on tree-grass-shrub coexistence in a semiarid climate." Water Resources Research 49.5 (2013): 2872-2895]
"""

"""
In this tutorial, we are going to work with a landscape in central New Mexico, USA, where aspect controls the organization of PFTs. The climate in this area is semi-arid with Mean Annual Precipitation (MAP) of 254 mm [Zhou et. al 2013]. 
We will do the following: 
- Import a landscape 
- Initialize the landscape with random distribution of PFTs
- Run the coupled Ecohydrology and cellular automata plant competition model for 50 years
- Visualize and examine outputs
"""

"""
## Let's walk through the code:
"""

"""
Import the required libraries:
"""

%matplotlib inline

import time

import numpy as np
from Ecohyd_functions_DEM import Create_PET_lookup, Empty_arrays, Initialize_, Plot_

from landlab import RasterModelGrid as rmg, load_params
from landlab.io import read_esri_ascii

"""
Note: 'Ecohyd_functions_DEM.py' is a utility script that contains 'functions', which instantiates components and manages inputs and outputs, and help keep this driver concise. Contents of 'Ecohyd_functions_DEM.py' can be a part of this driver (current file), however left out to keep driver concise.
"""

"""
We will use two grids in this driver. One grid will represent the actual landscape or domain (e.g., created from a DEM). Another grid, with one cell for each of the plant functional types (PFTs), will be used to create Potential Evapotranspiration (PET) lookup tables.

- grid: This grid represents the actual landscape. Each cell can be occupied by a single PFT such as tree, shrub, grass, or can be empty (bare). In this example we assume that the elevation field and the vegetation field has the same resolution.

- grid1: This grid will be used to compute plant-specific PET at a point. Spatially distributed PET Lookup arrays (for all days of the year) will be created for each PFT based on these point values.

Note: In this tutorial, the physical ecohydrological components and cellular automata plant competition will be run on grids with same resolution. To develop differential spatial resolutions for the two models, see the tutorial 'cellular_automaton_vegetation_flat.ipynb'.
"""

(grid, elevation) = read_esri_ascii("DEM_10m.asc")  # Read the DEM
grid1 = rmg((5, 4), xy_spacing=(5.0, 5.0))  # Representative grid

"""
Include the input file that contains all input parameters needed for all components. This file can either be a Python dictionary or a text file that can be converted into a Python dictionary. If a text file is provided, it will be converted to a Python dictionary. Here we use an existing text file prepared for this exercise.
"""

InputFile = "Inputs_Vegetation_CA_DEM.txt"
data = load_params(InputFile)  # Creates dictionary that holds the inputs

"""
Instantiate Landlab components to simulate corresponding attributes. In this example, we shall demonstrate the use of seasonal rainfall and PFT-specific potential evapotranspiration. The instantiated objects are:
- PD_D: object for dry season rainfall, 
- PD_W: object for wet season rainfall, 
- Rad: Radiation object computes radiation factor defined as the ratio of total shortwave radiation incident on a sloped surface to total shortwave radiation incident on a flat surface. 
- Rad_PET: Representative radiation object which is used only as an input for PET.
- PET_PFT: Plant specific PET objects (we use a cosine function, fitted to calculated PET, as a function of Day Of the Year (DOY) to reduce computation overhead). This value is spatially distributed by using a radiation factor.
- SM: Soil Moisture object simulates root-zone average soil moisture at each cell using inputs of potential evapotranspiration, live leaf area index, and vegetation cover.
- VEG: Vegetation dynamics object simulates net primary productivity and biomass and thus leaf area index at each cell based on inputs of root-zone average soil moisture.
- vegca: Cellular Automaton plant competition object. This object simulates the spatial dynamics of PFTs. It is run once every year at the end of the growing season. This object is initialized with a random cellular field of PFT. Each year, this object updates the field of PFTs based on probabilistic establishment and mortality rules employed at each cell of the modeled DEM.

Note: Almost every component in Landlab is coded as a 'class' (to harness the advantages of object oriented programming). An 'object' is the instantiation of the 'class' (for more information, please refer any object oriented programming book). A 'field' refers to a Landlab field (please refer to the [Landlab documentation](https://landlab.csdms.io/user_guide/grid.html#adding-data-to-a-landlab-grid-element-using-fields) to learn more about Landlab fields).
"""

"""
Now let's instantiate all Landlab components that we are going to use for this tutorial:
"""

PD_D, PD_W, Rad, Rad_PET, PET_Tree, PET_Shrub, PET_Grass, SM, VEG, vegca = Initialize_(
    data, grid, grid1, elevation
)

"""
Lets look at the initial organization of PFTs
"""

import matplotlib as mpl
import matplotlib.pyplot as plt

cmap = mpl.colors.ListedColormap(["green", "red", "black", "white", "red", "black"])
bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
description = "green: grass; red: shrub; black: tree; white: bare"
plt.figure(101)
grid.imshow(
    "vegetation__plant_functional_type",
    at="cell",
    cmap=cmap,
    grid_units=("m", "m"),
    norm=norm,
    limits=[0, 5],
    allow_colorbar=False,
)
plt.figtext(0.2, 0.0, description, weight="bold", fontsize=10)

"""
Specify an approximate number of years for the model to run.

IMPORTANT: 
This code in numerically extensive. It might take an hour or more to run this simulation for 300 years. It is suggested to run the simulation for 50 years which might take less than 7 minutes to execute.
"""

n_years = 50  # Approx number of years for model to run
# Calculate approximate number of storms per year
fraction_wet = (data["doy__end_of_monsoon"] - data["doy__start_of_monsoon"]) / 365.0
fraction_dry = 1 - fraction_wet
no_of_storms_wet = (
    8760 * (fraction_wet) / (data["mean_interstorm_wet"] + data["mean_storm_wet"])
)
no_of_storms_dry = (
    8760 * (fraction_dry) / (data["mean_interstorm_dry"] + data["mean_storm_dry"])
)
n = int(n_years * (no_of_storms_wet + no_of_storms_dry))

"""
Create empty arrays to store spatio-temporal data over multiple iterations. The captured data can be used for plotting model outputs.
"""

P, Tb, Tr, Time, VegType, PET_, Rad_Factor, EP30, PET_threshold = Empty_arrays(
    n, n_years, grid, grid1
)

"""
To reduce computational overhead, we shall create a lookup array for plant-specific PET values for each day of the year, and slope and aspect grid.
"""

Create_PET_lookup(
    Rad, PET_Tree, PET_Shrub, PET_Grass, PET_, Rad_Factor, EP30, Rad_PET, grid
)

"""
Specify current_time (in years). current_time is the current time in the simulation.
"""

# # Represent current time in years
current_time = 0  # Start from first day of Jan

# Keep track of run time for simulation—optional
Start_time = time.clock()  # Recording time taken for simulation

# declaring few variables that will be used in storm loop
time_check = 0.0  # Buffer to store current_time at previous storm
yrs = 0  # Keep track of number of years passed
WS = 0.0  # Buffer for Water Stress
Tg = 365  # Growing season in days

"""
The loop below couples the components introduced above in a for loop until all "n" number of storms are generated. Time is advanced by the soil moisture object based on storm and interstorm durations that are estimated by the strom generator object. The ecohydrologic model is run on each storm whereas cellular automaton vegetation component is run once every year.

Note: This loop might take around 10 minutes (depending on your computer) to run for a 50 year simulation. Ignore any warnings you might see.
"""

# # Run storm Loop
for i in range(0, n):
    # # Update objects
    # Calculate Day of Year (DOY)
    Julian = int(np.floor((current_time - np.floor(current_time)) * 365.0))
    # Generate seasonal storms
    # for Dry season
    if Julian < data["doy__start_of_monsoon"] or Julian > data["doy__end_of_monsoon"]:
        PD_D.update()
        P[i] = PD_D.get_storm_depth()
        Tr[i] = PD_D.get_precipitation_event_duration()
        Tb[i] = PD_D.get_interstorm_event_duration()
    # Wet Season—Jul to Sep—NA Monsoon
    else:
        PD_W.update()
        P[i] = PD_W.get_storm_depth()
        Tr[i] = PD_W.get_precipitation_event_duration()
        Tb[i] = PD_W.get_interstorm_event_duration()

    # Spatially distribute PET and its 30-day-mean (analogous to degree day)
    grid["cell"]["surface__potential_evapotranspiration_rate"] = (
        np.choose(grid["cell"]["vegetation__plant_functional_type"], PET_[Julian])
    ) * Rad_Factor[Julian]
    grid["cell"]["surface__potential_evapotranspiration_30day_mean"] = (
        np.choose(grid["cell"]["vegetation__plant_functional_type"], EP30[Julian])
    ) * Rad_Factor[Julian]

    # Assign spatial rainfall data
    grid["cell"]["rainfall__daily_depth"] = P[i] * np.ones(grid.number_of_cells)

    # Update soil moisture component
    current_time = SM.update(current_time, Tr=Tr[i], Tb=Tb[i])

    # Decide whether its growing season or not
    if Julian != 364:
        if EP30[Julian + 1, 0] > EP30[Julian, 0]:
            PET_threshold = 1
            # 1 corresponds to ETThresholdup (begin growing season)
        else:
            PET_threshold = 0
            # 0 corresponds to ETThresholddown (end growing season)

    # Update vegetation component
    VEG.update(PETthreshold_switch=PET_threshold, Tb=Tb[i], Tr=Tr[i])

    # Update yearly cumulative water stress data
    WS += (grid["cell"]["vegetation__water_stress"]) * Tb[i] / 24.0

    # Record time (optional)
    Time[i] = current_time

    # Cellular Automata
    if (current_time - time_check) >= 1.0:
        if yrs % 5 == 0:
            print(f"Elapsed time = {yrs} years")
        VegType[yrs] = grid["cell"]["vegetation__plant_functional_type"]
        grid["cell"]["vegetation__cumulative_water_stress"] = WS / Tg
        vegca.update()
        SM.initialize()
        VEG.initialize()
        time_check = current_time
        WS = 0
        yrs += 1
VegType[yrs] = grid["cell"]["vegetation__plant_functional_type"]

"""
Time_Consumed is an optional variable that gives information about computer running time
"""

Final_time = time.clock()
Time_Consumed = (Final_time - Start_time) / 60.0  # in minutes
print(f"Time_consumed = {Time_Consumed} minutes")

"""
Save the outputs using ``numpy.save()``. These files have '.nc' extension, which can be loaded using ``numpy.load()``.
"""

# # Saving
sim = "VegCA_DEM_26Jul16_"
# Save_(sim, Tb, Tr, P, VegType, yrs, Time_Consumed, Time)

"""
Lets look at outputs.

Plots of the cellular field of PFT at specified year step can be found below where:

GRASS = Green;  SHRUB = Red;  TREE = Black;  BARE = White;

At the end, percentage cover for each PFT is plotted with respect to time.
"""

Plot_(grid, VegType, yrs, yr_step=10)

"""
#### If you run this model for around 900 years, you will observe patterns of PFTs. For example, you will find more trees on north facing slopes and mostly shrubs and grass on south facing slopes, as shown below:
"""

from IPython.display import Image

Image(filename="presentation.png")

"""
If you want to explore this model further, open 'Inputs_Vegetation_CA.txt' and change the input parameters (e.g., initial PFT distribution percentages, storm characteristics, etc..).
"""



================================================
File: docs/source/tutorials/ecohydrology/cellular_automaton_vegetation_flat_surface/Inputs_Vegetation_CA_flat.txt
================================================

### All inputs for Vegetation Cellular Automaton Model built on The Landlab
### can be given here.
### 14Feb2015 - Sai Nudurupati & Erkan Istanbulluoglu
### 15Jul2016 - Updated to comply with Landlab Version 1 naming conventions.

### There are some rules to use this input file:
###    1) The variable's identifier should not be changed, for e.g. 'mean_storm_dry'  is
###       the model input parameter. The code only understands this variable this way.
###       Anything following '#' can be changed (commented part).
###    2) A separator ':'  is used to define the end of the variable name.
###    3) Input value/string should be entered in the following (immediate) line of the variable name.
###    4) Nothing other than the input values should  be entered in this line (where value is entered).
###    5) A float value should always have a number in front of the decimal '.', e.g  '0.1' instead of '.1'
###       If not, the input will be read as a string value.
###    6) Any numeric input will be identified as a float if it contains '.'  . If a decimal point is not present,
###       the input will be read in as an int.
###    7) String inputs are also recognized.

### Vegetation Cellular Automaton Model Input File:

n_short:                 # Number of storms for short simulation that plots hydrologic parameters
6600
n_long_DEM:              # Number of storms for long simulation that operates on single grid for sloped surface
1320
n_long_flat:             # Number of storms for long simulation that operates on two grids - flat surface
660000

## Initial Plant Functional Types (PFT) distribution
percent_bare_initial:   # Initial percentage of cells occupied by bare soil
0.7
percent_grass_initial:  # Initial percentage of cells occupied by grass
0.1
percent_shrub_initial:  # Initial percentage of cells occupied by shrubs
0.1
percent_tree_initial:   # Initial percentage of cells occupied by trees
0.1

## Precipitation:

# Dry Season
mean_storm_dry:          # Mean storm duration (hours)
2.016
mean_interstorm_dry:     # Mean interstorm duration (hours)
159.36
mean_storm_depth_dry:    # Mean storm depth (mm)
3.07
# Wet Season
mean_storm_wet:          # Mean storm duration (hours)
1.896
mean_interstorm_wet:     # Mean interstorm duration (hours)
84.24
mean_storm_depth_wet:    # Mean storm depth (mm)
4.79
doy__start_of_monsoon:   # Day of the year when the monsoon starts
182
doy__end_of_monsoon:     # Day of the year when the monsoon ends
273

## PotentialEvapotranspiration:
# Cosine Method
PET_method:
Cosine
LT:                     # Lag between peak TmaxF estimated by cosine method and solar forcing (days)
0
DeltaD:                 # Calibrated difference between
7.
ND:                     # Number of days in the year (days)
365.
MeanTmaxF_grass:        # Mean annual rate of TmaxF (mm/d)
5.15
MeanTmaxF_shrub:        # Mean annual rate of TmaxF (mm/d)
3.77
MeanTmaxF_tree:         # Mean annual rate of TmaxF (mm/d)
4.96

# TmaxF - Estimated maximum evapotranspiration as a function of DOY using Penman Monteith method for historical weather

## Soil Moisture:

runon:                  # Runon from higher elevations (mm)
0.
f_bare:                 # Fraction to partition PET for bare soil (None)
0.7

# Grass

VEGTYPE_grass:          # Integer value to infer Vegetation Type
0
intercept_cap_grass:    # Full canopy interception capacity  (mm)
1.
zr_grass:               # Root depth (m)
0.3
I_B_grass:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_grass:              # Infiltration capacity of vegetated soil (mm/h)
24.
pc_grass:               # Soil porosity (None)
0.43
fc_grass:               # Soil saturation degree at field capacity (None)
0.56
sc_grass:               # Soil saturation degree at stomatal closure (None)
0.33
wp_grass:               # Soil saturation degree at wilting point (None)
0.13
hgw_grass:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_grass:             # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Shrub

VEGTYPE_shrub:          # Integer value to infer Vegetation Type
1
intercept_cap_shrub:    # Full canopy interception capacity  (mm)
1.5
zr_shrub:               # Root depth (m)
0.5
I_B_shrub:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_shrub:              # Infiltration capacity of vegetated soil (mm/h)
40.
pc_shrub:               # Soil porosity (None)
0.43
fc_shrub:               # Soil saturation degree at field capacity (None)
0.56
sc_shrub:               # Soil saturation degree at stomatal closure (None)
0.24
wp_shrub:               # Soil saturation degree at wilting point (None)
0.13
hgw_shrub:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_shrub:             # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Tree

VEGTYPE_tree:           # Integer value to infer Vegetation Type
2
intercept_cap_tree:     # Full canopy interception capacity  (mm)
2.
zr_tree:                # Root depth (m)
1.3
I_B_tree:               # Infiltration capacity of bare soil (mm/h)
20.
I_V_tree:               # Infiltration capacity of vegetated soil (mm/h)
40.
pc_tree:                # Soil porosity (None)
0.43
fc_tree:                # Soil saturation degree at field capacity (None)
0.56
sc_tree:                # Soil saturation degree at stomatal closure (None)
0.22
wp_tree:                # Soil saturation degree at wilting point (None)
0.15
hgw_tree:               # Soil saturation degree at hygroscopic point (None)
0.1
beta_tree:              # Deep percolation constant = 2*b+4  where b is water retention parameter
13.8

# Bare Soil

VEGTYPE_bare:          # Integer value to infer Vegetation Type
3
intercept_cap_bare:    # Full canopy interception capacity  (mm)
1.
zr_bare:               # Root depth (m)
0.15
I_B_bare:              # Infiltration capacity of bare soil (mm/h)
20.
I_V_bare:              # Infiltration capacity of vegetated soil (mm/h)
20.
pc_bare:               # Soil porosity (None)
0.43
fc_bare:               # Soil saturation degree at field capacity (None)
0.56
sc_bare:               # Soil saturation degree at stomatal closure (None)
0.33
wp_bare:               # Soil saturation degree at wilting point (None)
0.13
hgw_bare:              # Soil saturation degree at hygroscopic point (None)
0.1
beta_bare:             # Deep percolation constant
13.8


## Vegetation Dynamics:

Blive_init:
102.
Bdead_init:
450.
PET_growth_threshold:    # PET threshold for growing season (mm/d)
3.8
PET_dormancy_threshold:  # PET threshold for dormant season (mm/d)
6.8
Tdmax:					# Constant for dead biomass loss adjustment (mm/d)
10.
w:						# Conversion factor of CO2 to dry biomass (Kg DM/Kg CO2)
0.55

# Grass

WUE_grass:              # Water use efficiency KgCO2Kg-1H2O
0.01
cb_grass:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.0047
cd_grass:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.009
ksg_grass:              # Senescence coefficient of green/live biomass (d-1)
0.012
kdd_grass:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_grass:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_grass:          # Maximum leaf area index (m2/m2)
2.
LAIR_max_grass:         # Reference leaf area index (m2/m2)
2.88

# Shrub

WUE_shrub:              # Water use efficiency KgCO2Kg-1H2O
0.0025
cb_shrub:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.004
cd_shrub:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.01
ksg_shrub:              # Senescence coefficient of green/live biomass (d-1)
0.002
kdd_shrub:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_shrub:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_shrub:          # Maximum leaf area index (m2/m2)
2.
LAIR_max_shrub:         # Reference leaf area index (m2/m2)
2.

# Tree

WUE_tree:               # Water use efficiency KgCO2Kg-1H2O
0.0045
cb_tree:                # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.004
cd_tree:                # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.01
ksg_tree:               # Senescence coefficient of green/live biomass (d-1)
0.002
kdd_tree:               # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_tree:               # Maximum drought induced foliage loss rate (d-1)
0.01
LAI_max_tree:          # Maximum leaf area index (m2/m2)
4.
LAIR_max_tree:          # Reference leaf area index (m2/m2)
4.

# Bare

WUE_bare:              # Water use efficiency KgCO2Kg-1H2O
0.01
cb_bare:               # Specific leaf area for green/live biomass (m2 leaf g-1 DM)
0.0047
cd_bare:               # Specific leaf area for dead biomass (m2 leaf g-1 DM)
0.009
ksg_bare:              # Senescence coefficient of green/live biomass (d-1)
0.012
kdd_bare:              # Decay coefficient of aboveground dead biomass (d-1)
0.013
kws_bare:              # Maximum drought induced foliage loss rate (d-1)
0.02
LAI_max_bare:          # Maximum leaf area index (m2/m2)
0.01
LAIR_max_bare:         # Reference leaf area index (m2/m2)
0.01


## Cellular Automaton Vegetation:

# Grass

Pemaxg:                 # Maximal establishment probability
0.35
ING:                    # Parameter to define allelopathic effect on grass from cresotebush
2
ThetaGrass:             # Drought resistant threshold
0.62
PmbGrass:               # Background mortality probability
0.05

# Shrub

Pemaxsh:                # Maximal establishment probability
0.2
ThetaShrub:             # Drought resistant threshold
0.75
PmbShrub:               # Background mortality probability
0.03
tpmaxShrub:             # Maximum age (yr)
600

# Tree

Pemaxtr:                # Maximal establishment probability
0.3
ThetaTree:              # Drought resistant threshold
0.75
PmbTree:                # Background mortality probability
0.01
tpmaxTree:              # Maximum age (yr)
350

# ShrubSeedling

ThetaShrubSeedling:     # Drought resistant threshold
0.64
PmbShrubSeedling:       # Background mortality probability
0.03
tpmaxShrubSeedling:     # Maximum age (yr)
18

# TreeSeedling

ThetaTreeSeedling:      # Drought resistant threshold
0.64
PmbTreeSeedling:        # Background mortality probability
0.03
tpmaxTreeSeedling:      # Maximum age (yr)
18



================================================
File: docs/source/tutorials/ecohydrology/cellular_automaton_vegetation_flat_surface/cellular_automaton_vegetation_flat_domain.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
WARNING: This tutorial has not been updated to work with Landlab 2.0 and is thus not tested to verify that it will run. 

# Tutorial For Cellular Automaton Vegetation Model Coupled With Ecohydrologic Model
"""

"""
This tutorial demonstrates implementation of the Cellular Automaton Tree-GRass-Shrub Simulator (CATGRaSS) [Zhou et al., 2013] on a flat domain. This model is built using components from the Landlab component library. CATGRaSS is spatially explicit model of plant coexistence. It simulates local ecohydrologic dynamics (soil moisture, transpiration, biomass) and spatial evolution of tree, grass, and shrub Plant Functional Types (PFT) driven by rainfall and solar radiation. 

Each cell in the model grid can hold a single PFT or remain empty. Tree and shrub plants disperse seeds to their neighbors. Grass seeds are assumed to be available at each cell. Establishment of plants in empty cells is determined probabilistically based on water stress of each PFT. Plants with lower water stress have higher probability of establishment. Plant mortality is simulated probabilistically as a result of aging and drought stress. Fires and grazing will be added to this model soon.  

This model (driver) contains:
  - A local vegetation dynamics model that simulates storm and inter-storm water balance and ecohydrologic fluxes (ET, runoff), and plant biomass dynamics by coupling the following components:
        - PrecipitationDistribution
        - Radiation
        - PotentialEvapotranspiration
        - SoilMoisture
        - Vegetation

  - A spatially explicit probabilistic cellular automaton component that simulates plant competition by tracking establishment and mortality of plants based on soil moisture stress:
        - VegCA
    
To run this Jupyter notebook, please make sure that the following files are in the same folder:
        - cellular_automaton_vegetation_flat_domain.ipynb (this notebook)
        - Inputs_Vegetation_CA.txt (Input parameters for the model)
        - Ecohyd_functions_flat.py (Utility functions)

[Ref: Zhou, X, E. Istanbulluoglu, and E.R. Vivoni. "Modeling the ecohydrological role of aspect-controlled radiation on tree-grass-shrub coexistence in a semiarid climate." Water Resources Research 49.5 (2013): 2872-2895]

"""

"""
In this tutorial, we are going to work with a landscape in central New Mexico, USA, where aspect controls the organization of PFTs. The climate in this area is semi-arid with Mean Annual Precipitation (MAP) of 254 mm [Zhou et. al 2013]. 
We will do the following: 
- Import a landscape 
- Initialize the landscape with random distribution of PFTs
- Run the coupled Ecohydrology and cellular automata plant competition model for 50 years
- Visualize and examine outputs
"""

"""
## Let us walk through the code:
"""

"""
Import the required libraries
"""

%matplotlib inline

import time

import numpy as np
from Ecohyd_functions_flat import Create_PET_lookup, Empty_arrays, Initialize_, Plot_

from landlab import RasterModelGrid as rmg, load_params

"""
Note: 'Ecohyd_functions_flat.py' is a utility script that contains 'functions', which instantiates components and manages inputs and outputs, and help keep this driver concise. Contents of 'Ecohyd_functions_flat.py' can be a part of this driver (current file), however left out to keep driver concise.
"""

"""
To minimize computation time, we will use two grids in this driver. One grid will represent a flat landscape or domain (i.e., landscape with same elevation), on which the cellular automata plant competition will be simulated at an yearly time step. Another grid, with enough cells to house one cell for each of the plant functional types (PFTs), will be used to simulate soil moisture decay and local vegetation dynamics, in between successive storms (i.e. time step = one storm). Cumulative water stress (stress experienced by plants due to lack of enough soil moisture) will be calculated over an year and mapped to the other grid.

- grid: This grid represents the actual landscape. Each cell can be occupied by a single PFT such as tree, shrub, grass, or can be empty (bare). Initial PFT distribution is randomnly generated from inputs of percentage of cells occupied by each PFT.

- grid1: This grid allows us to calculate PFT specific cumulative water stress (cumulated over each storm in the year) and mapped with 'grid'.

Note: In this tutorial, the physical ecohydrological components and cellular automata plant competition will be run on grids with different resolution. To use grids with same resolution, see the tutorial 'cellular_automaton_vegetation_DEM.ipynb'.
"""

grid1 = rmg((100, 100), spacing=(5.0, 5.0))
grid = rmg((5, 4), spacing=(5.0, 5.0))

"""
Include the input file that contains all input parameters needed for all components. This file can either be a python dictionary or a text file that can be converted into a python dictionary. If a text file is provided, it will be converted to a Python dictionary. Here we use an existing text file prepared for this exercise.
"""

InputFile = "Inputs_Vegetation_CA_flat.txt"
data = load_params(InputFile)  # Create dictionary that holds the inputs

"""
Instantiate landlab components to simulate corresponding attributes. In this example, we shall demonstrate the use of seasonal rainfall and PFT-specific potential evapotranspiration. The instantiated objects are:
- PD_D: object for dry season rainfall, 
- PD_W: object for wet season rainfall, 
- Rad: Radiation object computes radiation factor defined as the ratio of total shortwave radiation incident on a sloped surface to total shortwave radiation incident on a flat surface. Note: in this example a flat domain is considered. Radiation factor returned will be a cellular field of ones. This component is included because potential evaporanspiration (PET) component receives an input of radiation factor as a field.
- PET_PFT: Plant specific PET objects. PET is upper boundary to ET. For long-term simulations PET is represented using a cosine function as a function of day of year. Parameters of this function were obtained from P-M model application at a weather station. PET is spatially distributed by using the radiation factor.
- SM: Soil Moisture object simulates depth-averaged soil moisture at each cell using inputs of potential evapotranspiration, live leaf area index and vegetation cover.
- VEG: Vegetation dynamics object simulates net primary productivity, biomass and leaf area index (LAI) at each cell based on inputs of root-zone average soil moisture.
- vegca: Cellular Automaton plant competition object is run once every year. This object is initialized with a random cellular field of PFT. Every year, this object updates the cellular field of PFT based on probabilistic establishment and mortality of PFT at each cell.

Note: Almost every component in landlab is coded as a 'class' (to harness the advantages of objective oriented programming). An 'object' is the instantiation of the 'class' (for more information, please refer any objective oriented programming book). A 'field' refers to a Landlab field (please refer to the [Landlab documentation](https://landlab.csdms.io/user_guide/grid.html#adding-data-to-a-landlab-grid-element-using-fields) to learn more about Landlab fields).
"""

"""
Now let's instantiate all Landlab components that we are going to use for this tutorial:
"""

PD_D, PD_W, Rad, PET_Tree, PET_Shrub, PET_Grass, SM, VEG, vegca = Initialize_(
    data, grid, grid1
)

"""
Lets look at the initial organization of PFTs
"""

import matplotlib as mpl
import matplotlib.pyplot as plt

cmap = mpl.colors.ListedColormap(["green", "red", "black", "white", "red", "black"])
bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
description = "green: grass; red: shrub; black: tree; white: bare"
plt.figure(101)
grid1.imshow(
    "vegetation__plant_functional_type",
    at="cell",
    cmap=cmap,
    grid_units=("m", "m"),
    norm=norm,
    limits=[0, 5],
    allow_colorbar=False,
)
plt.figtext(0.2, 0.0, description, weight="bold", fontsize=10)

"""
Specify an approximate number of years for the model to run. For this example, we will run the simulation for 600 years. It might take less than 2+ minutes to run.
"""

n_years = 600  # Approx number of years for model to run
# Calculate approximate number of storms per year
fraction_wet = (data["doy__end_of_monsoon"] - data["doy__start_of_monsoon"]) / 365.0
fraction_dry = 1 - fraction_wet
no_of_storms_wet = (
    8760 * (fraction_wet) / (data["mean_interstorm_wet"] + data["mean_storm_wet"])
)
no_of_storms_dry = (
    8760 * (fraction_dry) / (data["mean_interstorm_dry"] + data["mean_storm_dry"])
)
n = int(n_years * (no_of_storms_wet + no_of_storms_dry))

"""
Create empty arrays to store spatio-temporal data over multiple iterations. The captured data can be used for plotting model outputs.
"""

P, Tb, Tr, Time, VegType, PET_, Rad_Factor, EP30, PET_threshold = Empty_arrays(
    n, grid, grid1
)

"""
To reduce computational overhead, we shall create a lookup array for plant-specific PET values for each day of the year.
"""

Create_PET_lookup(Rad, PET_Tree, PET_Shrub, PET_Grass, PET_, Rad_Factor, EP30, grid)

"""
Specify current_time (in years). current_time is the current time in the simulation.
"""

# # Represent current time in years
current_time = 0  # Start from first day of Jan

# Keep track of run time for simulation - optional
Start_time = time.clock()  # Recording time taken for simulation

# declaring few variables that will be used in the storm loop
time_check = 0.0  # Buffer to store current_time at previous storm
yrs = 0  # Keep track of number of years passed
WS = 0.0  # Buffer for Water Stress
Tg = 270  # Growing season in days

"""
The loop below couples the components introduced above in a for loop until all "n" number of storms are generated. Time is advanced by the soil moisture object based on storm and interstorm durations that are estimated by the strom generator object. The ecohydrologic model is run each storm whereas cellular automaton vegetation component is run once every year.

Note: This loop might take less than 2 minutes (depending on your computer) to run for 600 year simulation. Ignore any warnings you might see.
"""

# # Run storm Loop
for i in range(0, n):
    # Update objects

    # Calculate Day of Year (DOY)
    Julian = int(np.floor((current_time - np.floor(current_time)) * 365.0))

    # Generate seasonal storms
    # for Dry season
    if Julian < data["doy__start_of_monsoon"] or Julian > data["doy__end_of_monsoon"]:
        PD_D.update()
        P[i] = PD_D.storm_depth
        Tr[i] = PD_D.storm_duration
        Tb[i] = PD_D.interstorm_duration
    # Wet Season - Jul to Sep - NA Monsoon
    else:
        PD_W.update()
        P[i] = PD_W.storm_depth
        Tr[i] = PD_W.storm_duration
        Tb[i] = PD_W.interstorm_duration

    # Spatially distribute PET and its 30-day-mean (analogous to degree day)
    grid["cell"]["surface__potential_evapotranspiration_rate"] = PET_[Julian]
    grid["cell"]["surface__potential_evapotranspiration_30day_mean"] = EP30[Julian]

    # Assign spatial rainfall data
    grid["cell"]["rainfall__daily_depth"] = P[i] * np.ones(grid.number_of_cells)

    # Update soil moisture component
    current_time = SM.update(current_time, Tr=Tr[i], Tb=Tb[i])

    # Decide whether its growing season or not
    if Julian != 364:
        if EP30[Julian + 1, 0] > EP30[Julian, 0]:
            PET_threshold = 1
            # 1 corresponds to ETThresholdup (begin growing season)
        else:
            PET_threshold = 0
            # 0 corresponds to ETThresholddown (end growing season)

    # Update vegetation component
    VEG.update(PETThreshold_switch=PET_threshold, Tb=Tb[i], Tr=Tr[i])

    # Update yearly cumulative water stress data
    WS += (grid["cell"]["vegetation__water_stress"]) * Tb[i] / 24.0

    # Record time (optional)
    Time[i] = current_time

    # Update spatial PFTs with Cellular Automata rules
    if (current_time - time_check) >= 1.0:
        if yrs % 100 == 0:
            print(f"Elapsed time = {yrs} years")
        VegType[yrs] = grid1["cell"]["vegetation__plant_functional_type"]
        WS_ = np.choose(VegType[yrs], WS)
        grid1["cell"]["vegetation__cumulative_water_stress"] = WS_ / Tg
        vegca.update()
        time_check = current_time
        WS = 0
        yrs += 1

VegType[yrs] = grid1["cell"]["vegetation__plant_functional_type"]

"""
Time_Consumed is an optional variable that gives information about computer running time
"""

Final_time = time.clock()
Time_Consumed = (Final_time - Start_time) / 60.0  # in minutes
print(f"Time_consumed = {Time_Consumed} minutes")

"""
Save the outputs using ``numpy.save()``. These files have '.nc' extension, which can be loaded using ``numpy.load()``.
"""

# # Saving
sim = "Sim_26Jul16_"
# Save_(sim, Tb, Tr, P, VegType, yrs, Time_Consumed, Time)

"""
Let's look at outputs.

Plots of the cellular field of PFT at specified year step can be found below where:

GRASS = green;  SHRUB = red;  TREE = black;  BARE = white;  

At the end, percentage cover of each PFT is plotted with respect to time.
"""

Plot_(grid1, VegType, yrs, yr_step=100)

"""
If you want to explore this model further, open 'Inputs_Vegetation_CA.txt' and change the input parameters (e.g., initial PFT distribution percentages, storm characteristics, etc..).
"""



================================================
File: docs/source/tutorials/fault_scarp/landlab-fault-scarp.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to Landlab: Creating a simple 2D scarp diffusion model
"""

"""
This tutorial illustrates how you can use Landlab to construct a simple two-dimensional numerical model on a regular (raster) grid, using a simple forward-time, centered-space numerical scheme. The example is the erosional degradation of an earthquake fault scarp, and which evolves over time in response to the gradual downhill motion of soil. Here we use a simple "geomorphic diffusion" model for landform evolution, in which the downhill flow of soil is assumed to be proportional to the (downhill) gradient of the land surface multiplied by a transport coefficient.

We start by importing the [numpy](https://numpy.org) and [matplotlib](https://matplotlib.org) libraries:
"""

import matplotlib.pyplot as plt
import numpy as np

%matplotlib inline

"""
## Part 1: 1D version using numpy

This example uses a finite-volume numerical solution to the 2D diffusion equation. The 2D diffusion equation in this case is derived as follows. Continuity of mass states that:

$\frac{\partial z}{\partial t} = -\nabla \cdot \mathbf{q}_s$,

where $z$ is elevation, $t$ is time, the vector $\mathbf{q}_s$ is the volumetric soil transport rate per unit width, and $\nabla$ is the divergence operator (here in two dimensions). (Note that we have omitted a porosity factor here; its effect will be subsumed in the transport coefficient). The sediment flux vector depends on the slope gradient:

$\mathbf{q}_s = -D \nabla z$,

where $D$ is a transport-rate coefficient---sometimes called *hillslope diffusivity*---with dimensions of length squared per time. Combining the two, and assuming $D$ is uniform, we have a classical 2D diffusion equation:

$\frac{\partial z}{\partial t} = -\nabla^2 z$.

In this first example, we will create a our 1D domain in $x$ and $z$, and set a value for $D$.

This means that the equation we solve will be in 1D. 

$\frac{d z}{d t} = \frac{d q_s}{dx}$,

where 

$q_s = -D \frac{d z}{dx}$

"""

dx = 1
x = np.arange(0, 100, dx, dtype=float)
z = np.zeros(x.shape, dtype=float)
D = 0.01

"""
Next we must create our fault by uplifting some of the domain. We will increment all elements of `z` in which `x>50`.
"""

z[x > 50] += 100

"""
Finally, we will diffuse our fault for 1,000 years.

We will use a timestep with a [Courant–Friedrichs–Lewy condition](https://en.wikipedia.org/wiki/Courant–Friedrichs–Lewy_condition) of $C_{cfl}=0.2$. This will keep our solution numerically stable. 

$C_{cfl} = \frac{\Delta t D}{\Delta x^2} = 0.2$
"""

dt = 0.2 * dx * dx / D
total_time = 1e3
nts = int(total_time / dt)
z_orig = z.copy()
for i in range(nts):
    qs = -D * np.diff(z) / dx
    dzdt = -np.diff(qs) / dx
    z[1:-1] += dzdt * dt

plt.plot(x, z_orig, label="Original Profile")
plt.plot(x, z, label="Diffused Profile")
plt.legend()

"""
The prior example is pretty simple. If this was all you needed to do, you wouldn't need Landlab. 

But what if you wanted...

... to use the same diffusion model in 2D instead of 1D.

... to use an irregular grid (in 1 or 2D). 

... wanted to combine the diffusion model with a more complex model. 

... have a more complex model you want to use over and over again with different boundary conditions.

These are the sorts of problems that Landlab was designed to solve. 

In the next two sections we will introduce some of the core capabilities of Landlab. 

In Part 2 we will use the RasterModelGrid, fields, and a numerical utility for calculating flux divergence. 

In Part 3 we will use the HexagonalModelGrid. 

In Part 4 we will use the LinearDiffuser component. 

## Part 2: 2D version using Landlab's Model Grids

The Landlab model grids are data structures that represent the model domain (the variable `x` in our prior example). Here we will use `RasterModelGrid` which creates a grid with regularly spaced square grid elements. The RasterModelGrid knows how the elements are connected and how far apart they are.

Lets start by creating a RasterModelGrid class. First we need to import it. 
"""

from landlab import RasterModelGrid

"""

### (a) Explore the RasterModelGrid

Before we make a RasterModelGrid for our fault example, lets explore the Landlab model grid. 

Landlab considers the grid as a "dual" graph. Two sets of points, lines and polygons that represent 2D space. 

The first graph considers points called "nodes" that are connected by lines called "links". The area that surrounds each node is called a "cell".

First, the nodes
"""

from landlab.plot.graph import plot_graph

grid = RasterModelGrid((4, 5), xy_spacing=(3, 4))
plot_graph(grid, at="node")

"""
You can see that the nodes are points and they are numbered with unique IDs from lower left to upper right. 

Next the links
"""

plot_graph(grid, at="link")

"""
which are lines that connect the nodes and each have a unique ID number. 

And finally, the cells
"""

plot_graph(grid, at="cell")

"""
which are polygons centered around the nodes. 

Landlab is a "dual" graph because it also keeps track of a second set of points, lines, and polygons ("corners", "faces", and "patches"). We will not focus on them further.

### (b) Use the RasterModelGrid for 2D diffusion 

Lets continue by making a new grid that is bigger. We will use this for our next fault diffusion example.

The syntax in the next line says: create a new *RasterModelGrid* object called **mg**, with 25 rows, 40 columns, and a grid spacing of 10 m.
"""

mg = RasterModelGrid((25, 40), 10.0)

"""
Note the use of object-oriented programming here. `RasterModelGrid` is a class; `mg` is a particular instance of that class, and it contains all the data necessary to fully describe the topology and geometry of this particular grid.

Next we'll add a *data field* to the grid, to represent the elevation values at grid nodes. The "dot" syntax below indicates that we are calling a function (or *method*) that belongs to the *RasterModelGrid* class, and will act on data contained in **mg**. The arguments indicate that we want the data elements attached to grid nodes (rather than links, for example), and that we want to name this data field `topographic__elevation`. The `add_zeros` method returns the newly created NumPy array.
"""

z = mg.add_zeros("topographic__elevation", at="node")

"""
The above line of code creates space in memory to store 1,000 floating-point values, which will represent the elevation of the land surface at each of our 1,000 grid nodes.
"""

"""
Let's plot the positions of all the grid nodes. The nodes' *(x,y)* positions are stored in the arrays `mg.x_of_node` and `mg.y_of_node`, respectively.
"""

plt.plot(mg.x_of_node, mg.y_of_node, ".")

"""
If we bothered to count, we'd see that there are indeed 1,000 grid nodes, and a corresponding number of `z` values:
"""

len(z)

"""
Now for some tectonics. Let's say there's a fault trace that angles roughly east-northeast. We can describe the trace with the equation for a line. One trick here: by using `mg.x_of_node`, in the line of code below, we are calculating a *y* (i.e., north-south) position of the fault trace for each grid node---meaning that this is the *y* coordinate of the trace at the *x* coordinate of a given node.
"""

fault_trace_y = 50.0 + 0.25 * mg.x_of_node

"""
Here comes the earthquake. For all the nodes north of the fault (i.e., those with a *y* coordinate greater than the corresponding *y* coordinate of the fault trace), we'll add elevation equal to 10 meters plus a centimeter for every meter east along the grid (just to make it interesting):
"""

z[mg.y_of_node > fault_trace_y] += (
    10.0 + 0.01 * mg.x_of_node[mg.y_of_node > fault_trace_y]
)

"""
(A little bit of Python under the hood: the statement `mg.y_of_node > fault_trace_y` creates a 1000-element long boolean array; placing this within the index brackets will select only those array entries that correspond to `True` in the boolean array)

Let's look at our newly created initial topography using Landlab's *imshow_node_grid* plotting function (which we first need to import).
"""

from landlab.plot.imshow import imshow_grid

imshow_grid(mg, "topographic__elevation")

"""
To finish getting set up, we will define two parameters: the transport ("diffusivity") coefficient, `D`, and the time-step size, `dt`. (The latter is set using the Courant condition for a forward-time, centered-space finite-difference solution; you can find the explanation in most textbooks on numerical methods).
"""

D = 0.01  # m2/yr transport coefficient
dt = 0.2 * mg.dx * mg.dx / D
dt

"""
Boundary conditions: for this example, we'll assume that the east and west sides are closed to flow of sediment, but that the north and south sides are open. (The order of the function arguments is east, north, west, south)
"""

mg.set_closed_boundaries_at_grid_edges(True, False, True, False)

"""
*A note on boundaries:* with a Landlab raster grid, all the perimeter nodes are boundary nodes. In this example, there are 24 + 24 + 39 + 39 = 126 boundary nodes. The previous line of code set those on the east and west edges to be **closed boundaries**, while those on the north and south are **open boundaries** (the default). All the remaining nodes are known as **core** nodes. In this example, there are 1000 - 126 = 874 core nodes:
"""

len(mg.core_nodes)

"""
One more thing before we run the time loop: we'll create an array to contain soil flux. In the function call below, the first argument tells Landlab that we want one value for each grid link, while the second argument provides a name for this data *field*:
"""

qs = mg.add_zeros("sediment_flux", at="link")

"""
And now for some landform evolution. We will loop through 25 iterations, representing 50,000 years. On each pass through the loop, we do the following:

1. Calculate, and store in the array `g`, the gradient between each neighboring pair of nodes. These calculations are done on **links**. The gradient value is a positive number when the gradient is "uphill" in the direction of the link, and negative when the gradient is "downhill" in the direction of the link. On a raster grid, link directions are always in the direction of increasing $x$ ("horizontal" links) or increasing $y$ ("vertical" links).

2. Calculate, and store in the array `qs`, the sediment flux between each adjacent pair of nodes by multiplying their gradient by the transport coefficient. We will only do this for the **active links** (those not connected to a closed boundary, and not connecting two boundary nodes of any type); others will remain as zero.

3. Calculate the resulting net flux at each node (positive=net outflux, negative=net influx). The negative of this array is the rate of change of elevation at each (core) node, so store it in a node array called `dzdt'.

4. Update the elevations for the new time step.
"""

for i in range(25):
    g = mg.calc_grad_at_link(z)
    qs[mg.active_links] = -D * g[mg.active_links]
    dzdt = -mg.calc_flux_div_at_node(qs)
    z[mg.core_nodes] += dzdt[mg.core_nodes] * dt

"""
Let's look at how our fault scarp has evolved.
"""

imshow_grid(mg, "topographic__elevation")

"""
Notice that we have just created and run a 2D model of fault-scarp creation and diffusion with fewer than two dozen lines of code. How long would this have taken to write in C or Fortran?

While it was very very easy to write in 1D, writing this in 2D would mean we would have needed to keep track of the adjacency of the different parts of the grid. This is the primary problem that the Landlab grids are meant to solve. 

Think about how difficult this would be to hand code if the grid were irregular or hexagonal. In order to conserve mass and implement the differential equation you would need to know how nodes were conected, how long the links were, and how big each cell was.

We do such an example after the next section. 
"""

"""
### (c) What's going on under the hood?

This example uses a finite-volume numerical solution to the 2D diffusion equation. The 2D diffusion equation in this case is derived as follows. Continuity of mass states that:

$\frac{\partial z}{\partial t} = -\nabla \cdot \mathbf{q}_s$,

where $z$ is elevation, $t$ is time, the vector $\mathbf{q}_s$ is the volumetric soil transport rate per unit width, and $\nabla$ is the divergence operator (here in two dimensions). (Note that we have omitted a porosity factor here; its effect will be subsumed in the transport coefficient). The sediment flux vector depends on the slope gradient:

$\mathbf{q}_s = -D \nabla z$,

where $D$ is a transport-rate coefficient---sometimes called *hillslope diffusivity*---with dimensions of length squared per time. Combining the two, and assuming $D$ is uniform, we have a classical 2D diffusion equation:

$\frac{\partial z}{\partial t} = -\nabla^2 z$.

For the numerical solution, we discretize $z$ at a series of *nodes* on a grid. The example in this notebook uses a Landlab *RasterModelGrid*, in which every interior node sits inside a cell of width $\Delta x$, but we could alternatively have used any grid type that provides nodes, links, and cells.

The gradient and sediment flux vectors will be calculated at the *links* that connect each pair of adjacent nodes. These links correspond to the mid-points of the cell faces, and the values that we assign to links represent the gradients and fluxes, respectively, along the faces of the cells.

The flux divergence, $\nabla \mathbf{q}_s$, will be calculated by summing, for every cell, the total volume inflows and outflows at each cell face, and dividing the resulting sum by the cell area. Note that for a regular, rectilinear grid, as we use in this example, this finite-volume method is equivalent to a finite-difference method.

To advance the solution in time, we will use a simple explicit, forward-difference method. This solution scheme for a given node $i$ can be written:

$\frac{z_i^{t+1} - z_i^t}{\Delta t} = -\frac{1}{A_i} \sum\limits_{j=1}^{N_i} \delta (l_{ij}) q_s (l_{ij}) \lambda(l_{ij})$.

Here the superscripts refer to time steps, $\Delta t$ is time-step size, $q_s(l_{ij})$ is the sediment flux per width associated with the link that crosses the $j$-th face of the cell at node $i$, $\lambda(l_{ij})$ is the width of the cell face associated with that link ($=\Delta x$ for a regular uniform grid), and $N_i$ is the number of active links that connect to node $i$. The variable $\delta(l_{ij})$ contains either +1 or -1: it is +1 if link $l_{ij}$ is oriented away from the node (in which case positive flux would represent material leaving its cell), or -1 if instead the link "points" into the cell (in which case positive flux means material is entering).

To get the fluxes, we first calculate the *gradient*, $G$, at each link, $k$:

$G(k) = \frac{z(H_k) - z(T_k)}{L_k}$.

Here $H_k$ refers the *head node* associated with link $k$, $T_k$ is the *tail node* associated with link $k$. Each link has a direction: from the tail node to the head node. The length of link $k$ is $L_k$ (equal to $\Delta x$ is a regular uniform grid). What the above equation says is that the gradient in $z$ associated with each link is simply the difference in $z$ value between its two endpoint nodes, divided by the distance between them. The gradient is positive when the value at the head node (the "tip" of the link) is greater than the value at the tail node, and vice versa.

The calculation of gradients in $z$ at the links is accomplished with the `calc_grad_at_link` function. The sediment fluxes are then calculated by multiplying the link gradients by $-D$. Once the fluxes at links have been established, the `calc_flux_div_at_node` function performs the summation of fluxes.

## Part 3: Hexagonal grid

Next we will use an non-raster Landlab grid.

We start by making a random set of points with x values between 0 and 400 and y values of 0 and 250. We then add zeros to our grid at a field called "topographic__elevation" and plot the node locations. 

Note that the syntax here is exactly the same as in the RasterModelGrid example (once the grid has been created).
"""

from landlab import HexModelGrid

mg = HexModelGrid((25, 40), 10, node_layout="rect")
z = mg.add_zeros("topographic__elevation", at="node")
plt.plot(mg.x_of_node, mg.y_of_node, ".")

"""
Next we create our fault trace and uplift the hanging wall. 

We can plot just like we did with the RasterModelGrid. 
"""

fault_trace_y = 50.0 + 0.25 * mg.x_of_node
z[mg.y_of_node > fault_trace_y] += (
    10.0 + 0.01 * mg.x_of_node[mg.y_of_node > fault_trace_y]
)
imshow_grid(mg, "topographic__elevation")

"""
And we can use the same code as before to create a diffusion model!

Landlab supports multiple grid types. You can read more about them [here](https://landlab.csdms.io/user_guide/grid.html).
"""

qs = mg.add_zeros("sediment_flux", at="link")
for i in range(25):
    g = mg.calc_grad_at_link(z)
    qs[mg.active_links] = -D * g[mg.active_links]
    dzdt = -mg.calc_flux_div_at_node(qs)
    z[mg.core_nodes] += dzdt[mg.core_nodes] * dt
imshow_grid(mg, "topographic__elevation")

"""
## Part 3: Landlab Components

Finally we will use a Landlab component, called the LinearDiffuser [link to its documentation](https://landlab.csdms.io/generated/api/landlab.components.diffusion.diffusion.html).

Landlab was designed to have many of the utilities like `calc_grad_at_link`, and `calc_flux_divergence_at_node` to help you make your own models. Sometimes, however, you may use such a model over and over and over. Then it is nice to be able to put it in its own python class with a standard interface. 

This is what a Landlab Component is. 

There is a whole [tutorial on components](../component_tutorial/component_tutorial.ipynb) and a [page on the User Guide](https://landlab.csdms.io/user_guide/components.html). For now we will just show you what the prior example looks like if we use the LinearDiffuser. 

First we import it, set up the grid, and uplift our fault block. 
"""

from landlab.components import LinearDiffuser

mg = HexModelGrid((25, 40), 10, node_layout="rect")
z = mg.add_zeros("topographic__elevation", at="node")
fault_trace_y = 50.0 + 0.25 * mg.x_of_node
z[mg.y_of_node > fault_trace_y] += (
    10.0 + 0.01 * mg.x_of_node[mg.y_of_node > fault_trace_y]
)

"""
Next we instantiate a LinearDiffuser. We have to tell the component what value to use for the diffusivity. 
"""

ld = LinearDiffuser(mg, linear_diffusivity=D)

"""
Finally we run the component forward in time and plot. Like many Landlab components, the LinearDiffuser has a method called "run_one_step" that takes one input, the timestep dt. Calling this method runs the LinearDiffuser forward in time by an increment dt. 
"""

for i in range(25):
    ld.run_one_step(dt)
imshow_grid(mg, "topographic__elevation")



================================================
File: docs/source/tutorials/fields/working_with_fields.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Understanding and working with Landlab data fields
"""

"""
Data fields, or just fields for short, are the primary way that components share model data amongst themselves. This tutorial gives a short introduction to what fields are, what they do, and how to work with them.

Let's start by importing the modules we'll need for this tutorial, and instantiating a simple grid to work with for the first part of the tutorial:
"""

import numpy as np

from landlab import FieldError, RasterModelGrid

mg = RasterModelGrid((3, 4))

"""
A discussed in the grid tutorial, all data stored on the grid exists as "flat" one-dimensional arrays. This means that information can be retrieved from these grids using the ID of an grid element as the index:
"""

# demonstrate that arrays of properties are n-elements long
(
    mg.x_of_node.shape == (mg.number_of_nodes,)
    and mg.length_of_link.shape == (mg.number_of_links,)
)

# what's the length of the link with ID 6 (the 7th link)?
mg.length_of_link[6]

"""
Any values we defined across the grid are indexed in the same way, e.g., an array of elevations would be of shape (n-nodes, ).

A Landlab field, then, is simply an array like this explicitly linked to an element type, and stored within the grid object itself. Doing this serves four main purposes:

1. It means that if a component has access to the grid, it also has access to all the data defined on the grid.
2. It allows us to enforce the idea that an array of values of nodes is always n-nodes-long, an array on links is always n-links-long, etc.
3. It provides a standardized interface where the nomenclature used by a given component for input-output is both unambiguous and clear, in the spirit of the [CSDMS standard names](https://csdms.colorado.edu/wiki/CSDMS_Standard_Names).
4. The field structure also allows us to bind the measurement unit to the field, if we so wish.

Note that Landlab components generally follow a "CSDMS-like" naming conventiomn, where the name looks like `thing_that_is_described__quantity_described`, with a double underscore in the middle. In cases where the equivalent Standard Name would be excessively long, a shorter alternatively is usually used.


## Making fields on the grid

There are several ways to create a field within the grid. These include functions to create fields filled just with ones or zeros, similar to the numpy functions `np.ones` and `np.zeros`, and functions to create fields from existing value arrays that you want to join to the grid.

The first term supplied is always the element on which the field is defined, i.e., 'node', 'link', 'cell', etc. The second is the name to give the field.

All these creation routines also return a reference to the field. This can be a useful shorthand to get at the grid without having to write out the full field name every time:
"""

no_1a = mg.add_zeros("field__number_one", at="node")
no_1b = mg.add_ones(
    "field__number_two", at="link", dtype=int
)  # fns can also take dtype
no_1b[mg.active_links] = 0
print(no_1b)

"""
All the field creation routines share two optional keywords: `units` and `clobber`. `units` (default: '-') allows a unit to be associated with a field if desired. `clobber` (default: `False`) prevents accidental overwriting of an existing field. If you want to overwrite, set it to `False`.

Let's try creating a field from an existing array here (`grid.add_field()`). In this case, there's an additional keyword `copy` (default = `False`) that controls whether the field refers to the actual first array, or whether a copy of the data is made:
"""

input_array = np.arange(mg.number_of_nodes, dtype=float)

try:
    no_1c = mg.add_field(
        "field__number_one", input_array, at="node", copy=False, units="m"
    )
except FieldError:
    print("ERROR: This field name already exists!")

# ...let's try that again:
no_1c = mg.add_field(
    "field__number_one", input_array, at="node", copy=False, units="m", clobber=True
)
print(no_1c)

# note that the keyword `copy=False` means that the field array *is* the input_array...
input_array[:] = -1.0
print(no_1c)

"""
## Accessing a data field, deleting a data field

We've already seen that the array creation routines return a reference to the field data. But sometimes, you want to access the field directly.

In practical terms, think of the names themselves as nested inside the grid as if the grid itself were a Python dictionary. The element type is the first key, and the field name is the second key.

(In detail, the type is actually a Landlab-specific object called a ScalarDataField, but it behaves essentially as an enhanced Python dictionary).
"""

mg["node"]["field__number_one"]

"""
You'll also very commonly see some common "syntactic sugar" for this, where the element key is replaced by a grid property called `grid.at_[element]`. i.e.,
"""

mg.at_node["field__number_one"] is mg["node"]["field__number_one"]

"""
Because these structures are dictionary-like, we can use the usual set of Python dictionary methods to interact with them too:
"""

mg.at_node.keys()  # see the existing fields at nodes

mg.at_node.clear()  # delete all fields at nodes

mg.at_node.keys()

mg.at_link.keys()

mg.at_link.pop("field__number_two")  # return the field, and remove it from the array

mg.at_link.keys()

"""
The units are recorded in a further dict-like structure attached to `at_[element]`:
"""

z = mg.add_ones("field__number_3", at="node", units="km", clobber=True)
mg.at_node.units["field__number_3"]



================================================
File: docs/source/tutorials/flexure/flexure_1d.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab 1D flexure component

In this example we will:
* create a Landlab component that solves the (1D) flexure equation
* apply a point load
* run the component
* plot some output
* apply a distributed load

(Note that this tutorial uses the one-dimensional flexure component, `Flexure1D`. A separate tutorial notebook, "lots_of_loads", explores the two-dimensional elastic flexure component `Flexure`.)
"""

"""
A bit of magic so that we can plot within this notebook.
"""

# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np

"""
## Create the grid

We are going to build a uniform rectilinear grid with a node spacing of 100 km in the *y*-direction and 10 km in the *x*-direction on which we will solve the flexure equation.

First we need to import *RasterModelGrid*.
"""

from landlab import RasterModelGrid

"""
Create a rectilinear grid with a spacing of 100 km between rows and 10 km between columns. The numbers of rows and columms are provided as a `tuple` of `(n_rows, n_cols)`, in the same manner as similar numpy functions. The spacing is also a `tuple`, `(dy, dx)`.
"""

grid = RasterModelGrid((3, 800), xy_spacing=(100e3, 10e3))

grid.dy, grid.dx

"""
## Create the component
"""

"""
Now we create the flexure component and tell it to use our newly created grid. First, though, we'll examine the Flexure component a bit.
"""

from landlab.components import Flexure1D

"""
The `Flexure1D` component, as with most landlab components, will require our grid to have some data that it will use. We can get the names of these data fields with the `input_var_names` attribute of the component *class*.
"""

Flexure1D.input_var_names

"""
We see that flexure uses just one data field: the change in lithospheric loading. Landlab component classes can provide additional information about each of these fields. For instance, to see the units for a field, use the `var_units` method.
"""

Flexure1D.var_units("lithosphere__increment_of_overlying_pressure")

"""
To print a more detailed description of a field, use `var_help`.
"""

Flexure1D.var_help("lithosphere__increment_of_overlying_pressure")

"""
What about the data that `Flexure1D` provides? Use the `output_var_names` attribute.
"""

Flexure1D.output_var_names

Flexure1D.var_help("lithosphere_surface__increment_of_elevation")

"""
Now that we understand the component a little more, create it using our grid.
"""

grid.add_zeros("lithosphere__increment_of_overlying_pressure", at="node")

flex = Flexure1D(grid, method="flexure")

"""
## Add a point load
"""

"""
First we'll add just a single point load to the grid. We need to call the `update` method of the component to calculate the resulting deflection (if we don't run `update` the deflections would still be all zeros).

Use the `load_at_node` attribute of `Flexure1D` to set the loads. Notice that `load_at_node` has the same shape as the grid. Likewise, `x_at_node` and `dz_at_node` also reshaped.
"""

flex.load_at_node[1, 200] = 1e6
flex.update()
plt.plot(flex.x_at_node[1, :400] / 1000.0, flex.dz_at_node[1, :400])

"""
Before we make any changes, reset the deflections to zero.
"""

flex.dz_at_node[:] = 0.0

"""
Now we will double the effective elastic thickness but keep the same point load. Notice that, as expected, the deflections are more spread out.
"""

flex.eet *= 2.0
flex.update()
plt.plot(flex.x_at_node[1, :400] / 1000.0, flex.dz_at_node[1, :400])

"""
## Add some loading
We will now add a distributed load. As we saw above, for this component, the name of the attribute that holds the applied loads is `load_at_node`. For this example we create a loading that increases linearly of the center portion of the grid until some maximum. This could by thought of as the water load following a sea-level rise over a (linear) continental shelf.
"""

flex.load_at_node[1, :100] = 0.0
flex.load_at_node[1, 100:300] = np.arange(200) * 1e6 / 200.0
flex.load_at_node[1, 300:] = 1e6

plt.plot(flex.load_at_node[1, :400])

"""
## Update the component to solve for deflection
Clear the current deflections, and run `update` to get the new deflections.
"""

flex.dz_at_node[:] = 0.0
flex.update()

plt.plot(flex.x_at_node[1, :400] / 1000.0, flex.dz_at_node[1, :400])

"""
Exercise: try maintaining the same loading distribution but double the effective elastic thickness.
"""



================================================
File: docs/source/tutorials/flexure/lots_of_loads.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab flexure component

In this example we will:
* create a Landlab component that solves the two-dimensional elastic flexure equation
* apply randomly distributed point loads
* run the component
* plot some output
"""

"""
A bit of magic so that we can plot within this notebook.
"""

%matplotlib inline
import numpy as np

"""
## Create the grid

We are going to build a uniform rectilinear grid with a node spacing of 10 km in the *y*-direction and 20 km in the *x*-direction on which we will solve the flexure equation.

First we need to import `RasterModelGrid`.
"""

from landlab import RasterModelGrid

"""
Create a rectilinear grid with a spacing of 10 km between rows and 20 km between columns. The numbers of rows and columms are provided as a `tuple` of `(n_rows, n_cols)`, in the same manner as similar numpy functions. The spacing is also a `tuple`, `(dy, dx)`.
"""

grid = RasterModelGrid((200, 400), xy_spacing=(10e3, 20e3))

grid.dy, grid.dx

"""
## Create the component
"""

"""
Now we create the flexure component and tell it to use our newly-created grid. First, though, we'll examine the `Flexure` component a bit.
"""

from landlab.components.flexure import Flexure

"""
The Flexure component, as with most landlab components, will require our grid to have some data that it will use. We can get the names of these data fields with the `intput_var_names` attribute of the component *class*.
"""

Flexure.input_var_names

"""
We see that flexure uses just one data field: the change in lithospheric loading. landlab component classes can provide additional information about each of these fields. For instance, to the the units for a field, use the `var_units` method.
"""

Flexure.var_units("lithosphere__overlying_pressure_increment")

"""
To print a more detailed description of a field, use `var_help`.
"""

Flexure.var_help("lithosphere__overlying_pressure_increment")

"""
What about the data that `Flexure` provides? Use the `output_var_names` attribute.
"""

Flexure.output_var_names

Flexure.var_help("lithosphere_surface__elevation_increment")

"""
Now that we understand the component a little more, create it using our grid.
"""

grid.add_zeros("lithosphere__overlying_pressure_increment", at="node")
flex = Flexure(grid, method="flexure", n_procs=4)

"""
## Add some loading
We will add loads to the grid. As we saw above, for this component, the name of the variable that holds the applied loads is `lithosphere__overlying_pressure`. We add loads of random magnitude at every node of the grid.
"""

load = np.random.normal(0, 100 * 2650.0 * 9.81, grid.number_of_nodes)
grid.at_node["lithosphere__overlying_pressure_increment"] = load

grid.imshow(
    "lithosphere__overlying_pressure_increment",
    symmetric_cbar=True,
    cmap="nipy_spectral",
)

"""
## Update the component to solve for deflection
If you have more than one processor on your machine you may want to use several of them.
"""

flex.update()

"""
As we saw above, the flexure component creates an output field (`lithosphere_surface__elevation_increment`) that contains surface deflections for the applied loads.
"""

"""
## Plot the output
"""

"""
We now plot these deflections with the `imshow` method, which is available to all landlab components.
"""

grid.imshow(
    "lithosphere_surface__elevation_increment",
    symmetric_cbar=True,
    cmap="nipy_spectral",
)

"""
Maintain the same loading distribution but double the effective elastic thickness.
"""

flex.eet *= 2.0
flex.update()
grid.imshow(
    "lithosphere_surface__elevation_increment",
    symmetric_cbar=True,
    cmap="nipy_spectral",
)

"""
Now let's add a vertical rectangular load to the middle of the grid.  We plot the load grid first to make sure we did this correctly.
"""

load[np.where(np.logical_and(grid.node_x > 3000000, grid.node_x < 5000000))] = (
    load[np.where(np.logical_and(grid.node_x > 3000000, grid.node_x < 5000000))] + 1e7
)
grid.imshow(
    "lithosphere__overlying_pressure_increment",
    symmetric_cbar=True,
    cmap="nipy_spectral",
)

flex.update()
grid.imshow(
    "lithosphere_surface__elevation_increment",
    symmetric_cbar=True,
    cmap="nipy_spectral",
)



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/PriorityFlood_LandscapeEvolutionModel.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Landscape evolution model with Priority flood and Space_v2
<hr>

The priority flood flow director is designed to calculate flow properties over large scale grids. In the following notebook we illustrate how the priority flood flow accumulator can be used to simulate landscape evolution using the SPAVE_V2 Landlab component
"""

import numpy as np
from matplotlib import pyplot as plt
from tqdm import tqdm

from landlab import RasterModelGrid, imshow_grid
from landlab.components import PriorityFloodFlowRouter, SpaceLargeScaleEroder

"""
Create raster grid
"""

mg = RasterModelGrid((25, 25), xy_spacing=10.0)
z = mg.add_zeros("topographic__elevation", at="node")
mg.at_node["topographic__elevation"][mg.core_nodes] += np.random.rand(
    mg.number_of_core_nodes
)

s = mg.add_zeros("soil__depth", at="node", dtype=float)
mg.at_node["soil__depth"][mg.core_nodes] += 0.5
mg.at_node["topographic__elevation"] += mg.at_node["soil__depth"]

# fr = FlowAccumulator(mg, flow_director='D8')
# df = DepressionFinderAndRouter(mg)

fr = PriorityFloodFlowRouter(mg, flow_metric="D8", update_flow_depressions=True)


ha = SpaceLargeScaleEroder(mg, K_sed=0.0001, K_br=0.0001, phi=0.3, H_star=1)

br = mg.at_node["bedrock__elevation"]
z = mg.at_node["topographic__elevation"]

space_dt = 250

z_ori = np.array(z)
for i in tqdm(range(250)):
    # Uplift
    br[mg.core_nodes] += 0.001 * space_dt
    z[mg.core_nodes] = br[mg.core_nodes] + s[mg.core_nodes]
    fr.run_one_step()
    # df.map_depressions()
    ha.run_one_step(dt=space_dt)

imshow_grid(mg, "topographic__elevation", cmap="terrain")
plt.title("Final topographic__elevation")



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/PriorityFlood_realDEMs.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to priority flood component
<hr>

The priority flood flow director is designed to calculate flow properties over large scale grids. 
In the following notebook we illustrate how flow accumulation can be calculated for a real DEM downloaded with the [BMI_topography data component](https://bmi-topography.readthedocs.io/en/latest/). Moreover, we demonstrate how shaded relief can be plotted using the imshowhs_grid function. 
"""

"""
First we will import all the modules we need. 
"""

from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from bmi_topography import Topography

from landlab import imshowhs_grid
from landlab.components import FlowAccumulator, PriorityFloodFlowRouter
from landlab.io import esri_ascii

"""
Create a function to download and save SRTM images using  [BMI_topography](https://bmi-topography.readthedocs.io/en/latest/). 
"""

def get_topo(buffer, north=40.16, south=40.14, east=-105.49, west=-105.51):
    params = Topography.DEFAULT.copy()
    params["south"] = south - buffer
    params["north"] = north + buffer
    params["west"] = -105.51 - buffer
    params["east"] = -105.49 + buffer
    params["output_format"] = "AAIGrid"
    params["cache_dir"] = Path.cwd()
    dem = Topography(**params)
    name = dem.fetch()
    # props = dem.load()
    # dim_x = props.sizes["x"]
    # dim_y = props.sizes["y"]
    # cells = props.sizes["x"] * props.sizes["y"]
    with open(name) as fp:
        grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
    return grid

"""
Make function to plot DEMs and drainage accumulation with shaded relief. 
"""

def plotting(
    grid, topo=True, DA=True, hill_DA=False, flow_metric="D8", hill_flow_metric="Quinn"
):
    if topo:
        azdeg = 200
        altdeg = 20
        ve = 1
        plt.figure()
        plot_type = "DEM"
        ax = imshowhs_grid(
            grid,
            "topographic__elevation",
            grid_units=("deg", "deg"),
            var_name="Topo, m",
            cmap="terrain",
            plot_type=plot_type,
            vertical_exa=ve,
            azdeg=azdeg,
            altdeg=altdeg,
            default_fontsize=12,
            cbar_tick_size=10,
            cbar_width="100%",
            cbar_or="vertical",
            bbox_to_anchor=[1.03, 0.3, 0.075, 14],
            colorbar_label_y=-15,
            colorbar_label_x=0.5,
            ticks_km=False,
        )
    if DA:
        # %% Plot first instance of drainage_area
        grid.at_node["drainage_area"][grid.at_node["drainage_area"] == 0] = (
            grid.dx * grid.dx
        )
        plot_DA = np.log10(grid.at_node["drainage_area"] * 111e3 * 111e3)

        plt.figure()
        plot_type = "Drape1"
        drape1 = plot_DA
        thres_drape1 = None
        alpha = 0.5
        cmap1 = "terrain"
        ax = imshowhs_grid(
            grid,
            "topographic__elevation",
            grid_units=("deg", "deg"),
            cmap=cmap1,
            plot_type=plot_type,
            drape1=drape1,
            vertical_exa=ve,
            azdeg=azdeg,
            altdeg=altdeg,
            thres_drape1=thres_drape1,
            alpha=alpha,
            default_fontsize=12,
            cbar_tick_size=10,
            var_name="$log^{10}DA, m^2$",
            cbar_width="100%",
            cbar_or="vertical",
            bbox_to_anchor=[1.03, 0.3, 0.075, 14],
            colorbar_label_y=-15,
            colorbar_label_x=0.5,
            ticks_km=False,
        )

        props = dict(boxstyle="round", facecolor="white", alpha=0.6)
        textstr = flow_metric
        ax.text(
            0.05,
            0.95,
            textstr,
            transform=ax.transAxes,
            fontsize=10,
            verticalalignment="top",
            bbox=props,
        )

    if hill_DA:
        # Plot second instance of drainage_area (hill_drainage_area)
        grid.at_node["hill_drainage_area"][grid.at_node["hill_drainage_area"] == 0] = (
            grid.dx * grid.dx
        )
        np.log10(grid.at_node["hill_drainage_area"] * 111e3 * 111e3)

        plt.figure()
        plot_type = "Drape1"
        # plot_type='Drape2'
        drape1 = np.log10(grid.at_node["hill_drainage_area"])
        thres_drape1 = None
        alpha = 0.5
        cmap1 = "terrain"
        ax = imshowhs_grid(
            grid,
            "topographic__elevation",
            grid_units=("deg", "deg"),
            cmap=cmap1,
            plot_type=plot_type,
            drape1=drape1,
            vertical_exa=ve,
            azdeg=azdeg,
            altdeg=altdeg,
            thres_drape1=thres_drape1,
            alpha=alpha,
            default_fontsize=10,
            cbar_tick_size=10,
            var_name="$log^{10}DA, m^2$",
            cbar_width="100%",
            cbar_or="vertical",
            bbox_to_anchor=[1.03, 0.3, 0.075, 14],
            colorbar_label_y=-15,
            colorbar_label_x=0.5,
            ticks_km=False,
        )

        props = dict(boxstyle="round", facecolor="white", alpha=0.6)
        textstr = hill_flow_metric
        ax.text(
            0.05,
            0.95,
            textstr,
            transform=ax.transAxes,
            fontsize=10,
            verticalalignment="top",
            bbox=props,
        )

"""
## Compare default Landlab flow accumulator with priority flood flow accumulator 
For small DEMs (small buffer size, in degrees), the default flow accumulator is slightly faster than the priority flood flow accumulator. For large DEMs, the priority flood flow accumulator outperforms the default flow accumulator by several orders of magnitude.  To test the performance for larger DEM's increase the buffer size (e.g. with 1 degree = 111 km).
"""

"""
### Default flow director/accumulator 
"""

# Download or reload topo data with given buffer
# dim_x, dim_y, cells, grid_LL, z_LL, dem = get_topo(0.05)
grid_LL = get_topo(0.05)

fa_LL = FlowAccumulator(
    grid_LL, flow_director="D8", depression_finder="DepressionFinderAndRouter"
)
fa_LL.run_one_step()

# Plot output products
plotting(grid_LL)

north = 40.16
south = 40.14
east = -105.49
west = -105.51
buffer = 0.05

params = Topography.DEFAULT.copy()
params["south"] = south - buffer
params["north"] = north + buffer
params["west"] = -105.51 - buffer
params["east"] = -105.49 + buffer
params["output_format"] = "AAIGrid"
params["cache_dir"] = Path.cwd()
dem = Topography(**params)
name = dem.fetch()
# props = dem.load()
name

"""
### Priority flood flow director/accumulator 
Calculate flow directions/flow accumulation using the first instance of the flow accumulator 
"""

# Download or reload topo data with given buffer
# dim_x, dim_y, cells, grid_PF, z_PF, dem = get_topo(0.05)
grid_PF = get_topo(0.05)

# Here, we only calculate flow directions using the first instance of the flow accumulator
flow_metric = "D8"
fa_PF = PriorityFloodFlowRouter(
    grid_PF,
    surface="topographic__elevation",
    flow_metric=flow_metric,
    suppress_out=False,
    depression_handler="fill",
    accumulate_flow=True,
)

fa_PF.run_one_step()

# Plot output products
plotting(grid_PF)

"""
### Priority flood flow director/accumulator 
Calculate flow directions/flow accumulation using the second instance of the flow accumulator 
"""

# 3. Priority flow director/accumualtor
# Download or reload topo data with given buffer
# dim_x, dim_y, cells, grid_PF, z_PF, dem = get_topo(0.05)
grid_PF = get_topo(0.05)

# For timing compare only single flow
flow_metric = "D8"
hill_flow_metric = "Quinn"
fa_PF = PriorityFloodFlowRouter(
    grid_PF,
    surface="topographic__elevation",
    flow_metric=flow_metric,
    suppress_out=False,
    depression_handler="fill",
    accumulate_flow=True,
    separate_hill_flow=True,
    accumulate_flow_hill=True,
    update_hill_flow_instantaneous=False,
    hill_flow_metric=hill_flow_metric,
)


fa_PF.run_one_step()
fa_PF.update_hill_fdfa()

# 4. Plot output products
plotting(grid_PF, hill_DA=True, flow_metric="D8", hill_flow_metric="Quinn")


# Remove downloaded DEM. Uncomment to remove DEM.
# os.remove(dem.fetch())



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/compare_FlowDirectors.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Comparison of FlowDirectors

## Introduction

Landlab's topographic flow-routing capability directs flow and accumulates it using two types of components:

**FlowDirectors** use the topography to determine how flow moves between adjacent nodes. For every node in the grid it determines the node(s) to receive flow, and the proportion of flow to send from one node to its receiver(s). 

The **FlowAccumulator** uses the direction and proportion of flow moving between each node and (optionally) water runoff to calculate drainage area and discharge. 

The **FlowDirectors** are method-specific. Presently landlab supports four different methods for determining flow direction:

1. **FlowDirectorSteepest** Flow is routed to only one node. The algorithm considers the link slopes leaving from each node and chooses the steepest downhill link to route flow along. In the case of a raster grid, only the links are considered (Landlab differentiates between *links*, which never cross and are located at North, South, East, and West on a raster grid, and *diagonals* which cross and are located at North East, North West, South East, and South West). For raster grids, this method is also known as D4 flow routing. In the case of irregular grids, all links originating from a node are consideded.

2. **FlowDirectorD8** (raster only) Flow is only routed to one node but diagonals are also considered. 

3. **FlowDirectorMFD** Flow is directed to all nodes that are located downhill of the source node. In the case of a raster grid, diagonals can be included using the keyword ```diagonals=True```. Flow is partitioned between receiver nodes based on the relative slope along the links leading to the receiver nodes. The default method for partitioning is based on the sum of receiver slopes (```partition_method='slope'```). Partitioning can also be done on the basis of the square root of slope, which gives the result of a steady kinematic wave(```partition_method='square_root_of_slope'```).

4. **FlowDirectorDINF** (raster only) Flow is directed to two cells based on the slope of the triangular facets that can be defined between a node and its neighbors. The steepest downhill facet is chosen and then flow is partitioned between the receiver nodes at the bottom of that facet based on the relative slopes along the facet-bounding links. (The method, known as "D-infinity", is described by Tarboton (1997, Water Resources Research, 33(2), 309-319)).

In this tutorial we will go over more detailed examples that contrast the differences between each flow-direction algorithm. For information about how to initialize and run a **FlowDirector** or the **FlowAccumulator**, refer to the other tutorials in this section. 

First, we import the necessary python modules and make a small plotting routine. 
"""

import matplotlib.pyplot as plt
from matplotlib import cm

from landlab import RasterModelGrid
from landlab.components import (
    FlowAccumulator,
    FlowDirectorD8,
    FlowDirectorDINF,
    FlowDirectorMFD,
    FlowDirectorSteepest,
)
from landlab.plot.drainage_plot import drainage_plot


# create a plotting routine to make a 3d plot of our surface.
def surf_plot(mg, surface="topographic__elevation", title="Surface plot of topography"):
    plt.figure()
    ax = plt.axes(projection="3d")

    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    color = cm.gray((Z - Z.min()) / (Z.max() - Z.min()))
    ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
    )
    ax.view_init(elev=35, azim=-120)
    ax.set_xlabel("X axis")
    ax.set_ylabel("Y axis")
    ax.set_zlabel("Elevation")
    plt.title(title)
    plt.show()

"""
## 3 topographic grids

For this tutorial we will consider three different topographic surfaces that highlight the difference between each of the flow direction algorithms. 
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")
surf_plot(mg1, title="Grid 1: A basic ramp")

mg2 = RasterModelGrid((10, 10))
_ = mg2.add_field(
    "topographic__elevation", mg2.x_of_node + 2.0 * mg2.y_of_node, at="node"
)
surf_plot(mg2, title="Grid 2: A ramp inclined in X and in Y")

mg3 = RasterModelGrid((10, 10))
_ = mg3.add_field(
    "topographic__elevation",
    mg3.x_of_node**2 + mg3.y_of_node**2 + mg3.y_of_node,
    at="node",
)
surf_plot(mg3, title="Grid 3: A more complicated surface")

"""
## Comparing the different methods for each grid

We can illustrate the receiver node **FlowDirectionSteepest** has assigned to each donor node using a plotting function in Landlab called ```drainage_plot```. We will see many of these plots in this tutorial so let's take a moment to walk through the plot and what it contains. 

- The background image (white to black) shows the values of topographic elevation of the underlying surface.

- The color of the dots inside of each pixel show the locations of the nodes and the type of node. 

- The arrows show the direction of flow, and the color shows the proportion of flow that travels along that link. 

- An X on top of a node indicates that node is a local sink and flows to itself. 

Note that in Landlab *boundary nodes*, or nodes that are on the edge of a grid do not have area and do not contribute flow to nodes. These nodes can either be *Fixed Gradient Nodes*, *Fixed Value Nodes*, or *Closed Nodes*. With the exception of *Closed Nodes* the boundary nodes can receive flow. 

An important step in all flow direction and accumulation is setting the proper boundary condition. Refer to the boundary condition tutorial for more information. 


## Grid 1: Basic Ramp

As with the Introduction to Flow Director tutorial, let's start with the basic ramp. 
"""

mg1a = RasterModelGrid((10, 10))
_ = mg1a.add_field("topographic__elevation", mg1a.y_of_node, at="node")

fd1a = FlowDirectorSteepest(mg1a, "topographic__elevation")
fd1a.run_one_step()
plt.figure()
drainage_plot(mg1a, title="Basic Ramp using FlowDirectorSteepest")

"""
Reassuringly we can see that the flow is being sent from high elevations at the top of the grid to low elevations at the bottom of the grid. We can also see that all of the arrows are yellow, and thus all of the flow is traveling on these links. 

Now let's see how the other **FlowDirectors** direct the flow on this simple grid. We don't need to specify the surface so long as it is the field ```'topographic__elevation'```.
"""

mg1b = RasterModelGrid((10, 10))
_ = mg1b.add_field("topographic__elevation", mg1b.y_of_node, at="node")

fd1b = FlowDirectorD8(mg1b)
fd1b.run_one_step()
plt.figure()
drainage_plot(mg1b, title="Basic Ramp using FlowDirectorD8")

"""
For this ramp, the steepest slope is down a link, and not a diagonal, so **FlowDirectorD8** gives the same result as **FlowDirectorSteepest**.
"""

mg1c = RasterModelGrid((10, 10))
_ = mg1c.add_field("topographic__elevation", mg1c.y_of_node, at="node")

fd1c = FlowDirectorMFD(mg1c, diagonals=False)  # diagonals=False is the default option
fd1c.run_one_step()
plt.figure()
drainage_plot(mg1c, title="Basic Ramp using FlowDirectorMFD without diagonals")

"""
Similarly, while there is more than one node below each core node, there is only one node that is connected by a link and not a diagonal. Thus **FlowDirectorMFD** with the keyword ```diagonals``` set to ```True``` provides the same results as **FlowDirectorSteepest** and **FlowDirectorD8**
"""

mg1d = RasterModelGrid((10, 10))
_ = mg1d.add_field("topographic__elevation", mg1d.y_of_node, at="node")

fd1d = FlowDirectorMFD(mg1d, diagonals=True)
fd1d.run_one_step()
plt.figure()
drainage_plot(mg1d, title="Basic Ramp using FlowDirectorMFD with diagonals")

"""
When we permit flow along diagonal connections between nodes and flow to all downhill nodes, we see a difference in the directing pattern on this simple ramp. The flow is partitioned between the three downhill nodes, and there is more flow being sent to along the link as compared with the diagonals (the links are a lighter color blue than the diagonals). 

One issue we might have with the results from **FlowDirectorMFD** in this case is that the flow on the diagonals crosses. This is one of the problems with using diagonal connections between nodes. 

"""

mg1e = RasterModelGrid((10, 10))
_ = mg1e.add_field("topographic__elevation", mg1e.y_of_node, at="node")

fd1e = FlowDirectorDINF(mg1e)
fd1e.run_one_step()
plt.figure()
drainage_plot(mg1e, title="Basic Ramp using FlowDirectorDINF")

"""
In **FlowDirectorDINF** flow is partitioned to two nodes based on steepness of the eight triangular facets surrounding each node. The partitioning is based on the relation between the link and diagonal slope that form the edge of the facet and the slope of the facet itself. When one of the facet edges has the same slope as the facet, as is the case in this ramp example, all of the flow is partitioned along that edge. 

## Grid 2: Inclined plane in two dimentions

Next let's look at all the flow directors but with the inclined plane. Recall that this plane is tilted in both X and Y axes, and that is tilted more steeply in the Y direction. 
"""

mg2a = RasterModelGrid((10, 10))
_ = mg2a.add_field(
    "topographic__elevation", mg2a.x_of_node + 2.0 * mg2a.y_of_node, at="node"
)

fd2a = FlowDirectorSteepest(mg2a, "topographic__elevation")
fd2a.run_one_step()
plt.figure()
drainage_plot(mg2a, title="Grid 2 using FlowDirectorSteepest")

"""
Flow is directed down parallel to to the the Y-axis of the plane. This makes sense in the context of the **FlowDirectorSteepest** algorithm; it only sends flow to one node, so it an idealized geometry such as the plane in this example, it provides flow direction that is non-realistic. 

As we will discuss throughout this tutorial, there are benefits and drawbacks to each **FlowDirector** algorithm. 
"""

mg2b = RasterModelGrid((10, 10))
_ = mg2b.add_field(
    "topographic__elevation", mg2b.x_of_node + 2.0 * mg2b.y_of_node, at="node"
)

fd2b = FlowDirectorD8(mg2b)
fd2b.run_one_step()
plt.figure()
drainage_plot(mg2b, title="Grid 2 using FlowDirectorD8")

"""
**FlowDirectorD8** consideres the diagonal connections between nodes. As the plane is inclined to the southwest the flow direction looks better here, though as we will see later, sometimes **FlowDirectorD8** does non-realistic directing too. 
"""

mg2c = RasterModelGrid((10, 10))
_ = mg2c.add_field(
    "topographic__elevation", mg2c.x_of_node + 2.0 * mg2c.y_of_node, at="node"
)

fd2c = FlowDirectorMFD(mg2c, diagonals=False)  # diagonals=False is the default option
fd2c.run_one_step()
plt.figure()
drainage_plot(mg2c, title="Grid 2 using FlowDirectorMFD without diagonals")

"""
As **FlowDirectorMFD** can send flow to all the nodes downhill it doesn't have the same problem that **FlowDirectorSteepest** had. Because the plane is tilted down more steeply to the south than to the east, it sends more flow on the steeper link. 
"""

mg2d = RasterModelGrid((10, 10))
_ = mg2d.add_field(
    "topographic__elevation", mg2d.x_of_node + 2.0 * mg2d.y_of_node, at="node"
)

fd2d = FlowDirectorMFD(mg2d, diagonals=True)
fd2d.run_one_step()
plt.figure()
drainage_plot(mg2d, title="Grid 2 using FlowDirectorMFD with diagonals")

"""
When **FlowDirectorMFD** considers diagonals in addition to links, we see that it sends the flow to four nodes instead of three. While all of the receiver nodes are downhill from their donor nodes, we see again that using diagonals permits flow to cross itself. We also see that the most flow is routed to the south and the south east, which makes sense based on how the plane is tilted. 
"""

mg2e = RasterModelGrid((10, 10))
_ = mg2e.add_field(
    "topographic__elevation", mg2e.x_of_node + 2.0 * mg2e.y_of_node, at="node"
)

fd2e = FlowDirectorDINF(mg2e)
fd2e.run_one_step()
plt.figure()
drainage_plot(mg2e, title="Basic Ramp using FlowDirectorDINF")

"""
Here **FlowDirectorDINF** routes flow in two directions, to the south and southeast. The plane is steeper to from north to south than from east to west and so more flow is directed on the diagonal to the southeast. 

## Grid 3: Curved surface

Finally, let's consider our curved surface. 
"""

mg3a = RasterModelGrid((10, 10))
_ = mg3a.add_field(
    "topographic__elevation",
    mg3a.x_of_node**2 + mg3a.y_of_node**2 + mg3a.y_of_node,
    at="node",
)

fd3a = FlowDirectorSteepest(mg3a, "topographic__elevation")
fd3a.run_one_step()
plt.figure()
drainage_plot(mg3a, title="Grid 3 using FlowDirectorSteepest")

"""
Flow on this surface using **FlowDirectorSteepest** looks realistic, as flow is routed down into the bottom of the curved surface. 
"""

mg3b = RasterModelGrid((10, 10))
_ = mg3b.add_field(
    "topographic__elevation",
    mg3b.x_of_node**2 + mg3b.y_of_node**2 + mg3b.y_of_node,
    at="node",
)

fd3b = FlowDirectorD8(mg3b)
fd3b.run_one_step()
plt.figure()
drainage_plot(mg3b, title="Grid 3 using FlowDirectorD8")

"""
Near the bottom left of the grid, the steepest descent is on a diagonal, so using **FlowDirectorD8** gives a different drainage pattern. 
"""

mg3c = RasterModelGrid((10, 10))
_ = mg3c.add_field(
    "topographic__elevation",
    mg3c.x_of_node**2 + mg3c.y_of_node**2 + mg3c.y_of_node,
    at="node",
)

fd3c = FlowDirectorMFD(mg3c, diagonals=False)  # diagonals=False is the default option
fd3c.run_one_step()
plt.figure()
drainage_plot(mg3c, title="Grid 3 using FlowDirectorMFD without diagonals")

"""
Permitting multiple receivers with and without diagonals give an additional two different drainage patterns. 
"""

mg3d = RasterModelGrid((10, 10))
_ = mg3d.add_field(
    "topographic__elevation",
    mg3d.x_of_node**2 + mg3d.y_of_node**2 + mg3d.y_of_node,
    at="node",
)

fd3d = FlowDirectorMFD(mg3d, diagonals=True)
fd3d.run_one_step()
plt.figure()
drainage_plot(mg3d, title="Grid 3 using FlowDirectorMFD with diagonals")

"""
Again we see flow paths crossing when we permit consideration of flow along the diagonals. 
"""

mg3e = RasterModelGrid((10, 10))
_ = mg3e.add_field(
    "topographic__elevation",
    mg3e.x_of_node**2 + mg3e.y_of_node**2 + mg3e.y_of_node,
    at="node",
)

fd3e = FlowDirectorDINF(mg3e)
fd3e.run_one_step()
plt.figure()
drainage_plot(mg3e, title="Grid 3 using FlowDirectorDINF")

"""
Finally we see yet a different drainage pattern when we use **FlowDirectorDINF** and flow is routed along an adjacent diagonal-link pair.

## Comparison of Accumulated Area

Before concluding, let's examine the accumulated drainage area using each of the **FlowDirector** methods and the third grid. For an introduction to creating and running a **FlowAccumulator** see the tutorial "Introduction to Flow Accumulators". 

Often we do flow routing and accumulation because we want to use the accumulated area as a proxy for the water discharge. So the details of how the flow is routed are important because they influence how the drainage area pattern evolves. 

Lets begain with **FlowDirectorSteepest**.
"""

mg3 = RasterModelGrid((10, 10))
_ = mg3.add_field(
    "topographic__elevation",
    mg3.x_of_node**2 + mg3.y_of_node**2 + mg3.y_of_node,
    at="node",
)

fa = FlowAccumulator(mg3, "topographic__elevation", flow_director="Steepest")
fa.run_one_step()
plt.figure()
drainage_plot(
    mg3, "drainage_area", title="Flow Accumulation using FlowDirectorSteepest"
)

"""
Here we see that flow has accumulated into one channel in the bottom of the curved surface. 
"""

fa = FlowAccumulator(mg3, "topographic__elevation", flow_director="D8")
fa.run_one_step()
plt.figure()
drainage_plot(mg3, "drainage_area", title="Flow Accumulation using FlowDirectorD8")

"""
When diagonals are considered, as in **FlowDirectorD8**, the drainage patter looks very diferent. Instead of one channel we have two smaller channels. 
"""

mg3 = RasterModelGrid((10, 10))
_ = mg3.add_field(
    "topographic__elevation",
    mg3.x_of_node**2 + mg3.y_of_node**2 + mg3.y_of_node,
    at="node",
)

fa = FlowAccumulator(mg3, "topographic__elevation", flow_director="MFD")
fa.run_one_step()
plt.figure()
drainage_plot(
    mg3,
    "drainage_area",
    title="Flow Accumulation using FlowDirectorMFD without diagonals",
)

"""
Flow is distributed much more when we use **FlowDirectorMFD**.
"""

mg3 = RasterModelGrid((10, 10))
_ = mg3.add_field(
    "topographic__elevation",
    mg3.x_of_node**2 + mg3.y_of_node**2 + mg3.y_of_node,
    at="node",
)

fa = FlowAccumulator(mg3, "topographic__elevation", flow_director="MFD", diagonals=True)
fa.run_one_step()
plt.figure()
drainage_plot(
    mg3, "drainage_area", title="Flow Accumulation using FlowDirectorMFD with diagonals"
)

"""
Adding diagonals to **FlowDirectorMFD** gives a channel somewhat similar to the one created by **FlowDirectorSteepest** but much more distributed. 
"""

mg3 = RasterModelGrid((10, 10))
_ = mg3.add_field(
    "topographic__elevation",
    mg3.x_of_node**2 + mg3.y_of_node**2 + mg3.y_of_node,
    at="node",
)

fa = FlowAccumulator(mg3, "topographic__elevation", flow_director="DINF")
fa.run_one_step()
plt.figure()
drainage_plot(mg3, "drainage_area", title="Flow Accumulation using FlowDirectorDINF")

"""
Finally, **FlowDirectorDINF** gives yet another pattern for the accumulation of drainage area.

## Conclusion

This tutorial compared the different methods in more detail and over surfaces that are more complicated than a simple sloping ramp. It also described how these different **FlowDirector** methods change the patterns of accumulated drainage area. 

Next consider one of two additional tutorials about directing and accumulating flow in Landlab.

1. **Introduction to FlowDirector**: A tutorial that goes over the different **FlowDirectors** present in Landlab and how to create and run a **FlowDirector**.
2. **Introduction to FlowAccumulator**: A tutorial that describes how to use the **FlowAccumulator**.
"""



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/the_FlowAccumulator.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to the FlowAccumulator

Landlab directs flow and accumulates it using two types of components:

**FlowDirectors** use the topography to determine how flow moves between adjacent nodes. For every node in the grid it determines the nodes to receive flow and the proportion of flow to send from one node to its receiver. 

The **FlowAccumulator** uses the direction and proportion of flow moving between each node and (optionally) water runoff to calculate drainage area and discharge.  

In this tutorial we will go over how to initialize and run the **FlowAccumulator**. For tutorials on how to initialize and run a **FlowDirector** and a brief comparison between the different flow direction algorithms or for more detailed examples that contrast the differences between each flow direction algorithm, refer to the other tutorials in this section. 

First, we import the necessary python modules and make a small plotting routine. 
"""

%matplotlib inline

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import cm

from landlab import HexModelGrid, RasterModelGrid
from landlab.components import (
    DepressionFinderAndRouter,
    FlowAccumulator,
    FlowDirectorD8,
    FlowDirectorSteepest,
)
from landlab.plot.drainage_plot import drainage_plot


# create a plotting routine to make a 3d plot of our surface.
def surf_plot(mg, surface="topographic__elevation", title="Surface plot of topography"):
    plt.figure()
    ax = plt.axes(projection="3d")

    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    color = cm.gray((Z - Z.min()) / (Z.max() - Z.min()))
    ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
    )
    ax.view_init(elev=35, azim=-120)
    ax.set_xlabel("X axis")
    ax.set_ylabel("Y axis")
    ax.set_zlabel("Elevation")
    plt.title(title)
    plt.show()

"""
## Topographic grids

For this tutorial we will consider one topographic surface. Here it is plotted in three dimensions. 
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
surf_plot(mg, title="Grid 1")

"""
## Initalizing and running the FlowAccumulator

To instantiate the **FlowAccumulator**, you must pass it the minimum of a model grid that has a field called ```'topographic__elevation'```. 

Alternatively, you can pass it the name of another field name at node, or an array with length number of nodes. This is the surface over which flow is first directed and then accumulated. 

**FlowAccumulator** will create and use a **FlowDirector** to calculate flow directions. The default **FlowDirector** is **FlowDirectorSteepest**, which is the same as D4 in the special case of a raster grid. There are a few different ways to specify which **FlowDirector** you want **FlowAccumulator** to use. The next section will go over these options. 

**FlowAccumulator** can take a constant or spatially variable input called ```runoff_rate```, which it uses to calculate discharge. Alternatively, if there is an `at_node` field called ```water__unit_flux_in``` and no value is specified as the ```runoff_rate```, **FlowAccumulator** will use the values stored in ```water__unit_flux_in```.

In addition to directing flow and accumulating it in one step, **FlowAccumulator** can also deal with depression finding internally. This can be done by passing a **DepressionFinder** to the keyword argument ```depression_finder```. The default behavior is to not deal with depressions internally. 

Finally, if the **FlowDirector** you are using takes any keyword arguments, those can be passed to the **FlowAccumulator**. For example, **FlowDirectorMFD** has to option to use diagonals in addition to links and to proportion flow based on either the slope or the the square root of slope.
"""

fa = FlowAccumulator(mg)

# this is the same as writing:
fa = FlowAccumulator(
    mg,
    surface="topographic__elevation",
    flow_director="FlowDirectorSteepest",
    runoff_rate=None,
    depression_finder=None,
)

"""
The **FlowAccumulator** has two public methods: ```run_one_step()``` and ```accumulate_flow()```.

Both use the values of the surface provided to identify flow directions (and in the case of directing to more than one receiver, proportions) and then calculate discharge and drainage area. Both store the same information about receivers, proportions, and other calculated values to the model grid as fields. The difference is that ```run_one_step()``` does not return any values, while ```accumulate_flow()``` returns the drainage area and discharge as variables.
"""

fa.run_one_step()

(da, q) = fa.accumulate_flow()

"""
We can illustrate the receiver node **FlowDirectionSteepest** has assigned to each donor node using a plotting function in Landlab called ```drainage_plot```. We will see many of these plots in this tutorial so let's take a moment to walk through the plot and what it contains. 

   - The background image (white to black) shows the values of topographic elevation of the underlying surface or any other at_node field we choose to plot.

   - The colors of the dots inside of each pixel show the locations of the nodes and the type of node. 

   - The arrows show the direction of flow, and the color shows the proportion of flow that travels along that link. 

   - An X on top of a node indicates that node is a local sink and flows to itself. 

Note that in Landlab *Boundary Nodes*, or nodes that are on the edge of a grid, do not have area and do not contribute flow to nodes. These nodes can either be *Fixed Gradient Nodes*, *Fixed Value Nodes*, or *Closed Nodes*. With the exception of *Closed Nodes* the boundary nodes can receive flow. 

An important step in all flow direction and accumulation is setting the proper boundary condition. Refer to the boundary condition tutorials for more information.  
"""

plt.figure()
drainage_plot(mg)

"""
In this drainage plot, we can see that all of the flow is routed down the steepest link. A plot of the drainage area would illustrate how the flow would move. Next let's make a similar plot except that instead of plotting the topographic elevation as the background, we will plot the drainage area. 
"""

plt.figure()
drainage_plot(mg, "drainage_area")

"""
If we print out the drainage area, we can see that its maximum reaches 64, which is the total area of the interior of the grid.
"""

print(mg.at_node["drainage_area"].reshape(mg.shape))

"""
This is the same number as the number of core nodes. This makes sense becaue these are the only nodes in Landlab that have area, and in our model grid they each have an area of one. 
"""

print(mg.number_of_core_nodes)

"""
We can rain on the surface, store that rain in the field ```water__unit_flux_in```, and then re-run the **FlowAccumulator**. As an example, we will 'rain' a uniformly distributed random number between 0 and 1 on every node. 

Since we already ran the **FlowAccumulator**, under the hood our grid already has a field called ```water__unit_flux_in``` and we need to set the ```clobber``` keyword to ```True```.
"""

rain = 1.0 + 5.0 * np.random.rand(mg.number_of_nodes)

plt.imshow(rain.reshape(mg.shape), origin="lower", cmap="PuBu", vmin=0)
plt.colorbar()
plt.show()

_ = mg.add_field("water__unit_flux_in", rain, at="node", clobber=True)

"""
Next, we re-run the **FlowAccumulator** and plot the discharge. 
"""

fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
The basic pattern of drainage is the same but the values for the surface water discharge are different than for drainage area. 
"""

"""
### Alternative ways to specify the FlowDirector

**FlowAccumulator** allows the **FlowDirector** to be specified one of four ways:
1. As a string of the full name of the **FlowDirector** (e.g., ```'FlowDirectorSteepest'``` or ```'FlowDirectorD8'``` )
2. As a string of the short name of the **FlowDirector** method (e.g., ```'Steepest'``` or ```'D8'```)
3. As the class name for the desired **FlowDirector** component.
4. As an instantiated version of a **FlowDirector** component. 

Thus, the following four ways to instantiate a **FlowAccumulator** are equivalent.
"""

# option 1: Full name of FlowDirector
fa = FlowAccumulator(
    mg, surface="topographic__elevation", flow_director="FlowDirectorSteepest"
)

# option 2: Short name of FlowDirector
fa = FlowAccumulator(mg, surface="topographic__elevation", flow_director="Steepest")

# option 3: Uninstantiated FlowDirector Component
fa = FlowAccumulator(
    mg, surface="topographic__elevation", flow_director=FlowDirectorSteepest
)

# option 4: Instantiated FlowDirector Component
fd = FlowDirectorSteepest(mg)
fa = FlowAccumulator(mg, surface="topographic__elevation", flow_director=fd)

"""
### Providing a DepressionFinder

Just as with providing the **FlowDirector**, the **DepressionFinder** can be provided multiple ways. While there are presently four different **FlowDirectors** in Landlab, there is only one **DepressionFinder**. 

1. As a string of the full name of the **DepressionFinder** (e.g., ```'DepressionFinderAndRouter'```)
2. As the class name of the **DepressionFinder** component.
3. As an instantiated version of a **DepressionFinder** component. 

NOTE: The current Landlab depression finder only works with **FlowDirectorSteepest** and **FlowDirectorD8** no matter how the depression finder is run. This is because the depression finder presently only works with route-to-one methods. 

Thus, the following three ways to instantiated a **DepressionFinder** are equivalent.
"""

# option 1: Full name of FlowDirector
fa = FlowAccumulator(
    mg,
    surface="topographic__elevation",
    flow_director="FlowDirectorD8",
    depression_finder="DepressionFinderAndRouter",
)

# option 2: Uninstantiated FlowDirector Component
fa = FlowAccumulator(
    mg,
    surface="topographic__elevation",
    flow_director=FlowDirectorD8,
    depression_finder="DepressionFinderAndRouter",
)

# option 3: Instantiated FlowDirector Component
fd = FlowDirectorD8(mg)
df = DepressionFinderAndRouter(mg)
fa = FlowAccumulator(
    mg, surface="topographic__elevation", flow_director=fd, depression_finder=df
)

"""
Methods for specifying can be mixed, such that the following is permissible. 
"""

df = DepressionFinderAndRouter(mg)
fa = FlowAccumulator(
    mg, surface="topographic__elevation", flow_director="D8", depression_finder=df
)

"""
### Using the DepressionFinder with FlowAccumulator

To conclude this tutorial, we examine an example of a Hexagonal Model grid with a depression.
"""

hmg = HexModelGrid((9, 5))
_ = hmg.add_field("topographic__elevation", hmg.x_of_node + hmg.y_of_node, at="node")

fa = FlowAccumulator(hmg, flow_director="MFD")
fa.run_one_step()
plt.figure()
drainage_plot(hmg)

plt.figure()
drainage_plot(hmg, "drainage_area")

"""
We will put a depression in the middle of the topography, and then see what the drainage plot looks like. 
"""

hmg_hole = HexModelGrid((9, 5))
z = hmg_hole.add_field(
    "topographic__elevation",
    hmg_hole.x_of_node + np.round(hmg_hole.y_of_node),
    at="node",
)
hole_nodes = [21, 22, 23, 30, 31, 39, 40]
z[hole_nodes] = z[hole_nodes] * 0.1

fa = FlowAccumulator(hmg_hole, flow_director="Steepest")
fa.run_one_step()
plt.figure()
drainage_plot(hmg_hole)

plt.figure()
drainage_plot(hmg_hole, "drainage_area")

"""
As you can see, the flow gets stuck in the hole. We'd like the flow in the hole to move out and to the boundary. 

To route the flow out of the hole, we have two options. 
1. Run the **FlowAccumulator** and then the **DepressionFinder**
2. Run them together in **FlowAccumulator**. 

The options look like the following and they are equivalent. 
"""

# OPTION 1
fa = FlowAccumulator(hmg_hole, flow_director="Steepest")
fa.run_one_step()

df = DepressionFinderAndRouter(hmg_hole)
df.map_depressions()

# OPTION 2
fa = FlowAccumulator(
    hmg_hole, flow_director="Steepest", depression_finder="DepressionFinderAndRouter"
)
fa.run_one_step()
plt.figure()
drainage_plot(hmg_hole, "drainage_area")

"""
As you can see the flow is now routed out of the hole and down to a boundary. 

## Conclusion

This tutorial went over how to run the **FlowAccumulator**. To learn more, consider one of two additional tutorials about directing and accumulating flow in Landlab:

1. **Introduction to FlowDirector**: A tutorial that goes over the different **FlowDirectors** present in Landlab and how to create and run a **FlowDirector**.

2. **Comparison of FlowDirectors**: A tutorial that constrasts the different methods in more detail and over surfaces that are more complicated than a simple sloping ramp. 
"""



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/the_FlowDirectors.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to FlowDirectors

Landlab directs flow and accumulates it using two types of components:

**FlowDirectors** use the topography to determine how flow moves between adjacent nodes. For every node in the grid it determines the nodes to receive flow and the proportion of flow to send from one node to its receiver. 

The **FlowAccumulator** uses the direction and proportion of flow moving between each node and (optionally) water runoff to calculate drainage area and discharge. 

The **FlowDirectors** are method-specific, and presently landlab supports four different methods for determining flow direction. 

1. **FlowDirectorSteepest** Flow is routed to only one node. The algorithm considers the link slopes leaving from each node and chooses the steepest downhill link to route flow along. In the case of a raster grid, only the links are considered (Landlab differentiates between *links*, which never cross and are located at North, South, East, and West on a raster grid, and *diagonals*, which cross and are located at North East, North West, South East, and South West). For raster grids, this method is also known as D4 flow routing. In the case of irregular grids, all links originating from a node are consideded.

2. **FlowDirectorD8** (raster only) Flow is only routed to one node but diagonals are also considered. 

3. **FlowDirectorMFD** Flow is directed to all nodes that are located downhill of the source node. In the case of raster grid diagonals can be included using the keyword ```diagonals=True```. Flow is partitioned between receiver nodes based on the relative slope along the links leading to the receiver nodes. The default method for partitioning is based on the sum of receiver slopes (```partition_method='slope'```). Partitioning can also be done on the basis of the square root of slope which gives the result of a steady kinematic wave (```partition_method='square_root_of_slope'```).

4. **FlowDirectorDINF** (raster only) Flow is directed to two cells based on the slope of the triangular facets that can be defined between a node and its neighbors. The steepest downhill facet is chosen and then flow is partitioned between the receiver nodes at the bottom of that facet based on the relative slopes along the facet-bounding links. (The method, known as "D-infinity", is described by Tarboton (1997, Water Resources Research, 33(2), 309-319)).

In this tutorial we will go over how to initialize and run a **FlowDirector**, and briefly compare the different flow direction algorithms. For information on how to initialize and run the **FlowAccumulator** or more detailed examples that contrast the differences between each flow direction algorithm, refer to the other tutorials in this section. 

First, we import the necessary Python modules and make a small plotting routine. 
"""

import matplotlib.pyplot as plt
from matplotlib import cm

from landlab import HexModelGrid, RasterModelGrid
from landlab.components import (
    FlowDirectorD8,
    FlowDirectorDINF,
    FlowDirectorMFD,
    FlowDirectorSteepest,
)
from landlab.plot.drainage_plot import drainage_plot


# create a plotting routine to make a 3d plot of our surface.
def surf_plot(mg, surface="topographic__elevation", title="Surface plot of topography"):
    plt.figure()
    ax = plt.axes(projection="3d")

    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    color = cm.gray((Z - Z.min()) / (Z.max() - Z.min()))
    ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
    )
    ax.view_init(elev=35, azim=-120)
    ax.set_xlabel("X axis")
    ax.set_ylabel("Y axis")
    ax.set_zlabel("Elevation")
    plt.title(title)
    plt.show()

"""
## Topographic grid

For this tutorial we will consider one topographic surface. A separate tutorial exists that compares multiple grids and highlights the difference in flow direction and accumulation between the different methods. 
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")
surf_plot(mg1, title="Grid 1: A basic ramp")

"""
## Initalizing and running a FlowDirector

To instantiate a flow director, you must pass it the minimum of a model grid that has a field called ```'topographic__elevation'```. Alternatively, you can pass it the name of another field name at node, or an array with length number of nodes. 


"""

fd = FlowDirectorSteepest(mg1, "topographic__elevation")

"""
The **FlowDirectors** are method specific, so if you want to do D8 flow directing, you must use **FlowDirectorD8**.

All of the **FlowDirectors** have two public methods: ```run_one_step()``` and ```direct_flow()```.

Both use the values of the surface provided to identify flow directions (and in the case of directing to more than one receiver, proportions). Both store the same information about receivers, proportions, and other calculated values to the model grid as fields. The difference is that ```run_one_step()``` does not return any values while ```direct_flow()``` returns the receiver array in **FlowDirectorSteepest** and **FlowDirectorD8**, and the receiver and proportion arrays in **FlowDirectorMFD** and **FlowDirectorDINF**. 
"""

fd.run_one_step()

receivers = fd.direct_flow()

print(receivers)

"""
We can illustrate the receiver node **FlowDirectionSteepest** has assigned to each donor node using a plotting function in Landlab called ```drainage_plot```. We will see many of these plots in this tutorial so let's take a moment to walk through the plot and what it contains. 

- The background image (white to black) shows the values of topographic elevation of the underlying surface or any other at_node field we choose to plot.

- The colors of the dots inside of each pixel show the locations of the nodes and the type of node. 

- The arrows show the direction of flow, and the color shows the proportion of flow that travels along that link. 

- The X on top of a node shows indicates that the node is a local sink and flows to itself. 

Note that in Landlab *Boundary Nodes*, or nodes that are on the edge of a grid, do not have area and do not contribute flow to nodes. These nodes can either be *Fixed Gradient Nodes*, *Fixed Value Nodes*, or *Closed Nodes*. With the exception of *Closed Nodes* the boundary nodes can receive flow. 

An important step in all flow direction and accumulation is setting the proper boundary condition. Refer to the boundary condition tutorials for more information. 
"""

plt.figure()
drainage_plot(mg1, title="Basic Ramp using FlowDirectorSteepest")

"""
Reassuringly we can see that the flow is being sent from high elevations at the top of the grid to low elevations at the bottom of the grid. We can also see that all of the arrows are yellow, and thus all of the flow is traveling on these links. 

## Brief Comparison between FlowDirector methods

Now let's see how the other **FlowDirectors** direct the flow on this simple grid. We don't need to specify the surface so long as it is the field ```'topographic__elevation'```.
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")
fd = FlowDirectorD8(mg1)
fd.run_one_step()
plt.figure()
drainage_plot(mg1, title="Basic Ramp using FlowDirectorD8")

"""
For this ramp, the steepest slope is down a link, and not a diagonal, so **FlowDirectorD8** gives the same result as **FlowDirectorSteepest**.
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")
fd = FlowDirectorMFD(mg1, diagonals=False)  # diagonals=False is the default option
fd.run_one_step()
plt.figure()
drainage_plot(mg1, title="Basic Ramp using FlowDirectorMFD without diagonals")

"""
Similarly, while there is more than one node below each core node, there is only one node that is connected by a link and not a diagonal. Thus **FlowDirectorMFD** with the keyword ```diagonals``` set to ```True``` provides the same results as **FlowDirectorSteepest** and **FlowDirectorD8**
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")
fd = FlowDirectorMFD(mg1, diagonals=True)
fd.run_one_step()
plt.figure()
drainage_plot(mg1, title="Basic Ramp using FlowDirectorMFD with diagonals")

"""
When we permit flow along diagonal connections between nodes and flow to all downhill nodes, we see a difference in the directing pattern on this simple ramp. The flow is partitioned between the three downhill nodes, and there is more flow being sent to along the link as compared with the diagonals (the links are a lighter color blue than the diagonals). We can print out the proportion of flow, which is stored as a (number of nodes, number of possible receivers) array for **FlowDirectorMFD**. We will just print one node for clarity. The order of the receivers is in line with the standard Landlab ordering. The array will list the receiver proportions in the following order:

    [link to East,
    link to North,
    link to West,
    link to South,
    diagonal to North East,
    diagonal to North West,
    diagonal to South West,
    diagonal to South East]
"""

print(mg1.at_node["flow__receiver_proportions"][15])

"""
As we can see, the flow is moving on the link to the South, the South West and South East. There is about a third of the flow moving on the links and diagonals, though more flow is partitioned to the link. This makes sense as the link is steeper than the diagonals. 
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")

fd = FlowDirectorMFD(mg1, diagonals=True, partition_method="square_root_of_slope")
fd.run_one_step()
plt.figure()
drainage_plot(
    mg1,
    title="Basic Ramp using FlowDirectorMFD with diagonals and steady kinematic wave partitioning",
)

"""
In the **FlowDirectorMFD** we can partition flow based on slope (default) or based on the square root of the slope. This option gives the solution to a steady kinematic wave. We can see that the proportion of flow going on the links and diagonals is more similar. 
"""

mg1 = RasterModelGrid((10, 10))
_ = mg1.add_field("topographic__elevation", mg1.y_of_node, at="node")

fd = FlowDirectorDINF(mg1)
fd.run_one_step()
plt.figure()
drainage_plot(mg1, title="Basic Ramp using FlowDirectorDINF")

"""
In **FlowDirectorDINF** flow is partitioned to two nodes based on steepness of the eight triangular facets surrounding each node. The partitioning is based on the relation between the link and diagonal slope that form the edge of the facet and the slope of the facet itself. When one of the facet edges has the same slope as the facet, as is the case in this ramp example, all of the flow is partitioned along that edge. 
"""

"""
## FlowDirectors on irregular grids 

**FlowDirectorSteepest** and **FlowDirectorMFD** work on raster, hex, and irregular grids. **FlowDirectorD8** and **FlowDirectorDINF** don't work on hex or irregular grids because the directing and partitioning algorithm that underlies each of them is specific to raster grids. 

Before concluding this tutorial, we will briefly consider a hexagonal example. 
"""

hmg = HexModelGrid((9, 5))
_ = hmg.add_field("topographic__elevation", hmg.y_of_node, at="node")
fd = FlowDirectorSteepest(hmg)
fd.run_one_step()
plt.figure()
drainage_plot(hmg)

"""
Just as in the raster example, **FlowDirectorSteepest** sends flow from donor nodes to only one receiver node. You may ask why the flow is going to the southwest while the links are just as steep to the southeast. When two links have exactly the same slope, in route-to-one methods like **FlowDirectorSteepest** and **FlowDirectorD8** landlab will choose the first steepest link it encounters while searching through the links. When diagonal links are also considered in **FlowDirectorD8** the diagonals are examined after the links. Thus if a link and a diagonal leading from one node downhill had exactly the same slope, the flow would be sent down the link. 

For a more thorough discussion and comparison of each of the **FlowDirector** algorithms, please see the tutorial "Comparison of FlowDirectors".
"""

hmg = HexModelGrid((9, 5))
_ = hmg.add_field("topographic__elevation", hmg.y_of_node, at="node")

fd = FlowDirectorMFD(hmg)
fd.run_one_step()
plt.figure()
drainage_plot(hmg)

hmg.at_node["topographic__elevation"][hmg.core_nodes].max()

"""
Using **FlowDirectorMFD** flow is partitioned equally between the two links leading downhill. 
"""

"""
## Conclusion

This tutorial went over the different **FlowDirectors** present in Landlab and how to create and run a **FlowDirector**. Next consider reviewing two additional tutorials about directing and accumulating flow in Landlab:

1. **Comparison of FlowDirectors**: A tutorial that contrasts the different methods in more detail and over surfaces that are more complicated than a simple sloping ramp. 

2. **Introduction to FlowAccumulator**: A tutorial that describes how to use the **FlowAccumulator**.
"""



================================================
File: docs/source/tutorials/flow_direction_and_accumulation/the_Flow_Director_Accumulator_PriorityFlood.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to PriorityFloodFlowRouter (priorityFlood filler, director and accumulator)

Landlab directs flow and accumulates it using FlowDirectors to determine how flow moves between adjacent nodes and a FlowAccumulator that uses the direction and proportion of flow moving between each node and (optionally) water runoff to calculate drainage area and discharge. 

Here we showcase an alternative flow router and accumualtor that wraps an external python package (richdem).  The **PriorityFloodFlowRouter** component combines filling, flow direction and accumualtion of water over structured grids in one component and significantly improves performaces of flow accumualtion and direction operations over large grids, especially when filling operations are required to route water over landscapes.

This notebook follows the structure of the FlowAccumulator and flow director notebook.  
First, we import the necessary python modules and make a small plotting routine. 
"""

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import cm

from landlab import RasterModelGrid
from landlab.components import PriorityFloodFlowRouter
from landlab.plot.drainage_plot import drainage_plot


# create a plotting routine to make a 3d plot of our surface.
def surf_plot(mg, surface="topographic__elevation", title="Surface plot of topography"):
    plt.figure()
    ax = plt.axes(projection="3d")

    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    color = cm.gray((Z - Z.min()) / (Z.max() - Z.min()))
    ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
    )
    ax.view_init(elev=35, azim=-120)
    ax.set_xlabel("X axis")
    ax.set_ylabel("Y axis")
    ax.set_zlabel("Elevation")
    plt.title(title)
    plt.show()

"""
## Topographic grids

For this tutorial we will consider one topographic surface. Here it is plotted in three dimensions. 
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
surf_plot(mg, title="Grid 1")

"""
## Initalizing and running the FlowAccumulator

To instantiate the **PriorityFloodFlowRouter**, you must pass it the minimum of a model grid that has a field called ```'topographic__elevation'```. The default behavior to deal with depressions internally. Taking care of depressions is done using the 'RichDEM' filling or breaching algorithm. The `depressionHandler` variable can be set to 'fill or 'breach' to use respectively a filling or breaching algorithm to handle depressions. If DEMs do not need to be filled, set `updateFlowDepressions` to False. 


Similar to other landlab flow accumulators, **PriorityFloodFlowRouter** can take a constant or spatially variable input called ```runoff_rate```, which it uses to calculate discharge. Alternatively, if there is an `at_node` field called ```water__unit_flux_in``` and no value is specified as the ```runoff_rate```, **PriorityFloodFlowRouter** will use the values stored in ```water__unit_flux_in```.

In addition to directing flow and accumulating it in one step, **FlowAccumulator** can also deal with depression finding internally. This can be done by passing a **DepressionFinder** to the keyword argument ```depression_finder```. The default behavior is to not deal with depressions internally. 

The `flow_metric` variable controlls the way in which water is routed over teh landscape: Various options possible: 
            * D8 (O’Callaghan and Mark, 1984) {default}
            * Rho8 (Fairfield and Leymarie, 1991)
            * Quinn (1991)
            * Freeman (1991)
            * Holmgren (1994)
            * D∞ (Tarboton, 1997)
For details and comparison, see https://richdem.readthedocs.io/en/latest/flow_metrics.html
Some of these methods require an exponent, which can be provided throught the `exponent` variable. 
When routing flow, one challenge is to define water directions in flat regions. This is way an articifical small graident is introduced in flat areas. If you want to have such routing option in flat areas, set the `epsilon` variable to True {default is True}. This ensures that there is always a local gradient.


For some applications both single and multiple flow direction and accumulation is required. 
By calculating them in the same component, we can optimize procedures invovled with filling and breaching of DEMs. Set the `seperate_Hill_Flow` variable to True if you want a second flow accumualtor calcuatled on the same filled DEM data. 
"""

fa = PriorityFloodFlowRouter(mg)

# # this is the same as writing:
fa = PriorityFloodFlowRouter(
    mg,
    surface="topographic__elevation",
    flow_metric="D8",
    update_flow_depressions=True,
    runoff_rate=None,
    depression_handler="fill",
)

"""
The **FlowAccumulator** has one public methods: ```run_one_step()```.
"""

fa.run_one_step()

"""
We can illustrate the receiver node **FlowDirectionSteepest** has assigned to each donor node using a plotting function in Landlab called ```drainage_plot```. We will see many of these plots in this tutorial so let's take a moment to walk through the plot and what it contains. 

   - The background image (white to black) shows the values of topographic elevation of the underlying surface or any other at_node field we choose to plot.

   - The colors of the dots inside of each pixel show the locations of the nodes and the type of node. 

   - The arrows show the direction of flow, and the color shows the proportion of flow that travels along that link. 

   - An X on top of a node indicates that node is a local sink and flows to itself. 

Note that in Landlab *Boundary Nodes*, or nodes that are on the edge of a grid, do not have area and do not contribute flow to nodes. These nodes can either be *Fixed Gradient Nodes*, *Fixed Value Nodes*, or *Closed Nodes*. With the exception of *Closed Nodes* the boundary nodes can receive flow. 

An important step in all flow direction and accumulation is setting the proper boundary condition. Refer to the boundary condition tutorials for more information.  
"""

plt.figure()
drainage_plot(mg)

"""
In this drainage plot, we can see that all of the flow is routed down the steepest link. A plot of the drainage area would illustrate how the flow would move. Next let's make a similar plot except that instead of plotting the topographic elevation as the background, we will plot the drainage area. 
"""

plt.figure()
drainage_plot(mg, "drainage_area")

"""
If we print out the drainage area, we can see that its maximum reaches 64, which is the total area of the interior of the grid.
"""

print(mg.at_node["drainage_area"].reshape(mg.shape))

"""
This is the same number as the number of core nodes. This makes sense becaue these are the only nodes in Landlab that have area, and in our model grid they each have an area of one. 
"""

print(mg.number_of_core_nodes)

"""
We can rain on the surface, store that rain in the field ```water__unit_flux_in```, and then re-run the **FlowAccumulator**. As an example, we will 'rain' a uniformly distributed random number between 0 and 1 on every node. 

Since we already ran the **FlowAccumulator**, under the hood our grid already has a field called ```water__unit_flux_in``` and we need to set the ```clobber``` keyword to ```True```.
"""

rain = 1.0 + 5.0 * np.random.rand(mg.number_of_nodes)

plt.imshow(rain.reshape(mg.shape), origin="lower", cmap="PuBu", vmin=0)
plt.colorbar()
plt.show()

_ = mg.add_field("water__unit_flux_in", rain, at="node", clobber=True)

"""
Next, we re-run the **FlowAccumulator** and plot the discharge. 
"""

fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
The basic pattern of drainage is the same but the values for the surface water discharge are different than for drainage area. 
"""

"""
### Various flow routing algorithms 
* D4
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(mg, surface="topographic__elevation", flow_metric="D4")
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Rho8
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(mg, surface="topographic__elevation", flow_metric="Rho8")
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Rho4
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(mg, surface="topographic__elevation", flow_metric="Rho4")
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Quinn
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(mg, surface="topographic__elevation", flow_metric="Quinn")
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Freeman
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(
    mg, surface="topographic__elevation", flow_metric="Freeman"
)
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Holmgren
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(
    mg, surface="topographic__elevation", flow_metric="Holmgren"
)
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")

"""
* Dinf
"""

mg = RasterModelGrid((10, 10))
_ = mg.add_field(
    "topographic__elevation", 3.0 * mg.x_of_node**2 + mg.y_of_node**2, at="node"
)
fa = PriorityFloodFlowRouter(mg, surface="topographic__elevation", flow_metric="Dinf")
fa.run_one_step()
plt.figure()
drainage_plot(mg, "surface_water__discharge", title="Discharge")




================================================
File: docs/source/tutorials/fracture_grid/using_fracture_grid.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab `FractureGridGenerator` component

*(Greg Tucker, University of Colorado Boulder, July 2021)*


## Introduction

Landlab' `FractureGridGenerator` is a small helper component that generates a grid in which are embedded a set of randomly aligned fractures. A fracture is described by a line of nodes for which the field `fracture_at_node` equals 1. In other words, nodes where `fracture_at_node = 1` contain one or more fractures running through or near them, and nodes where `fracture_at_node = 0` are devoid of fractures. The component was originally written to initialize a cellular automaton model of rock weathering along fracture zones. An example of a gridded fracture network used in this way can be found in [Tucker et al. (2016)](https://doi.org/10.5194/gmd-9-823-2016) Figure 9.
"""

"""
## Simple example with a raster grid


"""

import copy

import matplotlib as mpl

from landlab import RasterModelGrid, imshow_grid
from landlab.components import FractureGridGenerator

grid = RasterModelGrid((51, 51))
fg = FractureGridGenerator(grid, frac_spacing=20)
fg.run_one_step()
cmap = copy.copy(mpl.colormaps["pink"])
imshow_grid(grid, grid.at_node["fracture_at_node"], cmap=cmap)

"""
## Example with a hex grid

This example also shows how you can use the optional `seed` parameter to get a different random pattern.
"""

from landlab import HexModelGrid

grid = HexModelGrid((51, 51), node_layout="rect")
fg = FractureGridGenerator(grid, frac_spacing=10, seed=4)
fg.run_one_step()
cmap = copy.copy(mpl.colormaps["pink"])
imshow_grid(grid, grid.at_node["fracture_at_node"], cmap=cmap)

"""
### Vertically oriented hex grid
"""

grid = HexModelGrid((51, 51), node_layout="rect", orientation="vertical")
fg = FractureGridGenerator(grid, frac_spacing=10, seed=3)
fg.run_one_step()
cmap = copy.copy(mpl.colormaps["pink"])
imshow_grid(grid, grid.at_node["fracture_at_node"], cmap=cmap)

"""
## References

Tucker, G. E., Hobley, D. E., Hutton, E., Gasparini, N. M., Istanbulluoglu, E., Adams, J. M., & Nudurupati, S. S. (2016). CellLab-CTS 2015: continuous-time stochastic cellular automaton modeling using Landlab. Geoscientific Model Development, 9(2), 823-839, [https://doi.org/10.5194/gmd-9-823-2016](https://doi.org/10.5194/gmd-9-823-2016).
"""



================================================
File: docs/source/tutorials/gradient_and_divergence/gradient_and_divergence.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using Landlab's gradient and flux divergence functions

Models of geophysical flow phenomena very commonly include gradient terms and flux divergence terms in their governing equations. Consider the example of conductive heat diffusion in two dimensions. The *flux* of heat, $\mathbf{q}$, at a point (in energy per time per area) depends on the *gradient* in temperature:

$\mathbf{q} = -k\nabla T$

where $T$ is temperature, $k$ is thermal conductivity, and $\nabla T$ represents the temperature gradient (here in two dimensions):

$\nabla T = \left( \frac{\partial T}{\partial x} + \frac{\partial T}{\partial y} \right)$.

Alternatively, you can write the heat-flow vector $\mathbf{q}$ in terms of its $x$ and $y$ components:

$q_x = -k \frac{\partial T}{\partial x}$, and

$q_y = -k \frac{\partial T}{\partial y}$,

where the subscripts on $q$ denote each of the two directions. 

The time rate of change of thermal energy depends on the derivative of flux, or *flux divergence*:

$\frac{dT}{dt} \propto -\left( \frac{\partial q_x}{\partial x} + \frac{\partial q_y}{\partial y} \right)$

In a finite-difference or finite-volume solution, the quantities $T$ and $\mathbf{q}$ are solved at discrete points. Staggered-grid schemes will place the scalar quantity ($T$) at one set of grid locations, and the vector quantity ($\mathbf{q}$) at "in-between" locations.

In Landlab, such a staggered grid is easy to implement by locating scalar quantities at nodes, and locating vector quantities at links. Recall that each link connects a pair of adjacent nodes. Therefore, a link is a natural location at which to calculate and store the gradient in some scalar quantity (like temperature) that is defined on its bounding nodes.

Landlab provides a set of "one-liner" functions to calculate the gradients in a quantity located at nodes, as well as to calculate the net flux or flux divergence in a vector quantity located at faces or links. This tutorial shows you examples of how to use these.

We'll start with a tiny grid, so it's easy to see what the various flavors of the gradient and flux functions do. Then we'll try them out on the example of a landform undergoing soil creep, which is the same example used in the introductory Landlab "fault scarp" tutorial.

## Tiny grid example

We'll start with a 3-row by 4-column raster grid, with 10-meter node spacing.
"""

from landlab import RasterModelGrid

mg = RasterModelGrid((3, 4), 10.0)

"""
Create a scalar field called `z`, representing elevation of the land surface, at the grid nodes:
"""

z = mg.add_zeros("topographic__elevation", at="node")
z[5] = 5.0
z[6] = 3.6

"""
Nodes 5 and 6 are the only core nodes; the rest are (so far) open boundaries. 

Here are the values. 
"""

z

"""
Nodes in a raster grid are numbered by row, starting from the bottom. In the array above, the first four are the bottom row, the next four are the middle row, and the last four are the top row. (Note that in general, nodes in any Landlab grid will be numbered in increasing order by their $y$ coordinates; nodes with equal $y$ coordinates, as in the case of rows in a raster grid, will then be numbered in order by $x$)

We can get a slightly more intuitive picture by reshaping the array:
"""

z.reshape((3, 4))

"""
Let's take a graphical look at the elevation grid we've created. To do so, we'll use the matplotlib graphics library (imported under the name `plt`). We also have to tell the Jupyter Notebook to display plots right here on the page. Finally, we will import Landlab's `imshow_grid` function to display our gridded values.
"""

%matplotlib inline

from landlab.plot.imshow import imshow_grid

"""
Let's plot the elevation values:
"""

imshow_grid(mg, "topographic__elevation")

"""
There are elevation values associated with all 12 of the nodes on the grid. The ones shown in black are **boundary nodes**; the two in the middle are **core nodes**. This is our *scalar field*.
"""

"""
## Links and gradients

Next, we will calculate the gradient in this field of elevation values. We want to find the gradient between each pair of adjacent nodes, and store that value at the associated **link** between them.

### What are links?

For each pair of adjacent nodes in a Landlab grid, there is a corresponding **link**. Links are directed line segments whose endpoints are the coordinates of the nodes. A link can be illustrated like this:

    o---->o

Here, each o represents a node, and the arrow is the link. A "vertical" link looks like this:

    o
    ^
    |
    |
    o

The tip of the arrow is known as the **link head**; the base of the arrow is known as the **link tail**. By default, links always "point" within the upper-right half-plane.

With this definition of links in mind, we can sketch our grid like so, with the ID numbers of the nodes shown by the numbers:


    8 ----> 9 ----> 10----> 11
    ^       ^       ^       ^
    |       |       |       |
    |       |       |       |
    4 ----> 5 ----> 6 ----> 7
    ^       ^       ^       ^
    |       |       |       |
    |       |       |       |
    0 ----> 1 ----> 2 ----> 3


If we label each node with its elevation value, it looks like this:


    0 ----> 0 ----> 0 ----> 0
    ^       ^       ^       ^
    |       |       |       |
    |       |       |       |
    0 ---->5.0---->3.6----> 0
    ^       ^       ^       ^
    |       |       |       |
    |       |       |       |
    0 ----> 0 ----> 0 ----> 0

"""

"""
### Calculating the gradient of a node field at links

To calculate the gradient of a node field, with one gradient value for each link, use the function `calc_grad_at_link`:
"""

dzdx = mg.calc_grad_at_link(z)
dzdx

"""
Here's a crude graphical representation of gradient array:


    o ---0--> o ---0--> o ---0--> o
    ^         ^         ^         ^
    0       -0.5      -0.36       0
    |         |         |         |
    o  +0.5 > o -0.14 > o -0.36 > o
    ^         ^         ^         ^
    0       +0.5      +0.36       0
    |         |         |         |
    o ---0--> o ---0--> 0 ---0--> 0

Links are listed in order by the $(x, y)$ coordinates of their midpoints. The ID numbering scheme for our links looks like this:


    o --14--> o --15--> o --16--> o
    ^         ^         ^         ^
    10       11        12        13
    |         |         |         |
    o ---7--> o ---8--> o ---9--> o
    ^         ^         ^         ^
    3         4         5         6
    |         |         |         |
    o ---0--> o ---1--> 0 ---2--> 0

Let's explore how the geometry and the values in the ID array of gradients correspond. Here are the gradients first three are the horizontal links along the bottom edge of the grid:
"""

dzdx[0:3]

"""
Next come four vertical links that connect the bottom to the middle rows of nodes. Two of these values are positive, indicating an *uphill gradient in the direction of the links*:
"""

dzdx[3:7]

"""
Now the middle row of horizontal links:
"""

dzdx[7:10]

"""
The next row of vertical links. The middle two of these are negative, indicating a downhill slope in the direction of the links:
"""

dzdx[10:14]

"""
Finally, the top row of horizontal links:
"""

dzdx[14:17]

"""
An alternative way to inspect link-based values in a raster grid is to use the `horizontal_links` and `vertical_links` grid attributes:
"""

dzdx[mg.horizontal_links]

dzdx[mg.vertical_links]

"""
So far, we've seen how to perform a centered-difference gradient calculation using Landlab's `calc_grad_at_link` function. Next, let's look at the flux divergence operation: adding up all the incoming and outgoing fluxes at a location.

## Cells and flux divergence

### A quick look at finite-volume numerical methods

The *finite-volume method* is a type of numerical approach that is similar to the more familiar finite-difference method. For some problems that are discretized on a regular grid, the two methods turn out to be equivalent. For our next step, we'll take a finite-volume approach, which turns out to be fairly intuitive.

Consider a rectangular *cell* of dimensions $\Delta x$ by $\Delta y$:

    o-------o
    |       |
    |       |
    |       |
    o-------o

Imagine that the cell represents a patch of ground on a hill. Along each edge of the rectangle, soil is gradually flowing either into or out of the cell. If more soil flows in than flows out, the cell's elevation will rise (we are assuming the soil bulk density is constant). If more soil flows out than flows in, the cell's elevation will shrink.

Suppose we know the average soil flux along each side of the cell. If we use the compass directions *N, S, E, W* to denote the four sides, we might represent these average fluxes as follows: $q_N, q_S, q_E, q_W$.

Let's take the convention that flow is always *positive* when it is going north or east, and negative when it is going south or west. With that in mind, we could compute the *net outflux of soil* as follows:

$Q_{net} = -q_E \Delta y - q_N \Delta x + q_W \Delta y + q_S \Delta x$

The *rate* at which the cell's average elevation is rising or falling could be expressed as:

$\frac{dz}{dt} = -\frac{Q_{net}}{\Delta x \Delta y}$

The term on the right side is a finite-volume approximation of the flux divergence. In commonly used symbols,

$\nabla \mathbf{q} = \left( \frac{\partial q_x}{\partial x} + \frac{\partial q_y}{\partial y} \right) \approx \frac{Q_{net}}{\Delta x \Delta y}$

This is the quantity we would like to calculate for the nodes in our grid.

### More on grid geometry: nodes and cells

In a Landlab grid, a *cell* is a polygon that contains a single *node*, which is a point. Every cell has one and only one node. However, not every node has a cell: the grid's perimeter consists of nodes without cells.

In our tiny grid example, there are 12 nodes. Ten of these lie on the grid's perimeter. Therefore, our grid has only two cells: one containing node 5, and one containing node 6. The geometry is crudely sketched here:


    b       b       b       b

        .-------.-------.
        |       |       |
    b   |   c   |   c   |   b
        |       |       |
        .-------.-------.

    b       b       b       b


Here, the letter `b` represents boundary nodes (10 of them), the letter `c` represents core nodes (2 of them), and the lines are the *faces* of the two cells. (The periods are called *corners*; we won't deal with them further in this tutorial.)

Our aim is to calculate a *soil flux* across each cell face, and then add up all in the incoming and outgoing fluxes.

Before we do this, notice that each face is crossed by a link. For example, there is a link running from the left core node to the right core node. Our strategy, therefore, will be to calculate a flux value for each link in the grid. The model we'll use will be the soil-transport law (sometimes known as Gilbert's Law):

$\mathbf{q} = -D \nabla z$

Here, $\nabla z$ is simply the gradient. We have already discretized the gradient, placing the gradient between each pair of adjacent nodes at the corresponding link. *This means we have already defined values of the gradient across each cell face* (as well as several links along the grid perimeter that don't cross cell faces).

We can calculate fluxes along grid links with a single expression: 
"""

D = 0.01
q = -D * dzdx
q

"""
Now, in order to calculate the flux divergence at our two cells, we need to do the following steps:

1 - For each cell, multiply the four flux values by the width of the cell (which is the same for every face in this grid).

2 - Add up the incoming fluxes and subtract the outgoing fluxes.

3 - Divide by the area of the cell.

The result will be a numerical approximation of the flux-divergene term.

It turns out that you can do this with a single Landlab function call:
"""

dqda = mg.calc_flux_div_at_node(q)

"""
At this point, you might be wondering why the function name says `_at_node` rather than `at_cell`. This is because Landlab assigns a value to each node. For the perimeter nodes, the value will be zero, because they have no cells and the calculation is meaningless. However, the two *core nodes*, which do have cells, **will** have meaningful values. Let's look at these values:
"""

dqda.reshape((3, 4))

"""
Flux-divergence values for the two core nodes are 0.00164 and 0.00094, respectively. Let's look at how these values came to be. For node 5, the fluxes per unit width ("unit fluxes") along the faces of its cell are as follows:

$q_E = -0.005$ m$^2$/yr

$q_N = -0.005$ m$^2$/yr

$q_W = -0.0014$ m$^2$/yr

$q_S = -0.005$ m$^2$/yr

So, this cell is leaking soil in every direction. The *total* fluxes along each cell, which we'll represent with the symbol $Q$, are obtained by multiplying each unit flux by the width of the face, which in this case is 10 meters:

$Q_E = -0.05$ m$^3$/yr

$Q_N = -0.05$ m$^3$/yr

$Q_W = -0.014$ m$^3$/yr

$Q_S = -0.05$ m$^3$/yr

The total volume loss rate from the cell is 0.164 m$^3$/yr. Dividing this by the cell's surface area of 100 m$^2$, the cell's rate of change in average elevation is 0.00164 m/yr.

For node 6, the unit fluxes are:

$q_E = -0.0036$ m$^2$/yr

$q_N = -0.0036$ m$^2$/yr

$q_W = +0.0014$ m$^2$/yr

$q_S = -0.0036$ m$^2$/yr

So the cell at node 6 is leaking soil in three directions, but gaining a little bit from the higher cell to its west.
Its total fluxes are:

$Q_E = -0.036$ m$^3$/yr

$Q_N = -0.036$ m$^3$/yr

$Q_W = +0.014$ m$^3$/yr

$Q_S = -0.036$ m$^3$/yr

This gives a net flux of 0.094 m$^3$/yr, and a rate of elevation change of 0.00094 m/yr.

If you want the net flux rather than flux divergence, you can get this with the `calc_net_flux_at_node` function:
"""

mg.calc_net_flux_at_node(q).reshape((3, 4))

"""
Notice that it correctly returns the values we computed above.

## Not just for raster grids

The grid functions `calc_grad_at_link` and `calc_flux_div_at_node` functions also work on hexagonal and irregular grids. Under the hood, Landlab takes account of the differences in face width, link length, cell area, and so on.

## Optimizing performance

With the usage illustrated above, Landlab will create and populate a new return array each time you call one of these functions. This costs computing time. To speed things up, you can pre-allocate your arrays and pass them in as arguments using the `out` keywork. For example, an alternative way to do our gradient calculation is as follows:
"""

# Do this step ONCE, on initialization
dzdx = mg.add_zeros("topographic__gradient_of_elevation", at="link")

# Do this step many times, in a loop
mg.calc_grad_at_link(z, out=dzdx)
dzdx

"""
In this case Landlab will places the results of the calculation in the array you passed, rather than allocating memory for a new array. The same applies to `calc_flux_div_at_node` and `calc_net_flux_at_node`.

In the example above, we created `dzdx` as a grid field, but you can alternatively pass in an empty or zero-valued NumPy array:
"""

from numpy import zeros

# Do this step ONCE, on initialization
dzdx = zeros(mg.number_of_links)

# Do this step many times, in a loop
mg.calc_grad_at_link(z, out=dzdx)
dzdx

"""
## Where to learn more

- The **fault scarp tutorial** provides an example of `calc_grad_at_link` and `calc_flux_div_at_node`

- See entries for these two functions in Landlab's *Reference Manual and API Documentation*


"""



================================================
File: docs/source/tutorials/grids/diverse_grid_classes.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Diverse grid classes

We present the diversity of grid classes available in Landlab, put in their historical context and advantages. Creation and display of each class is indicated by a portion of code which produces the figures indicated in the text.
"""

"""
1. [Introduction](#Introduction)
2. [NetworkModelGrid.](#NetworkModelGrid)
3. [RasterModelGrid.](#RasterModelGrid)
4. [HexModelGrid.](#HexModelGrid)
5. [RadialModelGrid.](#RadialModelGrid)
6. [VoronoiDelaunayGrid.](#VoronoiDelaunayGrid)
7. [FramedVoronoiGrid.](#FramedVoronoiGrid)
8. [IcosphereGlobalGrid.](#IcosphereGlobalGrid)

<img src="media/Grids1.png"/><br>
**Fig. 1.** Geometry and topology of grid elements on diverse Landlab grids ([Hobley et al., 2017](https://doi.org/10.5194/esurf-5-21-2017)).

"""

"""
## Introduction

Modeling can be used to test the impact of a process on an object and its properties through time and space. For instance, we can model the impact of mass wasting (the process) on the earth surface (the object) and its topographic elevation (the property). To do this, we need to represent the ***surface*** and its elevation. We could represent this property by a continuous 2-D function, such as a sinusoidal or a polynomial envelope. This is not always simple and practicable (see [Gerya, 2010, p. 37](https://doi.org/10.1017/9781316534243)). Some processes are simulated by partial differential equations. These equations can't always be solved analytically. That roughly means that they can't be easily solved the way x^2 = y + 3 * 3 can be solved (x being the property value before the impact of the process, y the value after the impact of the process). We usually solve these equations numerically. This requires ***discretizing*** the values of the surface properties.

To discretize property values, we represent the surface in a ***grid*** of small ***cells*** (also called a mesh) and affect to each cell a value for the property. The value is considered as an average over the cell. This representation is called ***tessellation***. It is also called tiling if the cells are regular. A tessellated space only contain cells that don't overlap with each other, and that don't have a gap between each other.

We can also represent the surface in a spatial grid of ***nodes*** and affect a property value to each of them. In this case, the surface is also tessellated in cells. A node is then the single point located at the center of each cell. Two nodes can have a ***link***. Using nodes and links is convenient to represent the fluxes or moves between cells, or to ease computation, for instance of gradients.
"""

"""
## NetworkModelGrid

Board games (review in [Depaulis, 2020](https://doi.org/10.2478/bgs-2020-0007)) are probably the oldest activity consisting in representing surfaces and properties. These games consist in moving pieces from a position to another on a surface, either to win a race or to win a war. The set of positions is limited, and the moves follow a set of rules: pieces can't go where they want and the way they want. Then the simplest way to represent the surface and its rule is using a network grid. Positions are represented by points, also called nodes, and the possible paths are represented by links. The ancient board of the alquerque game, the ancestor of checkers, is an illustration of this class of grids. 

In Landlab, this class is implemented by the ***NetworkModelGrid***. A regular grid instance of this class is shown **Fig. 2**. Note that the implementation of the NetworkGrid allows irregular networks, where links are of variable lengths and directions. The NetworkModelGrid class is adapted for surfaces subject to fluxes of particles or agents which are constrained by the river or the road network (See [the network_sediment_transporter notebook](../network_sediment_transporter/network_sediment_transporter.ipynb)). <br>
"""

# Code to create and display a NetworkModelGrid similar to the alquerque board

import matplotlib.pyplot as plt
import numpy as np

from landlab import NetworkModelGrid
from landlab.plot import graph

# nodes
x_n = 5  # number of nodes on a vertical line
y_n = 5  # number of nodes on a horizontal line
n = x_n * y_n  # number of nodes
# x-coordinates of nodes
x = np.array([])
for i in range(x_n):
    x = np.append(x, np.arange(x_n, dtype=float))
# y-coordinates of nodes
y = np.sort(np.repeat(np.arange(y_n, dtype=float), y_n))

# links
# horizontal links
lh = []
for j in range(y_n):
    lh += [(i + j * y_n, i + j * y_n + 1) for i in range(x_n - 1)]
# vertical
lv = [(i, i + y_n) for i in range(n - y_n)]
# diagonal 1
ld1 = []
for j in [0, 2]:
    ld1 += [(i + j * y_n, i + (j + 1) * y_n + 1) for i in [0, 2]]
for j in [0, 2]:
    ld1 += [(5 + 1 + i + j * y_n, 5 + 1 + i + (j + 1) * y_n + 1) for i in [0, 2]]
# diagonal 2
ld2 = []
for j in [0, 2]:
    ld2 += [(2 + i + j * y_n, 2 + 8 + i + j * y_n) for i in [0, 2]]
links = tuple(lh + lv + ld1 + ld2)

# grid
params = {"yx_of_node": (y, x), "links": links, "xy_axis_units": ""}

grid = NetworkModelGrid(**params)  # grid creation


print("\033[1mFig. 2A.\033[0m Node view.")
graph.plot_graph(grid, at="node")  # display
plt.show()
print("\033[1mFig. 2B.\033[0m Link view. The grid reproduces an alquerque board game.")
graph.plot_graph(grid, at="link", with_id=False)  # display

"""
## RasterModelGrid

Board games can be more complex than checkers. For instance, chess splits pieces in a diverse family. Their members don't follow the same rules to move, and these rules depend on the color property value of their initial position. The network grid has an inconvenient for this use, because visibility of the property values can be hindered by the pieces. Players rather use a grid of squares. Square and rectangular grids are implemented by the ***RasterModelGrid*** (**Fig. 3**). Note that NetworkModelGrid and RasterModelGrid can be combined (see the [run_network_generator_OpenTopoDEM notebook](../network_sediment_transporter/run_network_generator_OpenTopoDEM.ipynb)).

Square grids are the most commonly used grids in modeling. Most probably, you will prototype your model with a square grid. Still, many clues, such as the chinese character for a field, 田, point to a justification of the square grid dating back to the beginning of agriculture and land and work division. Square grids are practical because many mathematical operations on them are simple. Still, links of square grids can complexify the computation of fluxes between cells, because these links can be orthogonal to faces and ***diagonal***. Presently, with efficient algorithms and massive computer power, other classes of grids can have easy access to practical coordinate systems, resampling, combination of several grids. 

Then, the RasterModelGrid should be preferred when the model use or produce rasters of remote sensing data or digital elevation models, which would be too time-expensive to convert in another class of grids (see the [reading_dem_into_landlab notebook](../reading_dem_into_landlab/reading_dem_into_landlab.ipynb) and the sections 1. to 3. using BMI Opentopography to download a SRTM DEM and convert it into a grid, within the [run_network_generator_OpenTopoDEM notebook](../network_sediment_transporter/run_network_generator_OpenTopoDEM.ipynb)).
"""

# Code to create and display a RasterModelGrid similar to a chessboard

# Libraries
import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.plot import graph

x_n = y_n = 8  # number of nodes on a horizontal and a vertical line
n = x_n * y_n  # number of nodes

# grid creation.
# Shape is a tuple of the number of rows y_n and the number of columns x_n.
grid = RasterModelGrid(shape=(y_n, x_n))

# creation of the color property and affectation of values for each node, using their id = i + j
color_array = np.array([(i + j) % 2 for i in range(x_n) for j in range(y_n)])
color = grid.add_field("color", color_array, at="node", dbtype=float)

# display
print(
    "\033[1mFig. 3A.\033[0m Cell view with color property. The grid reproduces a chess board."
)
imshow_grid(grid, "color", cmap="Greys", limits=(0, 1), allow_colorbar=False)
plt.show()

print("\033[1mFig. 3B.\033[0m  Node view.")
graph.plot_graph(
    grid, at="node", with_id=True
)  # with_id=True allows the display of node ids

print(
    "\033[1mFig. 3C.\033[0m  Link view. Note that diagonal links are not represented because of a bug of the method."
)
graph.plot_graph(grid, at="link", with_id=False)

"""
## HexModelGrid

The most promissing type of regular grid is hexagonal like an Agon board game. It is implemented by the ***HexModelGrid*** (**Fig. 3**). This type of grid presents some advantages for modeling ([Birch et al., 2007](https://doi.org/10.1016/j.ecolmodel.2007.03.041) and [H3 by Uber](https://h3geo.org/). All links are orthogonal, which is favorable to study connections, least expensive paths, and fluxes. Hexagons have properties close to circles (tesselation can't use circles because of the gaps or overlapping between cells). They are adapted to modeling on large areas of a planet, because they better fit curved surfaces. They also have a small perimeter/area ratio, which reduces the edge effects of the grid. And natural patterns are usually more curvilinear than rectilinear. Hexagons help to visually spot these patterns without rectilinear modeling artefacts.

The HexModelGrid is an interesting compromise between RasterModelGrid and irregular grids. The hex grid is used in the [landlab-fault-scarp](../fault_scarp/landlab-fault-scarp.ipynb) and the [listric_kinematic_extender notebooks](../tectonics/listric_kinematic_extender.ipynb).

**Comment**: Another type of regular grid is the triangular grid, which is not implemented in Landlab. The applications of triangular grids in geomodeling might be limited. Contrary to square and hex grids, cells are oriented in two directions. Similar to the square grids, links can also be diagonal. 
"""

# Code to create and display a HexModelGrid

# Libraries
import numpy as np

from landlab import HexModelGrid, imshow_grid
from landlab.components import FlowDirectorSteepest
from landlab.plot import graph
from landlab.plot.drainage_plot import drainage_plot

x_n = 7  # number of nodes at the bottom edge of the hexagon
y_n = 13  # number of nodes at the left edge of the hexagon

# Shape is a tuple of the number of rows y_n and the number of columns x_n.
grid = HexModelGrid((y_n, x_n), node_layout="hex")
n = grid.number_of_nodes  # number of nodes

# creation of the color property and affectation to each node by using their ids (8, 16, etc ...)
color_array = np.ones(n)
for i in [
    17,
    18,
    19,
    20,
    21,
    26,
    31,
    36,
    38,
    39,
    40,
    42,
    47,
    49,
    52,
    54,
    59,
    61,
    63,
    65,
    67,
    72,
    74,
    77,
    79,
    84,
    86,
    87,
    88,
    90,
    95,
    100,
    105,
    106,
    107,
    108,
    109,
]:
    color_array[i] = 0.0
color = grid.add_field("color", color_array, at="node", dbtype=float)
grid.at_node["color"][grid.boundary_nodes] = 0

# construction of a drainage network based on the color property values
dir = FlowDirectorSteepest(grid, surface="color")
dir.run_one_step()

# display
print(
    "\033[1mFig. 4A.\033[0m Cell view with color property. The grid reproduce an agon game board."
)
imshow_grid(
    grid,
    "color",
    cmap="autumn",
    limits=(0, 1),
    allow_colorbar=False,
    show_elements=True,
)
# show_elements allows to draw cell contour, except for RasterModelGrid
plt.show()

print(
    "\033[1mFig. 4B.\033[0m Cell and node (dots and crosses) view. The boundary nodes don't have cells."
)
drainage_plot(grid, surface="color")
imshow_grid(
    grid,
    "color",
    cmap="Greys",
    limits=(0, 100),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print("\033[1mFig. 4C.\033[0m  Node view.")
graph.plot_graph(grid, at="node", with_id=True)
plt.show()

print("\033[1mFig. 4D.\033[0m  Link view.")
graph.plot_graph(grid, at="link", with_id=False)

"""
## RadialModelGrid

While HexModelGrid helps to improve modeling of natural objects, it's still not the panacea to investigate circular objects. Radial grids can be used to model the uplift and erosion of a volcano. It also can be used to model a cross-section of a cooling planetesimal. Radial grids can be structured as a series of rings of quadrilaterals, surrounding a circular set of triangles, with a size of cells varying with the distance from the center. In Landlab, radial grids are implemented by the ***RadialModelGrid*** (**Fig. 5.**) , which consists of rings of hexagonal cells, with a central heptagon cell. Cell areas are similar but their shapes differ according to their position.
"""

# Code to create and display a RadialModelGrid

# Libraries
import numpy as np

from landlab import RadialModelGrid, imshow_grid
from landlab.components import FlowDirectorSteepest
from landlab.plot import graph
from landlab.plot.drainage_plot import drainage_plot

rings_n = 5  # number of rings
outer_nodes_n = 8  # number of nodes on the outer boundary of the grid

grid = RadialModelGrid(rings_n, outer_nodes_n)  # grid creation
n = grid.number_of_nodes  # number of nodes

# creation of the color property
# generation of random colors and set the boundary colors to 0
random_generator = np.random.Generator(np.random.PCG64(200))
color_array = random_generator.random(n)
color_array[grid.boundary_nodes] = 0

color = grid.add_field("color", color_array, at="node", dbtype=float)

# construction of a drainage network based on the color property values
dir = FlowDirectorSteepest(grid, surface="color")
dir.run_one_step()

# display
print("\033[1mFig. 5A.\033[0m Cell view with color property.")
imshow_grid(
    grid,
    "color",
    cmap="terrain",
    limits=(0, 1),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print(
    "\033[1mFig. 5B.\033[0m Cell and node (dots and crosses) view. The boundary nodes don't have cells."
)
drainage_plot(grid, surface="color")
imshow_grid(
    grid,
    "color",
    cmap="Greys",
    limits=(0, 100),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print("\033[1mFig. 5C.\033[0m  Node view.")
graph.plot_graph(grid, at="node", with_id=False)

print("\033[1mFig. 5D.\033[0m  Link view.")
graph.plot_graph(grid, at="link", with_id=False)

"""
## VoronoiDelaunayGrid

Irregular grids (**Fig. 6-7**) can be advantageous to model earth surface processes [Braun & Sambridge, 1997](https://doi.org/10.1046/j.1365-2117.1997.00030.x). But they are still not commonly adopted. These grids are constructed from nodes that are not regularly organized on the surface. Their position can be random or link to a point of interest, for instance weather stations. Then, we construct Voronoi cells for the set of nodes. The Voronoi construction aims to make each node the closest node for all the points within its cell. Then, the links between the nodes are constructed following a Delaunay triangulation. This triangulation optimizes the construction so that no link cross another link and makes a network of triangles which edges are the links.

The landscapes generated using irregular grids appear more natural because of the absence of regularity. The drainage network forms without favoring specific directions, even when close to the grid boundaries, and has roughly similar patterns and properties whatever the resolution. Irregular grids can also tackle geomorphological objects with complex geometries.

In Landlab, irregular grids are implemented with the ***VoronoiDelaunayGrid*** (**Fig. 6**) and the ***[FramedVoronoiGrid](#FramedVoronoiGrid)***. In the VoronoiDelaunayGrid, the user has to input x-y coordinates of nodes. To carry out flow direction, the user has also to set up the boundary nodes.
"""

# Code to create and display a VoronoiDelaunayGrid

# Libraries
import numpy as np

from landlab import VoronoiDelaunayGrid, imshow_grid
from landlab.components import FlowDirectorSteepest
from landlab.plot import graph
from landlab.plot.drainage_plot import drainage_plot

n = 49  # number of nodes
xy_lengths = [10, 10]  # dimensions of the grid

# generators of random numbers for x-y coordinates
seeds = [200, 500]
xy_random_generator = (
    np.random.Generator(np.random.PCG64(seeds[0])),
    np.random.Generator(np.random.PCG64(seeds[1])),
)
# generation of x-y coordinates
x = xy_random_generator[0].random(n) * xy_lengths[0]
y = xy_random_generator[1].random(n) * xy_lengths[1]

grid = VoronoiDelaunayGrid(x=x, y=y)  # grid creation

# Manual setting of the boundary nodes.
# Boundary is automatically set for other type of grids, except for the NetworkModelGrid
boundary_nodes = [0, 1, 4, 7, 10, 13, 14]
grid.status_at_node[boundary_nodes] = grid.BC_NODE_IS_FIXED_VALUE

# creation of the color property
# generation of random colors and set the boundary colors to 0
color_array = xy_random_generator[0].random(n)
color = grid.add_field("color", color_array, at="node")
color[boundary_nodes] = 0.0

# construction of a drainage network based on the color property values
dir = FlowDirectorSteepest(grid, surface="color")
dir.run_one_step()

# display
print("\033[1mFig. 6A.\033[0m Cell view with color property.")
imshow_grid(
    grid,
    "color",
    cmap="terrain",
    limits=(0, 1),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print(
    "\033[1mFig. 6B.\033[0m Cell and node (dots and crosses) view. The boundary nodes don't have cells."
)
drainage_plot(grid, surface="color")
imshow_grid(
    grid,
    "color",
    cmap="Greys",
    limits=(0, 100),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print("\033[1mFig. 6C.\033[0m  Node view.")
graph.plot_graph(grid, at="node", with_id=True)

print("\033[1mFig. 6D.\033[0m  Link view.")
graph.plot_graph(grid, at="link", with_id=False)

"""
## FramedVoronoiGrid

The FramedVoronoiGrid (**Fig. 7**) is an elaborated version of the VoronoiDelaunayGrid. The user input parameters to automatically calculate the positions of the nodes. The boundary nodes are automatically fixed, in a not random way. The core nodes are first positioned in a regular, rectangular pattern, and then moved by a random distance in such a way that a minimal distance between nodes is respected. This minimal distance is convenient when we have to run diffusion or river incision processes on the grid, which can become unstable for two small distances between nodes (depending on the timestep of the run).
"""

# Code to create and display a FramedVoronoiGrid

# Libraries
import numpy as np

from landlab import FramedVoronoiGrid, imshow_grid
from landlab.components import FlowDirectorSteepest
from landlab.plot import graph
from landlab.plot.drainage_plot import drainage_plot

x_n = y_n = 7  # number of nodes on a horizontal and a vertical line
n = x_n * y_n  # number of nodes

params = {
    "shape": (x_n, y_n),
    "xy_spacing": (1.0, 1.0),  # starting distance between nodes
    "xy_min_spacing": (0.25, 0.25),  # minimal x-y distance between nodes
    "seed": 200,  # the seed is
    # used to generate the pseudo-random x-y moves around the starting positions
    # (pseudo-randomness used for reproducibility)
    # set to None to generate really random moves.
    "xy_axis_units": "m",
}

grid = FramedVoronoiGrid(**params)  # grid creation

# creation of the color property
# generation of random colors and set the boundary colors to 0
random_generator = np.random.Generator(np.random.PCG64(200))
color_array = random_generator.random(n)
color_array[grid.boundary_nodes] = 0
color = grid.add_field("color", color_array, at="node")

# construction of a drainage network based on the color property values
dir = FlowDirectorSteepest(grid, surface="color")
dir.run_one_step()

# display
print("\033[1mFig. 6A.\033[0m Cell view with color property.")
imshow_grid(
    grid,
    "color",
    cmap="terrain",
    limits=(0, 1),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print(
    "\033[1mFig. 6B.\033[0m Cell and node (dots and crosses) view. The boundary nodes don't have cells."
)
drainage_plot(grid, surface="color")
imshow_grid(
    grid,
    "color",
    cmap="Greys",
    limits=(0, 100),
    allow_colorbar=False,
    show_elements=True,
)
plt.show()

print("\033[1mFig. 6C.\033[0m  Node view.")
graph.plot_graph(grid, at="node", with_id=False)

print("\033[1mFig. 6D.\033[0m  Link view.")
graph.plot_graph(grid, at="link", with_id=False)

"""
## IcosphereGlobalGrid

The earth is a planet, and planets are round. For global models of surface or near-surface processes, it is helpful to have grid types that represent the surface of a spherical or near-spherical body such as our own planet. IcosphereGlobalGrid (**Fig. 8**) is a grid type that represents a planetary surface as an *icosphere*, also known as a *geodesic polyhedron*. An icosphere is a convex polyhedron composed of triangular faces, and it has the characteristic of having a dual geometry consisting of Goldberg Polyhedra (mostly hexagons, rather like a soccer ball). A useful property of an icosphere is the ability to subdivide it to any arbirary level of resolution by subdividing each triangle into four smaller triangles. Landlab's IcosphereGlobalGrid includes both elements of the dual geometry: an icosphere composed of triangular *patches* with *nodes* as vertices and *links* as edges, and a Goldberg Polyhedron composed of pentagonal and hexagonal *cells* with *corners* as vertices and *faces* as the edges of the pentagons and hexagons. The icosphere allows a relatively even distribution of points across the surface, as compared with a latitude-longitude grid, in which points bunch together around the poles.

Unlike the various 2D grid types, the nodes and corners in an IcosphereGlobalGrid has a $z$ coordinate in addition to their $x$ and $y$ coordinates. The grid also provides the corresponding spherical coordinates $r$, $\phi$, and $\theta$ ($r$ being radial distance from the center of the sphere, $\phi$ the longitude, and $\theta$ the latitude angle measured from zero at the "south" pole (so the equator lies at $\theta = \pi/2$ and the north pole lies at $\theta = \pi$).

To create an IcosphereGlobalGrid, the user specifies a radius (default is 1) and a level of mesh densification. The mesh densification level represents the number of times the mesh is subdivided.

A good way to visualize an IcosphereGlobalGrid is to use the `landlab.io.legacy_vtk.dump` function to output to a Legacy VTK file, and read that file into ParaView or an alternative 3D visualization package.
"""

from landlab import IcosphereGlobalGrid

# Soccer ball!
grid = IcosphereGlobalGrid(radius=1.0, mesh_densification_level=1)

fig = plt.figure()
ax = fig.add_subplot(projection="3d")
ax.set_title("Cells, corners, and faces (densification level = 1)")

val_for_vertex_color = 0.25 * (grid.x_of_corner + 1) + 0.25 * (1 - grid.y_of_corner)
val_for_line_color = 0.25 * (
    1 - grid.coords_of_corner[grid.corners_at_face[:, 0], 1]
) + 0.25 * (1 + grid.coords_of_corner[grid.corners_at_face[:, 0], 0])

ax.scatter(
    grid.coords_of_corner[:, 0],
    grid.coords_of_corner[:, 1],
    grid.coords_of_corner[:, 2],
    c=val_for_vertex_color,
    cmap="Reds",
)

for i in range(grid.number_of_faces):
    ax.plot(
        grid.coords_of_corner[grid.corners_at_face[i, :], 0],
        grid.coords_of_corner[grid.corners_at_face[i, :], 1],
        grid.coords_of_corner[grid.corners_at_face[i, :], 2],
        "k",
        alpha=val_for_line_color[i],
    )

fig = plt.figure()
ax = fig.add_subplot(projection="3d")
ax.set_title("Patches, nodes, and links (densification level = 1)")

val_for_vertex_color = 0.25 * (grid.x_of_node + 1) + 0.25 * (1 - grid.y_of_node)
val_for_line_color = 0.25 * (
    1 - grid.coords_of_node[grid.nodes_at_link[:, 0], 1]
) + 0.25 * (1 + grid.coords_of_node[grid.nodes_at_link[:, 0], 0])

ax.scatter(
    grid.coords_of_node[:, 0],
    grid.coords_of_node[:, 1],
    grid.coords_of_node[:, 2],
    c=val_for_vertex_color,
    cmap="Blues",
)

for i in range(grid.number_of_links):
    ax.plot(
        grid.coords_of_node[grid.nodes_at_link[i, :], 0],
        grid.coords_of_node[grid.nodes_at_link[i, :], 1],
        grid.coords_of_node[grid.nodes_at_link[i, :], 2],
        "k",
        alpha=val_for_line_color[i],
    )

# Denser mesh, highlighting nodes
grid = IcosphereGlobalGrid(radius=1.0, mesh_densification_level=4)

fig = plt.figure()
ax = fig.add_subplot(projection="3d")

val_for_color = 0.25 * (grid.x_of_node + 1) + 0.25 * (1 - grid.y_of_node)
ax.scatter(
    grid.x_of_node,
    grid.y_of_node,
    grid.z_of_node,
    ".",
    c=val_for_color,
    cmap="Blues",
    s=0.1,
)
ax.set_title("Nodes (densification level = 4)")

_ = ax.axis("equal")

"""
Author: Sebastien Lenard <br>
Date: 2022, Aug.

Edited by Greg Tucker (added IcosphereGlobalGrid), November 2023
"""



================================================
File: docs/source/tutorials/grids/grid_object_demo.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# What happens when you create a grid object?
"""

"""
Landlab supports a range of grid types. These include both rasters (with both square and rectangular cells), and a range of structured and unstructured grids based around the interlocking polygons and triangles of a Voronoi-Delaunay tesselation (radial, hexagonal, and irregular grids).

Here, we look at some of the features of both of these types.

We can create **grid** objects with the following lines of code.
"""

import numpy as np

from landlab import HexModelGrid, RasterModelGrid, VoronoiDelaunayGrid

smg = RasterModelGrid(
    (3, 4), 1.0
)  # a square-cell raster, 3 rows x 4 columns, unit spacing
rmg = RasterModelGrid((3, 4), xy_spacing=(1.0, 2.0))  # a rectangular-cell raster
hmg = HexModelGrid(shape=(3, 4))
# ^a hexagonal grid with 3 rows, 4 columns from the base row, & node spacing of 1.
x = np.random.rand(100) * 100.0
y = np.random.rand(100) * 100.0
vmg = VoronoiDelaunayGrid(x, y)
# ^a Voronoi-cell grid with 100 randomly positioned nodes within a 100.x100. square

"""
All these various `ModelGrid` objects contains various data items (known as *attributes*). These include, for example:
* number nodes and links in the grid
* *x* and *y* coordinates of each each node
* starting ("tail") and ending ("head") node IDs of each link
* IDs of links that are active
* IDs of core nodes
* etc.

From here on we'll focus on the square raster grid as its geometry is a bit easier to think through, but all of the following applies to all grid types.

## Understanding the topology of Landlab grids

All grids consist of two interlocked sets of *points* joined by *lines* outlining *areas*. If we define data on the points we call **nodes**, then they are joined by **links**, which outline **patches**. Each node within the interior of the grid lies at the geometric center of the area of a **cell**. The cell's edges are **faces**, and the endpoints of the faces---which are also vertices of the cells---are **corners**.

Note that this kind of scheme requires one set of features to be "dominant" over the other; i.e., either not every node has a cell, *or* not every link is crossed by a face. Both cannot be true, because one or other set of features has to define the edge of the grid. Landlab assumes that the node set is primary, so there are always more nodes than corners; more links than faces; and more patches than cells.

Each of these sets of *"elements"* has its own set of IDs. These IDs are what allow us to index the various Landlab fields, which store spatial data. Each feature is ordered by **x, then y**. The origin is always at the bottom left node, unless you choose to move it (`grid.move_origin`)... except in the specific case of a radial grid, where logic and symmetry dictates it must be the central node.

Whenever Landlab needs to order something rotationally (angles; elements around a different element type), it does so following the standard mathematical convention of **counterclockwise from east**. We'll see this in practical terms a bit later in this tutorial.

The final thing to know is that **links and faces have directions**. This lets us record fluxes on the grid by associating them with, and mapping them onto, the links (or, much less commonly, the faces). All lines point into the **upper right half-space**. So, on our raster, this means the horizontal links point east and the vertical links point north.

So, for reference, our raster grid looks like this:


    NODES:                       LINKS:                       PATCHES:
    8 ----- 9 ---- 10 ---- 11    * -14-->* -15-->* -16-->*    * ----- * ----- * ----- *
    |       |       |       |    ^       ^       ^       ^    |       |       |       |
    |       |       |       |   10      11      12      13    |   3   |   4   |   5   |
    |       |       |       |    |       |       |       |    |       |       |       |
    4 ----- 5 ----- 6 ----- 7    * --7-->* --8-->* --9-->*    * ----- * ----- * ----- *
    |       |       |       |    ^       ^       ^       ^    |       |       |       |
    |       |       |       |    3       4       5       6    |   0   |   1   |   2   |
    |       |       |       |    |       |       |       |    |       |       |       |
    0 ----- 1 ----- 2 ----- 3    * --0-->* --1-->* --2-->*    * ----- * ----- * ----- *

    CELLS:                       FACES:                       CORNERS:
    * ----- * ----- * ----- *    * ----- * ----- * ----- *    * ----- * ----- * ----- *
    |       |       |       |    |       |       |       |    |       |       |       |
    |   . ----- . ----- .   |    |   . --5-->. --6-->.   |    |   3 ----- 4 ----- 5   |
    |   |       |       |   |    |   ^       ^       ^   |    |   |       |       |   |
    * --|   0   |   1   |-- *    * --2       3       4-- *    * --|       |       |-- *
    |   |       |       |   |    |   |       |       |   |    |   |       |       |   |
    |   . ----- . ----- .   |    |   . --0-->. --1-->.   |    |   0 ----- 1 ----- 2   |
    |       |       |       |    |       |       |       |    |       |       |       |
    * ----- * ----- * ----- *    * ----- * ----- * ----- *    * ----- * ----- * ----- *


## Recording and indexing the values at elements

Landlab lets you record values at any element you want. In practice, the most useful places to store data is on the primary elements of nodes, links, and patches, with the nodes being most useful for scalar values (e.g, elevations) and the links for fluxes with direction to them (e.g., velocity or discharge).

In order to maintain compatibility across data types, *all* landlab data are stored in *number-of-elements*-long arrays. This includes both user-defined data and the properties of the nodes within the grid. This means that these arrays can be immediately indexed by their element ID. For example:
"""

# what are the y-coordinates of the pair of nodes in the middle of our 3-by-4 grid?
# the IDs of these nodes are 5 and 6, so:
smg.y_of_node[[5, 6]]

"""
If you're working with a raster, you can always reshape the value arrays back into two dimensions so you can take Numpy-style slices through it:
"""

# what are the x-coordinates of nodes in the middle row?
smg.x_of_node.reshape(smg.shape)[1, :]

"""
This same data storage pattern is what underlies the Landlab **data fields**, which are simply one dimensional, number-of-elements-long arrays that store user defined spatial data across the grid, attached to the grid itself.
"""

smg.add_zeros("elevation", at="node", clobber=True)
# ^Creates a new field of zero data associated with nodes
smg.at_node["elevation"]  # Note the use of dictionary syntax

"""
Or, equivalently, at links:
"""

smg.add_ones("slope", at="link", clobber=True)
# ^Creates a new array of data associated with links
smg.at_link["slope"]

"""
The Landlab **components** use fields to share spatial information among themselves. See the *fields* and *components* tutorials for more information.


## Getting this information from the grid object

All of this topological information is recorded within our grid objects, and can be used to work with data arrays that are defined over the grid. The grid records the numbers of each element, their positions, and their relationships with one another. Let's take a look at some of this information for the raster:
"""

smg.number_of_nodes

smg.number_of_links

"""
The grid contains its geometric information too. Let's look at the *(x,y)* coordinates of the nodes:
"""

for i in range(smg.number_of_nodes):
    print(i, smg.x_of_node[i], smg.y_of_node[i])

"""
Link connectivity and direction is described by specifying the starting ("tail") and ending ("head") node IDs for each link (to remember this, think of an arrow: TAIL ===> HEAD).
"""

for i in range(smg.number_of_links):
    print(
        "Link",
        i,
        ":  node",
        smg.node_at_link_tail[i],
        "===> node",
        smg.node_at_link_head[i],
    )

"""
Boundary conditions are likewise defined on these elements (see also the full boundary conditions tutorial). Landlab is clever enough to ensure that the boundary conditions recorded on, say, the links get updated when you redefine the conditions on, say, the nodes.

Nodes can be *core*, *fixed value*, *fixed gradient*, or *closed* (flux into or out of node is forbidden). Links can be *active* (can carry flux), *fixed* (always  carries the same flux; joined to a fixed gradient node) or *inactive* (forbidden from carrying flux). 

Note that this boundary coding does not mean that a particular boundary condition is automatically enforced. It's up to the user to take advantage of these codes. For example, if you are writing a model that calculates flow velocity on links but wish the velocity to be zero at inactive links, you the programmer must ensure this, for instance by including a line like `my_velocity[grid.inactive_links] = 0.0`, or alternatively `my_velocity[grid.active_links] = ...<something>...`.

Information on boundary coding is available from the grid:
"""

smg.core_nodes

smg.active_links

# let's demonstrate the auto-updating of boundary conditions:
smg.status_at_node[smg.nodes_at_bottom_edge] = smg.BC_NODE_IS_CLOSED
smg.active_links  # the links connected to the bottom edge nodes are now inactive

"""
### Element connectivity

Importantly, we can also find out which elements are connected to which other elements. This allows us to do computationally vital operations involving mapping values defined at one element onto another, e.g., the net flux at a node; the mean slope at a patch; the node value at a cell.

In cases where these relationships are one-to-many (e.g., `links_at_node`, `nodes_at_patch`), the shape of the resulting arrays is always (number_of_elements, max-number-of-connected-elements-across-grid). For example, on a raster, `links_at_node` is (nnodes, 4), because the cells are always square. On an irregular Voronoi-cell grid, `links_at_node` will be (nnodes, X) where X is the number of sides of the side-iest cell, and `nodes_at_patch` will be (npatches, 3) because all the patches are Delaunay triangles. And so on.

Lets take a look. Remember, Landlab orders things **counterclockwise from east**, so for a raster the order will the EAST, NORTH, WEST, SOUTH.
"""

smg.links_at_node[5]

smg.links_at_node.shape

"""
Undefined directions get recorded as `-1`:
"""

smg.links_at_node[8]

smg.patches_at_node

smg.nodes_at_patch

"""
Where element-to-element mapping is one-to-one, you get simple, one dimensional arrays:
"""

smg.node_at_cell  # shape is (n_cells, )

smg.cell_at_node  # shape is (n_nodes, ) with -1s as needed

"""
A bit of thought reveals that things get more complicated for links and faces, because they have direction. You'll need a convenient way to record whether a given flux (which is positive if it goes with the link's inherent direction, and negative if against) actually is travelling into or out of a given node. The grid provides `link_dirs_at_node` and `active_link_dirs_at_node` to help with this:
"""

smg.link_dirs_at_node  # all links; positive points INTO the node; zero where no link

# prove there are zeros where links are missing:
np.all((smg.link_dirs_at_node == 0) == (smg.links_at_node == -1))

smg.active_link_dirs_at_node  # in this one, inactive links get zero too

"""
Multiply the fluxes indexed by `links_at_node` and sum by axis=1 to have a very convenient way to calculate flux divergences at nodes:
"""

fluxes_at_node = smg.at_link["slope"][smg.links_at_node]
# ^...remember we defined the slope field as ones, above
fluxes_into_node = fluxes_at_node * smg.active_link_dirs_at_node
flux_div_at_node = fluxes_into_node.sum(axis=1)
print(flux_div_at_node[smg.core_nodes])

"""
Why? Remember that earlier in this tutorial we already set the bottom edge to `BC_NODE_IS_CLOSED`. So each of our core nodes has a flux of +1.0 coming in from the left, but two fluxes of -1.0 leaving from both the top and the right. Hence, the flux divergence is -1. at each node.

Note as well that Landlab offers the one-line grid method `calc_flux_div_at_node()` to perform this same operation. For more on this, see the **gradient_and_divergence** tutorial.
"""



================================================
File: docs/source/tutorials/grids/how_to_create_and_viz_icosphere_grid.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# How to create and visualize a Landlab Icosphere Grid

*(GE Tucker, CU Boulder, November 2023)*

This notebook demonstrates how to create a spherical `IcosphereGlobalGrid`, and to visualize its geometric elements and related fields.
"""

"""
## About IcosphereGlobal grid

`IcosphereGlobalGrid` represents a spherical surface as an *icosphere*, also known as a *geodesic polyhedron*: a convex polyhedron made of triangular faces. The icosphere allows a relatively even distribution of points across the surface.

The process of creating an `IcosphereGlobalGrid` starts with an *icosahedron* (a 20-sided polyhedron with 12 vertices). The initial icosahedron is then refined by iteratively subdividing each triangle into four smaller triangles. The user of `IcosphereGlobalGrid` specifies how many iterative levels of subdivision are applied, using the parameter `mesh_densification_level`.

An icosphere has the useful characteristic of having a dual geometry. The dual geometry for an icosahedron is a dodecahedron (12-sided polyhedron with 20 vertices). More generally, at any level of subdivision, an icosphere's triangular patches and their vertices have a matching Goldberg Polyhedron, in which each triangle vertex lies within a corresponding pentagonal or (if densification level >0) hexagonal polygon. 

In a Landlab `IcosphereGlobalGrid`, the icosphere comprises triangular *patches* with *nodes* as vertices and *links* as edges. The corresponding Goldberg Polyhedron is composed of pentagonal and hexagonal *cells* with *corners* as vertices and *faces* as the edges of the pentagons and hexagons.

Unlike the various 2D grid types, the nodes and corners in an `IcosphereGlobalGrid` have a $z$ coordinate in addition to their $x$ and $y$ coordinates. The grid also provides the corresponding spherical coordinates $r$, $\phi$, and $\theta$ ($r$ being radial distance from the center of the sphere, $\phi$ the longitude, and $\theta$ the latitude angle measured from zero at the "south" pole (so the equator lies at $\theta = \pi/2$ and the north pole lies at $\theta = \pi$).
"""

"""
## Creating an IcosphereGlobalGrid

The following examples illustrate how to create an `IcosphereGlobalGrid`:
"""

import matplotlib.pyplot as plt
import numpy as np

import landlab.io.legacy_vtk as vtk
from landlab import IcosphereGlobalGrid

def plot_ico_grid(vtx_coords, verts_at_line, cmap="Blues", title=None):
    """Plot vertex and line elements of an icosphere grid."""
    fig = plt.figure()
    ax = fig.add_subplot(projection="3d")
    ax.set_title(title)

    val_for_vertex_color = 0.25 * (vtx_coords[:, 0] + 1) + 0.25 * (1 - vtx_coords[:, 1])
    val_for_line_color = 0.25 * (1 - vtx_coords[verts_at_line[:, 0], 1]) + 0.25 * (
        1 + vtx_coords[verts_at_line[:, 0], 0]
    )

    ax.scatter(
        vtx_coords[:, 0],
        vtx_coords[:, 1],
        vtx_coords[:, 2],
        c=val_for_vertex_color,
        cmap=cmap,
    )

    for i in range(grid.number_of_links):
        ax.plot(
            vtx_coords[verts_at_line[i, :], 0],
            vtx_coords[verts_at_line[i, :], 1],
            vtx_coords[verts_at_line[i, :], 2],
            "k",
            alpha=val_for_line_color[i],
        )

    ax.axis("equal")

# No densification: icosahedron and dodecahedron
grid = IcosphereGlobalGrid()

# Icosahedron: nodes, patches, and links
plot_ico_grid(
    grid.coords_of_node,
    grid.nodes_at_link,
    cmap="Blues",
    title="Icosahedron: nodes, links, and patches",
)

# Dodecahedron: corners, cells, and faces
plot_ico_grid(
    grid.coords_of_corner,
    grid.corners_at_face,
    cmap="Reds",
    title="Dodecahedron: corners, faces, and cells",
)

# Densification level 1: soccer ball
grid = IcosphereGlobalGrid(radius=1.0, mesh_densification_level=1)

plot_ico_grid(grid.coords_of_corner, grid.corners_at_face, cmap="Reds")

"""
## Adding fields

Fields can be added using the same functions that are used with any other type of grid. The example below creates a grid and adds a node field called `latitude`, to which is assigned the latitude values in degrees. The example also illustrates the use of the `radius` parameter.
"""

grid = IcosphereGlobalGrid(radius=6.37e6, mesh_densification_level=4)

lat = grid.add_zeros("latitude", at="node")
lat[:] = np.abs(np.degrees(grid.theta_of_node) - 90.0)

fig = plt.figure()
ax = fig.add_subplot(projection="3d")

ax.scatter(
    grid.x_of_node,
    grid.y_of_node,
    grid.z_of_node,
    c=(90.0 - lat),
    cmap="Greens",
    s=5,
)

_ = ax.axis("equal")

"""
## Saving output for external 3D visualization

An effective way to visualize Landlab global grids and fields is to use a 3D visualization package like ParaView. ParaView accepts a variety of input formats; one format that Landlab provides is Legacy VTK. Here's the function signature for the `dump()` function of `landlab.io.legacy_vtk`.
"""

help(vtk.dump)

"""
The `dump()` function writes a Legacy VTK file for either nodes-links-patches (`at="node"`), or corners-faces-cells (`at="corner"`). By default this function will write all of the node and patch (or corner and face) fields. The fields that are written can be controled by the `include` and `exclude` keywords.
"""

"""
### Output example 1: latitude and longitude values

This example writes output for the grid defined above, along with its field of latitude values. The field is defined on nodes, but it could just as easily have been defined on cells, since there's a one-to-one relationship between nodes and cells for this grid type.

For the sake of illustration, we'll also create a field for longitude values and assign it to patches. This also provides an opportunity to list one of the spherical geometry utility functions, `cartesian_to_spherical()`, which we'll use to calculate the spherical coordinates of the grid *corners*. (In an `IcosphereGlobalGrid`, each *corner* lies within a corresponding triangular *patch*, and their numbering is the same, so it doesn't really matter whether we assign the values to a corner-based field or a patch-based field.)
"""

from landlab.utils.geometry.spherical import cartesian_to_spherical

# Get spherical coordinates for the corners
corner_r, corner_phi, corner_theta = cartesian_to_spherical(
    grid.x_of_corner, grid.y_of_corner, grid.z_of_corner
)

# Add a patch field for longitude
# lon = grid.add_field("longitude", np.degrees(corner_phi), at="patch")
grid.at_patch["longitude"] = np.degrees(corner_phi)
grid.at_cell["latitude"] = lat

with open("latlon_example-patches.vtk", "w") as fp:
    vtk.dump(grid, fp, at="node")

with open("latlon_example-cells.vtk", "w") as fp:
    vtk.dump(grid, fp, at="corner")

"""
Here's what these two files look like when rendered in ParaView:

![paraview_lat_cells_example-2.jpg](attachment:paraview_lat_cells_example-2.jpg)
"""

"""

![paraview_lat_cells_example.jpg](attachment:paraview_lat_cells_example.jpg)


"""

"""
### Output example 2: soccer ball

Just for fun, here's an example in which we use a field to assign different values to pentagonal versus hexagonal cells, so that the rendering of cells looks like a soccer ball.
"""

grid = IcosphereGlobalGrid(mesh_densification_level=1)

is_hexagon = np.amin(grid.corners_at_cell, axis=1) > -1

cell_code = grid.add_zeros("cell_code", at="cell")
cell_code[is_hexagon] = 1.0

with open("soccer_ball-patches.vtk", "w") as fp:
    vtk.dump(grid, fp, at="node")
with open("soccer_ball-cells.vtk", "w") as fp:
    vtk.dump(grid, fp, at="corner")

"""
Paraview rendering (note that apparent triangle subdivisions are a ParaView thing):

![icosphere_soccer_ball-2.jpg](attachment:icosphere_soccer_ball-2.jpg)
"""

"""
Displaying both dual geometries illustrates how the two map onto one another. In this image, *cells* and their *faces* are outlined in red; their vertices are *corners*. Triangular *patches* are shown in solid teal; their edges are *links* and their vertices are *nodes*.

![dual_geometry.jpg](attachment:dual_geometry.jpg)


"""



================================================
File: docs/source/tutorials/grids/icosphere_example_models.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Icosphere example models

*(GE Tucker, CU Boulder, November 2023)*

This notebook illustrates some examples of simple models that use the Landlab `IcosphereGlobalGrid` class.

We'll start with some imports:
"""

import matplotlib.pyplot as plt
import numpy as np

import landlab.io.legacy_vtk as vtk
from landlab import IcosphereGlobalGrid

"""
## Example 1: radiative energy balance for a planet

Consider a rocky planet that is heated by radiation from its star, and radiates energy into space. Imagine there's a "thermally active crust" layer of thickness $H$. A patch of crust of surface area $A$ receives energy from solar radiation, and loses energy by longwave radiation. Its thermal energy per unit mass is $E$. The change in temperature, $dT$, corresponding to a change in thermal energy, $dE$, is given by

$$dT = \frac{1}{m C_p} dE$$

where $m$ (kg) is mass and $C_p$ (J/kg K) is specific heat.

Energy balance dictates that

$$\frac{\partial E A H}{\partial t} = A S - A L$$

where $S$ is incoming (shortwave) radiant energy in W/m$^2$ and $L$ is outgoing (longwave) radiant energy in the same units.

This leads to:

$$\frac{\partial T}{\partial t} = \frac{1}{\rho C_p H}(S - L)$$

The radiant influx depends on latitude, $\theta$, and the axis tilt $\psi$ toward the sun (which varies throughout the year of course, creating seasons):

$$S = S_0 (1 - a) \max (\cos(\theta + \psi), 0)$$

where $S_0$ is solar irradiance and $a$ is albedo.

The outflux depends on temperature via the Stefan-Bolzmann law (assuming our planet is effectively a blackbody in the infrared):

$$L = \sigma T^4$$

So our complete equation is:

$$\frac{\partial T}{\partial t} = \frac{1}{\rho C_p H} 
\left( S_0 (1 - a) \max (\cos(\theta + \psi), 0) - \sigma T^4\right)$$


"""

# Parameters
radius = 6.37e6  # planetary radius, m
sec_per_year = 3600 * 24 * 365.25
S0 = 1360.0  # incoming shortwave, W/m2
a = 0.3  # albedo
sigma = 5.67e-8  # Stefan-Boltzmann constant
rho = 3000.0  # density, kg/m3
Cp = 1000.0  # specific heat, J/kg K
H = 10000.0  # crust thickness, m
max_tilt_deg = 23.5  # maximum seasonal tilt, degrees
dt = sec_per_year / 18.0  # time step duration, s
run_duration = 2500.0 * sec_per_year  # duration of run, s

# Other setup
max_tilt = np.radians(max_tilt_deg)  # convert to radians
coef = 1.0 / (rho * Cp * H)  # lump coefficients
shortwave_eq = (1.0 / np.pi) * S0 * (1 - a)  # shortwave at equator

# Data structures
mean_temp = []  # list to accumulate mean temperature over time
mean_lw = []  # list to accumulate mean longwave over time

# Instantiate an IcosphereGlobalGrid
grid = IcosphereGlobalGrid(radius=radius, mesh_densification_level=4)

# Set up some array data
lat = np.pi / 2 - grid.theta_of_node  # latitude in radians
temp = np.zeros(grid.number_of_cells)  # field for temperature
temp[:] = 3.0  # starting temperature, K

# Main loop
current_time = 0.0
while current_time < run_duration:
    # update tilt for the current time of year
    tilt = max_tilt * np.sin(2 * np.pi * current_time / sec_per_year)

    # calculate incoming shortwave at each grid cell
    shortwave = shortwave_eq * np.maximum(np.cos(lat + tilt), 0.0)

    # calculate outgoing longwave at each grid cell
    longwave = sigma * temp**4

    # calculate rate of change of temperature at each grid cell
    dTdt = coef * (shortwave - longwave)

    # update the temperature field
    temp += dTdt * dt

    # update time
    current_time += dt

    # record the mean temperature and longwave
    mean_temp.append(np.mean(temp))
    mean_lw.append(np.mean(longwave))

# plot the global mean temperature over time
plt.plot(
    np.linspace(dt / sec_per_year, run_duration / sec_per_year, len(mean_temp)),
    mean_temp,
)
plt.xlabel("Time (years)")
plt.ylabel("Global mean temperature (K)")

# plot the temperature by latitude
plt.plot(180.0 * lat / np.pi, temp, ".")
plt.xlabel("Latitude (degrees)")
plt.ylabel("Temperature (K)")

# for output, assign temperature to patches by averaging over eac
# triangular patches 3 nodes
temp_at_patch = np.mean(temp[grid.nodes_at_patch], axis=1)

# output data to a legacy-VTK format file
grid.at_patch["surface_temperature"] = temp_at_patch
grid.at_cell["surface_temperature"] = temp

with open("radiative_energy_bal-patches.vtk", "w") as fp:
    vtk.dump(grid, fp, include="*temperature", at="node")

with open("radiative_energy_bal-cells.vtk", "w") as fp:
    vtk.dump(grid, fp, include="*temperature", at="corner")

"""
The image below is from a ParaView rendering of the final surface temperature, looking down from above the north pole:

![global_surf_temp_from_n_pole.png](attachment:global_surf_temp_from_n_pole.png)
"""

# compare temperature predicted by a simple energy balance with the
# numerical model calculation - they should differ a bit because the
# numerical model is spatially distributed
energy_bal_est = (S0 * (1 - a) / (4 * sigma)) ** 0.25 - 273.15
model_mean_temp = np.sum(grid.area_of_cell * temp) / (4 * np.pi * radius**2) - 273.15
print("Energy balance predicted mean temperature (C):", energy_bal_est)
print("Numerical model mean temperature (C)", model_mean_temp)

"""
Part of the difference reflects transience: the numerical model might not have quite reached steady state. But is that all, or is it a result of the nonlinearity in the Stefan-Boltzmann law?
"""

"""
## Example 2: lateral heat diffusion in the crust of an asteroid

Suppose we have a small asteroid with a crust that is thermally insulated, exchanging essentially no heat with its interior (and receiving too little from the distant sun to make much difference). Why would we consider such a odd thing? Only to provide a test simple case: we want to see if we can use the `IcosphereGlobalGrid` to model heat diffusion in such a situation, using the Landlab functions `calc_grad_at_link` and `calc_flux_div_at_node`. We'll imagine further that the crust is initially relatively chilly, 250 K, but a meteorite impact has just flash-heated the crust at one location to 850 K. We want to demonstrate that the heat initially at the south pole will diffuse to adjacent latitudes. We also want to demonstrate that the total heat content, as represented by the area-averaged temperature, remains constant.

This case also provides an example of how to output a series of files that are numbered consecutively, so they can be imported into ParaView to create an animation.
"""

# Create a grid to represent the surface of an asteroid
radius = 500.0
grid = IcosphereGlobalGrid(radius=radius, mesh_densification_level=4)

# Set one grid cell to a high temperature, and all the others to a much lower temperature
temp = np.zeros(grid.number_of_nodes) + 250.0
temp[28] = 850.0

# Create an array for heat flux between cells (on links)
heat_flux = np.zeros(grid.number_of_links)

# Parameters
D = 1.0e-6  # diffusion coefficient (m2/s)
nsteps = 101  # number of steps
output_interval = 5  # interval for output
dt = 0.5 * sec_per_year

# Setup
surface_area = 4.0 * np.pi * radius**2
area_weighted_mean_temp = np.zeros(nsteps + 1)
area_weighted_mean_temp[0] = np.sum(grid.area_of_cell * temp) / surface_area
max_temp = np.zeros(nsteps + 1)
max_temp[0] = np.amax(temp)
time_slice_number = 0

# Output the initial state
grid.at_patch["surface_temperature"] = temp_at_patch
grid.at_cell["surface_temperature"] = temp

with open("diffusion_on_a_sphere000-patches.vtk", "w") as fp:
    vtk.dump(grid, fp, include="*temperature", at="node")

with open("diffusion_on_a_sphere000-cells.vtk", "w") as fp:
    vtk.dump(grid, fp, include="*temperature", at="corner")

# Main loop
for i in range(nsteps):
    # Calculate temperature gradients along links
    dTdx = grid.calc_grad_at_link(temp)

    # Update heat fluxes
    heat_flux[:] = -D * dTdx

    # Calculate divergence of flux
    dqdx = grid.calc_flux_div_at_node(heat_flux)

    # Update the temperature for one time step
    temp -= dqdx * dt

    # Update mean and maximum temperature
    area_weighted_mean_temp[i + 1] = np.sum(grid.area_of_cell * temp) / surface_area
    max_temp[i + 1] = np.amax(temp)

    # Write output once in a while
    if (i + 1) % output_interval == 0:
        time_slice_number += 1

        with open(f"diffusion_on_a_sphere{time_slice_number:03d}-cells.vtk", "w") as fp:
            vtk.dump(grid, fp, include="*temperature", at="corner")

# Plot final temperature as a function of latitude
plt.scatter(90 - grid.theta_of_node * 180 / np.pi, temp)
plt.xlabel("Latitude (degrees)")
plt.ylabel("Temperature (K)")

# Plot mean temperature over time: if energy is properly conserved,
# this should be constant
plt.figure()
t = np.linspace(0, dt / sec_per_year * nsteps, len(area_weighted_mean_temp))
plt.plot(
    t,
    area_weighted_mean_temp,
    label="Average",
)
plt.plot(t, max_temp, "r", label="Maximum")
plt.legend()
plt.xlabel("Time (years)")
plt.ylabel("Temperature (K)")

"""
Conclusion: numerical routines like `calc_grad_at_link` and `calc_flux_div_at_node` work just fine on an `IcoshereGlobalGrid`.
"""

"""
If we list the output files, we see two sequences of `vtk`-format files: one for cells and corners, and one for patches and nodes. Both will be recogized by ParaView as a collection, and can be played as an animation.
"""

!ls diffusion_on*cells.vtk
!ls diffusion_on*patches.vtk

"""
Conclusion: you can generate sequences of output files that ParaView (and perhaps other packages) will recognize as such.
"""

"""
## Example 3: flow routing on global topography

The final example demonstrates flow routing applied to a global grid. Here the elevation values have been previously interpolated onto a level-5 icosphere grid from the ETOPO2022 digital elevation model. Nodes below sea level are tagged as boundary nodes, so that the `FlowAccumulator` component recognizes them as outlets. (Note that the `DepressionFinderAndRouter` depression handler is robust but does not scale well; it works on this relatively small example, but more performant choices would be better for larger datasets.)
"""

from landlab.components import FlowAccumulator

# instantiate grid
grid = IcosphereGlobalGrid(radius=6.371e6, mesh_densification_level=5)

# read in data for topographic elevation
topo = grid.add_zeros("topographic__elevation", at="node")
topo[:] = np.loadtxt("global_elevation_etopo_ico_level5.txt")

# set ocean nodes to be boundaries for the flow accumulator
grid.status_at_node[topo < 0.0] = grid.BC_NODE_IS_FIXED_VALUE

# instantiate and run the FlowAccumulator
fa = FlowAccumulator(grid, depression_finder="DepressionFinderAndRouter")
fa.run_one_step()

"""
To demonstrate the functionality, here we draw a map of the computed drainage in South America. The drainage map is rather crude, reflecting the coarse resolution, but captures the major drainages, including the Amazon and Parana.
"""

def is_in_south_america(x0, y0):
    return x0 > 100 and x0 < 150 and y0 < 5 and y0 > -50


fig, ax = plt.subplots()

area = grid.at_node["drainage_area"]
rcvr = grid.at_node["flow__receiver_node"]

for i in range(grid.number_of_nodes):
    x0 = np.degrees(grid.phi_of_node[i])
    y0 = 90 - np.degrees(grid.theta_of_node[i])
    if area[i] >= 8.0e10 and is_in_south_america(x0, y0):
        x1 = np.degrees(grid.phi_of_node[rcvr[i]])
        y1 = 90 - np.degrees(grid.theta_of_node[rcvr[i]])
        ax.plot([x0, x1], [y0, y1], "k")
        ax.axis("equal")
        ax.set_xlabel("Longitude (degrees)")
        ax.set_ylabel("Latitude (degrees)")
        ax.set_title("South American drainages\n (level-5 resolution)")




================================================
File: docs/source/tutorials/groundwater/groundwater_flow.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Modeling groundwater flow in a conceptual catchment

This tutorial demonstrates how the GroundwaterDupuitPercolator can be used to model groundwater flow and seepage (groundwater return flow). It is recommended to read the documentation for the component before starting this tutorial to be familiar with the mechanics of the model.

In this tutorial you will:
* Create a raster grid on which to run the model
* Simulate constant recharge and check that the component conserves mass
* Confirm conservation of mass when the recharge rate and timestep are changed
* Simulate recharge from storm events, check conservation of mass, and look at the outflow hydrograph
* Learn how to set fixed gradient boundaries and set values for the hydraulic gradient
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import FlowAccumulator, GroundwaterDupuitPercolator
from landlab.components.uniform_precip import PrecipitationDistribution

"""
## Create a RasterModelGrid

Here you will make the grid on which we will run the model. You will create three fields: topographic elevation, aquifer base elevation, and initial water table elevation
"""

boundaries = {"top": "closed", "bottom": "closed", "right": "closed", "left": "closed"}
grid = RasterModelGrid((51, 51), xy_spacing=10.0, bc=boundaries)
grid.status_at_node[1] = grid.BC_NODE_IS_FIXED_VALUE

elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (0.001 * grid.x_of_node**2 + 0.001 * grid.y_of_node**2) + 2

base = grid.add_zeros("aquifer_base__elevation", at="node")
base[:] = elev - 2

wt = grid.add_zeros("water_table__elevation", at="node")
wt[:] = elev

plt.figure()
imshow_grid(grid, "topographic__elevation")

"""
The grid is square with dimensions 500x500m. The surface elevation and aquifer base have the same concave parabolic shape, with thickness 2m between them. The aquifer is initially fully saturated (water table at the surface). Water is only allowed to exit the domain through a single node in the the lower left corner. All other boundaries are closed.  
"""

"""
## Simulate constant groundwater recharge

Now initialize the model components. In addition to the grid, the GroundwaterDupuitPercolator takes four optional arguments: hydraulic conductivity, porosity, recharge rate, and a regularization factor that smooths the transition between subsurface and surface flow as the water table approaches the ground surface. The greater the value, the smoother the transition.

You will also initialize a FlowAccumulator in order to use an included method to calculate the surface water discharge out of the domain. The runoff rate used by the FlowAccumulator is the surface water specific discharge from the groundwater model.
"""

K = 0.01  # hydraulic conductivity, (m/s)
R = 0  # 1e-7 # recharge rate, (m/s)
n = 0.2  # porosity, (-)
gdp = GroundwaterDupuitPercolator(
    grid, hydraulic_conductivity=K, porosity=n, recharge_rate=R, regularization_f=0.01
)
fa = FlowAccumulator(
    grid,
    surface="topographic__elevation",
    flow_director="FlowDirectorSteepest",
    runoff_rate="surface_water__specific_discharge",
)

"""
Next, run the model forward in time, and track the fluxes leaving the domain.
"""

N = 500
dt = 1e2

recharge_flux = np.zeros(N)
gw_flux = np.zeros(N)
sw_flux = np.zeros(N)
storage = np.zeros(N)
s0 = gdp.calc_total_storage()

for i in range(N):
    gdp.run_one_step(dt)
    fa.run_one_step()

    storage[i] = gdp.calc_total_storage()
    recharge_flux[i] = gdp.calc_recharge_flux_in()
    gw_flux[i] = gdp.calc_gw_flux_out()
    sw_flux[i] = gdp.calc_sw_flux_out()

"""
Now visualize some results.
"""

plt.figure()
imshow_grid(grid, (wt - base) / (elev - base), cmap="Blues")

"""
The above shows how saturated the aquifer is. Note that it is most saturated at the lowest area of the domain, nearest the outlet.

Now look at the mass balance by ploting cumulative fluxes. The cumulative recharge in should be equal to cumulative fluxes out (groundwater and surface water) plus the change in storage from the initial condition.
"""

t = np.arange(0, N * dt, dt)

plt.figure(figsize=(8, 6))
plt.plot(
    t / 3600,
    np.cumsum(gw_flux) * dt + np.cumsum(sw_flux) * dt + storage - s0,
    "b-",
    linewidth=3,
    alpha=0.5,
    label="Total Fluxes + Storage",
)
plt.plot(
    t / 3600,
    np.cumsum(recharge_flux) * dt - recharge_flux[0] * dt,
    "k:",
    label="recharge flux",
)
plt.plot(t / 3600, np.cumsum(gw_flux) * dt, "b:", label="groundwater flux")
plt.plot(t / 3600, np.cumsum(sw_flux) * dt, "g:", label="surface water flux")
plt.plot(t / 3600, storage - s0, "r:", label="storage")
plt.ylabel("Cumulative Volume $[m^3]$")
plt.xlabel("Time [h]")
plt.legend(frameon=False)
plt.show()

"""
The thick blue line (cumulative fluxes plus storage) matches the black cumulative recharge flux line, which indicates that the model has conserved mass. Because the initial domain was fully saturated, the primary feature that shows up in this mass balance is the loss of that initial water. It will be easier to see what is going on here in the second example. 
"""

"""
### Check conservation of mass with changing recharge
"""

"""
Now check to confirm that mass is conserved with different recharge rates.
"""

wt0 = wt.copy()

K = 0.01  # hydraulic conductivity, (m/s)
R = np.array([1e-5, 1e-6, 1e-7, 1e-8])  # recharge rate, (m/s)
por = 0.2  # porosity, (-)

f_in = np.zeros(len(R))
f_out = np.zeros(len(R))

for n in range(len(R)):
    boundaries = {
        "top": "closed",
        "bottom": "closed",
        "right": "closed",
        "left": "closed",
    }
    grid = RasterModelGrid((51, 51), xy_spacing=10.0, bc=boundaries)
    grid.status_at_node[1] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.001 * grid.x_of_node**2 + 0.001 * grid.y_of_node**2) + 2

    base = grid.add_zeros("aquifer_base__elevation", at="node")
    base[:] = elev - 2

    wt = grid.add_zeros("water_table__elevation", at="node")
    wt[:] = wt0.copy()

    gdp = GroundwaterDupuitPercolator(
        grid,
        hydraulic_conductivity=K,
        porosity=por,
        recharge_rate=R[n],
        regularization_f=0.01,
        courant_coefficient=0.1,
    )
    fa = FlowAccumulator(
        grid,
        surface="topographic__elevation",
        flow_director="FlowDirectorSteepest",
        runoff_rate="surface_water__specific_discharge",
    )

    N = 250
    dt = 1e2

    recharge_flux = np.zeros(N)
    gw_flux = np.zeros(N)
    sw_flux = np.zeros(N)
    storage = np.zeros(N)
    s0 = gdp.calc_total_storage()

    for i in range(N):
        gdp.run_one_step(dt)
        fa.run_one_step()

        recharge_flux[i] = gdp.calc_recharge_flux_in()
        gw_flux[i] = gdp.calc_gw_flux_out()
        sw_flux[i] = gdp.calc_sw_flux_out()
        storage[i] = gdp.calc_total_storage()

    f_in[n] = np.sum(recharge_flux) * dt
    f_out[n] = np.sum(gw_flux) * dt + np.sum(sw_flux) * dt + storage[-1] - s0

"""
The code above simulates the evolution of the water table under four different recharge rates, and calculates the fluxes across the domain boundaries and the change in storage. It then sums the fluxes to find out the total volume in and out and change in storage. Below we visualize how flow in compares with flow out plus storage change. If mass is conserved they should be the same.
"""

x11 = np.linspace(0, max(f_in))

plt.figure()
plt.loglog(x11, x11, "r--", label="1:1")
plt.loglog(f_in, f_out, ".", markersize=10)
plt.legend(frameon=False)
plt.ylabel("flux out + storage $(m^3)$")
plt.xlabel("flux in $(m^3)$")
plt.show()

"""
The trials plot close to the 1:1 line, showing that we are close to mass conservation. Just how close? Calculate the relative error below.
"""

(f_in - f_out) / f_in

"""
### Check conservation of mass with changing timestep
"""

"""
To check conservation of mass with different timesteps, we will use the method `run_with_adaptive_time_step_solver` to ensure the model remains stable. This method is the same as run_one_step, except that it subdivides the provided timestep (event or inter-event duration in this case) in order to meet a Courant-type stability criterion.

We can set the `courant_coefficient` either as an argument when we create the component, or by setting the attribute `gdp.courant_coefficient`. This value indicates how large the maximum allowed timestep is relative to the Courant limit. Values close to 0.1 are recommended for best results.

For efficiency, fluxes are only calculated at the end of each large timestep when using `run_with_adaptive_time_step_solver`, not during the internally subdivided timesteps. As a result, deviations from mass conservation are possible.
"""

wt0 = wt.copy()

K = 0.01  # hydraulic conductivity, (m/s)
R = 1e-7  # recharge rate, (m/s)
por = 0.2  # porosity, (-)
N_all = np.array([10, 50, 100, 500, 1000])  # number of timesteps
T = 24 * 3600  # total time
dt_all = T / N_all  # timestep
gdp.courant_coefficient = 0.2

f_in = np.zeros(len(N_all))
f_out = np.zeros(len(N_all))

for n in range(len(N_all)):
    boundaries = {
        "top": "closed",
        "bottom": "closed",
        "right": "closed",
        "left": "closed",
    }
    grid = RasterModelGrid((51, 51), xy_spacing=10.0, bc=boundaries)
    grid.status_at_node[1] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.001 * grid.x_of_node**2 + 0.001 * grid.y_of_node**2) + 2

    base = grid.add_zeros("aquifer_base__elevation", at="node")
    base[:] = elev - 2

    wt = grid.add_zeros("water_table__elevation", at="node")
    wt[:] = wt0.copy()

    gdp = GroundwaterDupuitPercolator(
        grid,
        hydraulic_conductivity=K,
        porosity=por,
        recharge_rate=R,
        regularization_f=0.01,
        courant_coefficient=0.1,
    )
    fa = FlowAccumulator(
        grid,
        surface="topographic__elevation",
        flow_director="FlowDirectorSteepest",
        runoff_rate="surface_water__specific_discharge",
    )

    N = N_all[n]
    dt = dt_all[n]

    recharge_flux = np.zeros(N)
    gw_flux = np.zeros(N)
    sw_flux = np.zeros(N)
    storage = np.zeros(N)
    s0 = gdp.calc_total_storage()

    for i in range(N):
        gdp.run_with_adaptive_time_step_solver(dt)

        fa.run_one_step()

        recharge_flux[i] = gdp.calc_recharge_flux_in()
        gw_flux[i] = gdp.calc_gw_flux_out()
        sw_flux[i] = gdp.calc_sw_flux_out()
        storage[i] = gdp.calc_total_storage()

    f_in[n] = np.sum(recharge_flux) * dt
    f_out[n] = np.sum(gw_flux) * dt + np.sum(sw_flux) * dt + storage[-1] - s0

"""
The code above simulates the evolution of the water table for the same total amount of time, but using four different values for the timestep. Just as before, fluxes and storage are calculated, along with their totals. Again, look at the relative error in mass conservation.
"""

(f_in - f_out) / f_in

"""
## Simulate time-varying recharge

Lastly, simulate time-varying recharge, look at the mass balance, and the outflow hydrograph. This will use the same grid and groundwater model instance as above, taking the final condition of the previous model run as the new initial condition here. This time the adaptive timestep solver will be used to make sure the model remains stable.

First, we need a distribution of recharge events. We will use landlab's precipitation distribution tool to create a lists paired recharge events and intensities.
"""

# generate storm timeseries
T = 10 * 24 * 3600  # sec
Tr = 1 * 3600  # sec
Td = 24 * 3600  # sec
dt = 1e3  # sec
p = 1e-3  # m

precip = PrecipitationDistribution(
    mean_storm_duration=Tr,
    mean_interstorm_duration=Td,
    mean_storm_depth=p,
    total_t=T,
    delta_t=dt,
)
durations = []
intensities = []
precip.seed_generator(seedval=1)
for (
    interval_duration,
    rainfall_rate_in_interval,
) in precip.yield_storm_interstorm_duration_intensity(subdivide_interstorms=True):
    durations.append(interval_duration)
    intensities.append(rainfall_rate_in_interval)
N = len(durations)

"""
Next, run the model forward with the adaptive timestep solver.
"""

recharge_flux = np.zeros(N)
gw_flux = np.zeros(N)
sw_flux = np.zeros(N)
storage = np.zeros(N)
s0 = gdp.calc_total_storage()
num_substeps = np.zeros(N)

gdp.courant_coefficient = 0.2

for i in range(N):
    gdp.recharge = intensities[i] * np.ones_like(gdp.recharge)

    gdp.run_with_adaptive_time_step_solver(durations[i])
    fa.run_one_step()

    num_substeps[i] = gdp.number_of_substeps
    recharge_flux[i] = gdp.calc_recharge_flux_in()
    gw_flux[i] = gdp.calc_gw_flux_out()
    sw_flux[i] = gdp.calc_sw_flux_out()
    storage[i] = gdp.calc_total_storage()

"""
Again, visualize the mass balance:
"""

t = np.cumsum(durations)

plt.figure()
plt.plot(
    t / 3600,
    np.cumsum(gw_flux * durations) + np.cumsum(sw_flux * durations) + storage - s0,
    "b-",
    linewidth=3,
    alpha=0.5,
    label="Total Fluxes + Storage",
)
plt.plot(t / 3600, np.cumsum(recharge_flux * durations), "k:", label="recharge flux")
plt.plot(t / 3600, np.cumsum(gw_flux * durations), "b:", label="groundwater flux")
plt.plot(t / 3600, np.cumsum(sw_flux * durations), "g:", label="surface water flux")
plt.plot(t / 3600, storage - storage[0], "r:", label="storage")
plt.ylabel("Cumulative Volume $[m^3]$")
plt.xlabel("Time [h]")
plt.legend(frameon=False)
plt.show()

"""
Visualize numer of substeps that the model took for stability:
"""

plt.figure()
plt.plot(num_substeps, ".")
plt.xlabel("Iteration")
plt.ylabel("Numer of Substeps")
plt.yticks([1, 5, 10, 15, 20])
plt.show()

max(num_substeps)

"""
The method has subdivided the timestep up to 18 times in order to meet the stability criterion. This is dependent on a number of factors, including the Courant coefficient, the hydraulic conductivity, and hydraulic gradient.

Now look at the timeseries of recharge in and groundwater and surface water leaving the domain at the open node:
"""

fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(t / (3600 * 24), sw_flux, label="Surface water flux")
ax.plot(t / (3600 * 24), gw_flux, label="Groundwater flux")
ax.set_ylim((0, 0.04))
ax.set_ylabel("Flux out $[m^3/s]$")
ax.set_xlabel("Time [d]")
ax.legend(frameon=False, loc=7)
ax1 = ax.twinx()
ax1.plot(t / (3600 * 24), recharge_flux, "0.6")
ax1.set_ylim((1.2, 0))
ax1.set_ylabel("Recharge flux in $[m^3/s]$")
plt.show()

"""
The relationship between maximum flux that can be passed through the subsurface and the occurrence of groundwater seepage is clear from this figure.
"""

"""
## Using different boundary conditions
"""

"""
So far, we have used the fixed fixed value "open" boundary condition, and zero flux "closed" boundary condition. Fixed gradient (von Neumann) boundary conditions are also supported by this component. When fixed value is selected, the water table elevation remains fixed on the specified boundary nodes. When fixed gradient is selected, the water table gradient on specified links remains fixed.

Below is an example of setting fixed gradient links on one boundary.
"""

grid = RasterModelGrid((10, 10), xy_spacing=10.0)
grid.set_status_at_node_on_edges(
    right=grid.BC_NODE_IS_CLOSED,
    top=grid.BC_NODE_IS_CLOSED,
    left=grid.BC_NODE_IS_CLOSED,
    bottom=grid.BC_NODE_IS_FIXED_GRADIENT,
)

elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (0.001 * (grid.x_of_node - 100) ** 2 + 0.0002 * grid.y_of_node**2) + 10
base = grid.add_zeros("aquifer_base__elevation", at="node")
base[:] = elev - 2
wt = grid.add_zeros("water_table__elevation", at="node")
wt[:] = elev

gdp = GroundwaterDupuitPercolator(grid)

"""
Say we want to set the bottom boundary gradients to be equal to the slope of the topographic surface. This can be done simply as follows:
"""

# calculate surface slopes
S = grid.calc_grad_at_link(elev)

# assign hydraulic gradient at fixed linlks to be the surface slope there
grid.at_link["hydraulic__gradient"][grid.fixed_links] = S[grid.fixed_links]

grid.at_link["hydraulic__gradient"][grid.fixed_links]

"""
For more information on setting boundary conditions, please see the `boundary_conds` folder within `landlab/notebooks/tutorials`. 
"""



================================================
File: docs/source/tutorials/hillslope_geomorphology/depth_dependent_taylor_diffuser/depth_dependent_taylor_diffuser.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Component Overview: `DepthDependentTaylorDiffuser`
"""

"""
## Introduction and background

This tutorial introduces the `DepthDependentTaylorDiffuser` component, which we'll refer to here as "DDTD". The DDTD component models the process of downslope soil creep and its role in modifying topography. It combines the mathematics behind two other components: `DepthDependentDiffuser` and `TaylorNonLinearDiffuser`. The component is described (as one element in the terrainBento package) in Barnhart et al. (2019), which is the appropriate paper to cite for it.

### Theory

Consider a topographic surface in which the elevation at any time $t$ and horizontal position $(x,y)$ is $\eta (x,y,t)$. The thickness of the mobile soil layer is $H(x,y,t)$. Let $\mathbf{q}_s$ be a 2D vector that represents the rate of soil volume flow per unit slope width (with dimensions of length squared per time; we'll assume that $\mathbf{q}_s$ represents a "bulk" flux that includes pore spaces between soil grains). In the absence of any "local" input sources (such as weathering of rock) or output (such as removal by wash erosion), conservation of mass dictates that:

$$\frac{\partial \eta}{\partial t} = -\nabla \cdot \mathbf{q}_s$$

The DDTD component represents the soil flux as:

$$\mathbf{q}_s = K H_* \mathbf{S} [1 - \exp ( - H / H_*)] [ 1 + (S/S_c)^2 + (S/S_c)^4 + ... + (S/S_c)^2(n-1) ]$$

where $\mathbf{S} = -\nabla \eta$ is the downslope topographic gradient, and $S$ is its magnitude. Parameter $H_*$ is a depth scale that determines how rapidly transport rate decays as the soil thins. Parameter $K$ is a transport coefficient with dimensions of velocity. The effective diffusion-like coefficient is $D=KH_*$. This is the effective diffusivity when the soil is much thicker than $H_*$.

The above can be written slightly more compactly:

$$\mathbf{q}_s = K H_* \mathbf{S} [1 - \exp ( - H / H_*)] \left[ 1 + \sum_{i=1}^N \left(\frac{S}{S_c}\right)^{2i} \right]$$

where $i$ is the number of additional terms desired. If $i=0$, the expression is the same as the depth-dependent, slope-linear transport function implemented by the `DepthDependentDiffuser` component and described, for example, by Johnstone and Hilley (2015).

The use of a truncated Taylor series is meant to approximate the Andrews-Bucknam transport function (e.g., Roering et al., 1999) while avoiding that equation's blow-up at $S=S_c$; the idea of using a truncated Taylor series comes from Ganti et al. (2012).

### Numerical implementation

The component uses an explicit finite-volume solution method. Soil flux values are calculated from the gradient values on the active links, using the grid method `calc_grad_at_link`. Flux divergence is then calculated using the grid method `calc_flux_div_at_node`. The calculation updates soil thickness, bedrock elevation (using the user-provided values of the `soil_production__rate` field), and total elevation as the sum of the two.

An optional dynamic timestep capability will check the local Courant condition (which can vary in time and space when nonlinear terms are included) and sub-divide the user-specified time step as needed to ensure stability.
"""

"""
## Examples

### Needed imports

Like all Landlab components, DDTD requires a grid object on which to operate, so for this example we'll import `RasterModelGrid` as well as the component itself.
"""

import matplotlib.pyplot as plt
import numpy as np
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components import DepthDependentTaylorDiffuser

"""
### Example 1: equilibrium hillslope profile with linear diffusion

For the first example, we'll use a long and skinny grid to effectively create a 1D domain. We'll test the ability of DDTD to reduce to a simple linear, depth-independent diffusive model when $i=0$ and $H \gg H_*$. We'll impose (relative) rock uplift by raising the interior of the domain at a specified rate $U$ relative to the fixed boundary nodes on either side. The expectation is that:

$$\frac{d\eta}{dx} = -\frac{U}{D}x$$

where $x$ is distance from the ridge top (because the ridge top will form in the middle of the domain, $x<0$ on the left and $x>0$ on the right). Integrating this, we get

$$\eta = -\frac{U}{2D} x^2 + C$$

We can evaluate the integration constant by noting that $\eta = 0$ at $x = \pm L$, where $L$ is the distance from base to crest. Therefore,

$$\boxed{\eta = \frac{U}{2D} \left( L^2 - x^2 \right)}$$

We'll test this using a hill that is 100 m long (51 nodes, two of which are fixed boundaries, with 2 m spacing between them; 50 m from base to crest on each side), a soil layer that is much thicker than the characteristic decay depth $H^*$, a transport coefficient of 0.01 m$^2$/y, and an uplift rate of 0.0001 m/y. With these parameters, the predicted ridge height (at $x=0$) is calculated below.

"""

# define parameters
L = 50.0  # distance from base to ridgeline, m
dx = 2.0  # node spacing, m
Hstar = 0.1  # characteristic transport depth, m
V0 = 0.1  # transport velocity coefficient, m/y
U = 0.0001  # uplift rate, m/y
H = 100.0  # initial soil thickness, m
num_steps = 20000  # number of time steps

# time step size (calculate using Courant condition for linear diffusion)
D = V0 * Hstar  # effective (maximum) diffusivity
dt = 0.1 * dx * dx / D

# prediction
predicted_crest_height = 0.5 * (U / D) * L * L
print("Crest height should be " + str(predicted_crest_height))

# create grid
grid = RasterModelGrid((3, 51), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta
rock = grid.add_zeros("bedrock__elevation", at="node")  # this is eta - H
rock[:] = -H
soil = grid.add_zeros("soil__depth", at="node")  # this is H
soil_production_rate = grid.add_zeros("soil_production__rate", at="node")

# instantiate component
ddtd = DepthDependentTaylorDiffuser(
    grid, soil_transport_velocity=V0, soil_transport_decay_depth=Hstar, nterms=1
)

# run the model in a time loop with uplift applied
for _ in trange(num_steps):
    elev[grid.core_nodes] += U * dt
    rock[grid.core_nodes] += U * dt
    ddtd.run_one_step(dt)

midrow = np.arange(51, 102, dtype=int)
plt.plot(grid.x_of_node[midrow], elev[midrow])
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

print(np.amax(elev))

"""
### Example 2: linear, depth-dependent diffusion

In this example we add a rule for soil production that will limit the soil thickness and hence reduce the transport efficiency. The rate of soil production from bedrock will be:

$$P = P_0 \exp ( H / H_0 )$$

where $P_0$ is the maximum production rate and $H_0$ is a characteristic decay depth. In our example, we'll set $P_0$ to twice the uplift rate. At equilibrium, the actual production rate $P = U$, which means that the equilibrium soil thickness can be found from:

$$P = U = 2 U \exp ( -H / H_0 )$$

or

$$H = -H_0 \ln 1/2$$

The effective diffusion coefficient is therefore

$$D_{eff} = D [1 - \exp ( -H / H_* )] = D [1 - \exp ( H_0 \ln 1/2 / H_* )]$$

For the sake of example, we'll assume $H_0 = H_*$, so

$$D_{eff} = D / 2$$

and therefore our hill crest should be twice as high as in the prior case.
"""

# new parameter: maximum soil production rate
P0 = 2 * U  # m/yr

# create grid
grid = RasterModelGrid((3, 51), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta
rock = grid.add_zeros("bedrock__elevation", at="node")  # this is eta - H
soil = grid.add_zeros("soil__depth", at="node")  # this is H
soil_production_rate = grid.add_zeros("soil_production__rate", at="node")

# instantiate component
ddtd = DepthDependentTaylorDiffuser(
    grid, soil_transport_velocity=V0, soil_transport_decay_depth=Hstar, nterms=1
)

# run the model in a time loop with uplift applied
for _ in trange(num_steps):
    elev[grid.core_nodes] += U * dt
    rock[grid.core_nodes] += U * dt
    soil_production_rate[grid.core_nodes] = P0 * np.exp(-soil[grid.core_nodes] / Hstar)
    ddtd.run_one_step(dt)

plt.plot(grid.x_of_node[midrow], elev[midrow])
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

"""
Here we haven't quite reached equilibrium yet, but we can see that the hilltop crest is approaching our expected height of 25 m: twice as high as it would be if the soil flux were not limited by soil thickness.
"""

"""
### Example 3: Nonlinear behavior

When we include nonlinear terms in the transport law, we expect to see slopes that become more planar in character. We'll test this by setting a critical slope value $S_c = 0.6$ (about 31$^\circ$), and using a higher uplift rate. We'll have two terms, one linear and one cubic. We will also invoke the `dynamic_dt` option, which allows the component to subdivide each "global" timestep if needed for numerical stability: a useful thing to do because now our Courant condition varies according to slope gradient.
"""

U = 0.0005  # uplift rate, m/yr
Sc = 0.6  # critical slope gradient, m/m
H = 1000.0  # plenty of soil
num_steps = 2000  # number of time steps

# create grid
grid = RasterModelGrid((3, 51), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta
rock = grid.add_zeros("bedrock__elevation", at="node")  # this is eta - H
rock[:] = -H
soil = grid.add_zeros("soil__depth", at="node")  # this is H
soil_production_rate = grid.add_zeros("soil_production__rate", at="node")

# instantiate component
ddtd = DepthDependentTaylorDiffuser(
    grid,
    soil_transport_velocity=V0,
    soil_transport_decay_depth=Hstar,
    slope_crit=Sc,
    dynamic_dt=True,
    nterms=2,
)

# run the model in a time loop with uplift applied
for _ in trange(num_steps):
    elev[grid.core_nodes] += U * dt
    rock[grid.core_nodes] += U * dt
    ddtd.run_one_step(dt)

plt.plot(grid.x_of_node[midrow], elev[midrow])
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

"""
The resulting hill is taller (due to the higher uplift rate) and no longer has uniform convexity.

How do we know whether it has reached equilibrium? One way is to inspect the soil flux: it should increase linearly with $x$, and be zero at the crest. The values at the base of the slope should equal slope length times uplift rate, or 50 m x 0.0005 m/yr = 0.025 m$^2$/yr.
"""

active_link_midpts = (
    grid.x_of_node[grid.node_at_link_tail[grid.active_links]] + 0.5 * dx
)
plt.plot(active_link_midpts, grid.at_link["soil__flux"][grid.active_links])
plt.grid(True)
plt.xlabel("Distance (m)")
plt.ylabel("Soil flux (m2/yr)")

"""
So it appears as if we are not quite there, but pretty close.
"""

"""
### Example 4: Nonlinear, depth dependent, and 2D

In the final example we'll use a proper 2D domain, with both a soil-depth dependence and a nonlinear term in the flux law.
"""

U = 0.0002  # uplift rate, m/yr

# create grid
grid = RasterModelGrid((21, 31), xy_spacing=dx)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta
rock = grid.add_zeros("bedrock__elevation", at="node")  # this is eta - H
soil = grid.add_zeros("soil__depth", at="node")  # this is H
soil_production_rate = grid.add_zeros("soil_production__rate", at="node")

# instantiate component
ddtd = DepthDependentTaylorDiffuser(
    grid,
    soil_transport_velocity=V0,
    soil_transport_decay_depth=Hstar,
    slope_crit=Sc,
    dynamic_dt=True,
    nterms=2,
)

# run the model in a time loop with uplift applied
for _ in trange(num_steps):
    elev[grid.core_nodes] += U * dt
    rock[grid.core_nodes] += U * dt
    soil_production_rate[grid.core_nodes] = P0 * np.exp(-soil[grid.core_nodes] / Hstar)
    ddtd.run_one_step(dt)

grid.imshow(elev)

"""
## References

Barnhart, K., Glade, R., Shobe, C., Tucker, G. (2019). Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution. Geoscientific Model Development  12(4), 1267--1297, [https://dx.doi.org/10.5194/gmd-12-1267-2019](https://dx.doi.org/10.5194/gmd-12-1267-2019).

Ganti, V., Passalacqua, P., Foufoula-Georgiou, E. (2012). A sub-grid scale closure for nonlinear hillslope sediment transport models. Journal of Geophysical Research: Earth Surface, 117(F2), [https://dx.doi.org/10.1029/2011jf002181](https://dx.doi.org/10.1029/2011jf002181).

Johnstone, S., Hilley, G. (2015). Lithologic control on the form of soil-mantled hillslopes. Geology  43(1), 83-86, [https://doi.org/10.1130/G36052.1](https://doi.org/10.1130/G36052.1).

Roering, J. J., Kirchner, J. W., & Dietrich, W. E. (1999). Evidence for nonlinear, diffusive sediment transport on hillslopes and implications for landscape morphology. Water Resources Research, 35(3), 853-870.

"""



================================================
File: docs/source/tutorials/hillslope_geomorphology/taylor_diffuser/taylor_diffuser.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Component Overview: `TaylorNonLinearDiffuser`
"""

"""
## Introduction and background

This tutorial introduces the `TaylorNonLinearDiffuser` component, which we'll refer to here as "TNLD". The TNLD component models the process of downslope soil creep and its role in modifying topography. Inspired by Ganti et al. (2012), it uses a slope-dependent flux law with a user-specified number of terms in a Taylor expansion described in that paper. The component is described (as one element in the terrainBento package) in Barnhart et al. (2019), which is the appropriate paper to cite for it.

### Theory

Consider a topographic surface in which the elevation at any time $t$ and horizontal position $(x,y)$ is $\eta (x,y,t)$. Let $\mathbf{q}_s$ be a 2D vector that represents the rate of soil volume flow per unit slope width (with dimensions of length squared per time; we'll assume that $\mathbf{q}_s$ represents a "bulk" flux that includes pore spaces between soil grains). In the absence of any "local" input sources (such as weathering of rock) or output (such as removal by wash erosion), conservation of mass dictates that:

$$\frac{\partial \eta}{\partial t} = -\nabla \cdot \mathbf{q}_s$$

The TNLD component represents the soil flux as:

$$\mathbf{q}_s = D \mathbf{S} [ 1 + (S/S_c)^2 + (S/S_c)^4 + ... + (S/S_c)^2(n-1) ]$$

where $\mathbf{S} = -\nabla \eta$ is the downslope topographic gradient, and $S$ is its magnitude. Parameter $D$ is a diffusion-like coefficient with dimensions of length squared per time.

The above can be written slightly more compactly:

$$\mathbf{q}_s = D \mathbf{S} \left[1 + \sum_{i=1}^N \left( \frac{S}{S_c}\right)^{2i}\right]$$

where $i$ is the number of additional terms desired. If $i=0$, the expression reduces to plain old linear diffusion (see `LinearDiffuser`).

The use of a truncated Taylor series is meant to approximate the Andrews-Bucknam transport function (e.g., Roering et al., 1999) while avoiding that equation's blow-up at $S=S_c$; the idea of using a truncated Taylor series comes from Ganti et al. (2012).

### Numerical implementation

The component uses an explicit finite-volume solution method. Soil flux values are calculated from the gradient values on the active links, using the grid method `calc_grad_at_link`. Flux divergence is then calculated using the grid method `calc_flux_div_at_node`. The code then updates the elevation field.

An optional dynamic timestep capability will check the local Courant condition (which can vary in time and space when nonlinear terms are included) and sub-divide the user-specified time step as needed to ensure stability.
"""

"""
## Examples

### Needed imports

Like all Landlab components, TNLD requires a grid object on which to operate, so for this example we'll import `RasterModelGrid` as well as the component itself.
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid
from landlab.components import TaylorNonLinearDiffuser

"""
### Example 1: equilibrium hillslope profile with linear diffusion

For the first example, we'll use a long and skinny grid to effectively create a 1D domain. We'll test the ability of TNLD to reduce to a simple linear, depth-independent diffusive model when $i=0$. We'll impose (relative) rock uplift by raising the interior of the domain at a specified rate $U$ relative to the fixed boundary nodes on either side. The expectation is that:

$$\frac{d\eta}{dx} = -\frac{U}{D}x$$

where $x$ is distance from the ridge top (because the ridge top will form in the middle of the domain, $x<0$ on the left and $x>0$ on the right). Integrating this, we get

$$\eta = -\frac{U}{2D} x^2 + C$$

We can evaluate the integration constant by noting that $\eta = 0$ at $x = \pm L$, where $L$ is the distance from base to crest. Therefore,

$$\boxed{\eta = \frac{U}{2D} \left( L^2 - x^2 \right)}$$

We'll test this using a hill that is 100 m long (51 nodes, two of which are fixed boundaries, with 2 m spacing between them; 50 m from base to crest on each side), a soil layer that is much thicker than the characteristic decay depth $H^*$, a transport coefficient of 0.01 m$^2$/y, and an uplift rate of 0.0001 m/y. With these parameters, the predicted ridge height (at $x=0$) is calculated below.

"""

# define parameters
L = 50.0  # distance from base to ridgeline, m
dx = 2.0  # node spacing, m
D = 0.01  # diffusion-like coefficient, m2/y
U = 0.0001  # uplift rate, m/y
H = 100.0  # initial soil thickness, m
num_steps = 20000  # number of time steps

# time step size (calculate using Courant condition for linear diffusion)
dt = 0.1 * dx * dx / D

# prediction
predicted_crest_height = 0.5 * (U / D) * L * L
print("Crest height should be " + str(predicted_crest_height))

# create grid
grid = RasterModelGrid((3, 51), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# create elevation field
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta

# instantiate component
tnld = TaylorNonLinearDiffuser(grid, linear_diffusivity=D, nterms=1)

# run the model in a time loop with uplift applied
for i in range(num_steps):
    elev[grid.core_nodes] += U * dt
    tnld.run_one_step(dt)

midrow = np.arange(51, 102, dtype=int)
plt.plot(grid.x_of_node[midrow], elev[midrow])
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

print(np.amax(elev))

"""
### Example 2: Nonlinear behavior

When we include nonlinear terms in the transport law, we expect to see slopes that become more planar in character. We'll test this by setting a critical slope value $S_c = 0.6$ (about 31$^\circ$), and using a higher uplift rate. We'll have two terms, one linear and one cubic. We will also invoke the `dynamic_dt` option, which allows the component to subdivide each "global" timestep if needed for numerical stability: a useful thing to do because now our Courant condition varies according to slope gradient.
"""

U = 0.0005  # uplift rate, m/yr
Sc = 0.6  # critical slope gradient, m/m
num_steps = 2000  # number of time steps

# create grid
grid = RasterModelGrid((3, 51), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# create fields
elev = grid.add_zeros("topographic__elevation", at="node")  # this is eta

# instantiate component
tnld = TaylorNonLinearDiffuser(
    grid, linear_diffusivity=D, slope_crit=Sc, dynamic_dt=True, nterms=2
)

# run the model in a time loop with uplift applied
for i in range(num_steps):
    elev[grid.core_nodes] += U * dt
    tnld.run_one_step(dt)

plt.plot(grid.x_of_node[midrow], elev[midrow])
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

"""
The resulting hill is taller (due to the higher uplift rate) and no longer has uniform convexity.

How do we know whether it has reached equilibrium? One way is to inspect the soil flux: it should increase linearly with $x$, and be zero at the crest. The values at the base of the slope should equal slope length times uplift rate, or 50 m x 0.0005 m/yr = 0.025 m$^2$/yr.
"""

active_link_midpts = (
    grid.x_of_node[grid.node_at_link_tail[grid.active_links]] + 0.5 * dx
)
plt.plot(active_link_midpts, grid.at_link["soil__flux"][grid.active_links])
plt.grid(True)
plt.xlabel("Distance (m)")
plt.ylabel("Soil flux (m2/yr)")

"""
So it appears as if we are not quite there, but pretty close.
"""

"""
## References

Barnhart, K., Glade, R., Shobe, C., Tucker, G. (2019). Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution. Geoscientific Model Development  12(4), 1267--1297, [https://dx.doi.org/10.5194/gmd-12-1267-2019](https://dx.doi.org/10.5194/gmd-12-1267-2019).

Ganti, V., Passalacqua, P., Foufoula-Georgiou, E. (2012). A sub-grid scale closure for nonlinear hillslope sediment transport models. Journal of Geophysical Research: Earth Surface, 117(F2), [https://dx.doi.org/10.1029/2011jf002181](https://dx.doi.org/10.1029/2011jf002181).

Roering, J. J., Kirchner, J. W., & Dietrich, W. E. (1999). Evidence for nonlinear, diffusive sediment transport on hillslopes and implications for landscape morphology. Water Resources Research, 35(3), 853-870.

"""



================================================
File: docs/source/tutorials/hillslope_geomorphology/transport-length_hillslope_diffuser/TLHDiff_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The transport-length hillslope diffuser
"""

"""
This Jupyter notebook illustrates running the transport-length-model hillslope diffusion component in a simple example.

# The Basics

This component uses an approach similar to the Davy and Lague (2009) equation for fluvial erosion and transport, and applies it to hillslope diffusion. The formulation and implementation were inspired by Carretier et al. (2016); see this paper and references therein for justification.

## Theory

The elevation $z$ of a point of the landscape (such as a grid node) changes according to:

\begin{equation}
\frac{\partial z}{\partial t} = -\epsilon + D + U  \tag{1}\label{eq:1},
\end{equation}


and we define:
\begin{equation}
D = \frac{q_s}{L}  \tag{2}\label{eq:2},
\end{equation}


where $\epsilon$ is the local erosion rate [*L/T*], $D$ the local deposition rate [*L/T*], $U$ the uplift (or subsidence) rate [*L/T*], $q_s$ the incoming sediment flux per unit width [*L$^2$/T*] and $L$ is the **transport length**.

We specify the erosion rate $\epsilon$ and the transport length $L$:

\begin{equation}
\epsilon = \kappa S  \tag{3}\label{eq:3}
\end{equation}



\begin{equation}
L = \frac{dx}{1-({S}/{S_c})^2}  \tag{4}\label{eq:4}
\end{equation}

where $\kappa$ [*L/T*] is an erodibility coefficient, $S$ is the local slope [*L/L*] and $S_c$ is the critical slope [*L/L*]. 

Thus, the elevation variation results from the difference between local rates of detachment and deposition. 

The detachment rate is proportional to the local gradient. However, the deposition rate ($q_s/L$) depends on the local slope and the critical slope:
- when $S \ll S_c$, most of the sediment entering a node is deposited there, this is the pure diffusion case. In this case, the sediment flux $q_s$ does not include sediment eroded from above and is thus "local".
- when $S \approx S_c$, $L$ becomes infinity and there is no redeposition on the node, the sediments are transferred further downstream.  This behaviour corresponds to mass wasting, grains can travel a long distance before being deposited. In that case, the flux $q_s$ is "non-local" as it incorporates sediments that have both been detached  locally and transited from upslope.
- for an intermediate $S$, there is a prgogressive transition between pure creep and "balistic" transport of the material. This is consistent with experiments (Roering et al., 2001; Gabet and Mendoza, 2012).


"""

"""
## Contrast with the non-linear diffusion model

Previous models typically use a "non-linear" diffusion model proposed by different authors (e.g. Andrews and Hanks, 1985; Hanks, 1999; Roering et al., 1999) and supported by $^{10}$Be-derived erosion rates (e.g. Binnie et al., 2007) or experiments (Roering et al., 2001). It is usually presented in the following form:


\begin{equation} 
\frac{\partial z}{\partial t} = \frac{\partial q_s}{\partial x}  \tag{5}\label{eq:5}
\end{equation}



\begin{equation}
q_s = \frac{\kappa' S}{1-({S}/{S_c})^2}   \tag{6}\label{eq:6}
\end{equation}

where $\kappa'$ [*L$^2$/T*] is a diffusion coefficient.

This description is thus based on the definition of a flux of transported sediment parallel to the slope:
- when the slope is small, this flux refers to diffusion-like processes such as biogenic soil disturbance, rain splash, or diffuse runoff
- when the slope gets closer to the specified critical slope, the flux increases dramatically, simulating on average the cumulative effect of mass wasting events.


Despite these conceptual differences, equations ($\ref{eq:3}$) and ($\ref{eq:4}$) predict similar topographic evolution to the 'non-linear' diffusion equations for $\kappa' = \kappa dx$, as shown in the following example.
"""

"""
# Example 1:


"""

"""
First, we import what we'll need:
"""

import numpy as np
from matplotlib.pyplot import figure, plot, title, xlabel, ylabel

from landlab import RasterModelGrid
from landlab.components import FlowDirectorSteepest, TransportLengthHillslopeDiffuser
from landlab.plot import imshow_grid

# to plot figures in the notebook:
%matplotlib inline

"""
Make a grid and set boundary conditions:
"""

mg = RasterModelGrid(
    (20, 20), xy_spacing=50.0
)  # raster grid with 20 rows, 20 columns and dx=50m
z = np.random.rand(mg.size("node"))  # random noise for initial topography
mg.add_field("topographic__elevation", z, at="node")

mg.set_closed_boundaries_at_grid_edges(
    False, True, False, True
)  # N and S boundaries are closed, E and W are open

"""
Set the initial and run conditions:
"""

total_t = 2000000.0  # total run time (yr)
dt = 1000.0  # time step (yr)
nt = int(total_t // dt)  # number of time steps
uplift_rate = 0.0001  # uplift rate (m/yr)

kappa = 0.001  # erodibility (m/yr)
Sc = 0.6  # critical slope

"""
Instantiate the components:
The hillslope diffusion component must be used together with a flow router/director that provides the steepest downstream slope for each node, with a D4 method (creates the field *topographic__steepest_slope* at nodes).
"""

fdir = FlowDirectorSteepest(mg)
tl_diff = TransportLengthHillslopeDiffuser(mg, erodibility=kappa, slope_crit=Sc)

"""
Run the components for 2 Myr and trace an East-West cross-section of the topography every 100 kyr:
"""

for t in range(nt):
    fdir.run_one_step()
    tl_diff.run_one_step(dt)
    z[mg.core_nodes] += uplift_rate * dt  # add the uplift

    # add some output to let us see we aren't hanging:
    if t % 100 == 0:
        print(t * dt)

        # plot east-west cross-section of topography:
        x_plot = range(0, 1000, 50)
        z_plot = z[100:120]
        figure("cross-section")
        plot(x_plot, z_plot)

figure("cross-section")
title("East-West cross section")
xlabel("x (m)")
ylabel("z (m)")

"""
And plot final topography:
"""

figure("final topography")
im = imshow_grid(
    mg, "topographic__elevation", grid_units=["m", "m"], var_name="Elevation (m)"
)

"""
This behaviour corresponds to the evolution observed using a classical non-linear diffusion model.
"""

"""
# Example 2: 

In this example, we show that when the slope is steep ($S \ge S_c$), the transport-length hillsope diffusion simulates mass wasting, with long transport distances.

First, we create a grid: the western half of the grid is flat at 0 m of elevation, the eastern half is a 45-degree slope.

"""

# Create grid and topographic elevation field:
mg2 = RasterModelGrid((20, 20), xy_spacing=50.0)

z = np.zeros(mg2.number_of_nodes)
z[mg2.node_x > 500] = mg2.node_x[mg2.node_x > 500] / 10
mg2.add_field("topographic__elevation", z, at="node")

# Set boundary conditions:
mg2.set_closed_boundaries_at_grid_edges(False, True, False, True)

# Show initial topography:
im = imshow_grid(
    mg2, "topographic__elevation", grid_units=["m", "m"], var_name="Elevation (m)"
)

# Plot an east-west cross-section of the initial topography:
z_plot = z[100:120]
x_plot = range(0, 1000, 50)
figure(2)
plot(x_plot, z_plot)
title("East-West cross section")
xlabel("x (m)")
ylabel("z (m)")

"""
Set the run conditions:
"""

total_t = 1000000.0  # total run time (yr)
dt = 1000.0  # time step (yr)
nt = int(total_t // dt)  # number of time steps

"""
Instantiate the components:
"""

fdir = FlowDirectorSteepest(mg2)
tl_diff = TransportLengthHillslopeDiffuser(mg2, erodibility=0.001, slope_crit=0.6)

"""
Run for 1 Myr, plotting the cross-section regularly:
"""

for t in range(nt):
    fdir.run_one_step()
    tl_diff.run_one_step(dt)

    # add some output to let us see we aren't hanging:
    if t % 100 == 0:
        print(t * dt)
        z_plot = z[100:120]
        figure(2)
        plot(x_plot, z_plot)

"""
The material is diffused from the top and along the slope and it accumulates at the bottom, where the topography flattens.

As a comparison, the following code uses linear diffusion on the same slope:
"""

# Import Linear diffuser:
from landlab.components import LinearDiffuser

# Create grid and topographic elevation field:
mg3 = RasterModelGrid((20, 20), xy_spacing=50.0)
z = np.ones(mg3.number_of_nodes)
z[mg.node_x > 500] = mg.node_x[mg.node_x > 500] / 10
mg3.add_field("topographic__elevation", z, at="node")

# Set boundary conditions:
mg3.set_closed_boundaries_at_grid_edges(False, True, False, True)

# Instantiate components:
fdir = FlowDirectorSteepest(mg3)
diff = LinearDiffuser(mg3, linear_diffusivity=0.1)

# Set run conditions:
total_t = 1000000.0
dt = 1000.0
nt = int(total_t // dt)

# Run for 1 Myr, plotting east-west cross-section regularly:
for t in range(nt):
    fdir.run_one_step()
    diff.run_one_step(dt)

    # add some output to let us see we aren't hanging:
    if t % 100 == 0:
        print(t * dt)
        z_plot = z[100:120]
        figure(2)
        plot(x_plot, z_plot)



================================================
File: docs/source/tutorials/landscape_evolution/area_slope_transporter/einstein-brown.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Unit tests and parameterization for `AreaSlopeTransporter`

*(Greg Tucker, University of Colorado Boulder, October 2022)*

This notebook gives background on the default parameters for the `AreaSlopeTransporter` component, and also provides the calculations for a set of unit tests that are used in the code.

## Parameters for the Einstein-Brown transport equation

The `AreaSlopeTransporter` component calculates fluvial volumetric sediment flux, $Q_s$, from a generic area-slope power law:

$$Q_s = k_s A^m S^n$$

This section works out the transport parameters $k_s$, $m$, and $n$ for the Einstein-Brown law, based on Willgoose's 1991 appendix but adding the extra step of integrating across a channel of width $W = a Q^b$ to get total volumetric transport rate. These parameters are used as the default in the component.
"""

"""
### Converting to area-slope form

(This follows Willgoose et al. (1991a WRR) appendix):

Dimensionless transport rate:

$$\phi = 40 \tau_*^3$$

Definition of dimensionless xport rate:

$$\phi = \frac{M_s}{\rho_s F_1 \sqrt{g(s - 1) D^3}}$$

where $M_s$ sediment discharge in mass/time/width, $s$ is sed specific grav, $D$ is grain diameter. 

$\tau_*$ is the usual:

$$\tau_* = \frac{\tau_b}{(\rho_s - \rho) g D}$$

The weirdo factor is:

$$F_1 = \sqrt{\frac{2}{3} + \frac{36\nu^2}{g D^3 (s-1)}}
- \sqrt{\frac{36\nu^2}{gD^3(s-1)}}$$

From plenty of other derivations, we can cast $\tau_b$ in terms of discharge and slope. Here's one version using the Manning equation for a wide channel:

$$\tau_b = \rho g H S$$

$$Q = \frac{1}{n} W H^{5/3} S^{1/2}$$

$$H^{5/3} = \frac{Qn}{WS^{1/2}}$$


$$H = \frac{(Qn)^{3/5}}{W^{3/5}S^{3/10}}$$

Check the units here... we have L$^{9/5 - 3/5 - 1/5}$ T$^{-3/5+3/5}$...ok.

Plug in:

$$\tau_b = \rho g \frac{(Qn)^{3/5}}{W^{3/5}S^{3/10}} S$$

Simplify

$$\tau_b = \rho g n^{3/5} \left(\frac{Q}{W}\right)^{3/5} S^{7/10}$$

So then,

$$\phi = \frac{40}{(\rho_s - \rho)^3 g^3 D^3} \left(\rho g n^{3/5} \left(\frac{Q}{W}\right)^{3/5} S^{7/10}\right)^3$$

which converts to:

$$\phi = \frac{40\rho^3 g^3 n^{9/5}}{(\rho_s - \rho)^3 g^3 D^3} \left( \left(\frac{Q}{W}\right)^{3/5} S^{7/10}\right)^3$$

$$\phi = \frac{40 n^{9/5}}{(s - 1)^3 D^3} \left(\frac{Q}{W}\right)^{1.8} S^{2.1}$$

Check units again: L$^{-3/5 - 3 + 3.6 = 0}$, T$^{9/5 - 9/5 = 0}$.

Now the annoying $\phi$:

$$q_s = \frac{M_s}{\rho_s} = F_1\sqrt{g (s-1) D^3} \frac{40 n^{9/5}}{(s - 1)^3 D^3} \left(\frac{Q}{W}\right)^{1.8} S^{2.1}$$

$$q_s = \frac{M_s}{\rho_s} = F_1\sqrt{g} \frac{40 n^{9/5}}{(s - 1)^{5/2} D^{3/2}} \left(\frac{Q}{W}\right)^{1.8} S^{2.1}$$
"""

"""
Now it's time to bring in the pesky channel-width issue:

$$W = a Q^b$$

$$q_s = \frac{M_s}{\rho_s} = F_1\sqrt{g} \frac{40 n^{9/5}}{(s - 1)^{5/2} D^{3/2}} \left(\frac{Q^{1-b}}{a}\right)^{1.8} S^{2.1}$$

$$q_s = \frac{M_s}{\rho_s} = F_1\sqrt{g} \frac{40 n^{9/5}}{(s - 1)^{5/2} D^{3/2}a^{9/5}} Q^{1.8(1-b)} S^{2.1}$$
"""

"""
Using $b=1/2$, we have:

$$q_s = F_1\sqrt{g} \frac{40 n^{9/5}}{(s - 1)^{5/2} D^{3/2}a^{9/5}} Q^{0.9} S^{2.1}$$

Let's now cast in terms of total flux, again with $b=1/2$:

$$Q_s = a F_1\sqrt{g} \frac{40 n^{9/5}}{(s - 1)^{5/2} D^{3/2}a^{9/5}} Q^{1.4} S^{2.1}$$

That's instantaneous. Let's factor in an intermittency factor, $I$, and combine pieces,

$$Q_s = k_{sq} I Q^{1.4} S^{2.1}$$

For $F_1$, we need a grain diameter, densities, and kinematic viscosity. Using 0.05 m for grain diameter,
"""

"""
Next, we'll convert this into an area-slope formulation. Let's assume $Q_{bf} = RA$ (not ideal, given common sub-linear $A$ scaling, but let's run with it). Then,

$$\boxed{Q_s = k_s A^{1.4} S^{2.1}}$$

where

$$k_s = k_{sq} I R^{0.9}$$
"""

"""
### Estimating a value for $k_s$

Ok, now for some numbers. Let's use $n=0.01$ in SI units. For bankfull width, if we use $b = 1/2$ and $a = 5$ s$^{1/2}$/m, and a bankfull runoff rate of 10 m/y, what would we have for width?
"""

import numpy as np

a = 5.0
b = 0.5

area = np.array([1.0e6, 10.0e6, 100.0e6, 1000.0e6])
discharge = 1.0e-7 * area
width = a * discharge**b
print("At a bankfull discharge of:", discharge, "cms...")
print("...the corresponding bankfull width would be:", width)

"""
Note that this is just a rough guess at $a$. One should ideally interrogate hydraulic geometry, but here the purpose is simply to identify a value that is basically reasonable.

Here's one example. Boulder Creek at Orodell has an annual peak (snow-melt) flow 500 cfs. How wide would it be at a = 1, 5, 10? Drainage area is 102 mi$^2$, or 264 km$^2$. The channel is roughly 20 m wide here (though possibly artifically narrowed by the road). If we assume the annual maximum flow is the bankfull event, how wide would the channel be if the coefficient were 5 and the exponent 1/2?
"""

Qbf = 500 * (0.3048**3)  # bankfull flow, converted to cms
w = 5 * Qbf**0.5  # predicted width, m
am2 = 102 * (5280 * 0.3048) ** 2  # while we're at it, convert drainage area to m2
print("Peak discharge (cms):", Qbf)
print("Predicted width (m):", w)
print("Drainage area (km2):", am2 / 1e6)
print("Runoff rate (m/s):", Qbf / am2)
print("Runoff rate (m/y):", Qbf * 3600 * 365.25 * 24 / am2)

"""
The above turns out to be quite close to the estimated width of 20 m. Although this is just one example, and not a proper fit by any means, for our purposes it suffices to demonstrate that an $a$ value of 5 (in SI units) is not completely crazy.

For the sake of estimating a default value for $k_s$, we'll choose values for the kinematic viscosity of water (which is temperature-dependent; the value $10^{-6}$  Pa$\cdot$s applies to 20 $^\circ$C), grain diameter (5 cm), and sediment immersed specific gravity (1.65, representing quartz). Clearly this means that the coefficient value depends in particular on grain diameter, and to a lesser extent on grain density.

Next, the Einstein-Brown $F_1$ parameter:
"""

nu = 1.0e-6  # kinematic viscosity of water, m2/s
D = 0.05  # grain diameter, m
sm1 = 1.65  # immersed specific gravity
g = 9.8

term = (36.0 * nu**2) / (g * D**3 * sm1)
F1 = ((2.0 / 3.0) + term) ** 0.5 - term**0.5
print("F1 =", F1)

"""
This allows us to calculate $k_{sq}$, here with $n=0.01$ and $a=5$,
"""

n = 0.01  # Manning roughness coefficient in SI units
a = 5.0  # width-discharge factor, SI

ksq = a * F1 * g**0.5 * ((40.0 * n**4.5) / (sm1**2.5 * D**1.5 * a**4.5))
print("ksq", ksq)

"""
Next, we'll calculate the corresponding $k_s$ by applying a bankfull runoff rate (2 m/y) and an intermittency factor (0.01):
"""

R = 2.0  # bankfull runoff rate
intermittency = 0.01  # intermittency factor

ks = ksq * intermittency * R**0.9
print("ks", ks)

"""
For landscape evolution, it makes sense to compute $Q_s$ in m$^3$/y rather than m$^3$/s, so we will factor a unit conversion into the coefficient:
"""

# Convert ks to time units of years:
ksy = ks * 365.25 * 24 * 3600.0
print("ksy", ksy)

"""
If we round this off, we have our default value for $k_s$: 0.0055, with length units of m and time units of years.
"""

"""
Now we're ready to do a sanity check by examining the slope-area relationship. Let sediment flux be erosion rate times drainage area (ignoring fines and dissolved load), $Q_s = EA$. Equilibrium means:

$$EA = k_s A^{1.4} S^{2.1}$$

$$S = \left(\frac{E}{k_s}\right)^{1/2.1} A^{-0.4/2.1}$$

$$S \approx \left(\frac{E}{k_s}\right)^{0.48} A^{-0.19}$$



"""

print(1 / 2.1)
print(0.4 / 2.1)

"""
What does this imply for gradients given $E=10^{-4}$ m/y, and $A\in (10, 100, 1000) $km$^2$?
"""

E = 1.0e-4
A = np.array([10.0e6, 100.0e6, 1000.0e6])

print("S=", (E / ksy) ** 0.48 * A ** (-0.19))

"""
These seem like reasonable values for gradient.
"""

"""
## Unit tests

### Default parameters

Based on the derivation above, the default parameters will be $k_s = 0.0055$, $m=1.4$, $n=2.1$.

### Slope-area for one grid cell

Consider a grid cell 1000 x 1000 m with an uplift rate of $10^{-4}$ m/y. The sediment input rate is therefore 100 m$^3$/y. The resulting outflux should equal this:

$$Q_s = 0.0055 (10^6)^{1.4} S^{2.1} = 100 m^3/y$$

$$S = \left( \frac{(100)}{(0.0055)(10^6)^{1.4}}\right)^{1/2.1}$$
"""

Seq = (100.0 / (0.0055 * 1.0e6**1.4)) ** (1.0 / 2.1)
elev_eq = Seq * 1000.0
print("Equilibrium slope:", Seq)
print("Equilibrium elevation:", elev_eq)

# test: elevation at the node should be 1,068 cm when rounded to the nearest cm.
print("Rounded elevation in cm:", int(round(elev_eq * 100)))

"""
### Transport capacity for a single cell

Assume an elevation of 1.0 m, $\Delta x = 100$ m. Drainage area therefore is 10,000 m$^2$ and slope is 0.01. Therefore with default parameters, the volumetric sediment discharge should be:
"""

Qs = 0.0055 * (100 * 100) ** 1.4 * (0.01) ** 2.1
print("Qs:", Qs)
print("Qs in liters per year (to nearest liter):", int(Qs * 1000))

"""
### Sediment rate of change

Consider two core nodes flowing in one direction toward a single open boundary. Grid is raster with $\Delta x = 100$ m. Slope is 0.01. Calculate $dz/dt$ at each grid node.
"""

A = 1.0e4 * np.array([3, 2, 1])  # drainage area (m2); flow is right to left
Qsout = np.zeros(len(A))
Qsin = np.zeros(len(A))
Qsout[1:] = 0.0055 * A[1:] ** 1.4 * 0.01**2.1  # sediment outflux from each node, m3/y
Qsin[:2] = Qsout[1:]  # sediment influx to each node, m3/y
dzdt = (Qsin - Qsout) / 1.0e4  # rate of elevation change, m/y
print(Qsin)
print(Qsout)
print(dzdt)

# test: answer should be array([ 0.   ,  0.365,  0.138])
print(np.round(Qsout, 3))

# test: answer should be array([ 0.365,  0.138,  0.   ])
print(np.round(Qsin, 3))

# test: answer should be array([ -2.26400000e-05,  -1.38200000e-05])
print(np.round(dzdt[1:], 8))

"""
### `run_one_step`

Running one time step of 10,000 years with the above case should lower the nodes as follows:
"""

elev = np.array([0.0, 1.0, 2.0])
elev[1:] += dzdt[1:] * 10000.0  # erode for one time step of 10,000 years
print(elev)

# test: should be array([0.    , 0.7736, 1.8618])
np.round(elev, 4)

"""
These unit tests are embedded into the code as doctests.
"""



================================================
File: docs/source/tutorials/landscape_evolution/area_slope_transporter/transport-limited-LEM-example.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Example of a transport-limited LEM using `AreaSlopeTransporter`

*(Greg Tucker, University of Colorado Boulder, October 2022)*
"""

"""
This tutorial notebook illustrates how to use the Landlab `AreaSlopeTransporter` component to create a simple transport-limited Landscape Evolution Model (LEM).
"""

"""
## Background

The `AreaSlopeTransporter` is a landscape evolution component that models the time rate of change of elevation at a set of grid nodes, each of which has a defined contributing drainage area $A$ (field `drainage_area`) and a local steepest-descent slope gradient, $S$, defined from the node itself toward one of its neighboring nodes. The drainage area and slope can be computed with a drainage-routing component such as `FlowAccumulator` or `PriorityFloodFlowAccumulator`. The component is designed to function as an integral part of a transport-limited landscape evolution model in the spirit of Willgoose et al. (1991a,b,c,d).

Once $A$ and $S$ have been calculated, the volumetric outgoing sediment flux at each grid node is calculated using

$$Q_{out} = k_s A^m S^n$$

The component's default parameters are $m=1.4$, $n=2.1$, and $k_s = 0.0055$ (with time units of years). These defaults are based on Willgoose et al. (1991a), who used the Einstein-Brown sediment transport formula as a basis, but here modified to include an empirical sub-grid-cell channel width. The derivation is provided in a separate notebook (see *einstein-brown.ipynb*). The essence of the odd-seeming exponent values is this: Einstein-Brown describes a cubic dependence on shear stress, which essentially has a 2/3 power dependence on slope gradient. That gets you the power 2; the extra 0.1 shows up because of the use of the Manning equation to describe roughness, in which the roughness factor has a slight depenence on flow depth. The 1.4 exponent on drainage area has a similar story, with one difference from Willgoose et al. (1991a) (who used a 1.8 power) being the assumption that bankfull width is proportional to the square root of discharge. The derivation in the *einstein-brown.ipynb* notebook describes how that leads to 1.4 power scaling. Note that Howard (1994) also used Einstein-Brown as the basis for an alluvial-channel element of an otherwise detachment-limited landscape evolution model.

The time rate of change of elevation is calculated over a grid cell at node $i$ with surface area $\Lambda_i$, such that mass continuity gives the time rate of elevation ($z_i$) change (in the absence of other processes) as:

$$\frac{dz_i}{dt} = \frac{Q_{in} - Q_{out}}{\Lambda_i}$$

The sediment influx at each node is calculated as the sum of outflux of all upstream neighbor nodes that flow to it.

Note that this is a no-frills component, at least as of this writing. It uses only drainage area (not discharge, even if calculated). It uses a very basic forward-Euler solution algorithm, and so it requires very small time steps. There is no adaptive solver. It is designed mainly for illustrative purposes: to show how a basic transport-limited area-slope LEM behaves. As with all Landlab components, the user should understand the theory and be familiar with the background literature!

*This Landlab component is dedicated to the memory of two remarkable hydrologists: Garry Willgoose and Ignacio Rodriguez-Iturbe.*
"""

"""
## Example

The example uses a very small (15 x 15) domain, initially uplifted 25 m above the baselevel, which is represented by a single node in one corner of the grid. The small domain and short run duration are meant to keep the total run time under a second or so, depending on the computer architecture. The user is encouraged to experiment with larger domains and longer run durations, but beware that in general the larger the domain, the smaller the time-step size will need to be to ensure numerical stability. (If the concept of numerical instability is unfamiliar, then consultation of a textbook and/or online resources on numerical methods for partial differential equations is highly recommended.)
"""

import time

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import AreaSlopeTransporter, FlowAccumulator

# Parameters
nrows = 15  # number of node rows
ncols = 15  # number of node columns
dx = 20.0  # grid node spacing, m
run_duration = 4000.0  # run duration, y
dt = 2.5  # time-step duration, y
noise_amplitude = 1.0  # amplitude of initial random noise, m
initial_height = 25.0  # initial plateau height, m
seed = 1  # random seed

# Control and derived parameters, and other setup
elapsed_time = 0.0
np.random.seed(seed)

# Initialize grid and set boundary conditions
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
grid.status_at_node[ncols - 1] = grid.BC_NODE_IS_FIXED_VALUE  # corner outlet

# Create and initialize elevation field
elev = grid.add_zeros("topographic__elevation", at="node")
elev[grid.core_nodes] = initial_height + noise_amplitude * np.random.rand(
    grid.number_of_core_nodes
)

# Instantiate components
fa = FlowAccumulator(grid, flow_director="FlowDirectorD8")
ast = AreaSlopeTransporter(grid)

# Main loop
start = time.time()
while elapsed_time < run_duration:
    fa.run_one_step()
    ast.run_one_step(dt)
    elapsed_time += dt

wall_time = time.time() - start
print("Wall time for run:", wall_time, "s")

# Display the final topography in map view
imshow_grid(grid, elev)

# Display the final topography in 3d surface view
X = np.arange(0, dx * ncols, dx)
Y = np.arange(0, dx * nrows, dx)
X, Y = np.meshgrid(X, Y)

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
ax.plot_surface(X, Y, elev.reshape((nrows, ncols)))

"""
## References

Howard, A. D. (1994). A detachment‐limited model of drainage basin evolution. Water resources research, 30(7), 2261-2285.

Tucker, G. E., & Hancock, G. R. (2010). Modelling landscape evolution. Earth Surface Processes and Landforms, 35(1), 28-50.

Willgoose, G. (2018). *Principles of soilscape and landscape evolution.* Cambridge University Press.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991a). A coupled channel network growth and hillslope evolution model: 1. Theory. Water Resources Research, 27(7), 1671-1684.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991b). A coupled channel network growth and hillslope evolution model: 2. Nondimensionalization and applications. Water Resources Research, 27(7), 1685-1696.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991c). A physical explanation of an observed link area‐slope relationship. Water Resources Research, 27(7), 1697-1702.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991d). Results from a new model of river basin evolution. Earth Surface Processes and Landforms, 16(3), 237-254.

"""



================================================
File: docs/source/tutorials/landscape_evolution/erosion_deposition/erosion_deposition_component.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to the `ErosionDeposition` component
"""

"""
This tutorial introduces the `ErosionDeposition` component, which simulates erosion and deposition in a river network over long time scales.

## Theory and Overview

`ErosionDeposition` models fluvial processes using the approach described by Davy and Lague (2009). The basic goal is to calculate rates of erosion or deposition in the various branches of a river network that is embedded in a gridded landscape (see, e.g., Tucker and Hancock, 2010). The literature has a number of different approaches to this problem. Some models assume transport-limited conditions, such that erosion or deposition result from local imbalances in sediment transport capacity (see, e.g., Willgoose, 2018). Some assume detachment-limited conditions, such that any eroded sediment is entirely removed  (e.g., Howard, 1994; Whipple and Tucker, 1999; Tucker and Whipple, 2002). Still others allow for both erosion of detachment-resistant material (bedrock or cohesive sediments), and re-deposition of that material. The Davy-Lague approach falls in the latter category, and is similar to the approach used in some shorter-term morphodynamic models as well as agricultural soil erosion models. The basic idea involves conservation of sediment mass in the water column of a river. One calculates the rate of entrainment of sediment from the bed into the water as a function of discharge and local slope. The bed also accumulates sediment that settles out from the water column, at a rate that depends on sediment concentration (treated as the ratio of sediment flux to water discharge) and a settling-velocity parameter.

The theory behind using this kind of dual erosion-deposition approach in the context of fluvial landscape evolution is described by Davy and Lague (2009). Tucker and Hancock (2010) provide a review of landscape evolution modeling that compares this with other approaches to fluvial erosion/deposition theory. The equations used in the Landlab `ErosionDeposition` component are described by Barnhart et al. (2019) as part of the *terrainBento* collection of Landlab-based landscape evolution models, which includes models that use `ErosionDeposition`.
"""

import copy

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

from landlab import HexModelGrid
from landlab.components import ErosionDeposition, FlowAccumulator
from landlab.plot import imshow_grid

"""
Look at the top-level internal documentation for the `ErosionDeposition` component:
"""

print(ErosionDeposition.__doc__)

"""
The `__init__` docstring lists the parameters for this component:
"""

print(ErosionDeposition.__init__.__doc__)

"""
Set some parameters:
"""

# Parameters
nrows = 41
ncols = 41
dx = 100.0
K = 0.0001  # erodibility coefficient, 1/yr
m_sp = 0.5  # exponent on drainage area or discharge, -
n_sp = 1.0  # exponent on slope, -
sp_crit = 0.0  # erosion threshold
v_s = 100.0  # settling velocity parameter (dimensionless if drainage area is used instead of discharge)
F_f = 0.5  # fraction of fines generated during bed erosion
initial_elevation = (
    200.0  # starting elevation of an "uplifted block" (rapid baselevel drop), m
)

run_duration = 120000.0  # duration of run, yr
dt = 100.0  # time-step duration, yr
plot_every = 40000.0  # time interval for plotting, yr

# Derived parameters
nsteps = int(run_duration / dt)
next_plot = plot_every

# set up colormap
cmap = copy.copy(mpl.colormaps["pink"])

"""
Create a grid with one side open:
"""

mg = HexModelGrid(
    (nrows, ncols), spacing=dx, node_layout="rect", orientation="vertical"
)
z = mg.add_zeros("topographic__elevation", at="node")
# add some roughness, as this lets "natural" channel planforms arise
np.random.seed(0)
initial_roughness = np.random.rand(z.size)
z[:] += initial_roughness
z[mg.core_nodes] += initial_elevation
z[mg.boundary_nodes] = 0.0

# close off boundaries on 3 sides
is_closed_boundary = np.logical_and(
    mg.status_at_node != mg.BC_NODE_IS_CORE,
    mg.x_of_node < (np.amax(mg.x_of_node) - 0.5 * dx),
)
mg.status_at_node[is_closed_boundary] = mg.BC_NODE_IS_CLOSED

"""
Instantiate components:
"""

fr = FlowAccumulator(mg, depression_finder="DepressionFinderAndRouter")
ed = ErosionDeposition(
    mg,
    K=K,
    m_sp=m_sp,
    n_sp=n_sp,
    sp_crit=sp_crit,
    v_s=v_s,
    F_f=F_f,
    solver="adaptive",  # use the adaptive time stepper, which is slightly faster
)

"""
Run the model in a loop to evolve topography on the uplifted block:
"""

for i in range(1, nsteps + 1):
    # route flow
    fr.run_one_step()  # run_one_step isn't time sensitive, so it doesn't take dt as input

    # do some erosion/deposition
    ed.run_one_step(dt)

    if i * dt >= next_plot:
        plt.figure()
        imshow_grid(
            mg,
            "topographic__elevation",
            grid_units=["m", "m"],
            var_name="Elevation (m)",
            cmap=cmap,
        )
        next_plot += plot_every

"""
## References

Barnhart, K. R., Glade, R. C., Shobe, C. M., & Tucker, G. E. (2019). Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution. Geoscientific Model Development, 12(4), 1267-1297.

Davy, P., & Lague, D. (2009). Fluvial erosion/transport equation of landscape evolution models revisited. Journal of Geophysical Research: Earth Surface, 114(F3).

Howard, A. D. (1994). A detachment‐limited model of drainage basin evolution. Water resources research, 30(7), 2261-2285.

Tucker, G. E., & Hancock, G. R. (2010). Modelling landscape evolution. Earth Surface Processes and Landforms, 35(1), 28-50.

Tucker, G. E., & Whipple, K. X. (2002). Topographic outcomes predicted by stream erosion models: Sensitivity analysis and intermodel comparison. Journal of Geophysical Research: Solid Earth, 107(B9), ETG-1.

Whipple, K. X., & Tucker, G. E. (1999). Dynamics of the stream‐power river incision model: Implications for height limits of mountain ranges, landscape response timescales, and research needs. Journal of Geophysical Research: Solid Earth, 104(B8), 17661-17674.

Willgoose, G. (2018). Principles of soilscape and landscape evolution. Cambridge University Press.
"""



================================================
File: docs/source/tutorials/landscape_evolution/erosion_deposition/shared_stream_power.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab Shared Stream Power Model

*(Ann Thompson, Arizona State University, July 2024)*

This notebook is a tutorial of the `SharedStreamPower` component, which is an extension of the `ErosionDeposion` component. `SharedStreamPower` is a landscape evolution model designed to seamlessly transition between bedrock incision (detachment limited erosion) and sediment transport (transport limited erosion). It is based off of the shared stream power model from Hergarten (2021).
"""

"""
## Overview

### Theory

Here is the equation for the shared stream power model:

$$E = k_{bedrock}A^mS^n- \frac{k_{bedrock}}{k_{transport}}\frac{Q_s}{A} $$ 

where $k_{bedrock}$ is the erodibility with no sediment and $k_{transport}$ is the ability to transport sediment. The ratio, $\frac{k_{bedrock}}{k_{transport}}$ determines how much relative bedrock incision and sediment transport is occurring.

For $\frac{k_{bedrock}}{k_{transport}} = 0$, the model is entirely detachment limited, and behaves as the stream power model:
$$E = k_{bedrock}A^mS^n$$

For $\frac{k_{bedrock}}{k_{transport}} = \infty$, the model is completely dominated by deposition.


"""

"""
Import Libraries
"""

import matplotlib.pyplot as plt
import numpy as np
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components import (
    ChannelProfiler,
    ChiFinder,
    DepressionFinderAndRouter,
    FlowAccumulator,
    SharedStreamPower,
    SteepnessFinder,
)

"""
Make Grid
"""

# Create grid
grid = RasterModelGrid((20, 20), xy_spacing=100.0)

# Leave bottom boundary open
grid.set_closed_boundaries_at_grid_edges(True, True, True, False)


# Create initial topography
np.random.seed(35)  # seed set so our figures are reproducible

# initial noise on elevation grid
# set up the elevation on the grid
grid.at_node["topographic__elevation"] = np.random.rand(grid.number_of_nodes) / 1000.0

"""
Set Parameters
"""

k_bedrock = 0.001  # bedrock erodibility
k_transport = 0.01  # transport coefficient
# For detachment limited behavior, set k_bedrock = 0.001, k_transport = 0.01
# For transport limited behavior, set k_bedrock = 0.01, k_transport = 0.001
# For mixed bedrock-alluvial conditions, set k_bedrock = k_transport = 0.001

F_f = 0.0  # fraction of fines
m_sp = 0.5  # discharge exponent
n_sp = 1.0  # slope exponent
r = 1.0  # m/yr # Define runoff parameter r, where Q=Ar

# time parameters, timestep, run time, print time  (years)
timestep = 10
run_time = 50000
print_time = 10000

# Set elapsed time to zero
elapsed_time = 0

# set uplift rate
rock_uplift_rate = 1e-4  # m/yr

"""
Instantiate Components
"""

# Instantiate flow accumulator and depression finder for each timestep
flow_accumulator = FlowAccumulator(grid, flow_director="D8")
depression_finder = DepressionFinderAndRouter(grid)

# Instantiate components for plotting results
steepness_finder = SteepnessFinder(
    grid, reference_concavity=m_sp / n_sp, min_drainage_area=1000.0
)
chi_finder = ChiFinder(
    grid,
    min_drainage_area=1000.0,
    reference_concavity=m_sp / n_sp,
    use_true_dx=True,
)

# Instantiate the shared stream power component
shared_stream_power = SharedStreamPower(
    grid, k_bedrock=k_bedrock, k_transport=k_transport, m_sp=m_sp, n_sp=n_sp
)

"""
Run
"""

for _ in trange(0, run_time, timestep):
    # Run the flow router
    flow_accumulator.run_one_step()

    # Run the depression finder and router; optional
    depression_finder.map_depressions()

    # Run the SSPM model
    shared_stream_power.run_one_step(dt=timestep)

    # Move  elevation of core nodes upwards relative to base level
    # at the rock uplift rate
    grid.at_node["topographic__elevation"][grid.core_nodes] += (
        rock_uplift_rate * timestep
    )

"""
### Plot
"""

# Pick individual channels to plot in map view
prf = ChannelProfiler(
    grid,
    number_of_watersheds=2,
    main_channel_only=False,
    minimum_channel_threshold=grid.dx**2,
)
prf.run_one_step()

plt.figure(1)
prf.plot_profiles_in_map_view()
plt.show()

# Plot channel profiles
plt.figure(2)
prf.plot_profiles()
plt.show()

# Plot slope-area plots for the channels
plt.figure(3)
plt.figure(figsize=(6, 2))
for i, outlet_id in enumerate(prf.data_structure):
    for j, segment_id in enumerate(prf.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        color = segment["color"]
        plt.loglog(
            grid.at_node["drainage_area"][profile_ids],
            grid.at_node["topographic__steepest_slope"][profile_ids],
            ".",
            color=color,
            label=label,
        )

plt.legend(loc="lower left")
plt.xlabel("drainage area (m^2)")
plt.ylabel("channel slope [m/m]")
plt.title("Area vs. Slope")


# calculate normalized channel steepness
steepness_finder.calculate_steepnesses()

# plots of normalized channel steepness in the profiled channels
plt.figure(6)
plt.figure(figsize=(6, 2))
for i, outlet_id in enumerate(prf.data_structure):
    for j, segment_id in enumerate(prf.data_structure[outlet_id]):
        if j == 0:
            label = f"channel {i + 1}"
        else:
            label = "_nolegend_"
        segment = prf.data_structure[outlet_id][segment_id]
        profile_ids = segment["ids"]
        distance_upstream = segment["distances"]
        color = segment["color"]
        plt.plot(
            distance_upstream,
            grid.at_node["channel__steepness_index"][profile_ids],
            "x",
            color=color,
            label=label,
        )

plt.xlabel("distance upstream (m)")
plt.ylabel("steepness index")
plt.legend(loc="lower left")
plt.title("Distance Upstream vs. Ksn")

# Plot drainage area vs. sediment flux
plt.figure(7)
plt.figure(figsize=(6, 2))
plt.scatter(
    grid.at_node["drainage_area"],
    grid.at_node["sediment__flux"],
    marker="o",
    color="y",
)

plt.xlabel("drainage area (m^2)")
plt.ylabel("(sediment flux m^3/s)")
plt.title("Area vs. Sediment Flux")

"""
# Run with Transient Uplift 
To observe the landscape response to increased uplift, we set a new uplift rate, run for 10,000 years, and plot the normalized channel steepness at every 1000 years.

"""

"""
Set new parameters
"""

rock_uplift_rate = 0.001  # increased by a factor of     0
time_interval = 1000  # interval between each plot
run_time = 10000  # total run time
elapsed_time = 0  # reset elapsed time to 0

"""
Run loop at plot at each interval
"""

for elapsed_time in trange(0, run_time, timestep):
    if elapsed_time % time_interval == 0:  # if time interval is reached, plot
        prf.run_one_step()
        steepness_finder.calculate_steepnesses()
        plt.figure(6)
        plt.figure(figsize=(6, 2))
        for i, outlet_id in enumerate(prf.data_structure):
            for j, segment_id in enumerate(prf.data_structure[outlet_id]):
                if j == 0:
                    label = f"channel {i + 1}"
                else:
                    label = "_nolegend_"
                segment = prf.data_structure[outlet_id][segment_id]
                profile_ids = segment["ids"]
                distance_upstream = segment["distances"]
                color = segment["color"]
                plt.plot(
                    distance_upstream,
                    grid.at_node["channel__steepness_index"][profile_ids],
                    "x",
                    color=color,
                    label=label,
                )

        plt.xlabel("distance upstream (m)")
        plt.ylabel("steepness index")
        plt.legend(loc="lower left")
        plt.title(f"Steepness index at t = {elapsed_time}")

    # Run the flow router
    flow_accumulator.run_one_step()

    # Run the depression finder and router; optional
    depression_finder.map_depressions()

    # Run the SSPM model for one timestep
    shared_stream_power.run_one_step(dt=timestep)

    # Move  elevation of core nodes upwards relative to base level
    # at the rock uplift rate
    grid.at_node["topographic__elevation"][grid.core_nodes] += (
        rock_uplift_rate * timestep
    )

"""
## References


Hergarten, S. (2021). The influence of sediment transport on stationary
    and mobile knickpoints in river profiles. Journal of Geophysical Research:
    Earth Surface, 126, e2021JF006218. https://doi.org/10.1029/2021JF006218

"""



================================================
File: docs/source/tutorials/landscape_evolution/gravel_bedrock_eroder/gravel_bedrock_transporter_unit_tests.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Unit Tests for the Landlab GravelBedrockEroder Component

*G.E. Tucker, CIRES and Department of Geological Sciences, University of Colorado Boulder*

This notebook describes a series of basic unit tests for the `GravelBedrockEroder` component. These tests are implemented in the file `test_gravel_bedrock_eroder.py`, and are in addition to the unit tests implemented as doctests in the source code.
"""

"""
## Types of test

The theory starts with a representation of a layer of sediment overlying rock. Each grid cell is assumed to contain a primary channel that drains to an adjacent cell. The cell may also receive inflow of water and sediment from neighboring cells.

Processes and effects include:

1. Dynamic adjustment of channel width, based on near-threshold theory (implicit in derivation; not calculated explicitly unless requested via function call)
2. Transport of coarse (assumed gravel-size) sediment as bed load
3. Abrasion of sediment, which turns coarse sediment into wash load (not tracked)
4. Abrasion of underlying bedrock
5. Plucking erosion of underlying bedrock, which supplies coarse sediment

Ideally, each of these elements should be tested, both separately and in combination. Two types of test are used: instantaneous tests, which are "single iteration" comparisons between predicted and computed values, and equilibrium tests, in which a small terrain is run with baselevel forcing ("uplift") until it reaches an equilibrium that is then compared with an independently calculated solution.

Parameters, their default values, and mathematical symbols are:

- intermittency_factor=0.01 ($I$) dimensionless
- transport_coefficient=0.041 ($k_Q$) dimensionless
- abrasion_coefficient=0.0 ($\beta$) [1/L]
- sediment_porosity=0.35 ($\phi$) dimensionless
- depth_decay_scale=1.0 ($H_*$) [L]
- plucking_coefficient=1.0e-6 ($k_p$) [1/L]
- coarse_fraction_from_plucking=1.0 ($\gamma$) dimensionless

Mathematical symbols for the `GravelBedrockEroder` state variables and their corresponding at-node fields are:

- $\eta$ = channel elevation = `topographic__elevation`
- $H$ = sediment thickness = `soil__depth`
- $\eta_b$ = bedrock surface elevation = `bedrock__elevation`
- $S$ = flow-wise slope gradient = `topographic__steepest_slope`
- $Q$ = bankfull discharge [L$^3/T$] = `surface_water__discharge` (externally calculated)
- $Q_{in}$ = sediment flux entering the cell at a node [L$^3$/T] = `bedload_sediment__volume_influx`
- $Q_{out} = Q_s$ = sediment flux leaving a cell along its flow link [L$^3$/T] = `bedload_sediment__volume_outflux`
- $\alpha$ = bedrock exposure fraction [-] = `bedrock__exposure_fraction`

Mathematical symbols for other variables used in the calculations below:

- $U$ = uplift rate relative to baselevel [L/T]
- $\Lambda$ = grid cell (projected) surface area [L$^2$]
- $\lambda$ = grid link length [L]
- $t$ = time (in the underlying governing equations)

In addition, runoff rate $r$ is provided indirectly, through the field `surface_water__discharge`. Its default is considered to be unity (1 m/y). Bankfull discharge $Q$ in these tests is equal to $r$ times drainage area $A$, which is equal to cell area $\Lambda$ times the number of cells drained. The local flow-directed slope gradient, $S$, is calculated at each grid node. Rock uplift (or sediment uplift, in the unlimited sediment case) is applied as a boundary condition.

Channel width is adequately tested by the doctests, so additional tests of width are not included here.
"""

"""
## Test setup

The doctests in the code use a `RasterModelGrid`. For these external tests, we will use a `HexModelGrid` with three core nodes and a single open boundary node. This configuration is small enough for tests to be quick and efficient, but large enough to include flow convergence (two cells feel flow into a third, which then drains to the open boundary).
"""

"""
## Imports
"""

import numpy as np
from numpy.testing import assert_almost_equal

from landlab import HexModelGrid
from landlab.components import FlowAccumulator, GravelBedrockEroder

"""
## Instantaneous tests

### Transport rate

**Test condition**: 3-core-node hex grid with gradient of 0.01 along flow paths. Sediment cover: ample (100 m), limited (0.5 m, with depth decay scale also set to 0.5 m), and none.

Predicted sediment transport rate under ample cover (not limited by bedrock exposure):

$$Q_s = k_Q I Q S^{7/6}$$

Here the default value $k_Q=0.041$ is used, but the intermittency factor is set to 0.02. The discharge by default will be one meter per year times drainage area. The drainage area of one cell is the cell's area, here about 866,025 m$^2$, and the drainage area of the cell that receives flow is three times this. Therefore the predicted sediment transport rate for the two "upstream" cells and for the single "downstream" cell is:
"""

Q = (3.0**0.5 / 2.0) * 1e6 * np.array([3, 1, 1])
Qs = 0.041 * 0.02 * Q * (0.01) ** (7.0 / 6.0)
print("Predicted transport rate:", Qs)

"""
For the case with limiting sediment cover, when the cover thickness is equal to the depth decay scale (set to 0.5 m), the transport rate should be reduced by a factor of $1 - 1/e$. This works out to:
"""

print("Predicted transport rate:", Qs * (1.0 - np.exp(-1.0)))

"""
Finally, with no sediment at all, the transport rate should be zero.
"""

"""
Note that in order to give the grid nodes a gradient of 0.01, the elevations need to rise in the y-direction at a rate equal to 0.01 / cos 30$^\circ$.
"""

def test_transport_rate():
    grid = HexModelGrid((4, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 100.0

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(grid, intermittency_factor=0.02, depth_decay_scale=0.5)
    rock = grid.at_node["bedrock__elevation"]
    qs_out = grid.at_node["bedload_sediment__volume_outflux"]

    gbe.run_one_step(1.0e-6)  # using dt=0 prevents change to sed, rock, or elev
    assert_almost_equal(qs_out[grid.core_nodes], [9.88854526, 3.29618175, 3.29618175])

    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed[:] = 0.5
    rock[:] = elev - sed

    gbe.run_one_step(1.0e-6)
    assert_almost_equal(qs_out[grid.core_nodes], [6.25075275, 2.08358425, 2.08358425])

    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed[:] = 0.0
    rock[:] = elev

    gbe.run_one_step(1.0e-6)
    assert_almost_equal(qs_out[grid.core_nodes], [0.0, 0.0, 0.0])

test_transport_rate()

"""
### Sediment abrasion rate

Consider the first of the cases above, in which the transport rate is about 3.3 m$^3$/y for the upstream cells and 9.9 m$^3$/y for the downstream ones. If the abrasion coefficient is 10$^{-4}$ m$^{-1}$, then we can calculate the resulting lowering rate of the thickness of sediment as:

$$\frac{dH}{dt} = -\beta (Q_{in} + Q_{out}) \lambda / 2 \Lambda$$

where $\beta$ is the abrasion coefficient, $Q_{in}$ is incoming sediment flux (m$^3$/y), $Q_{out}$ is the outgoing sediment flux, $\lambda$ is the length of the flow path (distance from the node to its downstream neighbor), and $\Lambda$ is the surface area of the cell. The factor of two is there to average between $Q_{in}$ and $Q_{out}$. The flow length $\lambda$ appears because the abrasion rate $\beta Q_s$ is the rate per length, so we need to multiply by length to get the total volume rate. Finally, cell area $\Lambda$ appears in the denominator in order to convert a volume rate to a lowering rate.

In this case, the numbers are as follows (here sediment flux is half the above case because we are using the default intermittency factor):
"""

beta = 1.0e-4  # abrasion coefficient, 1/m
Qout = 0.5 * 3.29618175  # transport rate, m3/y
path_length = 1000.0  # node spacing, m
cell_area = 1000.0 * 1000.0 * 0.5 * 3.0**0.5
print(
    "Rate of thickness loss from sediment abrasion (upstream):",
    beta * 0.5 * (0.0 + Qout) * path_length / cell_area,
)

Qin = 2 * Qout
Qout = 0.5 * 9.88854526
print(
    "Rate of thickness loss from sediment abrasion (downstream):",
    beta * 0.5 * (Qin + Qout) * path_length / cell_area,
)

def test_sediment_abrasion_rate():
    grid = HexModelGrid((4, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 100.0

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(grid, abrasion_coefficient=1.0e-4)
    gbe.run_one_step(1.0)

    assert_almost_equal(
        gbe._abrasion[grid.core_nodes],
        [4.7576285545378313e-07, 9.515257103302159e-08, 9.515257103302159e-08],
    )

test_sediment_abrasion_rate()

"""
### Bedrock abrasion

Here we test the calculation of bedrock abrasion rate. We need a test that has some sediment, but not so much that the bed is totally shielded. We'll use 1 m thick sediment. That reduces the transport capacity, which should be equal to the above transport rates times the fractional alluvial cover, which is 1 minus the bedrock exposure fraction:
"""

beta = 1.0e-4
path_length = 1000.0
frac_bed_exposed = np.exp(-1.0)
cell_area = 1.0e6 * 0.5 * 3.0**0.5
Qs_out = (
    0.041
    * 0.01
    * 0.01 ** (7.0 / 6.0)
    * cell_area
    * np.array([3, 1, 1])
    * (1.0 - frac_bed_exposed)
)
Qs_in = np.array([Qs_out[1] + Qs_out[2], 0.0, 0.0])

print("Sed outflux:", Qs_out)
print("Sed influx:", Qs_in)

sed_abr_rate = beta * 0.5 * (Qs_in + Qs_out) * path_length / cell_area
print("Sediment abrasion rate:", sed_abr_rate)

rock_abr_rate = sed_abr_rate * frac_bed_exposed
print("Bed abrasion rate:", rock_abr_rate)

def test_rock_abrasion_rate():
    grid = HexModelGrid((4, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 1.0

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(grid, abrasion_coefficient=1.0e-4)
    gbe.run_one_step(1.0)

    assert_almost_equal(
        gbe._sediment_outflux[grid.core_nodes], [3.12537638, 1.04179213, 1.04179213]
    )
    assert_almost_equal(
        gbe._rock_abrasion_rate[grid.core_nodes],
        [1.10635873e-07, 2.21271745e-08, 2.21271745e-08],
    )

test_rock_abrasion_rate()

"""
### Plucking erosion

Here we test the calculation of bedrock plucking rate. 
"""

plucking_coef = 1.0e-6
intermittency_factor = 0.01
frac_bed_exposed = np.exp(-1.0)
flow_link_length = 1000
cell_area = (3.0**0.5 / 2.0) * 1e6
Q = cell_area * np.array([3, 1, 1])
slope = 0.01

pluck_rate = (
    plucking_coef
    * intermittency_factor
    * Q
    * slope ** (7.0 / 6.0)
    * frac_bed_exposed
    * (flow_link_length / cell_area)
)
print("Plucking rate:", pluck_rate)

grid = HexModelGrid((4, 2), spacing=1000.0)
grid.length_of_link[0]
grid.area_of_cell[0]

def test_rock_plucking_rate():
    grid = HexModelGrid((4, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.01 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 1.0

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(grid, plucking_coefficient=1.0e-4)
    gbe.run_one_step(1.0)

    assert_almost_equal(
        gbe._pluck_rate[grid.core_nodes],
        [5.12263532e-06, 1.70754511e-06, 1.70754511e-06],
    )

test_rock_plucking_rate()

"""
## Equilibrium tests

### Case of unlimited sediment

We start with an all-sediment case, using the same 3-cell configuration as above. We will impose a rate of uplift relative to the fixed baselevel node of $U=10^{-4}$ m/y. Once the system reaches steady state, each of the upper cells should show a balance between the rate of sediment input via uplift $U\Lambda$, the rate of loss to abrasion $\beta Q_{out}^0 / 2$, and the rate of output downstream, $Q_{out}^0$ (the superscript zero notation means we're talking about the upper two cells):

$$Q_{out}^0 + \beta \lambda Q_{out}^0/2 = (1-\phi)U\Lambda$$

Solving for $Q_{out}^0$,

$$Q_{out}^0 = \frac{(1-\phi)U\Lambda}{1+\beta\lambda /2}$$

The balance for the downstream cell is similar, except that there are two inputs as well. Denoting outflux from the downstream cell as $Q_{out}^1$,

$$Q_{out}^1 + \beta\lambda (Q_{out}^1 + 2 Q_{out}^0)/2 = (1-\phi)U\Lambda + 2Q_{out}^0$$

or

$$Q_{out}^1 = \frac{(1-\phi)U\Lambda + (2 - \beta\lambda) Q_{out}^0}{1+\beta\lambda /2}$$

Using $U=10^{-4}$ m/y, $\Lambda = 866,025$ m$^2$, $\lambda = 1000$ m, $\phi = 0.35$, and $\beta = 0.0005$, here are the predicted values:
"""

beta = 0.0005
U = 0.0001
Lambda = 866025.0
length = 1000.0  # "little lambda"
phi = 0.35  # porosity

Qout0 = (1 - phi) * U * Lambda / (1 + beta * length / 2)
print("Qout0:", Qout0, "m3/y")

Qout1 = ((1 - phi) * U * Lambda + (2 - beta * length) * Qout0) / (1 + beta * length / 2)
print("Qout1:", Qout1, "m3/y")

"""
We can find the corresponding slope from the flux laws. For the upper nodes,

$$Q_{out}^0 = k_Q I r \Lambda S^{7/6}$$

$$S_0 = \left(\frac{Q_{out}^0}{k_Q I r \Lambda}\right)^{6/7}$$

For the lower node,

$$S_1 = \left( \frac{Q_{out}^1}{3 k_Q I r \Lambda} \right)^{6/7}$$
"""

kQ = 0.041
intermittency = 0.01
r = 1.0

S_pred0 = (Qout0 / (kQ * intermittency * r * Lambda)) ** (6.0 / 7.0)
print("Predicted slope at upper nodes:", S_pred0)

S_pred1 = (Qout1 / (3 * kQ * intermittency * r * Lambda)) ** (6.0 / 7.0)
print("Predicted slope at lower node:", S_pred1)

"""
The test code follows.
"""

def test_steady_unlimited_sediment():
    grid = HexModelGrid((4, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.13 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 10000.0
    rock = grid.add_zeros("bedrock__elevation", at="node")
    rock[:] = elev - sed

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(grid, abrasion_coefficient=0.0005)

    dt = 4.0e4
    uplift_rate = 0.0001
    nsteps = 500
    for i in range(nsteps):
        elev[grid.core_nodes] += uplift_rate * dt
        sed[grid.core_nodes] += uplift_rate * dt
        gbe.run_one_step(dt)

    assert_almost_equal(
        grid.at_node["bedload_sediment__volume_outflux"][grid.core_nodes],
        [99.073, 45.033, 45.033],
        decimal=2,
    )
    assert_almost_equal(
        grid.at_node["topographic__steepest_slope"][grid.core_nodes],
        [0.130579, 0.170346, 0.170346],
        decimal=5,
    )

test_steady_unlimited_sediment()

"""
#### Case of general equilibrium

For this test, we will use a grid with a single core node.

Volume rate of gravel sediment produced by plucking is the areal average rate times cell area,

$$Q_p = k_p I r S^{7/6} \gamma \Lambda \lambda \alpha$$

Equilibrium $Q_s$ equals sediment produced from plucking minus sediment lost to abrasion:

$$Q_s = k_p I r S^{7/6} \gamma \Lambda \lambda \alpha - \beta\lambda Q_s / 2$$

Solve for $Q_s$:

$$\boxed{Q_s = \frac{k_p I r S^{7/6} \gamma \Lambda \lambda \alpha}{1 + \beta\lambda / 2}}$$

Equate this with transport rate:

$$k_Q I r \Lambda S^{7/6} (1 - \alpha) = \frac{k_p I r S^{7/6} \gamma \Lambda \lambda \alpha}{1 + \beta\lambda / 2}$$

Cancel common factors:

$$k_Q (1 - \alpha) = \frac{k_p \gamma \lambda \alpha}{1 + \beta\lambda / 2}$$

Rearrange to isolate $\alpha$:

$$\frac{1 - \alpha}{\alpha} = \frac{k_p \gamma \lambda}{k_Q(1 + \beta\lambda / 2)}$$

$$\frac{1}{\alpha} - 1 = \frac{k_p \gamma \lambda}{k_Q(1 + \beta\lambda / 2)}$$

$$\alpha = \frac{1}{1 + \frac{k_p \gamma \lambda}{k_Q(1 + \beta\lambda / 2)}}$$

$$\boxed{\alpha = \frac{k_Q(1 + \beta\lambda / 2)}{k_Q(1 + \beta\lambda / 2) + k_p \gamma \lambda}}$$

To understand this equation for $\alpha$, note that if plucking produces no coarse sediment at all---that is, if $\gamma=0$, then the bedrock exposure fraction is unity. One the other hand, if the plucking process is highly efficient, such that the second term in the denominator is much bigger than the first, then $\alpha\rightarrow 0$, meaning that the bed is mostly covered by sediment and only the most miniscule bedrock exposure fraction suffices to allow downcutting.

Equilibrium bedrock lowering rate:

$$U = k_p I r S^{7/6} \lambda \alpha + \beta\lambda Q_s \alpha / 2 \Lambda$$

Rearrange to isolate $Q_s$:

$$\beta\lambda Q_s \alpha / 2 \Lambda = U - k_p I r S^{7/6} \lambda \alpha$$

$$Q_s  = 2\Lambda\frac{U/\alpha - k_p I r S^{7/6} \lambda}{\beta\lambda}$$

Plug in transport rate,

$$k_Q I r \Lambda S^{7/6} (1 - \alpha) = 2\Lambda\frac{U/\alpha - k_p I r S^{7/6} \lambda}{\beta\lambda}$$

Rearrange to solve for slope,

$$k_Q I r \Lambda S^{7/6} (1 - \alpha) = \frac{2\Lambda U/\alpha}{\beta\lambda} - \frac{2\Lambda k_p I r S^{7/6} \lambda}{\beta\lambda}$$

$$k_Q I r \Lambda S^{7/6} (1 - \alpha) + \frac{2\Lambda k_p I r S^{7/6} \lambda}{\beta\lambda}= \frac{2\Lambda U/\alpha}{\beta\lambda} $$

$$\left(k_Q I r \Lambda (1 - \alpha) + \frac{2\Lambda k_p I r \lambda}{\beta\lambda}\right) S^{7/6} = \frac{2\Lambda U/\alpha}{\beta\lambda} $$

$$ S^{7/6} = \frac{2\Lambda U/\alpha}{\beta\lambda\left(k_Q I r \Lambda (1 - \alpha) + \frac{2\Lambda k_p I r \lambda}{\beta\lambda}\right)} $$

$$ S^{7/6} = \frac{2\Lambda U/\alpha}{\beta\lambda k_Q I r \Lambda (1 - \alpha) + 2\Lambda k_p I r \lambda}$$

$$ S^{7/6} = \frac{2 U}{\beta\lambda k_Q I r \alpha (1 - \alpha) + 2k_p I r \lambda\alpha}$$

$$\boxed{S = \left( \frac{2U}{\lambda I r \alpha (\beta k_Q (1 - \alpha ) + 2k_p)} \right)^{6/7}}$$

This has some familiar pieces to it in terms of a slope-area (or in this case, slope-$\lambda$) relationship. Slope gradient is directly proportional to uplift rate, and inversely proportional to rainfall rate ($rI$). Slope gets smaller with more efficient transport (higher $k_Q$), more efficient plucking ($k_p$), or more efficient abrasion ($\beta$). 
"""

kQ = 0.041
beta = 0.0005
length = 1000.0
kp = 1.0e-4
gamma = 0.5
U = 1.0e-4
Lambda = 866025.404
intermittency = 0.01
r = 1.0

# alpha (bedrock exposure fraction)
term1 = kQ * (1.0 + beta * length / 2.0)
term2 = kp * gamma * length
alpha = term1 / (term1 + term2)
print("Predicted alpha:", alpha)

# Qs (gravel sediment transport rate out of cell)

# S (slope gradient)
S = (
    2 * U / (length * intermittency * r * alpha * (beta * kQ * (1.0 - alpha) + 2 * kp))
) ** (6.0 / 7.0)
print("Predicted S:", S)

# Qs (gravel sediment transport rate out of cell)
Qs = (kp * intermittency * r * S ** (7 / 6) * gamma * Lambda * length * alpha) / (
    1 + beta * length / 2
)
print("Predicted Qs:", Qs)

def test_steady_general():
    grid = HexModelGrid((3, 2), spacing=1000.0)
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE

    elev = grid.add_zeros("topographic__elevation", at="node")
    elev[:] = (0.2 * grid.y_of_node) / np.cos(np.radians(30.0))
    sed = grid.add_zeros("soil__depth", at="node")
    sed[:] = 1.0
    rock = grid.add_zeros("bedrock__elevation", at="node")
    rock[:] = elev - sed

    fa = FlowAccumulator(grid)
    fa.run_one_step()
    gbe = GravelBedrockEroder(
        grid, abrasion_coefficient=0.0005, coarse_fraction_from_plucking=0.5
    )

    dt = 7500.0
    uplift_rate = 0.0001
    nsteps = 3000
    for i in range(nsteps):
        elev[grid.core_nodes] += uplift_rate * dt
        rock[grid.core_nodes] += uplift_rate * dt
        gbe.run_one_step(dt)

    assert_almost_equal(
        grid.at_node["bedrock__exposure_fraction"][grid.core_nodes], 0.5062, decimal=4
    )
    assert_almost_equal(
        grid.at_node["topographic__steepest_slope"][grid.core_nodes], 0.2387, decimal=4
    )
    assert_almost_equal(
        grid.at_node["bedload_sediment__volume_outflux"][grid.core_nodes],
        32.972,
        decimal=3,
    )

import time

start = time.time()
test_steady_general()
print(time.time() - start)

"""
## References and further reading

Attal, M., & Lavé, J. (2006). Changes of bedload characteristics along the Marsyandi River (central Nepal): Implications for understanding hillslope sediment supply, sediment load evolution along fluvial networks, and denudation in active orogenic belts. Geol. Soc. Am. Spec. Pap, 398, 143-171.

Attal, M., & Lavé, J. (2009). Pebble abrasion during fluvial transport: Experimental results and implications for the evolution of the sediment load along rivers. Journal of Geophysical Research: Earth Surface, 114(F4).

Meyer-Peter, E., & Müller, R. (1948). Formulas for bed-load transport. In IAHSR 2nd meeting, Stockholm, appendix 2. IAHR.

Parker, G. (1978). Self-formed straight rivers with equilibrium banks and mobile bed. Part 2. The gravel river. Journal of Fluid mechanics, 89(1), 127-146.

Phillips, C. B., & Jerolmack, D. J. (2016). Self-organization of river channels as a critical filter on climate signals. Science, 352(6286), 694-697.

Wickert, A. D., & Schildgen, T. F. (2019). Long-profile evolution of transport-limited gravel-bed rivers. Earth Surface Dynamics, 7(1), 17-43.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991). A physical explanation of an observed link area‐slope relationship. Water Resources Research, 27(7), 1697-1702.

Willgoose, G. (1994). A physical explanation for an observed area‐slope‐elevation relationship for catchments with declining relief. Water Resources Research, 30(2), 151-159.

Wong, M., & Parker, G. (2006). Reanalysis and correction of bed-load relation of Meyer-Peter and Müller using their own database. Journal of Hydraulic Engineering, 132(11), 1159-1168.
"""



================================================
File: docs/source/tutorials/landscape_evolution/gravel_river_transporter/gravel_river_transporter.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The Landlab GravelRiverTransporter Component

*G.E. Tucker, CIRES and Department of Geological Sciences, University of Colorado Boulder*

This notebook describes the `GravelRiverTransporter` component and its underlying theory, and provides some simple examples of usage.


## Overview

`GravelRiverTransporter` is a Landlab component for modeling landscape evolution in the context of a network of gravel-bed alluvial channels. The component is meant to operate on a 2d grid in conjunction with a single-direction flow routing scheme, such that each grid node drains to one and only one of its neighbors. Channels are assumed to be sub-grid-scale features with a bankfull channel width that adjusts according to the local discharge, slope, and grain diameter. The approach follows that of Wickert & Schildgen (2019), but with two additions:

1. Because the channel network is calculated from, and embedded within, a topographic field represented as a 2d grid, conservation of mass is calculated on the basis of individual grid cells rather than using a prescribed valley width.

2. The theory implemented by the component includes the progressive loss of gravel load due to abrasion; the lost material is assumed to become part of the suspended and/or wash load, which is not explicitly tracked.

The theory that channels with gravel bed and bank materials tend to adjust their shear stress ratio dates back to Parker (1978), and a variety of studies have supported the idea for gravel rivers. Phillips and Jerolmack (2016) argued that the concept may also be applicable to some "bedrock" rivers as well (the question depends somewhat on the definition of "bedrock river", but presumably would apply to a river that is capable of eroding into bedrock but that also has at least one self-formed bank made of alluvial material, so that erosion or deposition of bank material alters the hydraulic geometry).
"""

"""
## Theory

### Channel-width adjustment

We treat only the coarse, bed-load fraction. We assume channel width adjusts so as to ensure that bankfull shear stress is slightly larger (by a fraction $\epsilon$) than critical shear stress for the median sediment diameter. Wickert & Schildgen (2019) show that when this is the case, the channel tends to adjust such that its bankfull width depends on bankfull discharge, $Q$, channel gradient, $S$, and the median diameter of sediment on the bed, $D$, as follows: 

$$b = k_b \frac{QS^{7/6}}{D^{3/2}}$$

where $k_b$ is a factor given by:

$$k_b = 0.17 g^{-1/2} \left[ \left(\frac{\rho_s-\rho}{\rho}\right)(1+\epsilon )\tau_c^*\right]^{-5/3}$$

where $g$ is gravitational acceleration, $\rho_s$ is sediment grain density, $\rho$ is water density, $\epsilon$ is the ratio of bankfull to critical shear stress, and $\tau_c^*$ is the critical Shields stress (i.e., dimensionless critical shear stress). Using $g=9.8$ m/s$^2$, $\rho_s=2,650$ kg/m$^3$ (quartz), $\rho=1,000$ kg/m$^3$, $\epsilon=0.2$, and $\tau_c^*=0.0495$ (from Wong & Parker, 2006), the value of $k_b$ is approximately 2.61 s/m$^{1/2}$ (as calculated below).
"""

g = 9.8  # gravitational acceleration, m/s2
rhos = 2650.0  # sediment density, kg/m3
rho = 1000.0  # water density, kg/m3
eps = 0.2  # shear stress ratio
taustarc = 0.0495  # critical Shields stress (here from Wong & Parker (2006))

kb = 0.17 * g ** (-0.5) * (((rhos - rho) / rho) * (1 + eps) * taustarc) ** (-5.0 / 3.0)
print("kb =", kb, "seconds per square-root meter")
print("kb =", kb / (3600 * 24 * 365.25), "years per square-root meter")

"""
For example, the width of a channel with 1 cm diameter sediment on the bed, a 1% gradient, and a bankfull discharge with 1 cms discharge would be:
"""

D = 0.01  # grain diameter, m
Q = 1.0  # bankfull discharge, m3/s
S = 0.01  # slope gradient, m/m
print("b = " + str(kb * Q * S ** (7.0 / 6.0) / D**1.5), "meters")

"""
Note that one aspect of the above width theory that may limit its applicability is the prediction that width should *increase* when slope increases. To appreciate where this comes from, recall that boundary shear stress in a relatively wide channel is proportional to the depth-slope product (i.e., $\tau \approx \rho g H S$, where $H$ is depth and $S$ is slope). All else equal, for a fixed shear stress, a steeper channel should be shallower and vice versa. For a given discharge, a shallower channel must either be wider or have faster flow, or both. So the prediction is logically and mathematically consistent. However, it neglects potential variations in roughness, and in particular the possibility that steeper channels might become rougher as the flow increases toward criticality (as suggested by Grant, 1997). The theory outlined here does not attempt to account for this effect, but users of the component should be aware of this limitation. In addition, the underlying treatment of shear stress as proportional to depth times slope is not appropriate for channels with a relatively small width-depth ratio. The component does not include any checks on this, so the user should be alert to unrealistic behavior when the calculated channel width is rather narrow.
"""

"""
### Gravel transport rate

We follow Wickert and Schildgen (2019) in using the Meyer-Peter and Müller (1948) equation for bed-load transport, as modified by Wong and Parker (2006). When combined with the width-closure equation above, the predicted gravel transport rate is:

$$Q_s = k_Q I Q S^{7/6}$$

where $k_Q$ is a dimensionless transport efficiency factor equal to $\approx 0.041$. The variable $I$ is an efficiency factor, defined as the fraction of time that bankfull discharge occurs. In other words, one of the simplifications of the model is that the channel has two states: for a small fraction of the year, flow is equal to bankfull; for the rest of the time, the flow is too low to move any sediment.

To get a sense for what the transport law implies about rates, consider a case in which $Q = 1$ cms, $S = 0.01$, and bankfull flow occurs for 1% of the year:
"""

Qs = 0.041 * 0.01 * 1 * (0.01) ** (7.0 / 6.0)
print("Qs", Qs, "cms")
print("Qs", Qs * 3600 * 24 * 365.25, "cubic meters per year")

"""
This implies that 1 cms on a slope of 0.01 would carry about $2 \times 10^{-6}$ cms of sediment, or about 60 cubic meters in a given year.
"""

"""
### Gravel abrasion

The component uses a Sternberg-like method to calculate the downstream loss of mass to abrasion. The abrasion model is inspired by Attal & Lave (2006, 2009). We assume that the rate of loss of gravel mass to finer material per unit transport distance, $A$, is proportional to the gravel transport rate, $Q_s$:

$$A = \beta Q_s$$

where $\beta$ is an abrasion coefficient with units of inverse length.

To appreciate the implication of this treatment, consider a reach of channel with an incoming gravel load $Q_0$ at the head of the reach, and no inputs along the reach itself. The rate of change of gravel load with respect to downstream distance, $x$, is:

$$\frac{dQ_s}{dx} = -\beta Q_s$$

Integrating downstream from the head of the reach $x=0$, where $Q_s=Q_0$, 

$$Q_s = Q_0 e^{-\beta x}$$

In other words, one obtains a Sternberg-like profile, except here expressed in terms of remaining gravel load rather than median size.
"""

"""
## Setting up a gravel river model

In the code below, we create a class that turns the `GravelRiverTransporter` component into a stand-alone model. This will make it simpler to set up and run examples.
"""

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

from landlab import create_grid, imshow_grid
from landlab.components import FlowAccumulator, GravelRiverTransporter
from landlab.plot.drainage_plot import drainage_plot

mpl.rcParams["figure.dpi"] = 300

class GravelRiverNetworkModel:
    """Model of gravel river transport & evolution on a
    flow-network grid.

    Parameters
    ----------
    grid_params : dict
        Dictionary of grid parameters (for format see create_grid)
    flow_params : dict
        Dictionary with FlowAccumulator parameters
    fluvial_params : dict, default empty
        Dictionary with GravelRiverTransporter parameters
    initial_noise_amplitude : float, default 0
        Amplitude of random noise on initial topography
    uplift_rate : float, default 0.0001
        Applied uplift (baselevel) rate in m/y
    run_duration : float, default 1.0e4
        Duration of run in years
    dt : float, default 100
        Time-step duration, years
    grid_setup_fn : function, default None
        Handle to user-defined function to set up the grid
    grid_setup_params : dict, default empty
        Dict with any parameters to be passed to the above function
    """

    _DEFAULT_GRID_PARAMS = {
        "RasterModelGrid": {
            "shape": (4, 5),
            "xy_spacing": 1000.0,
            "fields": {
                "node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}
            },
        }
    }

    _DEFAULT_FLOW_PARAMS = {"flow_director": "FlowDirectorD8"}

    _DEFAULT_FLUVIAL_PARAMS = {}

    def __init__(
        self,
        grid_params=_DEFAULT_GRID_PARAMS,
        flow_params=_DEFAULT_FLOW_PARAMS,
        fluvial_params=_DEFAULT_FLUVIAL_PARAMS,
        initial_noise_amplitude=0.0,
        uplift_rate=0.0001,
        run_duration=1.0e4,
        dt=100.0,
        grid_setup_fn=None,
        grid_setup_params={},
    ):
        """Initialize GravelRiverNetworkModel."""

        self.grid = create_grid({**self._DEFAULT_GRID_PARAMS, **grid_params})
        self.elev = self.grid.at_node["topographic__elevation"]
        if grid_setup_fn is not None:
            grid_setup_fn(self.grid, **grid_setup_params)
        if initial_noise_amplitude > 0.0:
            self.elev[self.grid.core_nodes] += initial_noise_amplitude * np.random.rand(
                self.grid.number_of_core_nodes
            )
        self.flow_handler = FlowAccumulator(
            self.grid, **{**self._DEFAULT_FLOW_PARAMS, **flow_params}
        )
        self.transporter = GravelRiverTransporter(
            self.grid, **{**self._DEFAULT_FLUVIAL_PARAMS, **fluvial_params}
        )
        self.uplift_rate = uplift_rate
        self.time_remaining = run_duration
        self.dt = dt

    def run(self):
        """Run model from start to finish."""
        while self.time_remaining > 0.0:
            dt = min(self.dt, self.time_remaining)
            self.update(dt)
            self.time_remaining -= dt

    def update(self, dt):
        """Update for one time step of duration dt."""
        self.elev[self.grid.core_nodes] += self.uplift_rate * dt
        self.flow_handler.run_one_step()
        self.transporter.run_one_step(dt)

"""
## Example: 1d longitudinal profile

This example compares a 1d profile version of the model with the steady analytical solution. The analytical solution is presented in two parts: the special case of no abrasion ($\beta = 0$), and the more general case with abrasion ($\beta > 0$).

### Special case of no abrasion

#### Downstream gravel flux

Consider a valley of width $\Delta y$ with no tributaries or other inputs of water or sediment. Down-valley distance is $x$. Let the bankfull runoff rate be $r$ (in depth of runoff per time, e.g., meters per year), and assume the discharge is proportional to drainage area, $A$, such that the bankfull discharge increases linearly with down-valley distance:

$$Q = r A = r x \Delta y$$

Let the steady erosion (channel lowering) rate be $E$. When the erosion rate is steady, the rate of increase in volumetric gravel flux with respect to down-valley distance depends on two effects: the addition of new gravel through lowering of the valley, and the loss of gravel to finer material through abrasion. We can express this as:

$$\frac{dQ_s}{dx} = \psi (1-\phi_s) E\Delta y - \beta Q_s$$

Here $\phi_s$ is the porosity of the substrate into which the valley lowers through time, and $\psi$ is the fraction of entrained material that is of gravel size (note that the latter parameter is assumed to be unity in the GravelRiverTransporter component).

For the special case of $\beta = 0$ (no abrasion), the integral is simply:

$$\boxed{Q_s = \psi (1-\phi_s) E\Delta y x}$$

In other words, with no abrasion, the gravel flux increases linearly down-valley.

#### Profile shape

To solve for the profile shape, we set the gravel flux equal to the transport rate and solve for slope gradient. For the special case of no abrasion ($\beta = 0$),

$$k_Q I Q S^{7/6} = \psi (1-\phi_s) E \Delta y x$$

Rearranging, and substituting the relationship between discharge and distance,

$$\boxed{S = \left(\frac{\psi (1-\phi_s) E}{k_Q I r}\right)^{6/7}}$$

Note that slope gradient does not depend on position along the valley! In other words, when the rate of water and sediment addition down-valley are both linear, the two effects balance and gradient remains constant. All else equal, the profile will be steeper with more sediment (higher $E$, $\psi$) and gentler with more transport potential (more frequent flow, more runoff, or a higher transport coefficient).

#### Numerical test

To create an effectively one-dimensional domain, we run a model with three rows of nodes, two of which are closed boundaries and one of which is the model domain. The code below can be summarized as:

1. Define a grid setup function to configure a 1d domain with an initial down-valley slope.
2. Set parameter values.
3. Create dictionaries for the grid, flow, and fluvial parameters.
4. Instantiate and initialize the model object.
5. Run it.
6. Plot and compare with analytical solutions.

"""

# Define grid setup function for 3 rows with open boundary at right side


def channel_profile_setup(grid, init_slope):
    """Set boundary nodes to CLOSED except the right side, which is the profile
    outlet; give"""
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
    grid.at_node["topographic__elevation"][grid.core_nodes] = init_slope * (
        np.amax(grid.x_of_node) - grid.x_of_node[grid.core_nodes]
    )

# Parameters
nrows = 3
ncols = 17
dx = 1000.0  # grid spacing, m
bf_runoff_rate = 10.0  # bankfull runoff rate, m/y
imfac = 0.01  # intermittency factor, -
xport_coef = 0.041  # transport coefficient, -
abr_coef = 0.0  # abrasion coefficient, 1/m
porosity = 0.35  # sediment porosity, -
uplift_rate = 0.0001  # uplift (i.e., baselevel) rate, m/y

# Group parameters into dicts for grid, flow, and fluvial
profile_grid_params = {
    "RasterModelGrid": {
        "shape": (nrows, ncols),
        "xy_spacing": dx,
        "fields": {"node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}},
    }
}

flow_params = {
    "flow_director": "FlowDirectorD8",
    "runoff_rate": bf_runoff_rate,
}

fluvial_params = {
    "intermittency_factor": imfac,
    "transport_coefficient": xport_coef,
    "abrasion_coefficient": abr_coef,
    "sediment_porosity": porosity,
}

# Instantiate model
model = GravelRiverNetworkModel(
    profile_grid_params,
    flow_params,
    fluvial_params,
    uplift_rate=uplift_rate,
    run_duration=1.8e7,
    dt=3000.0,
    grid_setup_fn=channel_profile_setup,
    grid_setup_params={"init_slope": 0.0001},
)

# Run model
model.run()

# Set up for plotting 1D profiles
midrow = np.arange(ncols + 1, 2 * ncols, dtype=int)
profile_x = model.grid.x_of_node[midrow]

# Calculate analytical solution for gravel flux
Qspred = uplift_rate * (1 - porosity) * dx * profile_x

# Plot
plt.plot(profile_x / 1000.0, Qspred, "ro-")
plt.plot(
    profile_x[:-1] / 1000.0,
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[:-1]],
    ".-",
)
plt.xlabel("Distance (km)")
plt.ylabel("Sediment flux (m3/y)")
plt.legend(["Analytical", "Computed"])

# Report
print("Predicted gravel flux at outlet:", Qspred[-2], "m3/y")
print(
    "Computed gravel flux:",
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[-2]],
    "m3/y",
)

# Calculate analytical solution for gradient
Spred = (
    1.0 * (1.0 - porosity) * uplift_rate / (xport_coef * imfac * bf_runoff_rate)
) ** (6.0 / 7.0)

# Analytical solution for height
Zpred = Spred * (np.amax(model.grid.x_of_node) - model.grid.x_of_node[midrow])

# Plot
plt.plot(model.grid.x_of_node[midrow] / 1000.0, Zpred, "ro-")
plt.plot(model.grid.x_of_node[midrow] / 1000.0, model.elev[midrow], ".-")
plt.xlabel("Distance (km)", fontsize=14)
plt.ylabel("Elevation (m)", fontsize=14)
plt.grid(True)

# Report
print("Predicted gradient:", Spred)
print(
    "Computed gradient at outlet:",
    np.mean(model.grid.at_node["topographic__steepest_slope"][midrow[-2]]),
)

"""
The above example demonstrates that the model can reproduce the expected equilibrium without abrasion, and that it takes a long time (about 18 million years using the given parameters) to get there. The example also illustrates the uniform gradient predicted by the case without sediment abrasion (which is at odds with the common observation that channel longitudinal profiles tend to be concave-upward).

We can also examine the implied channel width. The width depends median bed grain diameter, so we will set this to 10 cm for illustrative purposes:
"""

w = model.transporter.calc_implied_width(grain_diameter=0.1)
plt.plot(profile_x[:-1] / 1000.0, w[midrow[:-1]])
plt.xlabel("Distance (km)")
_ = plt.ylabel("Bankfull channel width (m)")

"""
Without abrasion (and with a linear relation between bankfull discharge and drainage area), we obtain the odd result that width increases linearly with bankfull discharge, rather than approximately square-root relation that is commonly observed. This in fact is perfectly consistent: since the channel maintains a fixed shear-stress ratio, the only way for the channel to accommodate a downstream-increasing sediment load is by widening, and because the sediment load grows linearly downstream, so too must the channel width.

Neither the linear profile nor the linear width increase are particularly realistic, at least when compared with most erosional river profiles. The next example looks at the role of gravel abrasion, and considers the extent to which it can produce more realistic profile morphology.
"""

"""

### General case with abrasion

#### Downstream gravel flux

Recall that the downstreamrate of change in gravel flux is 

$$\frac{dQ_s}{dx} = \psi (1-\phi_s) E\Delta y - \beta Q_s$$

To integrate this for the general case of $\beta > 0$, we can use the method of substitution. Let $\alpha = \psi (1-\phi_s) E \Delta y$, and $w = \alpha - \beta Q_s$. Then $dw = -\beta dQ_s$, so that $dQ_s = -(1/\beta) dw$. 

At $x=0$, the head of the reach, $Q_s=0$. Therefore, when $x=0$, $w=\alpha$.

Substituting these,

$$-\frac{1}{\beta} \frac{dw}{dx} = w$$

$$\frac{1}{w}dw = -\beta dx$$

Integrating from $w = \alpha$ to $w$ and from $x = 0$ to $x$,

$$\ln \frac{w}{\alpha} = -\beta x$$

$$\frac{w}{\alpha} = e^{-\beta x}$$

$$\alpha - \beta Q_s = \alpha e^{-\beta x}$$

$$\beta Q_s = \alpha (1 - e^{-\beta x})$$

$$\boxed{Q_s = \frac{\psi (1-\phi_s) E \Delta y}{\beta} (1 - e^{-\beta x})}$$

The implication is that the sediment flux is a saturating exponential that asymptotes to an equilibrium value 

$$Q_s^\text{eq} = \frac{\psi (1-\phi_s) E \Delta y}{\beta}$$

which represents a balance between addition of gravel-size sediment through erosional lowering, and loss of gravel-size sediment to finer material through abrasion. The equilibrium flux is larger when the erosion rate is faster, the valley is wider, the eroded material produces a higher gravel fraction, or the eroded material is less porous. The flux is smaller when the abrasion rate is higher.



#### Profile shape

Setting transport rate and gravel supply equal,

$$k_Q I Q S^{7/6} = \frac{\psi (1-\phi_s) E \Delta y}{\beta} (1 - e^{-\beta x})$$

Solving for gradient,

$$S = \left( \frac{\psi (1-\phi_s) E \Delta y}{\beta k_Q I Q }(1 - e^{-\beta x})\right)^{6/7}$$

Substituting the discharge-distance relation,

$$\boxed{S = \left( \frac{\psi (1-\phi_s) E}{\beta k_Q I r x}(1 - e^{-\beta x})\right)^{6/7}}$$
"""

"""
We can use these solutions to test the model, as in the runs that follow.
"""

# Parameters
abr_coef = 1.0 / 2000.0  # abrasion coefficient, 1/m
run_duration = 1.2e7  # duration of run, years
dt = 3000.0  # time-step duration, years
init_slope = 0.0001  # initial valley gradient, m/m

profile_grid_params = {
    "RasterModelGrid": {
        "shape": (nrows, ncols),
        "xy_spacing": dx,
        "fields": {"node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}},
    }
}

flow_params = {
    "flow_director": "FlowDirectorD8",
    "runoff_rate": bf_runoff_rate,
}

fluvial_params = {
    "intermittency_factor": imfac,
    "transport_coefficient": xport_coef,
    "abrasion_coefficient": abr_coef,
    "sediment_porosity": porosity,
}

model = GravelRiverNetworkModel(
    profile_grid_params,
    flow_params,
    fluvial_params,
    uplift_rate=uplift_rate,
    run_duration=run_duration,
    dt=dt,
    grid_setup_fn=channel_profile_setup,
    grid_setup_params={"init_slope": init_slope},
)

model.run()

# Calculate analytical solution for gravel flux
Qseqb = (1.0 - porosity) * uplift_rate * dx / abr_coef
Qspred = Qseqb * (1.0 - np.exp(-abr_coef * profile_x))

# Plot
plt.plot(profile_x / 1000.0, Qspred, "ro-")
plt.plot(
    profile_x[:-1] / 1000.0,
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[:-1]],
    ".-",
)
plt.xlabel("Distance (km)")
plt.ylabel("Sediment flux (m3/y)")
plt.legend(["Analytical", "Computed"])

# Report
print("Predicted gravel flux at outlet:", Qspred[-2], "m3/y")
print(
    "Computed gravel flux at outlet:",
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[-2]],
    "m3/y",
)

"""
The numerical model captures the downstream asymptotic approach to uniform gravel flux. How does it do with the valley gradient? Let's check this next:
"""

# Calculate analytical solution for gradient
Sfac = (1.0 - porosity) * uplift_rate / (abr_coef * xport_coef * imfac * bf_runoff_rate)
Spred = ((Sfac / profile_x) * (1.0 - np.exp(-abr_coef * profile_x))) ** (6.0 / 7.0)

# Plot
Smod = model.grid.at_node["topographic__steepest_slope"]
plt.plot(profile_x / 1000.0, Spred, "ro-")
plt.plot(profile_x[:-1] / 1000.0, Smod[midrow[:-1]], ".-")
plt.xlabel("Distance (km)", fontsize=14)
plt.ylabel("Valley Gradient (m/m)", fontsize=14)
plt.grid(True)

# Report
print("Predicted gradient at outlet:", Spred[-2])
print(
    "Computed gradient at outlet:",
    Smod[midrow[-2]],
)

"""
The process of abrasion causes the equilibrium longitudinal profile to become concave-upward, because the water discharge increases faster downstream than the gravel flux.

The corresponding width no longer increases linearly downstream. Here it is with a median bed grain size of 5 cm:
"""

w = model.transporter.calc_implied_width(grain_diameter=0.05)
plt.plot(profile_x[:-1] / 1000.0, w[midrow[:-1]])
plt.xlabel("Distance (km)")
plt.ylabel("Bankfull channel width (m)")

"""
In the foregoing example, we used a rather high abrasion coefficient. Attal & Lave (2006) report pebble abrasion coefficients ranging from 0.1 to 47 percent per km. The equivalent proportion per km is 0.001 to 0.47, and the equivalent length scales are the inverse of these. Here are some examples from their paper, in terms of length scale:
"""

print("Quartzite:", 1.0 / 0.001, "km")
print("Granite:", 1.0 / 0.004, "km")
print("Gneiss:", 1.0 / 0.009, "km")
print("Ordovician limestone:", 1.0 / 0.026, "km")
print("Schist:", 1.0 / 0.07, "km")
print("Sandstone:", 1.0 / 0.47, "km")

"""
Here's an example model run with a clast abrasion coefficient similar to that of their Himalayan gneiss:
"""

# Parameters
abr_coef = 1.0 / 100000.0  # abrasion coefficient, 1/m
run_duration = 3.6e7  # run duration, years

profile_grid_params = {
    "RasterModelGrid": {
        "shape": (nrows, ncols),
        "xy_spacing": dx,
        "fields": {"node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}},
    }
}

flow_params = {
    "flow_director": "FlowDirectorD8",
    "runoff_rate": bf_runoff_rate,
}

fluvial_params = {
    "intermittency_factor": imfac,
    "transport_coefficient": xport_coef,
    "abrasion_coefficient": abr_coef,
    "sediment_porosity": porosity,
}

model = GravelRiverNetworkModel(
    profile_grid_params,
    flow_params,
    fluvial_params,
    uplift_rate=uplift_rate,
    run_duration=run_duration,
    dt=dt,
    grid_setup_fn=channel_profile_setup,
    grid_setup_params={"init_slope": init_slope},
)

model.run()

# Calculate analytical solution for gravel flux
Qseqb = (1.0 - porosity) * uplift_rate * dx / abr_coef
Qspred = Qseqb * (1.0 - np.exp(-abr_coef * profile_x))

# Plot
plt.plot(profile_x / 1000.0, Qspred, "ro-")
plt.plot(
    profile_x[:-1] / 1000.0,
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[:-1]],
    ".-",
)
plt.xlabel("Distance (km)")
plt.ylabel("Sediment flux (m3/y)")
plt.legend(["Analytical", "Computed"])
plt.grid(True)

# Report
print("Predicted gravel flux at outlet:", Qspred[-2], "m3/y")
print(
    "Computed gravel flux at outlet:",
    model.grid.at_node["bedload_sediment__volume_outflux"][midrow[-2]],
    "m3/y",
)

# Calculate analytical solution for gradient
Sfac = (1.0 - porosity) * uplift_rate / (abr_coef * xport_coef * imfac * bf_runoff_rate)
Spred = ((Sfac / profile_x) * (1.0 - np.exp(-abr_coef * profile_x))) ** (6.0 / 7.0)

# Plot
Smod = model.grid.at_node["topographic__steepest_slope"]
plt.plot(profile_x / 1000.0, Spred, "ro-")
plt.plot(profile_x[:-1] / 1000.0, Smod[midrow[:-1]], ".-")
plt.xlabel("Distance (km)", fontsize=14)
plt.ylabel("Valley Gradient (m/m)", fontsize=14)
plt.grid(True)

# Report
print("Predicted gradient at outlet:", Spred[-2])
print(
    "Computed gradient at outlet:",
    Smod[midrow[-2]],
)

"""
Again, the gradient decreases down-valley, implying a concave-upward profile, but the comparatively more resistant clasts lead to a more gentle down-valley decrease in gradient.
"""

"""
## Example: tiny drainage basin

This example extends the domain to two dimensions, keeping the grid size very small (so the notebook runs fast), and comparing the equilibrium condition with analytical solutions for the sediment outflux and gradient at headwater nodes.
"""

# Parameters
nrows = 10
ncols = 10
dx = 1000.0  # grid spacing, m
bf_runoff_rate = 10.0  # bankfull runoff rate, m/y
imfac = 0.01  # intermittency factor, -
xport_coef = 0.041  # transport coefficient, -
abr_coef = 1.0 / 2000.0  # abrasion coefficient, 1/m
porosity = 0.35  # sediment porosity, -
uplift_rate = 0.0001  # uplift (i.e., baselevel) rate, m/y

np.random.seed(0)

grid_params = {
    "RasterModelGrid": {
        "shape": (nrows, ncols),
        "xy_spacing": dx,
        "fields": {"node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}},
    }
}

flow_params = {
    "flow_director": "FlowDirectorD8",
    "runoff_rate": bf_runoff_rate,
}

fluvial_params = {
    "intermittency_factor": imfac,
    "transport_coefficient": xport_coef,
    "abrasion_coefficient": abr_coef,
    "sediment_porosity": porosity,
}

# Define grid setup function for 3 rows with open boundary at right side


def mini_basin_setup(grid):
    """Set boundary nodes to CLOSED except the right side, which is the profile
    outlet; give"""
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[1] = grid.BC_NODE_IS_FIXED_VALUE

model = GravelRiverNetworkModel(
    grid_params,
    flow_params,
    fluvial_params,
    initial_noise_amplitude=10.0,
    uplift_rate=uplift_rate,
    run_duration=5.0e5,
    dt=1000.0,
    grid_setup_fn=mini_basin_setup,
)

for _ in range(7):
    model.run()
    plt.figure()
    drainage_plot(model.grid)
    model.time_remaining += 5.0e5

"""
The plots above illustrate a dendritic drainage network. We can also examine the slope-area relationship (see, e.g., Willgoose et al., 1991; Willgoose, 1994):
"""

s = model.grid.at_node["topographic__steepest_slope"]
a = model.grid.at_node["drainage_area"]
cores = model.grid.core_nodes
plt.loglog(a[cores], s[cores], ".")
plt.xlabel("Drainage area (m2)")
_ = plt.ylabel("Slope (m/m)")

"""
### Test: sediment flux and slope at headwater cells

One way to test the steady mini-basin solution is to look at the headwater cells: those that receive no external water or sediment. When in equilibrium with a specified rate of baselevel lowering, a headwater cell should erode at the rate of baselevel lowering, $E$. This will effectively supply a quantity of sediment equal to the erosion rate times the cell area, $\Lambda$, times the solid fraction, so that we can express the volume inflow of sediment to the cell from erosional lowering as:

$$Q_\text{bl} = (1-\phi) E \Lambda$$

As sediment flows through and out of the cell, we should lose gravel to abrasion at a rate that depends on the abrasion coefficient, $\beta$, the local gravel flux $Q_s$, and the length of the channel, which here is treated as the length of the grid link along which water flows, $\lambda_f$:

$$Q_\text{abr} = \beta \lambda_f Q_s$$

In the component, the local sediment flux $Q_s$ is treated as the average of the incoming flux, $Q_\text{in}$, and the outgoing flux, $Q_\text{out}$. In a headwater cell, there's no influx, so the average of in and outflux is evaluated as $Q_s = Q_\text{out} / 2$, and hence

$$Q_\text{abr} = \beta \lambda_f Q_\text{out} / 2$$

At equilibrium, the volume rate of sediment addition via erosional lowering equals the sum of the abrasion loss rate and the downstream transport rate:

$$Q_\text{bl} = Q_\text{out} + Q_\text{abr}$$

Substituting the above, we can rearrange like so:

$$Q_\text{out} = (1-\phi) E \Lambda - \beta \lambda_f Q_\text{out} / 2$$

and then solve for the expected sediment outflux from a headwater cell:

$$\boxed{Q_\text{out} = \frac{(1-\phi) E \Lambda}{1 + \beta \lambda_f / 2}}$$

Using the transport equation, we can then solve for the expected gradient of headwater cells. In doing so, we use the fact that $Q = r A$ and in this case $A = \Lambda$ (i.e., drainage area equals the cell area, because there is no inflow of water besides local runoff generation):

$$\boxed{S = \left( \frac{(1-\phi) E}{k_Q I r \left( 1 + \beta \lambda_f / 2 \right)} \right)^{6/7}}$$

The code below tests this for headwater cells. Note that on a raster grid with D8 flow routing, $\lambda_f$ will differ between cardinal and diagonal directions, so we will calculate the expected flux and gradient for both cases.
"""

# Get an array of headwater node ids
hw = np.where(model.grid.at_node["drainage_area"] == 1.0e6)[0]
print("There are", len(hw), "headwater nodes.")

# Calculate the expected sediment outflux for cardinal & diagonal dirs
Qoutpred = (1 - porosity) * uplift_rate * dx * dx / (1 + abr_coef * dx / 2)
Qoutpred_diag = (1 - porosity) * uplift_rate * dx * dx / (1 + abr_coef * dx / 2**0.5)
print()
print("Predicted outflux for cardinal directions:", Qoutpred)
print("Predicted outflux for diagonal directions:", Qoutpred_diag)

# Actual outflux for headwater nodes:
print()
print("Modeled outflux:")
print(model.grid.at_node["bedload_sediment__volume_outflux"][hw])

"""
As predicted, there are some locations consistent with a cardinal-direction outflow, and some with a diagonal outflow. (On a hex grid, this would not be an issue.) The modeled values are slightly lower than the analytical predictions, in part because we are not yet 100% at steady state (just very close).

Next, we inspect the corresponding slope gradients:
"""

# Calculate expected gradients
Shwpred = (
    (1 - porosity)
    * uplift_rate
    / (xport_coef * imfac * bf_runoff_rate * (1 + abr_coef * dx / 2))
) ** (6.0 / 7.0)
Shwpred_diag = (
    (1 - porosity)
    * uplift_rate
    / (xport_coef * imfac * bf_runoff_rate * (1 + abr_coef * dx / 2**0.5))
) ** (6.0 / 7.0)
print("Predicted gradient for cardinal-direction outflow:", Shwpred)
print("Predicted gradient for diagonal outflow:", Shwpred_diag)

# Compare with actual gradients
print()
print("Computed gradients at headwater nodes:")
print(s[hw])

"""
Again, as expected, the slopes are consistent with the predictions for both flow directions. The headwater cells with diagonal outflow directions have a slightly lower gradient because the longer flow paths allow for more gravel attrition. As before, the modeled values are slightly lower than predicted because the run has not fully reached steady state.
"""

"""
## Example: transient erosion and deposition

This example illustrates the ability of the model to calculate deposition as well as erosion. Here we use a domain that has a sine-curve-shaped valley along one axis, with an abrupt step in the middle of the valley. We expect erosion to occur upstream of the step, and deposition downstream.
"""

# Parameters
nrows = 11
ncols = 50
dx = 1000.0  # grid spacing, m
init_elev_plateau = 100.0
init_slope = 0.0001
bf_runoff_rate = 10.0  # bankfull runoff rate, m/y
imfac = 0.01  # intermittency factor, -
xport_coef = 0.041  # transport coefficient, -
abr_coef = 0.0  # abrasion coefficient, 1/m
porosity = 0.35  # sediment porosity, -
uplift_rate = 0.0  # uplift (i.e., baselevel) rate, m/y
nsteps = 1000  # number of time steps
dt = 100.0  # duration of a time step, y

grid_params = {
    "RasterModelGrid": {
        "shape": (nrows, ncols),
        "xy_spacing": dx,
        "fields": {"node": {"topographic__elevation": {"constant": [{"value": 0.0}]}}},
    }
}

flow_params = {
    "flow_director": "FlowDirectorD8",
    "runoff_rate": bf_runoff_rate,
}

fluvial_params = {
    "intermittency_factor": imfac,
    "transport_coefficient": xport_coef,
    "abrasion_coefficient": abr_coef,
    "sediment_porosity": porosity,
}

# Define grid setup function for a valley with a step


def valley_with_step_setup(grid, init_slope, init_elev_plateau):
    """Create a sine-shaped valley with a step."""
    grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
    grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
    elev = grid.at_node["topographic__elevation"]
    elev[grid.x_of_node <= dx * ncols // 2] += init_elev_plateau
    xmax = np.amax(grid.x_of_node)
    elev[:] += init_slope * (xmax - grid.x_of_node)
    elev[:] += 10.0 * np.sin(2 * np.pi * grid.y_of_node / (dx * 10) + np.pi / 2.0)

model = GravelRiverNetworkModel(
    grid_params,
    flow_params,
    fluvial_params,
    initial_noise_amplitude=0.0,
    uplift_rate=uplift_rate,
    run_duration=nsteps * dt,
    dt=dt,
    grid_setup_fn=valley_with_step_setup,
    grid_setup_params={
        "init_slope": init_slope,
        "init_elev_plateau": init_elev_plateau,
    },
)

# Plot the starting topography
ax = plt.axes(projection="3d")
_ = ax.plot_surface(
    model.grid.x_of_node.reshape((nrows, ncols)),
    model.grid.y_of_node.reshape((nrows, ncols)),
    model.elev.reshape((nrows, ncols)),
)

model.run()

# Plot the final topography
ax = plt.axes(projection="3d")
_ = ax.plot_surface(
    model.grid.x_of_node.reshape((nrows, ncols)),
    model.grid.y_of_node.reshape((nrows, ncols)),
    model.elev.reshape((nrows, ncols)),
)

# Plot the final drainage pattern
plt.axes()
drainage_plot(model.grid)

# Show a plan-view of drainage area
imshow_grid(model.grid, "drainage_area")

"""
Note that a fan-like area of deposition forms at the base of the step. The flow will remain stable and fixed in the central part of the upper valley, but varies over time across the fan, as aggradation modifies the topography and leads to avulsion-like behavior.
"""

"""
## Concluding remarks

The `GravelRiverTransporter` component simulates a grid-based network of equilibrium-width, gravel-bed rivers in which gravel can be lost to abrasion downstream. The component is consistent with analytical solutions. One limitation of the examples shown here is that valley width is effectively uniform and equal to grid-cell width. Another limitation is that the component makes no attempt to evaluate whether the model's state variables are always consistent with the assumptions used to derive the underlying theory. For example, it is theoretically possible to have the implied channel width be so narrow that the wide-channel assumption no longer holds; similarly, it is possible to have an implied valley width larger than a single grid cell. It is also theoretically possible that the implied flow speed could become supercritical, which would be unrealistic. The user is cautioned to be aware of these limitations!

As of this writing, the only fully implemented solver is a simple explicit, forward-Euler method. A matrix-based implicit solver is under construction but not fully operational. An explicit Runge-Kutta method would also be worth trying, as would an adaptive time-stepper.
"""

"""
## References and further reading

Attal, M., & Lavé, J. (2006). Changes of bedload characteristics along the Marsyandi River (central Nepal): Implications for understanding hillslope sediment supply, sediment load evolution along fluvial networks, and denudation in active orogenic belts. Geol. Soc. Am. Spec. Pap, 398, 143-171.

Attal, M., & Lavé, J. (2009). Pebble abrasion during fluvial transport: Experimental results and implications for the evolution of the sediment load along rivers. Journal of Geophysical Research: Earth Surface, 114(F4).

Grant, G. E. (1997). Critical flow constrains flow hydraulics in mobile‐bed streams: A new hypothesis. Water Resources Research, 33(2), 349-358.

Meyer-Peter, E., & Müller, R. (1948). Formulas for bed-load transport. In IAHSR 2nd meeting, Stockholm, appendix 2. IAHR.

Parker, G. (1978). Self-formed straight rivers with equilibrium banks and mobile bed. Part 2. The gravel river. Journal of Fluid mechanics, 89(1), 127-146.

Phillips, C. B., & Jerolmack, D. J. (2016). Self-organization of river channels as a critical filter on climate signals. Science, 352(6286), 694-697.

Wickert, A. D., & Schildgen, T. F. (2019). Long-profile evolution of transport-limited gravel-bed rivers. Earth Surface Dynamics, 7(1), 17-43.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991). A physical explanation of an observed link area‐slope relationship. Water Resources Research, 27(7), 1697-1702.

Willgoose, G. (1994). A physical explanation for an observed area‐slope‐elevation relationship for catchments with declining relief. Water Resources Research, 30(2), 151-159.

Wong, M., & Parker, G. (2006). Reanalysis and correction of bed-load relation of Meyer-Peter and Müller using their own database. Journal of Hydraulic Engineering, 132(11), 1159-1168.
"""



================================================
File: docs/source/tutorials/landscape_evolution/hylands/HyLandsTutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# HyLands: modelling the evolution of landscapes and mass movements

This notebook provides a brief introduction and user's guide to the HyLands Hybrid Landscape Evolution model. The model simulates both continuous fluvial incision and sediment transport using the Landlab Space component as well as stochastic deep-seated bedrock landsliding using the Landlab BedrockLandslider component. This notebook combines two documents, a User's Manual and a notebook-based example, written Benjamin Campforts to accompany the following publications:

* Campforts, B., Shobe, C. M., Overeem, I., & Tucker, G. E. (2022). The Art of Landslides: How Stochastic Mass Wasting Shapes Topography and Influences Landscape Dynamics. Journal of Geophysical Research: Earth Surface, 127(8), 1–16. [doi: 10.1029/2022JF006745](https://doi.org/10.1029/2022JF006745)
* Campforts B., Shobe C.M., Steer P., Vanmaercke M., Lague D., Braun J. (2020) HyLands 1.0: a hybrid landscape evolution model to simulate the impact of landslides and landslide-derived sediment on landscape evolution. Geosci Model Dev: 13(9):3863–86, [doi: 10.5194/gmd-13-3863-2020](https://doi.org/10.5194/gmd-13-3863-2020).
"""

"""
## Background on BedrockLandslider component

The Landlab BedrockLandslider (Hybrid Landscape evolution model) component computes stochastic deep-seated bedrock landsliding and landslide-derived sediment runout across two-dimensional model landscapes. 

This user manual teaches users how to use the BedrockLandslider component using two examples. BedrockLandslider tracks both bedrock and sediment elevation through time. Ideally, a fluvial incision code tracking both bedrock incision and sediment transport is used. Throughout this notebook, we will use the Landlab SPACE component for that purpose. The user is motivated to check out the SPACE notebook before applying the BedrockLandslider component ([see notebook on SPACE](../space/SPACE_user_guide_and_examples.ipynb) and [notebook on SPACELargeScaleEroder](../space/SPACE_large_scale_eroder_user_guide_and_examples.ipynb)).

Prerequisites: A working knowledge of the Python programming language (BedrockLandslider and Landlab support Python 3.x) as well as the NumPy and MatPlotLib libraries. Basic familiarity with the Landlab modeling toolkit (see Hobley et al., 2017 GMD, and Barnhart et al., 2020 eSurf) is recommended.
"""

"""
## Model description

### Input parameters

- **angle_int_frict** $\psi$: Materials angle of internal friction in [m/m]. Default = 1.0
- **cohesion_eff** $c_{eff}$: Effective cohesion of material [m L^-1 T^-2].
- **landslides_return_time** $t_{LS}$: Return time for stochastic landslide events to occur [yr]. Default = 1e5
- **rho_r** $\rho_r$: Bulk density rock [m L^-3].
- **fraction_fines_LS** $F_f$: Fraction of permanently suspendable fines in bedrock [-].
- **phi** $\phi$: Sediment porosity [-].        
- **max_pixelsize_landslide**: Maximum size for landslides in number of pixels. Default = 1e9
- **verbose_landslides**: Print output as number of simulated landslides per time step. Default = False  
- **seed**: Provide seed to set stochastic model. If not provided, seed is set to 2021.Provide None to keep current seed. Default = 2021 
- **landslides_on_boundary_nodes**: Allow landslides to initiate (critical node) and extend over boundary nodes. Default = True
- **critical_sliding_nodes**: Provide list with critical nodes where landslides have to initiate. This cancels the stochastic part of the algorithm and allows the user to form landslides at the provided critical nodes. Default = None
"""

"""
### Model fields 
Fields listed here are updated by the component at the grid locations listed. NOTE: because flow routing is handled by other Landlab components, fields such as `flow__receiver_node`, `flow__upstream_node_order`, `flow__receiver_node`, `topographic__steepest_slope`, `hill_flow__receiver_proportions`, `hill_topographic__steepest_slope` and `hill_flow__receiver_node` are not altered by the BedrockLandslider model and are not listed here but required to run the model.

- `soil__depth`, node, [m]: Thickness of soil (also called sediment or alluvium) at every node. The name “soil” was used to match existing Landlab components. Soil thickness is updated for all nodes impacted by landsliding.

- `sediment__flux`, node, [m$^3$/yr]: The volumetric flux of sediment at each node. Sediment flux is updated based on the volumes of landslide-derived sediment and is used to calculate sediment deposition rates.

- `landslide__erosion`, node, [m]: Erosion by landslides given in total erosion in m per node. 

- `landslide__deposition`, node, [m]: Sediment erosion by landslides given in total erosion in m per node. 

- `landslide_sediment_point_source`, node, [m3]: Landslide derived sediment, as point sources on all the critical nodes where landslides initiate, before landslide runout is calculated.

### Model attributes
Other model attributes created upon model initiation and updated when executing run_one_step are: 
- `landslides_size`: List with the size of simulated landslides. The list is reset every time the landslide_erosion function is called.

- `landslides_volume`: List with the volume of simulated landslides.The list is reset every time the landslide_erosion function is called. 

- `landslides_volume_sed`: List with the volume of sediment eroded by landslides. The list is reset every time the landslide_erosion function is called.

- `landslides_volume_bed`: List with the volume of bedrock eroded by landslides. The list is reset every time the landslide_erosion function is called.
"""

"""
## Steps of a BedrockLandslider model

Note: these steps are for a BedrockLandslider model that is coupled to the SPACE Landlab component. To see examples of how to couple other Landlab components, please refer to the Landlab documentation: [http://landlab.github.io](http://landlab.github.io).
"""

"""
### Step 1: Import the necessary libraries 

The BedrockLandslider and SPACE components are required, as are the model grid component and a flow routing component. We will use the `PriorityFloodFlowRouter` that takes care of routing flow across flats or pits in a digital elevation model.
"""

import copy

import matplotlib as mpl
import matplotlib.pyplot as plt  # For plotting results; optional
import numpy as np

from landlab import RasterModelGrid  # Grid utility
from landlab import imshow_grid, imshowhs_grid  # For plotting results; optional
from landlab.components import BedrockLandslider  # BedrockLandslider model
from landlab.components import SpaceLargeScaleEroder  # SPACE model
from landlab.components import PriorityFloodFlowRouter

"""
Three Landlab components are essential to running the BedrockLandslider model: the model itself, the SPACE model and the `PriorityFloodFlowRouter`, which calculates drainage pathways, topographic slopes, and surface water discharge across the grid. The `PriorityFloodFlowRouter` will act as a depression handler which is useful if a grid is likely to have pits or closed depressions. 

In addition to the relevant process components, some Landlab utilities are required to generate the model grid (in this example `RasterModelGrid`) and to visualize output (`imshowhs_grid`). Note that while it is possible to visualize output through functionality in other libraries (e.g., matplotlib), `imshowhs_grid` provides a simple way to generate 2-D maps of model variables.

Most Landlab functionality requires the Numpy package for scientific computing in python. The matplotlib plotting library has also been imported to aid visualization of results.
"""

"""
### Step 2: Define the model domain and initial conditions

The BedrockLandslider and SPACE components work on raster grids. For this example we will use a synthetic raster grid. In addition to using user-defined, synthetic model grids, it is also possible to import digital elevation models for use as a model domain (see the tutorial *reading_dem_into_landlab*). In this example, we create a synthetic, square model domain by creating an instance of the RasterModelGrid. In this case, the domain will be a plane with random micro-scale topographic roughness to force flow convergence and channelization, and the development of realistic landscapes. The grid is composed of 50 rows and 50 columns for a total of 250 nodes, with user-defined spacing of 25m.

Once the grid has been created, the user defines a grid field to contain values of land surface elevation, and then imposes the desired initial condition topography on the model grid. In the case shown below, the field `topographic__elevation` is added to the model grid and given initial values of all zeros. After that, initial model topography is added to the field. Randomized micro-scale topographic roughness is added to the model grid. While not strictly necessary for the SPACE and BedrockLandslider models to run, the micro-roughness allows flow convergence, channelization, and the development of realistic landscapes.

In this example, we initialize the model domain with 2 meters of sediment thickness at every core (non-boundary) node. The sediment thickness will shrink over time as water mobilizes and removes sediment. To do this, the fields `soil__depth` and `bedrock__elevation` must be added to the model grid. If they are not added, the SPACE model will create them. In that case, however, the default sediment thickness is zero and the default bedrock topography is simply the provided topographic elevation.
"""

# Set grid parameters
num_rows = 50
num_columns = 50
node_spacing = 25.0

# track sediment flux at the node adjacent to the outlet at lower-left
node_next_to_outlet = num_columns + 1

# Instantiate model grid
mg = RasterModelGrid((num_rows, num_columns), node_spacing)
# add field ’topographic elevation’ to the grid
mg.add_zeros("topographic__elevation", at="node")
# set constant random seed for consistent topographic roughness
np.random.seed(seed=5000)

# Create initial model topography:

# add topographic roughness
random_noise = (
    np.random.rand(len(mg.node_y)) / 1000.0
)  # impose topography values on model grid
mg["node"]["topographic__elevation"] += random_noise

# add field 'soil__depth' to the grid
mg.add_zeros("soil__depth", at="node")

# Set 2 m of initial soil depth at core nodes
mg.at_node["soil__depth"][mg.core_nodes] = 1.0  # meters

# Add field 'bedrock__elevation' to the grid
mg.add_zeros("bedrock__elevation", at="node")

# Sum 'soil__depth' and 'bedrock__elevation'
# to yield 'topographic elevation'
mg.at_node["bedrock__elevation"][:] = mg.at_node["topographic__elevation"]
mg.at_node["topographic__elevation"][:] += mg.at_node["soil__depth"]

"""
### Step 3: Set the boundary conditions

The user must determine the boundary conditions of the model domain (i.e., determine across which boundaries water and sediment may flow). Boundary conditions are controlled by setting the status of individual nodes or grid edges (see Hobley et al., 2017). Here, we keep all boundaries open so that water and sediment can leave the domain at all times over all edges. 
"""

# Open all model boundary edges
mg.set_closed_boundaries_at_grid_edges(
    bottom_is_closed=False,
    left_is_closed=False,
    right_is_closed=False,
    top_is_closed=False,
)

"""
### Step 4: Initialize the flow director and SPACE 

Like most Landlab components, PriorityFloodFlowRouter, SPACE and BedrockLandslider are written as a Python classes. The class was imported at the beginning of the driver script (step 1). In this step, the user declares the instance of the PriorityFloodFlowRouter and SPACE classes and sets any relevant model parameters. At this point we do not yet make an instance of the BedrockLandslider component. 
"""

# Instantiate flow router
fr = PriorityFloodFlowRouter(mg, flow_metric="D8", suppress_out=True)

# Instantiate SPACE model with chosen parameters
sp = SpaceLargeScaleEroder(
    mg,
    K_sed=2.5e-5,
    K_br=2.5e-5,
    F_f=0.0,
    phi=0.0,
    H_star=1.0,
    v_s=1,
    m_sp=0.5,
    n_sp=1.0,
    sp_crit_sed=0,
    sp_crit_br=0,
)

"""
### Step 5: Run the time loop to develop a landscape without landslide activity

The SPACE component calculates sediment entrainment and deposition, bedrock erosion, and changes in land surface elevation over time. The code shown below is an example of how to run the SPACE model over several model timesteps. In the example below, SPACE is run in a loop that executes until elapsed model time has reached a user-defined run time. The user is also responsible for choosing the model timestep. Within the loop, the following steps occur:

1. The flow router runs first to determine topographic slopes and water discharge at all nodes on the model domain.
2. The depression finder and router runs to map any nodes located in local topographic minima (i.e., nodes that water cannot drain out of) and to establish flow paths across the surface of these “lakes.” Using the depression finder and router is optional. However, because the SPACE model may in certain situations create local minima, using the depression finder and router can prevent the development of fatal instabilities.
3. The depression finder and router generates a list of flooded nodes, which is then saved as a variable called “flooded” and passed to the SPACE model.
4. The SPACE model runs for the duration of a single timestep, computing sediment transport, bedrock erosion, and topographic surface evolution.
5. The elapsed time is updated.
"""

# Set model timestep
timestep = 1e3  # years

# Set elapsed time to zero
elapsed_time = 0.0  # years

# Set timestep count to zero
count = 0

# Set model run time
run_time = 5e5  # years

# Array to save sediment flux values
sed_flux = np.zeros(int(run_time // timestep))

# Uplift rate in m/yr
U = 1e-3

cmap = copy.copy(mpl.colormaps["terrain"])

while elapsed_time < run_time:  # time units of years
    # Insert uplift at core nodes
    mg.at_node["bedrock__elevation"][mg.core_nodes] += U * timestep
    mg.at_node["topographic__elevation"][:] = (
        mg.at_node["bedrock__elevation"] + mg.at_node["soil__depth"]
    )

    # Run the flow router
    fr.run_one_step()

    # Run SPACE for one time step
    sp.run_one_step(dt=timestep)

    # Add to value of elapsed time
    elapsed_time += timestep

    if np.mod(elapsed_time, 1e5) == 0:
        print("%.2f of model run completed" % (elapsed_time / run_time))
        imshow_grid(
            mg, "topographic__elevation", cmap=cmap, colorbar_label="Elevation (m)"
        )
        plt.show()

"""
## Visualization of results
"""

"""
### Topography and soil depth
"""

cmap = copy.copy(mpl.colormaps["terrain"])
# Show DEM draped over the shaded topographic relief
imshowhs_grid(
    mg,
    "topographic__elevation",
    var_name="Topo",
    var_units=r"m",
    grid_units=("m", "m"),
    cmap=cmap,
    ticks_km=False,
)
plt.show()
# Show Soil thickness draped over the shaded topographic relief
cmap = copy.copy(mpl.colormaps["pink"])
imshowhs_grid(
    mg,
    "topographic__elevation",
    drape1=mg.at_node["soil__depth"],
    plot_type="Drape1",
    var_name="Soil",
    var_units=r"m",
    grid_units=("m", "m"),
    cmap=cmap,
    ticks_km=False,
)

z_before_LS = np.array(mg["node"]["topographic__elevation"])

"""
### Step 6: Initialize the flow director and SPACE and BedrockLandslider components

BedrockLandslider is written as a Python class. The class was imported at the beginning of the driver script (step 1). 
In this step, the user declares the instance of the BedrockLandslider class and sets any relevant model parameters. 
To calculate landslide runout, a non-local deposition scheme is used that requires a multiple flow direction structure. This is to ensure that landslide-derived sediment can be distributed over all 8 neighboring cells and not just to it's steepest neighbor as would be the case with a D8 flow routing algorithm. The priority flood flow router is designed as such that both fluvial (D8) and hillslope (multiple flow directions) can be calculated in the same go. To do this, we re-instantiate the flow router first before making an instance of the BedrockLandslider model. This will create the required fields (`hill_flow__receiver_node` and `hill_flow__receiver_proportions` and `hill_topographic__steepest_slope`) for the BedrockLandslider model. 
"""

# Instantiate flow router, with additional multiple flow director for hillslopes
fr = PriorityFloodFlowRouter(
    mg,
    flow_metric="D8",
    separate_hill_flow=True,
    hill_flow_metric="Quinn",
    update_hill_flow_instantaneous=True,
)

# Instantiate SPACE model with chosen parameters
hy = BedrockLandslider(
    mg,
    angle_int_frict=0.4,
    cohesion_eff=1e3,
    landslides_return_time=1000,
    landslides_on_boundary_nodes=False,
)

"""
### Step 7: Run the time loop over 200 years to develop a landscape with landslide activity

Like before, uplift will be inserted, the flow routers will be updated and the SAPCELargeScaleEroder will be run, but this time, landslides will be actively simulated.  
"""

# Reset elevation back to elevation simulated without landslides to test various landslide configuration settings

mg["node"]["topographic__elevation"][:] = z_before_LS
timestep = 20  # years
landslides_size_all_steps = []

for i in range(10):
    # Insert uplift at core nodes
    mg.at_node["bedrock__elevation"][mg.core_nodes] += U * timestep
    mg.at_node["topographic__elevation"][:] = (
        mg.at_node["bedrock__elevation"] + mg.at_node["soil__depth"]
    )

    # Run the flow router
    fr.run_one_step()

    # Run SPACE for one time step
    sp.run_one_step(dt=timestep)

    # Run BedrockLandslider for one time step
    hy.run_one_step(dt=timestep)

    # Store landslide sizes of current time step into general ls_size list
    landslides_size_all_steps = np.append(landslides_size_all_steps, hy.landslides_size)

"""
## Visualization of results
### Magnitude frequency of landslides simulated over 200 years
"""

LS_size = landslides_size_all_steps * mg.dx**2
counts, bins = np.histogram(np.log10(LS_size), 10)
plt.hist(np.log10(LS_size), log=True, bins=bins, density=True)
plt.xlabel("log10 LS Area, m2")
plt.ylabel("Landslide frequency")

"""
### Location of landslides during last model iteration
Let's plot the resulting landslides 
"""

# Landslide Erosion
cmap = copy.copy(mpl.colormaps["hot_r"])
imshow_grid(
    mg,
    np.sqrt(mg.at_node["landslide__erosion"]),
    colorbar_label="SQRT( Landslide erosion, m) ",
    cmap=cmap,
)
plt.show()

# Landslide Deposition
cmap = copy.copy(mpl.colormaps["winter_r"])
imshow_grid(
    mg,
    np.sqrt(mg.at_node["landslide__deposition"]),
    colorbar_label="SQRT( Landslide deposition, m) ",
    cmap=cmap,
)
plt.show()



================================================
File: docs/source/tutorials/landscape_evolution/river_input_lem/adding_discharge_point_source_to_a_lem.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Adding a discharge point source to a LEM

*(Greg Tucker, CSDMS / CU Boulder, fall 2020)*

This notebook shows how to add one or more discharge point sources to a Landlab-built landscape evolution model (LEM), using the flow routing components. The basic idea is to modify the `water__unit_flux_in` field to include a large flux (which could be represented as either drainage area or discharge) at one or more locations along the edge of a grid.
"""

import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import FlowAccumulator

"""
## Docstring example from `FlowAccumulator`

The following is a tiny example from the `FlowAccumulator` documentation:
"""

mg = RasterModelGrid((5, 4), xy_spacing=(10.0, 10))

topographic__elevation = np.array(
    [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        21.0,
        10.0,
        0.0,
        0.0,
        31.0,
        20.0,
        0.0,
        0.0,
        32.0,
        30.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
    ]
)

_ = mg.add_field("topographic__elevation", topographic__elevation, at="node")
mg.set_closed_boundaries_at_grid_edges(True, True, True, False)
fa = FlowAccumulator(mg, "topographic__elevation", flow_director="FlowDirectorSteepest")
runoff_rate = np.arange(mg.number_of_nodes, dtype=float)
rnff = mg.add_field("water__unit_flux_in", runoff_rate, at="node", clobber=True)
fa.run_one_step()
print(mg.at_node["surface_water__discharge"].reshape(5, 4))
#    array([    0.,   500.,  5200.,     0.,
#               0.,   500.,  5200.,     0.,
#               0.,   900.,  4600.,     0.,
#               0.,  1300.,  2700.,     0.,
#               0.,     0.,     0.,     0.])

"""
We can extend this tiny example to show that you can subsequently modify the `rnff` array and it will take effect when you re-run the `FlowAccumulator`:
"""

rnff[:] = 1.0
fa.run_one_step()
print(mg.at_node["surface_water__discharge"].reshape(5, 4))

"""
## Larger example

In this example, we create a slightly larger grid, with a surface that slopes down toward the south / bottom boundary. We will introduce a runoff point source at a node in the middle of the top-most non-boundary row.

Start by defining some parameters:
"""

# Parameters
nrows = 41
ncols = 41
dx = 100.0  # grid spacing in m
slope_gradient = 0.01  # gradient of topographic surface
noise_amplitude = 0.2  # amplitude of random noise
input_runoff = 10000.0  # equivalent to a drainage area of 10,000 dx^2 or 10^8 m2

"""
Create grid and topography, and set boundaries:
"""

# Create a grid, and a field for water input
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)

# Have just one edge (south / bottom) be open
grid.set_closed_boundaries_at_grid_edges(True, True, True, False)

# Create an elevation field as a ramp with random noise
topo = grid.add_zeros("topographic__elevation", at="node")
topo[:] = slope_gradient * grid.y_of_node
np.random.seed(0)
topo[grid.core_nodes] += noise_amplitude * np.random.randn(grid.number_of_core_nodes)

"""
The `FlowAccumulator` component takes care of identifying drainage directions (here using the D8 method) and calculating the cumulative drainage area and surface water discharge.

Note that in this case we are assuming a default runoff value of unity, meaning that the calculated `surface_water__discharge` is actually just drainage area. To introduce the drainage area of a river entering at the top, we will use a large value for runoff. Because we are considering drainage area as the primary variable, with unit "runoff", our input runoff is a dimensionless variable: the number of contributing grid cell equivalents. We will set this to unity at all the nodes in the model except the point-source location.
"""

# Create a FlowAccumulator component
fa = FlowAccumulator(grid, flow_director="FlowDirectorD8")

# Create a runoff input field, and set one of its nodes to have a large input
runoff = grid.add_ones("water__unit_flux_in", at="node", clobber=True)
top_middle_node = grid.number_of_nodes - int(1.5 * ncols)
runoff[top_middle_node] = input_runoff

fa.run_one_step()

imshow_grid(grid, "surface_water__discharge")

"""
## Changing the amount and/or location of input

We can change the input drainage area / discharge amount or location simply by modifying the `water__unit_flux_in` field. Here we will shift it to the left and double its magnitude.
"""

runoff[top_middle_node] = 1.0  # go back to being a "regular" node
runoff[top_middle_node - 15] = 2 * input_runoff  # shift 15 cells left and double amount
fa.run_one_step()

imshow_grid(grid, "surface_water__discharge")

"""
Note that the `drainage_area` field does not recognize any runoff input. It continues to track *only* the local drainage area:
"""

imshow_grid(grid, "drainage_area")

"""
This means that you should use the `surface_water__discharge` field rather than the `drainage_area` field, regardless of whether the former is meant to represent discharge (volume per time) or effective drainage area (area).
"""

"""
## Combining with a Landscape Evolution Model

Here we'll set up a simple LEM that uses the river input.
"""

from landlab.components import LinearDiffuser, StreamPowerEroder

# Parameters
K = 4.0e-5
D = 0.01
uplift_rate = 0.0001
nrows = 51
ncols = 51
dx = 10.0  # grid spacing in m
slope_gradient = 0.01  # gradient of topographic surface
noise_amplitude = 0.04  # amplitude of random noise
input_runoff = 10000.0  # equivalent to a drainage area of 10,000 dx^2 or 10^6 m2
run_duration = 25.0 / uplift_rate

dt = dx / (K * (dx * dx * input_runoff) ** 0.5)
num_steps = int(run_duration / dt)
print(str(num_steps) + " steps.")

# Create a grid, and a field for water input
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)

# Have just one edge (south / bottom) be open
grid.set_closed_boundaries_at_grid_edges(True, True, True, False)

# Create an elevation field as a ramp with random noise
topo = grid.add_zeros("topographic__elevation", at="node")
topo[:] = slope_gradient * grid.y_of_node
np.random.seed(0)
topo[grid.core_nodes] += noise_amplitude * np.random.randn(grid.number_of_core_nodes)

# Create components
fa = FlowAccumulator(grid, flow_director="FlowDirectorD8")
sp = StreamPowerEroder(grid, K_sp=K, discharge_field="surface_water__discharge")
ld = LinearDiffuser(grid, linear_diffusivity=D)

runoff = grid.add_ones("water__unit_flux_in", at="node", clobber=True)
top_middle_node = grid.number_of_nodes - int(1.5 * ncols)
runoff[top_middle_node] = input_runoff

for _ in range(num_steps):
    topo[grid.core_nodes] += uplift_rate * dt
    fa.run_one_step()
    ld.run_one_step(dt)
    sp.run_one_step(dt)

imshow_grid(grid, topo)



================================================
File: docs/source/tutorials/landscape_evolution/smooth_threshold_eroder/stream_power_smooth_threshold_eroder.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The `StreamPowerSmoothThresholdEroder` component

Landlab's `StreamPowerSmoothThresholdEroder` (here SPSTE for short) is a fluvial landscape evolution component that uses a thresholded form of the stream power erosion law. The novel aspect is that the threshold takes a smoothed form rather than an abrupt mathematical discontinuity: as long as slope and drainage area are greater than zero, there is always *some* erosion rate even if the erosive potential function is below the nominal threshold value. This approach is motivated by the finding that mathematically discontinuous functions in numerical models can lead to "numerical daemons": non-smooth functional behavior that can greatly complicate optimization (Clark & Kavetski, 2010; Kavetski & Clark, 2010, 2011). The SPSTE is one of the fluvial erosion components used in the *terrainBento* collection of landscape evolution models (Barnhart et al., 2019).

This tutorial provides a brief overview of how to use the SPSTE component.

*(G.E. Tucker, 2021)*
"""

"""
## Theory

The SPSTE formulation is as follows. Consider a location on a stream channel that has local downstream slope gradient $S$ and drainage area $A$. We define an erosion potential function $\omega$ as

$$\omega = KA^mS^n$$

where $K$ is an erodibility coefficient with dimensions of $[L^{(1-2m)}/T]$. The erosion potential function has dimensions of erosion (lowering) rate, [L/T], and it represents the rate of erosion that would occur if there were no threshold term. The expression takes the form of the familiar area-slope erosion law, also known as the "stream power law" because the exponents can be configured to represent an erosion law that depends on stream power per unit bed area (Whipple & Tucker, 1999). A common choice of exponents is $m=1/2$, $n=1$, but other combinations are possible depending on one's assumptions about process, hydrology, channel geometry, and other factors (e.g., Howard et al., 1994; Whipple et al., 2000).

We also define a threshold erosion potential function, $\omega_c$, below which erosion rate declines precipitously. Given these definitions, a mathematically discontinuous threshold erosion function would look like this:

$$E = \max (\omega - \omega_c, 0)$$

This kind of formulation is mathematically simple, and given data on $E$ and $\omega$, one could easily find $K$ and $\omega_c$ empirically by fitting a line. Yet even in the case of sediment transport, where the initial motion of grains is usually represented by a threshold shear stress (often referred to as the *critical shear stress* for initiation of sediment motion), we know that *some* transport still occurs below the nominal threshold (e.g, Wilcock & McArdell, 1997). Although it is undeniably true that the rate of sediment transport declines rapidly when the average shear stress drops below a critical value, the strictly linear-with-threshold formulation is really more of convenient mathematical fiction than an accurate reflection of geophysical reality. In bed-load sediment transport, reality seems to be smoother than this mathematical fiction, if one transport rates averaged over a suitably long time period. The same is likely true for the hydraulic detachment and removal of cohesive/rocky material as well. Furthermore, as alluded to above, a strict threshold expression for transport or erosion can create numerical daemons that complicate model analysis.

To avoid the mathematical discontinuity at $\omega=\omega_c$, SPSTE uses a smoothed version of the above function:

$$E = \omega - \omega_c \left( 1 - e^{-\omega / \omega_c} \right)$$

The code below generates a plot that compares the strict threshold and smooth threshold erosion laws.
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import FlowAccumulator, StreamPowerSmoothThresholdEroder

omega = np.arange(0, 5.01, 0.01)
omegac = 1.0
Eabrupt = np.maximum(omega - omegac, 0.0)
Esmooth = omega - omegac * (1.0 - np.exp(-omega / omegac))

plt.plot(omega, Esmooth, "k", label="Smoothed threshold")
plt.plot(omega, Eabrupt, "k--", label="Hard threshold")
plt.plot([1.0, 1.0], [0.0, 4.0], "g:", label=r"$\omega=\omega_c$")
plt.xlabel(r"Erosion potential function ($\omega$)")
plt.ylabel("Erosion rate")
plt.legend()

"""
Notice that the SPSTE formulation effectively smooths over the sharp discontinuity at $\omega = \omega_c$.
"""

"""
### Equilibrium

Consider a case of steady, uniform fluvial erosion. Let the ratio of the erosion potential function to its threshold value be a constant, as

$$\beta = \omega / \omega_c$$

This allows us to replace instances of $\omega_c$ with $(1/\beta) \omega$,

$$E = KA^m S^n - \frac{1}{\beta} KA^m S^n \left( 1 - e^{-\beta} \right)$$

$$ = K A^m S^n \left( 1 - \frac{1}{\beta}  \left( 1 - e^{-\beta} \right)\right)$$

Let
$$\alpha = \left( 1 - \frac{1}{\beta}  \left( 1 - e^{-\beta} \right)\right)$$

Then we can solve for the steady-state slope as

$$\boxed{S = \left( \frac{E}{\alpha K A^m} \right)^{1/n}}$$

We can relate $\beta$ and $\omega_c$ via

$$\omega_c = E / (1-\beta (1 - e^{-\beta} ))$$
"""

"""
## Usage

Here we get a summary of the component's usage and input parameters by printing out the component's header docstring:
"""

print(StreamPowerSmoothThresholdEroder.__doc__)

"""
## Example

Here we'll run a steady-state example with $\beta = 1$. To do this, we'll start with a slightly inclined surface with some superimposed random noise, and subject it to a steady rate of rock uplift relative to baselevel, $U$, until it reaches a steady state.
"""

# Parameters
K = 0.0001  # erodibility coefficient, 1/yr
m = 0.5  # drainage area exponent
beta = 1.0  # ratio of w / wc [-]
uplift_rate = 0.001  # rate of uplift relative to baselevel, m/yr
nrows = 16  # number of grid rows (small for speed)
ncols = 25  # number of grid columns (")
dx = 100.0  # grid spacing, m
dt = 1000.0  # time-step duration, yr
run_duration = 2.5e5  # duration of run, yr
init_slope = 0.001  # initial slope gradient of topography, m/m
noise_amplitude = 0.1  # amplitude of random noise on init. topo.

# Derived parameters
omega_c = uplift_rate / (beta - (1 - np.exp(-beta)))
nsteps = int(run_duration / dt)

# Create grid and elevation field with initial ramp
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(True, True, True, False)
elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = init_slope * grid.y_of_node
np.random.seed(0)
elev[grid.core_nodes] += noise_amplitude * np.random.rand(grid.number_of_core_nodes)

# Display starting topography
imshow_grid(grid, elev)

# Instantiate the two components
# (note that m=0.5, n=1 are the defaults for SPSTE)
fa = FlowAccumulator(grid, flow_director="D8")
spste = StreamPowerSmoothThresholdEroder(grid, K_sp=K, threshold_sp=omega_c)

# Run the model
for i in range(nsteps):
    # flow accumulation
    fa.run_one_step()

    # uplift / baselevel
    elev[grid.core_nodes] += uplift_rate * dt

    # erosion
    spste.run_one_step(dt)

# Display the final topopgraphy
imshow_grid(grid, elev)

# Calculate the analytical solution in slope-area space
alpha = 1.0 - (1.0 / beta) * (1.0 - np.exp(-beta))
area_pred = np.array([1.0e4, 1.0e6])
slope_pred = uplift_rate / (alpha * K * area_pred**m)

# Plot the slope-area relation and compare with analytical
area = grid.at_node["drainage_area"]
slope = grid.at_node["topographic__steepest_slope"]
cores = grid.core_nodes
plt.loglog(area[cores], slope[cores], "k.")
plt.plot(area_pred, slope_pred)
plt.legend(["Numerical", "Analytical"])
plt.title("Equilibrium slope-area relation")
plt.xlabel(r"Drainage area (m$^2$)")
_ = plt.ylabel("Slope (m/m)")

"""
The above plot shows that the simulation has reached steady state, and that the slope-area relation matches the analytical solution.

We can also inspect the erosion potential function, which should be uniform in space, and (because $\beta = 1$ in this example) equal to the threshold $\omega_c$. We can also compare this with the uplift rate and the erosion-rate function:
"""

# Plot the erosion potential function
omega = K * area[cores] ** m * slope[cores]
plt.plot([0.0, 1.0e6], [omega_c, omega_c], "g", label=r"$\omega_c$")
plt.plot(area[cores], omega, ".", label=r"$\omega$")
plt.plot([0.0, 1.0e6], [uplift_rate, uplift_rate], "r", label=r"$U$")
erorate = omega - omega_c * (1.0 - np.exp(-omega / omega_c))
plt.plot(
    area[cores], erorate, "k+", label=r"$\omega - \omega_c (1 - e^{-\omega/\omega_c})$"
)
plt.ylim([0.0, 2 * omega_c])
plt.legend()
plt.title("Erosion potential function vs. threshold term")
plt.xlabel(r"Drainage area (m$^2$)")
_ = plt.ylabel("Erosion potential function (m/yr)")

"""
The above plot illustrates how the SPSTE allows erosion to occur even when the erosion potential lies at or below the nominal threshold.
"""

"""
## References

Barnhart, K. R., Glade, R. C., Shobe, C. M., & Tucker, G. E. (2019). Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution. Geoscientific Model Development, 12(4), 1267-1297.

Clark, M. P., & Kavetski, D. (2010). Ancient numerical daemons of conceptual hydrological modeling: 1. Fidelity and efficiency of time stepping schemes. Water Resources Research, 46(10).

Howard, A. D., Dietrich, W. E., & Seidl, M. A. (1994). Modeling fluvial erosion on regional to continental scales. Journal of Geophysical Research: Solid Earth, 99(B7), 13971-13986.

Kavetski, D., & Clark, M. P. (2010). Ancient numerical daemons of conceptual hydrological modeling: 2. Impact of time stepping schemes on model analysis and prediction. Water Resources Research, 46(10).

Kavetski, D., & Clark, M. P. (2011). Numerical troubles in conceptual hydrology: Approximations, absurdities and impact on hypothesis testing. Hydrological Processes, 25(4), 661-670.

Whipple, K. X., Hancock, G. S., & Anderson, R. S. (2000). River incision into bedrock: Mechanics and relative efficacy of plucking, abrasion, and cavitation. Geological Society of America Bulletin, 112(3), 490-503.

Whipple, K. X., & Tucker, G. E. (1999). Dynamics of the stream‐power river incision model: Implications for height limits of mountain ranges, landscape response timescales, and research needs. Journal of Geophysical Research: Solid Earth, 104(B8), 17661-17674.

Wilcock, P. R., & McArdell, B. W. (1997). Partial transport of a sand/gravel sediment. Water Resources Research, 33(1), 235-245.
"""



================================================
File: docs/source/tutorials/landscape_evolution/space/SPACE_large_scale_eroder_user_guide_and_examples.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# User guide and example for the Landlab SPACE_large_Scale_eroder component

This notebook provides a brief introduction and user's guide for the Stream Power And Alluvial Conservation Equation large_Scale_eroder (SPACE_large_Scale_eroder) component for landscape evolution modeling. 
The SPACE_large_Scale_eroder is based on the SPACE component and is designed to be more robust against large time steps and coded in such a way that mass conservation is explicitly conserved during calculation.  

This notebook combines two documents, a User's Manual and a notebook-based example, written Charles M. Shobe to accompany the following publication:

Shobe, C. M., Tucker, G. E., & Barnhart, K. R. (2017). The SPACE 1.0 model: a Landlab component for 2-D calculation of sediment transport, bedrock erosion, and landscape evolution. Geoscientific Model Development, 10(12), 4577-4604, [https://doi.org/10.5194/gmd-10-4577-2017](https://doi.org/10.5194/gmd-10-4577-2017).

This notebook is adjusted from the SAPCE notebook created by Greg Tucker in July 2021 and created to complement the development of the SPACE_large_Scale_eroder. 


*(User's Manual and example notebook written by C.M. Shobe in July 2017; combined into a notebook, updated for compatibility with Landlab 2.x, and added to the Landlab tutorials collection by Greg Tucker, July 2021. Later adjusted to demonstrate the functionality of the SPACE_large_Scale_eroder by Benjamin Campforts in October 2021.)*
"""

"""
## Background on SPACE_large_Scale_eroder component

The Landlab SPACE_large_Scale_eroder (Stream Power with Alluvium Conservation and Entrainment) component computes sediment transport and bedrock erosion across two-dimensional model landscapes. The SPACE model provides advantages relative to many other fluvial erosion models in that it 1) allows simultaneous erosion of sediment and bedrock, 2) explicitly treats sediment fluxes rather than relying on a proxy for bed cover, and 3) is easily coupled with other surface process components in Landlab. The SPACE component enhances Landlab’s functionality by enabling modeling of bedrock-alluvial channels, rather than simply using parameterized sediment-flux-dependent incision models.

This user manual teaches users how to use the SPACE component using two
examples provided in Shobe et al. (2017).

This user manual serves as a supplement to that manuscript.
Prerequisites: A working knowledge of the Python programming language
(SPACE and Landlab support Python 3.x) as well as the NumPy
and MatPlotLib libraries. Basic familiarity with the Landlab modeling toolkit (see Hobley et al., 2017 GMD, and Barnhart et al., 2020 eSurf) is recommended.
"""

"""
## Model description

### Input parameters

- **Sediment erodibility** $K_s$: Governs the rate of sediment entrainment; may be specified as a single floating point number, an array of length equal to the number of grid nodes, or a string naming an existing grid field.

- **Bedrock erodibility** $K_r$: Governs the rate of bedrock erosion; may be specified as a single floating point number, an array of length equal to the number of grid nodes, or a string naming an existing grid field.

- **Fraction of fine sediment** $F_f$: The unitless fraction (0–1) of rock that does not get converted to sediment, but is assumed to exit the model domain as “fine sediment,” or wash load.

- **Sediment porosity** $\phi$: The unitless fraction (0–1) of sediment thickness caused by pore space.

- **Sediment entrainment length scale** $H_*$: Length scale governing the shape of the exponential sediment entrainment and bedrock erosion func- tions. $H_*$ may be thought of as reflecting bedrock surface roughness, with larger $H_*$ representing a rougher bedrock surface.

- **Effective settling velocity** $V$: Settling velocity of sediment after accounting for the upward effects of turbulence. For details, see discussion by Davy and Lague, 2009.

- **Stream power exponent** $m$: Exponent on drainage area or discharge in the stream power framework. Generally $\approx 0.5$.

- **Stream power exponent** $n$: Exponent on channel slope in the stream power framework. Generally $\approx 1$.

- **Sediment erosion threshold** $\omega_{cs}$: Threshold erosive power required to entrain sediment.

- **Bedrock erosion threshold** $\omega_{cr}$: Threshold erosive power required to erode bedrock.

- **Discharge field**: The field name or array to use for water discharge. The default is to use the grid field `surface_water__discharge`, which is simply drainage area multiplied by the default rainfall rate (1 m/yr). To use custom spatially/temporally varying rainfall, use `water__unit_flux_in` to specify water input to the `FlowAccumulator`.
"""

"""
### Model Variables

Variables listed here are updated by the component at the grid locations listed. NOTE: because flow routing, calculation of discharge, and calculation of flow depth (if applicable) are handled by other Landlab components, variables such as water discharge and flow depth are not altered by the SPACE model and are not listed here.
Note that the SPACE_large_Scale_eroder does currently not support different numerical solvers. A 'basic' (default): explicit forward-time extrapolation is used. The implies that the solution will become unstable if time step is too large so care must be taken when selecting a timestep. 

- `soil__depth`, node, [m]: Thickness of soil (also called sediment or alluvium) at every node. The name “soil” was used to match existing Landlab components. Soil thickness is calculated at every node incorporating the effects of sediment entrainment and deposition and bedrock erosion.

- `sediment__flux`, node, [m$^3$/yr]: The volumetric flux of sediment at each node. Sediment flux is used to calculate sediment deposition rates.

"""

"""
## Steps of a SPACE_large_Scale_eroder model

Note: these steps are for a SPACE model that is not coupled to any other Landlab components. To see examples of how to couple Landlab components, please refer to the Landlab documentation: [http://landlab.github.io](http://landlab.github.io).
"""

"""
### Step 1: Import the necessary libraries 

The `SPACE_large_Scale_eroder` component is required, as are the model grid component and a flow routing component. Here, we use the `PriorityFloodFlowRouter` component that takes care of routing the flow across flats or pits in the digital elevation model, calculates the flow direction as well as the flow accumulation. 
"""

import matplotlib.pyplot as plt  # For plotting results; optional
import numpy as np
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components import PriorityFloodFlowRouter, SpaceLargeScaleEroder

"""
Two Landlab components are essential to running the SPACE model: the model itself, and the `PriorityFloodFlowRouter`, which calculates drainage pathways, topographic slopes, and surface water discharge across the grid. 

In addition to the relevant process components, some Landlab utilities are required to generate the model grid (in this example `RasterModelGrid`).

Most Landlab functionality requires the Numpy package for scientific computing in python. The matplotlib plotting library has also been imported to aid visualization of results.
"""

"""
### Step 2: Define the model domain and initial conditions

The SPACE component works on raster grids. For this example we will use a synthetic raster grid. An example and description of the Landlab raster model grid are given in (Shobe et al., 2017), with a more complete explanation offered in Hobley et al. (2017) and Barnhart et al. (2020). In addition to using user-defined, synthetic model grids, it is also possible to import digital elevation models for use as a model domain (see the tutorial *reading_dem_into_landlab*). In this example, we create a synthetic, square model domain by creating an instance of the RasterModelGrid. In this case, the domain will be a plane slightly tilted towards the lower-left (southwest) corner with random micro-scale topographic roughness to force flow convergence and channelization. The grid is composed of 20 rows and 20 columns for a total of 400 nodes, with user-defined spacing.

Once the grid has been created, the user defines a grid field to contain values of land surface elevation, and then imposes the desired initial condition topography on the model grid. In the case shown below, the field `topographic__elevation` is added to the model grid and given initial values of all zeros. After that, initial model topography is added to the field. To create a plane tilted to the southwest corner, which is referenced by $(x,y)$ coordinate pair (0,0), topographic elevation is modified to depend on the $x$ and $y$ coordinates of each grid node. Then, randomized micro-scale topographic roughness is added to the model grid. While not strictly necessary for the `SPACE_large_Scale_eroder` model to run, the micro-roughness allows flow convergence, channelization, and the development of realistic landscapes.

In this example, we initialize the model domain with 2 meters of sediment thickness at every core (non-boundary) node. The sediment thickness will shrink over time as water mobilizes and removes sediment. To do this, the fields `soil__depth` and `bedrock__elevation` must be added to the model grid. If they are not added, the SPACE model will create them. In that case, however, the default sediment thickness is zero and the default bedrock topography is simply the provided topographic elevation.
"""

rng = np.random.default_rng(seed=5000)

mg = RasterModelGrid((20, 20), xy_spacing=100.0)

# plane tilted towards the lower−left corner
mg.at_node["bedrock__elevation"] = (
    mg.y_of_node / 100000.0
    + mg.x_of_node / 100000.0
    + rng.uniform(0.0, 1e-3, size=mg.number_of_nodes)
)

# Set 2 m of initial soil depth at core nodes
mg.add_zeros("soil__depth", at="node")
mg.at_node["soil__depth"][mg.core_nodes] = 2.0  # meters

# Sum 'soil__depth' and 'bedrock__elevation'
# to yield 'topographic elevation'
mg.at_node["topographic__elevation"] = (
    mg.at_node["bedrock__elevation"] + mg.at_node["soil__depth"]
)

"""
### Step 3: Set the boundary conditions

The user must determine the boundary conditions of the model domain (i.e., determine across which boundaries water and sediment may flow). Boundary conditions are controlled by setting the status of individual nodes or grid edges (see Hobley et al., 2017). We will use a single corner node as an “open” boundary and all other boundary nodes will be “closed”. We first use set closed boundaries at grid edges to ensure that no mass (water or sediment) may cross the model boundaries. Then, set watershed boundary condition outlet id is used to open (allow flow through) the lower-left corner of the model domain.
"""

# Close all model boundary edges
mg.set_closed_boundaries_at_grid_edges(
    bottom_is_closed=True, left_is_closed=True, right_is_closed=True, top_is_closed=True
)

# Set lower-left (southwest) corner as an open boundary
mg.set_watershed_boundary_condition_outlet_id(
    0, mg.at_node["topographic__elevation"], -9999.0
)

mg.imshow("topographic__elevation", cmap="terrain")

"""
In this configuration, the model domain is set to drain water and sediment out of the only open boundary on the grid, the lower-left corner. There are several options for changing boundary conditions in Landlab. See Hobley et al. (2017) or the Landlab [online documentation](https://landlab.csdms.io).
"""

"""
### Step 4: Initialize the SPACE_large_Scale_eroder component and any other components used

Like most Landlab components, SPACE is written as a Python class. The class was imported at the beginning of the driver script (step 1). In this step, the user declares the instance of the SPACE class and sets any relevant model parameters. The same must be done for any other components used.
"""

# Instantiate flow router
fr = PriorityFloodFlowRouter(mg, flow_metric="D8")

# Instantiate SPACE model with chosen parameters
sp = SpaceLargeScaleEroder(
    mg,
    K_sed=0.01,
    K_br=0.001,
    F_f=0.0,
    phi=0.0,
    H_star=1.0,
    v_s=5.0,
    m_sp=0.5,
    n_sp=1.0,
    sp_crit_sed=0,
    sp_crit_br=0,
)

"""
### Step 5: Run the time loop

The `SPACE_large_Scale_eroder` component calculates sediment entrainment and deposition, bedrock erosion, and changes in land surface elevation over time. The code shown below is an example of how to run the `SPACE_large_Scale_eroder` model over several model timesteps. In the example below, SPACE is run in a loop that executes until elapsed model time has reached a user-defined run time. The user is also responsible for choosing the model timestep. Within the loop, the following steps occur:

1. The flow router (`PriorityFloodFlowRouter`) runs first to determine topographic slopes and water discharge at all nodes on the model domain. Within this component, any nodes located in local topographic minima (i.e., nodes that water cannot drain out of) are mapped to establish flow paths across the surface of these “lakes". Looking for depressions is optional. However, because the SPACE_large_Scale_eroder model may in certain situations create local minima, using the depression finder and router can prevent the development of fatal instabilities.
2. The SPACE model runs for the duration of a single timestep, computing sediment transport, bedrock erosion, and topographic surface evolution.
3. The elapsed time is updated.
"""

n_steps = 500
dt = 1.0  # years

# track sediment flux at the node adjacent to the outlet at lower-left
node_next_to_outlet = mg.shape[0] + 1
sed_flux = []

for time in trange(n_steps):
    # Run the flow router
    fr.run_one_step()

    # Run SPACE for one time step
    sp.run_one_step(dt=dt)

    # Save sediment flux value to array
    sed_flux.append(mg.at_node["sediment__flux"][node_next_to_outlet])

"""
## Visualization of results
"""

"""
### Sediment flux map
"""

mg.imshow(
    "sediment__flux",
    plot_name="Sediment flux",
    var_name="Sediment flux",
    var_units=r"m$^3$/yr",
    grid_units=("m", "m"),
    cmap="terrain",
)

"""
### Elevation map
"""

mg.imshow("topographic__elevation", cmap="terrain")

"""
### Sedimentograph

Once the data required for the time series has been saved during the time loop, the time series may be plotted using standard matplotlib plotting commands:
"""

plt.plot(np.arange(len(sed_flux)) * dt, sed_flux, color="k", linewidth=3.0)

plt.gca().set_xlabel("Time [yr]")
plt.gca().set_ylabel(r"Sediment flux [m$^3$/yr]")

"""
There is an initial increase in sediment flux from the model domain as the water reaches its equilibrium transport capacity. Over the long run, topographic gradients are reduced by the erosion of sediment, which results in lower and lower sediment fluxes from the domain over time.
"""



================================================
File: docs/source/tutorials/landscape_evolution/space/SPACE_user_guide_and_examples.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# User guide and example for the Landlab SPACE component

This notebook provides a brief introduction and user's guide for the Stream Power And Alluvial Conservation Equation (SPACE) component for landscape evolution modeling. It combines two documents, a User's Manual and a notebook-based example, written Charles M. Shobe to accompany the following publication:

Shobe, C. M., Tucker, G. E., & Barnhart, K. R. (2017). The SPACE 1.0 model: a Landlab component for 2-D calculation of sediment transport, bedrock erosion, and landscape evolution. Geoscientific Model Development, 10(12), 4577-4604, [https://doi.org/10.5194/gmd-10-4577-2017](https://doi.org/10.5194/gmd-10-4577-2017).

This notebook contains text from user manual along with executable code for its examples.

*(User's Manual and example notebook written by C.M. Shobe in July 2017; combined into a notebook, updated for compatibility with Landlab 2.x, and added to the Landlab tutorials collection by Greg Tucker, July 2021.)*
"""

"""
## Background on SPACE component

The Landlab SPACE (Stream Power with Alluvium Conservation and Entrainment) component computes sediment transport and bedrock erosion across two-dimensional model landscapes. The SPACE model provides advantages relative to many other fluvial erosion models in that it 1) allows simultaneous erosion of sediment and bedrock, 2) explicitly treats sediment fluxes rather than relying on a proxy for bed cover, and 3) is easily coupled with other surface process components in Landlab. The SPACE component enhances Landlab’s functionality by enabling modeling of bedrock-alluvial channels, rather than simply using parameterized sediment-flux-dependent incision models.

This user manual teaches users how to use the SPACE component using two
examples provided in Shobe et al. (2017).

This user manual serves as a supplement to that manuscript.
Prerequisites: A working knowledge of the Python programming language
(SPACE and Landlab support Python 3.x) as well as the NumPy
and MatPlotLib libraries. Basic familiarity with the Landlab modeling toolkit (see Hobley et al., 2017 GMD, and Barnhart et al., 2020 eSurf) is recommended.
"""

"""
## Model description

### Input parameters

- **Sediment erodibility** $K_s$: Governs the rate of sediment entrainment; may be specified as a single floating point number, an array of length equal to the number of grid nodes, or a string naming an existing grid field.

- **Bedrock erodibility** $K_r$: Governs the rate of bedrock erosion; may be specified as a single floating point number, an array of length equal to the number of grid nodes, or a string naming an existing grid field.

- **Fraction of fine sediment** $F_f$: The unitless fraction (0–1) of rock that does not get converted to sediment, but is assumed to exit the model domain as “fine sediment,” or wash load.

- **Sediment porosity** $\phi$: The unitless fraction (0–1) of sediment thickness caused by pore space.

- **Sediment entrainment length scale** $H_*$: Length scale governing the shape of the exponential sediment entrainment and bedrock erosion func- tions. $H_*$ may be thought of as reflecting bedrock surface roughness, with larger $H_*$ representing a rougher bedrock surface.

- **Effective settling velocity** $V$: Settling velocity of sediment after accounting for the upward effects of turbulence. For details, see discussion by Davy and Lague, 2009.

- **Stream power exponent** $m$: Exponent on drainage area or discharge in the stream power framework. Generally $\approx 0.5$.

- **Stream power exponent** $n$: Exponent on channel slope in the stream power framework. Generally $\approx 1$.

- **Sediment erosion threshold** $\omega_{cs}$: Threshold erosive power required to entrain sediment.

- **Bedrock erosion threshold** $\omega_{cr}$: Threshold erosive power required to erode bedrock.

- **Discharge field**: The field name or array to use for water discharge. The default is to use the grid field `surface_water__discharge`, which is simply drainage area multiplied by the default rainfall rate (1 m/yr). To use custom spatially/temporally varying rainfall, use `water__unit_flux_in` to specify water input to the `FlowAccumulator`.

- **Solver**: string indicating the solver to use. Options at present include:
  - 'basic' (default): explicit forward-time extrapolation. Simple but will become unstable if time step is too large.
  - 'adaptive': subdivides global time step as needed to prevent slopes from reversing and alluvium from going negative.
"""

"""
### Model Variables

Variables listed here are updated by the component at the grid locations listed. NOTE: because flow routing, calculation of discharge, and calculation of flow depth (if applicable) are handled by other Landlab components, variables such as water discharge and flow depth are not altered by the SPACE model and are not listed here.

- `soil__depth`, node, [m]: Thickness of soil (also called sediment or alluvium) at every node. The name “soil” was used to match existing Landlab components. Soil thickness is calculated at every node incorporating the effects of sediment entrainment and deposition and bedrock erosion.

- `sediment__flux`, node, [m$^3$/yr]: The volumetric flux of sediment at each node. Sediment flux is used to calculate sediment deposition rates.

"""

"""
## Steps of a SPACE model

Note: these steps are for a SPACE model that is not coupled to any other Landlab components. To see examples of how to couple Landlab components, please refer to the Landlab documentation: [http://landlab.github.io](http://landlab.github.io).
"""

"""
### Step 1: Import the necessary libraries 

The SPACE component is required, as are the model grid component and a flow routing component. It is generally a good idea to also include a depression handler such as `LakeMapperBarnes` or `DepressionFinderAndRouter`. These depression handlers route flow across flats or pits in a digital elevation model.
"""

import matplotlib.pyplot as plt  # For plotting results; optional
import numpy as np

from landlab import RasterModelGrid  # Grid utility
from landlab import imshow_grid  # For plotting results; optional
from landlab.components import Space  # SPACE model
from landlab.components import DepressionFinderAndRouter, FlowAccumulator

"""
Two Landlab components are essential to running the SPACE model: the model itself, and the `FlowAccumulator`, which calculates drainage pathways, topographic slopes, and surface water discharge across the grid. A depression handler, such as `DepressionFinderAndRouter`, is extremely useful if a grid is likely to have pits or closed depressions. For this reason, it is generally a good idea to use the DepressionFinderAndRouter in addition to the `FlowAccumulator`. However, it is not required.

In addition to the relevant process components, some Landlab utilities are required to generate the model grid (in this example `RasterModelGrid`) and to visualize output (`imshow_grid`). Note that while it is possible to visualize output through functionality in other libraries (e.g., matplotlib), `imshow_grid` provides a simple way to generate 2-D maps of model variables.

Most Landlab functionality requires the Numpy package for scientific computing in python. The matplotlib plotting library has also been imported to aid visualization of results.
"""

"""
### Step 2: Define the model domain and initial conditions

The SPACE component works on raster grids. For this example we will use a synthetic raster grid. An example and description of the Landlab raster model grid are given in (Shobe et al., 2017), with a more complete explanation offered in Hobley et al. (2017) and Barnhart et al. (2020). In addition to using user-defined, synthetic model grids, it is also possible to import digital elevation models for use as a model domain (see the tutorial *reading_dem_into_landlab*). In this example, we create a synthetic, square model domain by creating an instance of the RasterModelGrid. In this case, the domain will be a plane slightly tilted towards the lower-left (southwest) corner with random micro-scale topographic roughness to force flow convergence and channelization. The grid is composed of 20 rows and 20 columns for a total of 400 nodes, with user-defined spacing.

Once the grid has been created, the user defines a grid field to contain values of land surface elevation, and then imposes the desired initial condition topography on the model grid. In the case shown below, the field `topographic__elevation` is added to the model grid and given initial values of all zeros. After that, initial model topography is added to the field. To create a plane tilted to the southwest corner, which is referenced by $(x,y)$ coordinate pair (0,0), topographic elevation is modified to depend on the $x$ and $y$ coordinates of each grid node. Then, randomized micro-scale topographic roughness is added to the model grid. While not strictly necessary for the SPACE model to run, the micro-roughness allows flow convergence, channelization, and the development of realistic landscapes.

In this example, we initialize the model domain with 2 meters of sediment thickness at every core (non-boundary) node. The sediment thickness will shrink over time as water mobilizes and removes sediment. To do this, the fields `soil__depth` and `bedrock__elevation` must be added to the model grid. If they are not added, the SPACE model will create them. In that case, however, the default sediment thickness is zero and the default bedrock topography is simply the provided topographic elevation.
"""

# Set grid parameters
num_rows = 20
num_columns = 20
node_spacing = 100.0

# track sediment flux at the node adjacent to the outlet at lower-left
node_next_to_outlet = num_columns + 1

# Instantiate model grid
mg = RasterModelGrid((num_rows, num_columns), node_spacing)
# add field ’topographic elevation’ to the grid
mg.add_zeros("topographic__elevation", at="node")
# set constant random seed for consistent topographic roughness
np.random.seed(seed=5000)

# Create initial model topography:
# plane tilted towards the lower−left corner
topo = mg.node_y / 100000.0 + mg.node_x / 100000.0

# add topographic roughness
random_noise = (
    np.random.rand(len(mg.node_y)) / 1000.0
)  # impose topography values on model grid
mg["node"]["topographic__elevation"] += topo + random_noise

# add field 'soil__depth' to the grid
mg.add_zeros("soil__depth", at="node")

# Set 2 m of initial soil depth at core nodes
mg.at_node["soil__depth"][mg.core_nodes] = 2.0  # meters

# Add field 'bedrock__elevation' to the grid
mg.add_zeros("bedrock__elevation", at="node")

# Sum 'soil__depth' and 'bedrock__elevation'
# to yield 'topographic elevation'
mg.at_node["bedrock__elevation"][:] = mg.at_node["topographic__elevation"]
mg.at_node["topographic__elevation"][:] += mg.at_node["soil__depth"]

"""
### Step 3: Set the boundary conditions

The user must determine the boundary conditions of the model domain (i.e., determine across which boundaries water and sediment may flow). Boundary conditions are controlled by setting the status of individual nodes or grid edges (see Hobley et al., 2017). We will use a single corner node as an “open” boundary and all other boundary nodes will be “closed”. We first use set closed boundaries at grid edges to ensure that no mass (water or sediment) may cross the model boundaries. Then, set watershed boundary condition outlet id is used to open (allow flow through) the lower-left corner of the model domain.
"""

# Close all model boundary edges
mg.set_closed_boundaries_at_grid_edges(
    bottom_is_closed=True, left_is_closed=True, right_is_closed=True, top_is_closed=True
)

# Set lower-left (southwest) corner as an open boundary
mg.set_watershed_boundary_condition_outlet_id(
    0, mg["node"]["topographic__elevation"], -9999.0
)

"""
In this configuration, the model domain is set to drain water and sediment out of the only open boundary on the grid, the lower-left corner. There are several options for changing boundary conditions in Landlab. See Hobley et al. (2017) or the Landlab [online documentation](https://landlab.csdms.io).
"""

"""
### Step 4: Initialize the SPACE component and any other components used

Like most Landlab components, SPACE is written as a Python class. The class was imported at the beginning of the driver script (step 1). In this step, the user declares the instance of the SPACE class and sets any relevant model parameters. The same must be done for any other components used.
"""

# Instantiate flow router
fr = FlowAccumulator(mg, flow_director="FlowDirectorD8")

# Instantiate depression finder and router; optional
df = DepressionFinderAndRouter(mg)

# Instantiate SPACE model with chosen parameters
sp = Space(
    mg,
    K_sed=0.01,
    K_br=0.001,
    F_f=0.0,
    phi=0.0,
    H_star=1.0,
    v_s=5.0,
    m_sp=0.5,
    n_sp=1.0,
    sp_crit_sed=0,
    sp_crit_br=0,
)

"""
### Step 5: Run the time loop

The SPACE component calculates sediment entrainment and deposition, bedrock erosion, and changes in land surface elevation over time. The code shown below is an example of how to run the SPACE model over several model timesteps. In the example below, SPACE is run in a loop that executes until elapsed model time has reached a user-defined run time. The user is also responsible for choosing the model timestep. Within the loop, the following steps occur:

1. The flow router runs first to determine topographic slopes and water discharge at all nodes on the model domain.
2. The depression finder and router runs to map any nodes located in local topographic minima (i.e., nodes that water cannot drain out of) and to establish flow paths across the surface of these “lakes.” Using the depression finder and router is optional. However, because the SPACE model may in certain situations create local minima, using the depression finder and router can prevent the development of fatal instabilities.
3. The depression finder and router generates a list of flooded nodes, which is then saved as a variable called “flooded” and passed to the SPACE model.
4. The SPACE model runs for the duration of a single timestep, computing sediment transport, bedrock erosion, and topographic surface evolution.
5. The elapsed time is updated.
"""

# Set model timestep
timestep = 1.0  # years

# Set elapsed time to zero
elapsed_time = 0.0  # years

# Set timestep count to zero
count = 0

# Set model run time
run_time = 500.0  # years

# Array to save sediment flux values
sed_flux = np.zeros(int(run_time // timestep))

while elapsed_time < run_time:  # time units of years
    # Run the flow router
    fr.run_one_step()

    # Run the depression finder and router; optional
    df.map_depressions()

    # Run SPACE for one time step
    sp.run_one_step(dt=timestep)

    # Save sediment flux value to array
    sed_flux[count] = mg.at_node["sediment__flux"][node_next_to_outlet]

    # Add to value of elapsed time
    elapsed_time += timestep

    # Increase timestep count
    count += 1

"""
## Visualization of results
"""

"""
### Sediment flux map
"""

# Instantiate figure
fig = plt.figure()

# Instantiate subplot
plot = plt.subplot()

# Show sediment flux map
imshow_grid(
    mg,
    "sediment__flux",
    plot_name="Sediment flux",
    var_name="Sediment flux",
    var_units=r"m$^3$/yr",
    grid_units=("m", "m"),
    cmap="terrain",
)

# Export figure to image
fig.savefig("sediment_flux_map.eps")

"""
### Sedimentograph

Once the data required for the time series has been saved during the time loop, the time series may be plotted using standard matplotlib plotting commands:
"""

# Instantiate figure
fig = plt.figure()

# Instantiate subplot
sedfluxplot = plt.subplot()

# Plot data
sedfluxplot.plot(np.arange(500), sed_flux, color="k", linewidth=3.0)

# Add axis labels
sedfluxplot.set_xlabel("Time [yr]")
sedfluxplot.set_ylabel(r"Sediment flux [m$^3$/yr]")

"""
There is an initial increase in sediment flux from the model domain as the water reaches its equilibrium transport capacity. Over the long run, topographic gradients are reduced by the erosion of sediment, which results in lower and lower sediment fluxes from the domain over time.
"""



================================================
File: docs/source/tutorials/landscape_evolution/threshold_eroder/threshold_eroder.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# User guide and example for the Landlab threshold_eroder component

This notebook provides a brief introduction and user's guide for the threshold eroder component for landscape evolution modeling. 

Threshold eroder that cuts off slopes at a given threshold slope ($Sc$) and assumes material to dissolve away
with $$S(S>Sc) 	\rightarrow Sc$$
where *S* is the topographic slope and $Sc$ represents a set threshold slope        
"""

"""
## Threshold eroder with regular grid

"""

import numpy as np

from landlab import RasterModelGrid
from landlab.components import PriorityFloodFlowRouter, ThresholdEroder

mg = RasterModelGrid((5, 5))
mg.set_closed_boundaries_at_grid_edges(False, False, False, False)
z = np.array(
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
    + [0.0, 1.0, 10.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
    + [0.0, 0.0, 0.0, 0.0, 0.0]
)
_ = mg.add_field("topographic__elevation", z, at="node")

# Instantiate Flow director (steepest slope type) and Threshold Eroder
fdir = PriorityFloodFlowRouter(mg)
th_ero = ThresholdEroder(mg, slope_crit=0.6)

# Run the components for ten short timepsteps
for t in range(2):
    fdir.run_one_step()
    th_ero.run_one_step()

# Check final topography

np.allclose(
    mg.at_node["topographic__elevation"],
    np.array(
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.6, 0.6, 0.0]
        + [0.0, 0.6, 1.2, 0.6, 0.0, 0.0, 0.6, 0.6, 0.6, 0.0]
        + [0.0, 0.0, 0.0, 0.0, 0.0]
    ),
)

"""
## Threshold eroder with regular grid using a bedrock and soil field

"""

mg = RasterModelGrid((5, 5))
mg.set_closed_boundaries_at_grid_edges(False, False, False, False)
z = np.array(
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
    + [0.0, 1.0, 10.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0]
    + [0.0, 0.0, 0.0, 0.0, 0.0]
)
topo = mg.add_zeros("topographic__elevation", at="node")
bed = mg.add_field("bedrock__elevation", z, at="node")
soil = mg.add_ones("soil__depth", at="node")
soil[mg.boundary_nodes] = 0
topo[:] = soil + bed

# Instantiate Flow director (steepest slope type) and Threshold Eroder
fdir = PriorityFloodFlowRouter(mg)
th_ero = ThresholdEroder(mg, slope_crit=0.6)

# Run the components for ten short timepsteps

for t in range(2):
    fdir.run_one_step()
    th_ero.run_one_step()

# Check final topography

np.allclose(
    mg.at_node["topographic__elevation"],
    np.array(
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.6, 0.6, 0.0]
        + [0.0, 0.6, 1.2, 0.6, 0.0, 0.0, 0.6, 0.6, 0.6, 0.0]
        + [0.0, 0.0, 0.0, 0.0, 0.0]
    ),
)

"""
## Threshold eroder with hexagonal grid

"""

import numpy as np

from landlab import HexModelGrid
from landlab.components import FlowAccumulator, FlowDirectorSteepest, ThresholdEroder
from landlab.plot.imshow import imshow_grid

hmg = HexModelGrid((8, 8))

topo = hmg.add_zeros("topographic__elevation", at="node")
topo[hmg.core_nodes] += 100

# Instantiate Flow director (steepest slope type) and Threshold Eroder
fdir = FlowDirectorSteepest(hmg)
fa = FlowAccumulator(hmg)
th_ero = ThresholdEroder(hmg, slope_crit=0.6)

# Run the components for ten short timepsteps
for t in range(5):
    fdir.run_one_step()
    fa.run_one_step()
    th_ero.run_one_step()
imshow_grid(hmg, "topographic__elevation")

np.allclose(
    hmg.at_node["topographic__elevation"],
    np.array(
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.6, 0.6, 0.6, 0.6]
        + [0.6, 0.6, 0.0, 0.0, 0.6, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 0.6, 0.0, 0.0]
        + [0.6, 1.2, 1.8, 1.8, 1.8, 1.8, 1.8, 1.2, 0.6, 0.0, 0.0, 0.6, 1.2, 1.8]
        + [1.8, 1.8, 1.8, 1.8, 1.8, 1.2, 0.6, 0.0, 0.0, 0.6, 1.2, 1.2, 1.2, 1.2]
        + [1.2, 1.2, 1.2, 0.6, 0.0, 0.0, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6]
        + [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    ),
)

"""
### Click here to learn about <a href="https://landlab.csdms.io/tutorials/">Landlab tutorials</a>
"""



================================================
File: docs/source/tutorials/lithology/lithology_and_litholayers.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to the Lithology and LithoLayers objects

Lithology and LithoLayers are two Landlab components meant to make it easier to work with spatially variable lithology that produces spatially variable parameter values (e.g. stream power erodability or diffusivity). 

This tutorial is meant for users who have some experience using Landlab components.

In this tutorial we will explore the creation of spatially variable lithology and its impact on the evolution of topography. After an introductory example that will let you see how LithoLayers works, we will work through two more complicated examples. In the first example, we use the LithoLayers to erode either dipping layeres or an anticline. Then we will use Lithology to create inverted topography. 

We will use [xarray](https://xarray.pydata.org/en/stable/) to store and annotate our model output. While we won't extensively discuss the use of xarray, some background will be provided. 

To start, we will import the necessary modules. A note: this tutorial uses the [HoloViews package](http://holoviews.org) for visualization. This package is a great tool for dealing with multidimentional annotated data (e.g. an xarray dataset). If you get an error on import, consider updating dask (this is what the author needed to do in April 2018). You will also need to have the [Bokeh](https://bokeh.pydata.org/en/latest/) and [Matplotlib](https://matplotlib.org) packages installed.

In testing we've seen some users have a warning raised related to the Matplotlib backend. In our testing it was OK to ignore these errors. 
"""

import warnings

warnings.filterwarnings("ignore")

import matplotlib
import numpy as np
import xarray as xr

matplotlib.use("Agg")

%matplotlib inline

import holoviews as hv

hv.notebook_extension("matplotlib")

from landlab import RasterModelGrid
from landlab.components import (
    FastscapeEroder,
    FlowAccumulator,
    LinearDiffuser,
    LithoLayers,
    Lithology,
)

"""
## Part 1: Creating layered rock

First we will create an instance of a LithoLayers to learn how this component works. Both LithoLayers and Lithology work closely with a Landlab ModelGrid, storing information about rock type at each grid node. 

To create LithoLayers you need the following information:

1. A model grid that has the field `'topographic__elevation'` already created. 
2. A list of elevations, called `'layer_elevations'` that the bottom of your layers will go through at specified plan-view anchor point (default value for the anchor point is (x, y) = (0, 0)), and a list of rock type IDs that indicate the rock type of that layer. When `'layer_elevations'` is negative that means that the layer goes through the anchor point above the topographic surface. These layers will be created where they extend below the topographic surface.
3. A dictionary of rock property attributes that maps a rock ID type to property values.
4. A functional form in x and y that defines the shape of your surface. 

The use of this function form makes it possible for any function of x and y to be passed to LithoLayers.

Both the Lithology and LithoLayers components then know the rock type ID of all the material in the 'block of rock' you have specified. This can be used to continuously know the value of specified rock properties at the topographic surface, even as the rock is eroded, uplifted, or new rock is deposited. 

In this tutorial we will first make an example to help build intuition and then do two more complex examples. Most of the functionality of Lithology and LithoLayers is shown in this tutorial, but if you want to read the full component documentation for LithoLayers, it can be found [here](https://landlab.csdms.io/generated/api/landlab.components.lithology.litholayers.html). Links to both components documentation can be found at the bottom of the tutorial.

First, we create a small RasterModelGrid with topography. 
"""

mg = RasterModelGrid((10, 15))
z = mg.add_zeros("topographic__elevation", at="node")

"""
Next we make our layer elevations. We will make 20 layers that are 5 meters thick. Note that here, as with most Landlab components, there are no default units. At the anchor point, half of the layers will be above the ground (`'layer_elevations'`  will have negative values) and half will be below the ground (`'layer_elevations'` have positive values). 

We will make this with the [`np.arange`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html) function. We will also make the bottom layer really really thick so that we won't be able to erode through through it. 
"""

layer_elevations = 5.0 * np.arange(-10, 10)

# we create a bottom layer that is very thick.
layer_elevations[-1] = layer_elevations[-2] + 100

"""
Next we create an array that represents our rock type ID values. We will create alternating layers of four types of rock by making an array with alternating `0`s `1`s `2`s and `3`s with the [np.tile](https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html) function. 
"""

layer_ids = np.tile([0, 1, 2, 3], 5)

"""
Our dictionary containing rock property attributes has the following form:
"""

attrs = {"K_sp": {0: 0.0003, 1: 0.0001, 2: 0.0002, 3: 0.0004}}

"""
`'K_sp'` is the property that we want to track through the layered rock, `0`, `1`, `2`, `3` are the rock type IDs, and `0.0003` and `0.0001` are the values for `'K_sp'`  for the rock types `0` and `1`. 

The rock type IDs are unique identifiers for each type of rock. A particular rock type may have many properties (e.g. `'K_sp'`, `'diffusivity'`, and more). You can either specify all the possible rock types and attributes when you instantiate the LithoLayers component, or you can add new ones with the [`lith.add_rock_type`](https://landlab.csdms.io/generated/api/landlab.components.lithology.lithology.html#landlab.components.lithology.lithology.Lithology.add_rock_type) or [`lith.add_property`](https://landlab.csdms.io/generated/api/landlab.components.lithology.lithology.html#landlab.components.lithology.lithology.Lithology.add_property) built in functions.

Finally, we define our function. Here we will use a [lambda expression](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions) to create a small anonymous function. In this case we define a function of `x` and `y` that returns the value `x + (2. * y)`. The LithoLayers component will check that this function is a function of two variables and that when passed two arrays of size number-of-nodes it returns an array of size number-of-nodes.

This means that planar rock layers will dip into the ground to the North-North-East. By changing this functional form, we can make more complicated rock layers.
"""

"""
Finally we construct our LithoLayers component by passing the correct arguments.
"""

lith = LithoLayers(
    mg, layer_elevations, layer_ids, function=lambda x, y: x + (2.0 * y), attrs=attrs
)

"""
LithoLayers will make sure that the model grid has at-node grid fields with the layer attribute names. In this case, this means that the model grid will now include a grid field called `'K_sp'` and a field called `'rock_type__id'`. We can plot these with the Landlab [imshow](https://landlab.csdms.io/generated/api/landlab.plot.imshow.html#landlab.plot.imshow.imshow_grid) function. 
"""

mg.imshow("rock_type__id", cmap="viridis")

"""
As you can see, we have layers that strike East-South-East. Since we can only see the surface expression of the layers, we can't infer the dip direction or magnitude from the plot alone. 

If the topographic surface erodes, then you will want to update LithoLayers. Like most Landlab components, LithoLayers uses a `run_one_step` method to update. 

Next we will erode the topography by decrementing the variable `z`, which points to the topographic elevation of our model grid, by an amount 1. In a landscape evolution model, this would typically be done by running the `run_one_step` method for each of the process components in the model. If the rock mass is being advected up or down by an external force (e.g. tectonic rock uplift), then then advection must be specified. The `dz_advection` argument can be a single value or an array of size number-of-nodes. 
"""

z -= 1.0
dz_ad = 0.0
lith.dz_advection = dz_ad
lith.run_one_step()

"""
We can re-plot the value of `'K_sp'`. We will see that the location of the surface expression of the rock layers has changed. As we expect, the location has changed in a way that is consistent with layers dipping to the NNE. 
"""

mg.imshow("rock_type__id", cmap="viridis")

"""
Anytime material is added, LithoLayers or Lithology needs to know the type of rock that has been added. LithoLayers and Lithology do not assume to know the correct rock type ID and thus require that the user specify it with the `rock_id` keyword argument. In the `run_one_step` function, both components will check to see if any deposition has occured. If deposition occurs **and** this argument is not passed, then an error will be raised. 

For example here we add 1 m of topographic elevation and do not advect the block of rock up or down. When we run `lith.run_one_step` we specify that the type of rock has id `0`. 
"""

z += 1.0
dz_ad = 0.0

lith.dz_advection = dz_ad
lith.rock_id = 0

lith.run_one_step()

"""
When we plot the value of the rock type ID at the surface, we find that it is now all purple, the color of rock type zero. 
"""

mg.imshow("rock_type__id", cmap="viridis", vmin=0, vmax=3)

"""
The value passed to the `rock_id` keyword argument can be either a single value (as in the second to last example) or an array of length number-of-nodes. This option permits a user to indicate that more than one type of rock is deposited in a single time step. 

Next we will add a 2 m thick layer that is type `1` for x values less than or equal to 6 and type `2` for all other locations. 
"""

z += 2.0
dz_ad = 0.0
spatially_variable_rock_id = mg.ones("node")
spatially_variable_rock_id[mg.x_of_node > 6] = 2

lith.dz_advection = dz_ad
lith.rock_id = spatially_variable_rock_id

lith.run_one_step()
mg.imshow("rock_type__id", cmap="viridis", vmin=0, vmax=3)

"""
As you can see this results in the value of rock type at the surface being about half rock type `1` and about half rock type `2`. Next we will create an xarray dataset that has 3D information about our Lithology to help visualize the layers in space. We will use the `rock_cube_to_xarray` method of the LithoLayers component. 

We will then convert this xarray dataset into a HoloViews dataset so we can visualize the result. 

As you can see the LithoLayers has a value of rock types `1` and `2` at the surface, then a layer of `0` below, and finally changes to alternating layers. 
"""

ds = lith.rock_cube_to_xarray(np.arange(30))
hvds_rock = hv.Dataset(ds.rock_type__id)

%opts Image style(cmap='viridis') plot[colorbar=True]
hvds_rock.to(hv.Image, ["x", "y"])

"""
The slider allows us to change the depth below the topographic surface.

We can also plot the cube of rock created with LithoLayers as a cross section. In the cross section we can see the top two layers we made by depositing rock and then dipping layers of alternating rock types. 
"""

%opts Image style(cmap='viridis') plot[colorbar=True, invert_yaxis=True]
hvds_rock.to(hv.Image, ["x", "z"])

"""
Hopefuly this gives you a sense of how LithoLayers works. The next two blocks of code have all the steps we just worked through in one place. 

Try modifying the layer thicknesses, the size of the grid, the function used to create the form of the layers, the layers deposited and eroded, and the location of the anchor point to gain intuition for how you can use LithoLayers to create different types of layered rock. 
"""

# Parameters that control the size and shape of the model grid
number_of_rows = 50
number_of_columns = 50
dx = 1

# Parameters that control the LithoLayers

# the layer thicknesses
layer_thickness = 50.0

# the location of the anchor point
x0 = 25
y0 = 25

# the resolution at which you sample to create the plan view and cros-section view figures.
sample_depths = np.arange(0, 30, 1)

# create the model grid
mg = RasterModelGrid((number_of_rows, number_of_columns), dx)
z = mg.add_zeros("topographic__elevation", at="node")

# set up LithoLayers inputs
layer_ids = np.tile([0, 1, 2, 3], 5)
layer_elevations = layer_thickness * np.arange(-10, 10)
layer_elevations[-1] = layer_elevations[-2] + 100
attrs = {"K_sp": {0: 0.0003, 1: 0.0001, 2: 0.0002, 3: 0.0004}}

# create LithoLayers
lith = LithoLayers(
    mg,
    layer_elevations,
    layer_ids,
    x0=x0,
    y0=y0,
    function=lambda x, y: (0.5 * x) ** 2 + (0.5 * y) ** 2,
    attrs=attrs,
)

# deposity and erode
dz_ad = 0.0

z -= 1.0
lith.dz_advection = dz_ad
lith.run_one_step()

z += 1.0
lith.dz_advection = dz_ad
lith.rock_id = 0
lith.run_one_step()

z += 2.0
spatially_variable_rock_id = mg.ones("node")
spatially_variable_rock_id[mg.x_of_node > 6] = 2
lith.dz_advection = dz_ad
lith.rock_id = spatially_variable_rock_id
lith.run_one_step()

# get the rock-cube data structure and plot
ds = lith.rock_cube_to_xarray(sample_depths)
hvds_rock = hv.Dataset(ds.rock_type__id)

# make a plan view image
%opts Image style(cmap='viridis') plot[colorbar=True]
hvds_rock.to(hv.Image, ["x", "y"])

"""
You can also make a cross section of this new LithoLayers component. 
"""

%opts Image style(cmap='viridis') plot[colorbar=True, invert_yaxis=True]
hvds_rock.to(hv.Image, ["x", "z"])

"""
## Part 2: Creation of a landscape evolution model with LithoLayers


In this next section, we will run LithoLayers with components used for a simple Landscape Evolution Model. 

We will start by creating the grid.
"""

mg = RasterModelGrid((50, 30), 400)
z = mg.add_zeros("topographic__elevation", at="node")
random_field = 0.01 * np.random.randn(mg.size("node"))
z += random_field - random_field.min()

"""
Next we set all the parameters for LithoLayers. Here we have two types of rock with different erodabilities. 
"""

attrs = {"K_sp": {0: 0.0003, 1: 0.0001}}

z0s = 50 * np.arange(-20, 20)
z0s[-1] = z0s[-2] + 10000

ids = np.tile([0, 1], 20)

"""
There are three functional forms that you can choose between. Here we define each of them. 
"""

# Anticline


def anticline_func(x, y):
    return (0.002 * x) ** 2 + (0.001 * y) ** 2


# Shallow dips
def shallow_func(x, y):
    return (0.001 * x) + (0.003 * y)


# Steeper dips
def steep_func(x, y):
    return (0.01 * x) + (0.01 * y)

"""
The default option is to make an anticline, but you can comment/uncomment lines to choose a different functional form. 
"""

# Anticline
lith = LithoLayers(
    mg, z0s, ids, x0=6000, y0=10000, function=anticline_func, attrs=attrs
)

# Shallow dips
# lith = LithoLayers(mg, z0s, ids, function=shallow_func, attrs=attrs)

# Steeper dips
# lith = LithoLayers(mg, z0s, ids, function=steep_func, attrs=attrs)

"""
Now that we've created LithoLayers, model grid fields for each of the LithoLayers attributes exist and have been set to the values of the rock exposed at the surface. 

Here we plot the value of `'K_sp'` as a function of the model grid. 
"""

mg.imshow("K_sp")

"""
As you can see (in the default anticline option) we have concentric elipses of stronger and weaker rock. 

Next, lets instantiate a FlowAccumulator and a FastscapeEroder to create a simple landscape evolution model. 

We will point the FastscapeEroder to the model grid field `'K_sp'` so that it will respond to the spatially variable erodabilities created by LithoLayers. 
"""

nts = 300
U = 0.001
dt = 1000

fa = FlowAccumulator(mg)
sp = FastscapeEroder(mg, K_sp="K_sp")

"""
Before we run the model we will also instatiate an xarray dataset used to store the output of our model through time for visualization. 

The next block may look intimidating, but I'll try and walk you through what it does. 

[xarray](https://xarray.pydata.org/en/stable/) allows us to create a container for our data and label it with information like units, dimensions, short and long names, etc.  xarray gives all the tools for dealing with N-dimentional data provided by python packages such as [numpy](http://www.numpy.org), the labeling and named indexing power of the [pandas](https://pandas.pydata.org) package, and the data-model of the [NetCDF file](https://www.unidata.ucar.edu/software/netcdf/).

This means that we can use xarray to make a "self-referential" dataset that contains all of the variables and attributes that describe what each part is and how it was made. In this application, we won't make a fully self-referential dataset, but if you are interested in this, check out the [NetCDF best practices](https://docs.unidata.ucar.edu/nug/current/best_practices.html). 

Important for our application is that later on we will use the [HoloViews package](http://holoviews.org) for visualization. This package is a great tool for dealing with multidimentional annotated data and will do things like automatically create nice axis labels with units. However, in order for it to work, we must first annotate our data to include this information.

Here we create an xarray Dataset with two variables `'topographic__elevation'` and `'rock_type__id'` and three dimensions `'x'`, `'y'`, and `'time'`. 

We pass xarray two dictionaries, one with information about the data variabiables (`data_vars`) and one with information about the coordinate system (`coords`). For each data variable or coordinate, we pass a tuple of three items: `(dims, data, atts)`. The first element is a tuple of the name of the dimensions, the second element is the data, an the third is a dictionary of attributes. 
"""

ds = xr.Dataset(
    data_vars={
        "topographic__elevation": (
            ("time", "y", "x"),  # tuple of dimensions
            np.empty((nts, mg.shape[0], mg.shape[1])),  # n-d array of data
            {
                "units": "meters",  # dictionary with data attributes
                "long_name": "Topographic Elevation",
            },
        ),
        "rock_type__id": (
            ("time", "y", "x"),
            np.empty((nts, mg.shape[0], mg.shape[1])),
            {"units": "-", "long_name": "Rock Type ID Code"},
        ),
    },
    coords={
        "x": (
            ("x"),  # tuple of dimensions
            mg.x_of_node.reshape(mg.shape)[0, :],  # 1-d array of coordinate data
            {"units": "meters"},
        ),  # dictionary with data attributes
        "y": (("y"), mg.y_of_node.reshape(mg.shape)[:, 1], {"units": "meters"}),
        "time": (
            ("time"),
            dt * np.arange(nts) / 1e6,
            {"units": "millions of years since model start", "standard_name": "time"},
        ),
    },
)

"""
We can print the data set to get some basic information about it.
"""

print(ds)

"""
We can also print a single variable to get more detailed information about it. 

Since we initialized the datset with empty arrays for the two data variables, we just see zeros for the data values. 
"""

ds.topographic__elevation

"""
Next, we run the model. In each time step we first run the FlowAccumulator to direct flow and accumulatate drainage area. Then the FastscapeEroder erodes the topography based on the stream power equation using the erodability value in the field `'K_sp'`. We create an uplift field that uplifts only the model grid's core nodes. After uplifting these core nodes, we update LithoLayers. Importantly, we must tell the LithoLayers how it has been advected upward by uplift using the `dz_advection` keyword argument. 

As we discussed in the introductory example, the built-in function [`lith.run_one_step`](https://landlab.csdms.io/generated/api/landlab.components.lithology.litholayers.html#landlab.components.lithology.litholayers.LithoLayers.run_one_step) has an optional keyword argument `rock_id` to use when some material may be deposited. The LithoLayers component needs to know what type of rock exists everywhere and it will raise an error if material is deposited **and** no rock type is specified. However, here we are using the FastscapeEroder which is fully detachment limited, and thus we know that no material will be deposited at any time. Thus we can ignore this keyword argument. Later in the tutorial we will use the LinearDiffuser which can deposit sediment and we will need to set this keyword argument correctly. 

Within each timestep we save information about the model for plotting. 
"""

out_fields = ["topographic__elevation", "rock_type__id"]

for i in range(nts):
    fa.run_one_step()
    sp.run_one_step(dt=dt)
    dz_ad = np.zeros(mg.size("node"))
    dz_ad[mg.core_nodes] = U * dt
    z += dz_ad
    lith.dz_advection = dz_ad
    lith.run_one_step()

    for of in out_fields:
        ds[of][i, :, :] = mg["node"][of].reshape(mg.shape)

"""
Now that the model has run, lets start by plotting the resulting topography. 
"""

mg.imshow("topographic__elevation", cmap="viridis")

"""
The layers of rock clearly influence the form of topography. 

Next we will use HoloViews to visualize the topography and rock type together. 

To start, we create a HoloViewDataset from our xarray datastructure. 
"""

hvds_topo = hv.Dataset(ds.topographic__elevation)
hvds_rock = hv.Dataset(ds.rock_type__id)
hvds_topo

"""
Next we specify that we want two images, one showing rock type and one showing topographic elevation. A slider bar shows us model time in millions of years.  

Be patient. Running this next block may take a moment. HoloViews is rendering an image of all time slices so you can see an animated slider. This is pretty magical (but not instantaneous).  
"""

%opts Image style(interpolation='bilinear', cmap='viridis') plot[colorbar=True]
topo = hvds_topo.to(hv.Image, ["x", "y"])
rock = hvds_rock.to(hv.Image, ["x", "y"])

topo + rock

"""
We can see the form of the anticline advecting through the topography. Cool!


## Part 3: Creation of Inverted Topography

Here we will explore making inverted topography by eroding Lithology with constant properties for half of the model evaluation time, and then filling Lithology in with resistant material only where the drainage area is large. This is meant as a simple example of filling in valleys with volcanic material. 

All of the details of the options for creating a [Lithology](https://landlab.csdms.io/generated/api/landlab.components.lithology.lithology.html) can be found here. 

In the next code block we make a new model and run it. There are a few important differences between this next example and the one we just worked through in Part 2. 

Here we will have two rock types. Type `0` that represents non-volcanic material. It will have a higher diffusivity and erodability than the volcanic material, which is type `1`. 

Recall that in Part 2 we did not specify a `rock_id` keyword argument to the `lith.run_one_step` method. This was because we used only the FastscapeEroder component which is fully detachment limited and thus never deposits material. In this example we will also use the LinearDiffuser component, which may deposity material. The `Lithology` component needs to know the rock type everywhere and thus we must indicate the rock type of the newly deposited rock. This is done by passing a single value or number-of-nodes sized array rock type values to the `run_one_step` method. 

We also are handling the model grid boundary conditions differently than in the last example, setting the boundaries on the top and bottom to closed. 
"""

mg2 = RasterModelGrid((30, 30), 200)
mg2.set_closed_boundaries_at_grid_edges(False, True, False, True)
z2 = mg2.add_zeros("topographic__elevation", at="node")
random_field = 0.01 * np.random.randn(mg2.size("node"))
z2 += random_field - random_field.min()

thicknesses2 = [10000]
ids2 = [0]

attrs2 = {"K_sp": {0: 0.0001, 1: 0.00001}, "D": {0: 0.4, 1: 0.001}}

lith2 = Lithology(mg2, thicknesses2, ids2, attrs=attrs2)

nts = 500
U = 0.005
dt = 1000

fa2 = FlowAccumulator(mg2)
sp2 = FastscapeEroder(mg2, K_sp="K_sp")
ld2 = LinearDiffuser(mg2, linear_diffusivity="D")

out_fields = ["topographic__elevation", "rock_type__id"]

out_fields = ["topographic__elevation", "rock_type__id"]

nts = 200
U = 0.001
dt = 1000

ds2 = xr.Dataset(
    data_vars={
        "topographic__elevation": (
            ("time", "y", "x"),
            np.empty((nts, mg2.shape[0], mg2.shape[1])),
            {"units": "meters", "long_name": "Topographic Elevation"},
        ),
        "rock_type__id": (
            ("time", "y", "x"),
            np.empty((nts, mg2.shape[0], mg2.shape[1])),
            {"units": "-", "long_name": "Rock Type ID Code"},
        ),
    },
    coords={
        "x": (("x"), mg2.x_of_node.reshape(mg2.shape)[0, :], {"units": "meters"}),
        "y": (("y"), mg2.y_of_node.reshape(mg2.shape)[:, 1], {"units": "meters"}),
        "time": (
            ("time"),
            dt * np.arange(nts) / 1e6,
            {"units": "millions of years since model start", "standard_name": "time"},
        ),
    },
)

half_nts = int(nts / 2)

dz_ad2 = np.zeros(mg2.size("node"))
dz_ad2[mg2.core_nodes] = U * dt
lith2.dz_advection = dz_ad2
lith2.rock_id = 0

for i in range(half_nts):
    fa2.run_one_step()
    sp2.run_one_step(dt=dt)
    ld2.run_one_step(dt=dt)

    z2 += dz_ad2
    lith2.run_one_step()

    for of in out_fields:
        ds2[of][i, :, :] = mg2["node"][of].reshape(mg2.shape)

"""
After the first half of run time, let's look at the topography. 
"""

mg2.imshow("topographic__elevation", cmap="viridis")

"""
We can see that we have developed ridges and valleys as we'd expect from a model with stream power erosion and linear diffusion. 

Next we will create some volcanic deposits that fill the channels in our model.
"""

volcanic_deposits = np.zeros(mg2.size("node"))
da_big_enough = mg2["node"]["drainage_area"] > 5e4

topo_difference_from_top = (
    mg2["node"]["topographic__elevation"].max() - mg2["node"]["topographic__elevation"]
)

volcanic_deposits[da_big_enough] = 0.25 * topo_difference_from_top[da_big_enough]
volcanic_deposits[mg2.boundary_nodes] = 0.0

z2 += volcanic_deposits
lith2.rock_id = 1
lith2.run_one_step()

mg2.imshow(volcanic_deposits)

"""
We should expect that the locations of our valleys and ridges change as the river system encouters the much stronger volcanic rock. 
"""

for i in range(half_nts, nts):
    fa2.run_one_step()
    sp2.run_one_step(dt=dt)
    ld2.run_one_step(dt=dt)
    dz_ad2 = np.zeros(mg2.size("node"))
    dz_ad2[mg2.core_nodes] = U * dt
    z2 += dz_ad2
    lith2.dz_advection = dz_ad2
    lith2.rock_id = 0
    lith2.run_one_step()

    for of in out_fields:
        ds2[of][i, :, :] = mg2["node"][of].reshape(mg2.shape)

"""
Now that the model has run, let's plot the final elevation
"""

mg2.imshow("topographic__elevation", cmap="viridis")

"""
And now a HoloView Plot that lets us explore the time evolution of the topography
"""

hvds_topo2 = hv.Dataset(ds2.topographic__elevation)
hvds_rock2 = hv.Dataset(ds2.rock_type__id)

%opts Image style(interpolation='bilinear', cmap='viridis') plot[colorbar=True]
topo2 = hvds_topo2.to(hv.Image, ["x", "y"])
rock2 = hvds_rock2.to(hv.Image, ["x", "y"])

topo2 + rock2

# if you wanted to output to visualize in something like ParaView, the following commands can be used
# ds.to_netcdf('anticline.nc')
# ds2.to_netcdf('inversion.nc')

"""
Sure enough, the volcanic deposits impact the location of the ridges and valleys. The old valleys become ridges because it takes so much time for them to be eroded. 

You can explore how this changes as the thickness of the deposit changes and as the relative erodabilities change. 


## The end.

Nice work getting to the end of the tutorial!

For more detailed information about the [Lithology](https://landlab.csdms.io/generated/api/landlab.components.lithology.lithology.html) and [LithoLayers](https://landlab.csdms.io/generated/api/landlab.components.lithology.litholayers.html#module-landlab.components.lithology.litholayers) objects, check out their detailed documentation. 

### **Click [here](https://landlab.csdms.io/tutorials/) for more Landlab tutorials**
"""



================================================
File: docs/source/tutorials/making_components/component_design_tips.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Tips on Writing Landlab Components
"""

"""
Thanks for your interest in developing a component in Landlab! 

This ipython notebook provides some tips on designing and building Landlab components. It assumes you are familiar with the basics of building a component. If you haven't already, take a look at the tutorial on [How to Write a Landlab Component](making_components.ipynb), the User Guide section on [Developing Your Own Component](https://landlab.csdms.io/development/contribution/), and the [Example Pull Request Creating a Component](https://github.com/landlab/landlab/pull/678). We also recommend that you familiarize yourself with the [Style and Lint conventions](https://landlab.csdms.io/development/practices/style_conventions.html).
"""

"""
## Why Does This Guide Exist?

The Landlab development team has been working together for nearly a decade to create the Landlab toolkit. Through this time many of the team members have iterated toward a set of best practices for creating and using components. Some of these recommendations are enforced in order to contribute code to Landlab, and some of them are just recommended. 

We want to make sure we communicate these recommendations to the community of potential Landlab component developers. 
"""

"""
## Components versus Models

Landlab components are designed to serve as the building blocks for numerical models, but a Landlab component is not a model by itself. Rather, a component-based Landlab model typically consists of a *driver program* that instantiates and runs one or more components. For this reason, a Landlab component will not normally create or contain another component (though there are occasional exceptions that prove the rule; for example, a `FlowAccumulator` can create a `FlowDirector`). Instead, if one component relies on output from another component, the recommended practice is to have the relevant output field from one component act as an input field for another. For example, a component that generates a spatial rainfall pattern would have the rainfall as an output field; a runoff-generation component might then require a rainfall field as an input.

A common question we get that relates to the component vs model concept is "how do I setup my component to ingest entire rainfall record for my model run?" The recommended practice is to build your component so it can look at fields on the model grid and run forward in time a duration `dt`. If say, you had a external dataset that gave you gridded rainfall through time as a `(nr, nc, nt)` numpy array, we would recommend that your build your component to look at a precipitation field each time it runs one step, and that your driver use the gridded precipititation each timestep to update that field. 

We advocate for this design because it is agnostic to exactly how a components input fields (in this example precipitation) are set. This makes components more reusable. 
"""

"""
## Required and Recommended Elements for Components

A Landlab component must:

* Derive from the Component base class
* Provide the standard header information (such as `input_var_names`)
* Provide an `__init__` method. A Landlab grid object should be the first argument (after `self`). Any other necessary parameters should be given as keyword arguments with meaningful defaults. 
* Provide a `run_one_step` method. 
* Include external and internal documentation. If the component is included in the Landlab package (as opposed to being a separate add-on), it needs to have an entry in the API Reference Manual at landlab.csdms.io. (In most cases, the text on the website is autogenerated from the docstrings in the component itself, but the documentation files must still be updated by hand to refer to the new component, as described below.) The component code should include a header docstring that briefly describes what it is, and lists its input parameters.

In addition to these basic ingredients, we highly recommend that Landlab components also include the following:

* A docstring for each function. Docstrings should ideally include (1) a one-line description of what the component does, starting with a verb (e.g., "Update fields with current loading conditions"); (2) a list of parameters with their data types, units (if applicable), and a brief description; (3) data returned (if any); (4) one or more doctests; and (5) any relevant notes that will help your future self (or others) understand how the function works.
* Unit tests. These can be implemented either as built-in doctests, or as external tests, or both. 
* Tutorial(s). A Jupyter Notebook is a great way to illustrate how a component can be used. Notebooks that contain tutorials about various Landlab components are in the notebooks folder. Ideally, every component should have an accompanying tutorial (though as of this writing we have not yet reached that goal).

As part of an ongoing effort to standardize the Landlab component library, we will soon require the following additional characteristics. Not all Landlab components currently meet these requirements, but starting with an upcoming v2.0 release all components will be required to meet these standards. 

* The component may use `*kwds` at the end of the `__init__` but must raise an error if unused `kwds` are passed. 
* The `run_one_step` method must either have no arguments other than `self`, or have a single additional argument that represents the duration of the step.
* Class variables -- i.e., those defined as `self.[var_name]` in the code -- that are not meant to be seen or modified by users should ideally be flagged as private by adding a leading underscore to the variable name (this will be most of them!). Those that don't are considered public, and should be handled using the `@property` decorator as described below.


"""

"""
## Unit Testing

Testing is essential to writing robust scientific software (see, e.g., [The Turing Way guide to testing research code](https://book.the-turing-way.org/reproducible-research/testing.html)). A typical Landlab component includes two types of test: doctests and external tests.

Doctests, in addition to testing a particular piece of code, should also give users an idea of how the code works---in other words, it should function both as a test, and as an example of how to use the functionality in question. Docstrings, including doctests, are scraped automatically to create content in the [Landlab API Reference Manual](https://landlab.csdms.io).

External testing scripts normally live in a subdirectory called `tests` inside your component's main folder, in a file called `test_`(something)`.py`, with one or more functions whose names begin with `test_`. Using this naming convention is how the testing tool we use ([`pytest`](https://pytest.org/en/latest/)) is able to find and run your tests. 

### Useful tools for writing tests
The `numpy.testing` module provides handy functions for testing, such as asserting that the values in a particular array match the values that you expect. [`pytest`](https://pytest.org/en/latest/) provides the ability to test whether a particular error is raised with the [`pytest.raises`](https://docs.pytest.org/en/latest/reference.html?highlight=assert#pytest-raises) function. Nonetheless, in many cases the core Python libraries will suffice for testing: a test fails if any assertion fails and/or an error or exception is raised, and you can both `assert` logical conditions in tests and `raise` various [standard Python](https://docs.python.org/3/library/exceptions.html) or [Landlab-specific](https://landlab.csdms.io/generated/api/landlab.field.errors.html#landlab.field.errors.FieldError) exceptions within components "by hand".

If you use a common block of code (e.g., setting up a grid) in multiple test, we recommend looking into using a [`pytest.fixture`](https://docs.pytest.org/en/latest/reference.html?highlight=assert#pytest-fixture) to define it. 

If you want to write the same test but loop through multiple parameter values (e.g., use both `D8` and `MFD` flow directing), check out the [`pytest.parametrize`](https://docs.pytest.org/en/latest/reference.html?highlight=assert#pytest-mark-parametrize) function.

### How we use the tests as part of maintaining Landlab
If your component is part of the Landlab codebase (and not an external plugin), its tests will be run automatically whenever a pull request is made and we will enforce that they all pass before bringing the code into the main repository. 

But as part of your development, you might also want to run the tests locally. As of this writing, the Landlab Development Team uses the `pytest` utility, together with the `coverage` extension that calculates which lines of code are and are not covered by at least one test. An example of the command-line syntax to run tests is:

`pytest --doctest-modules --cov-report term-missing --cov=.`

This example usage tells pytest to run doctests as well as external tests, to examine the coverage of any files in the current directory or its subdirectories, and to display a report listing the coverage in each file.

### What parts of my should I write tests for? 
Best practice is to have your component 100% tested, meaning that every line gets run at least once. Not all of Landlab meets this standard (as of writing, total coverage is 87 %) and the following is what we find to be most practical. We recommend writing tests with small grids for which you can do all calculations by hand (typically 3x10, 5x5, or smaller).

* Any part of your code that has an analytical solution should get a test demonstrating that this solution is met.
* Barring an analytical solution, you should make a small grid and create a test that asserts that a known correct answer is met (e.g., run just one step forward, and calculate exactly what the end-of-run-one-step values are). 
* If there are places where you ensure something about an input (e.g., that porosity is positive), you should write a tests indicating that if the value is bad and an [`Error`](https://docs.python.org/3/library/exceptions.html) is `raised`. 
* Your tests don't need to be of the entire run-one-step process, but might just test critical parts of it. 

"""

"""
## Documentation

Each Landlab component ideally has three kinds of documentation: internal documentation using docstrings within the code, "external" documentation in the [Landlab API Reference Manual](https://landlab.csdms.io), and one or more tutorials in the notebooks folder. Internal and external documentation are essentially one and the same: the internal docstrings are read and formatted ("scraped") to produce the API Reference documentation for each component. To get a component's docstrings included in the API Reference, you simply need to create a short text file in Landlab's `docs` folder, and edit the `index.rst` file in the same folder to add a reference to your new file. The process is described in the User Guide section on [Developing Your Own Component](https://landlab.csdms.io/development/contribution/develop_a_component.html).
"""

"""
## Coding Tips and Tricks

### Avoid Hard-Coding Numbers

It can be tempting to include hard numbers in your code, such as:

```python
grav_force = 9.81 * mass
```

There are two disadvantages to this approach. An obvious one is that a user who wants to change the hard number is forced to edit the code (what if you want to run your model for Mars?). Another disadvantage is that the hard numbers are buried deep in the code, and might not be documented. Yet a third potential problem is that the hard-wired numbers may have units, and therefore rely on the assumption that any other inputs and variables have compatible units. And finally, your hardwired numbers may lack sufficient precision for a user's application (e.g., is gravitational acceleration 10.0 or 9.8 or 9.81?).

A better option is to have these numbers be user-determined inputs with built-in default values. For example,

```python
class MyCoolComponent(Component):
    ...
    def __init__(self, grid, grav_accel=9.8):
        ...
```

If for some reason this is not a practical option---for example, if the numerical value in question is truly a constant---then a good practice is to use "syntactic sugar": define a variable in ALLCAPS near the head of the file in question. For example,

```python
GRAV_CONSTANT = 6.67408e-11  # near head of file

...

grav_force = GRAV_CONSTANT * (mass1 * mass2 / distance**2)  # somewhere deep in the code
```

### Avoid Multiple `if` Sequences

Sometimes it is the nature of an algorithm to ask a lot of questions:

```python
if this:
    ...
elif that:
    ...
else:
    ...
```

Although this kind of construction can be hard to avoid in some cases, it also increases the testing burden: each case needs to be tested in order to ensure 100% coverage. They can also hamper performance, if the tests need to be repeated many times. If you find yourself writing long chains of conditional statements, consider whether there are any cleaner alternatives.

For example consider the following example. Say that `params` is a dictionary and you need to check if `spam` is in `params`, you need a boolean variable called `spam_in_params` that indicats whether it is present. You could write:

```python
if "spam" in params:
    spam_in_params = True
else:
    spam_in_params = False
```

You could acomplish the same thing with a cleaner alternative:

```python
spam_in_params = params.get("spam", False)
```

Very complex sets of if/else logic may be best dealt with using a dictionary as a lookup table. 


### Field Names

Landlab field names should be reasonably descriptive, while not being overly long. For example, `hydraulic_conductivity` is a better field name than simply `K`. As of this writing, Landlab has not yet adopted a standard naming convention (such as the CSDMS Standard Names, or the CF Standard Names), but best practice is to follow the *de facto* Landlab standards for names that already exist in at least one component. Landlab has tended thus far to use names that are in the spirit of (and sometimes identical to) the CSDMS Standard Names, while keeping these names to a manageable length.

An (infrequently updated) list of the standard names currently used in Landlab can be found [here](https://landlab.csdms.io/user_guide/field_definitions.html).

### Public and Private Variables

The following describes an emerging coding standard for component class variables to be adopted starting with Landlab 2.0:

Use the Python convention that class variables are "private" if their name begins with an underscore, and "public" if it does not. For internal variables that are not intended to be viewed or modified by users, make the variable private by prepending an underscore. Example:

```python
self._diffusivity = 0.01
```
For internal variables that you wish users to be able to read (only), make the internal variable private but provide a "getter" function that is tagged with the `@property` decorator. Example (from the Flexure component):

```python
@property
def youngs(self):
    """Young's modulus of lithosphere (Pa)."""
    return self._youngs
```

Including the "getter" function allows you to include documentation for the public variable in the form of a docstring.

If you want users to have both read and write access to a variable---for example, if you want a user to be able to dynamically change one of your parameters if needed---provide both a "getter" and a "setter". An example of a getter-setter pair is (also from Flexure):

```python
@property
def eet(self):
    """Effective elastic thickness (m)."""
    return self._eet

@eet.setter
def eet(self, new_val):
    if new_val <= 0:
        raise ValueError("Effective elastic thickness must be positive.")
    self._eet = new_val
    self._r = self._create_kei_func_grid(
       self._grid.shape, (self.grid.dy, self.grid.dx), self.alpha
    )
```

Using a setter function allows you to make sure that the user isn't giving an inappropriate value of the parameter (as in the example of a negative elastic thickness above, which would not make any sense). In general, think long and hard about giving users the ability to set variables. An update of a variable at the "wrong" time can easily lead to unforeseen consequences if some parts of the component have assumed the old value previously. Careful [testing](#unit-testing) is probably in order in these cases.

## Other references
Many of the landlab developers have found this [resource on python anti-patterns](https://docs.quantifiedcode.com/python-anti-patterns/) helpful. 
"""



================================================
File: docs/source/tutorials/making_components/making_components.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# How to write a Landlab component
"""

"""
This ipython notebook walks you through the basic procedure for writing a Landlab component, using the example of a kinematic-wave flow model.

## Overview
A Landlab component is implemented as a Python `class`. Although every Landlab component is unique in some respects, to be a component, a class must have at least the following standard ingredients:

(1) The class must inherit the base class `Component`.

(2) The class must include a set of standard variables defined in the header (i.e., before the `__init__` method), which describe the data arrays that the component uses.

(3) The class must have an `__init__` method defined, with a semi-standardized parameter list described below.

(4) The class must provide a function that does performs the component's "action", typically named `run_one_step()` and this function's parameter list must follow the convention described below.


## Class definition and header

A Landlab component is a class that inherits from `Component`. The name of the class should be in CamelCase, and should make sense when used in the sentence: "A *(component-name)* is a...". The class definition should be followed by a docstring. The docstring should include a list of parameters for the `__init__` method and succintly describe them.
"""

import numpy as np

from landlab import Component


class KinwaveOverlandFlowModel(Component):
    """
    Calculate water flow over topography.

    Landlab component that implements a two-dimensional
    kinematic wave model.

    You can put other information here... Anything you
    think a user might need to know. We use numpy style
    docstrings written in restructured text. You can use
    math formatting.

    Useful Links:
    - https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html
    - https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html

    Parameters
    ----------
    grid : ModelGrid
        A Landlab grid object.
    precip_rate : float, optional (defaults to 1 mm/hr)
        Precipitation rate, mm/hr
    precip_duration : float, optional (defaults to 1 hour)
        Duration of precipitation, hours
    infilt_rate : float, optional (defaults to 0)
        Maximum rate of infiltration, mm/hr
    roughnes : float, defaults to 0.01
        Manning roughness coefficient, s/m^1/3

    """

    def __init__():  # ignore this for now, we will add more stuff eventually.
        pass

"""
## Doc tests
"""

"""
The following docstring section 'Examples' should help the user understand what is the component's purpose and how it works. It is an example (or examples) of its use in a (more or less) simple case within the Landlab framework: a grid is created, the component is instantiated on this grid and run. Unlike in the example below, we strongly recommend commenting your example(s) to explain what is happening.

This is also the section that will be run during the integration tests of your component (once you have submitted a pull request to have your component merged into the Landlab release branch). All lines starting with >>> are run and should produce the results you provided: here, the test will fail if `kw.vel_coeff` does not return `100.0.`
"""

"""
Examples
--------
>>> from landlab import RasterModelGrid
>>> rg = RasterModelGrid((4, 5), 10.0)
>>> kw = KinwaveOverlandFlowModel(rg)
>>> kw.vel_coef
100.0
>>> rg.at_node['surface_water__depth']
array([ 0.,  0.,  0.,  0.,  0.,
        0.,  0.,  0.,  0.,  0.,
        0.,  0.,  0.,  0.,  0.,
        0.,  0.,  0.,  0.,  0.])
"""

"""
### Header information: `_name`
Every component should have a name, as a string. Normally this will be the same as the class name.
"""

_name = "KinwaveOverlandFlowModel"

"""
### Header information: `_unit_agnostic`

Components also indicate whether they are unit agnostic or not. Unit agnostic components require that component users are consistent with units within and across components used in a single application, but do not require that inputs conform to a specific set of units. 

This component is not unit agnostic because it includes an assumption that time units will be in hours but assumes that the Manning coefficient will be provided with time units of seconds. 
"""

_unit_agnostic = False

"""
### Header information: `_info`


All the metadata about the fields that a components requires and creates is described in a datastructured called `Component._info`. 

Info is a dictionary with one key for each field. The value associated with that key is a dictionary that must contain all of the following elements (and no other elements). 

* "dtype": a python data type
* "intent": a string indicating whether the field is an input ("in"), and output ("out"), or both ("inout")
* "optional": a boolean indicating whether the field is an optional input or output
* "units": a string indicating what units the field has (use "-")
* "mapping": a string indicating the grid element (e.g., node, cell) on which the field is located
* "doc": a string describing the field. 

The code in the Component base class will check things like:
* Can the component be created if all of the required inputs exist?
* Is all this information present? Is something extra present?
* Does the component create outputs of the correct dtype?
"""

_info = {
    "surface_water__depth": {
        "dtype": float,
        "intent": "out",
        "optional": False,
        "units": "m",
        "mapping": "node",
        "doc": "Depth of water on the surface",
    },
    "topographic__elevation": {
        "dtype": float,
        "intent": "in",
        "optional": False,
        "units": "m",
        "mapping": "node",
        "doc": "Land surface topographic elevation",
    },
    "topographic__gradient": {
        "dtype": float,
        "intent": "in",
        "optional": False,
        "units": "m/m",
        "mapping": "link",
        "doc": "Gradient of the ground surface",
    },
    "water__specific_discharge": {
        "dtype": float,
        "intent": "out",
        "optional": False,
        "units": "m2/s",
        "mapping": "link",
        "doc": "flow discharge component in the direction of the link",
    },
    "water__velocity": {
        "dtype": float,
        "intent": "out",
        "optional": False,
        "units": "m/s",
        "mapping": "link",
        "doc": "flow velocity component in the direction of the link",
    },
}

"""
### Class with complete header information
"""

from landlab import Component


class KinwaveOverlandFlowModel(Component):
    """
    Calculate water flow over topography.

    Landlab component that implements a two-dimensional
    kinematic wave model.

    Construction:

        KinwaveOverlandFlowModel(grid, [stuff to be added later])

    Parameters
    ----------
    grid : ModelGrid
        Landlab ModelGrid object
    precip_rate : float, optional (defaults to 1 mm/hr)
        Precipitation rate, mm/hr
    precip_duration : float, optional (defaults to 1 hour)
        Duration of precipitation, hours
    infilt_rate : float, optional (defaults to 0)
        Maximum rate of infiltration, mm/hr
    roughness : float, defaults to 0.01
        Manning roughness coefficient, s/m^1/3
    """

    _name = "KinwaveOverlandFlowModel"

    _unit_agnostic = False

    _info = {
        "surface_water__depth": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m",
            "mapping": "node",
            "doc": "Depth of water on the surface",
        },
        "topographic__elevation": {
            "dtype": float,
            "intent": "in",
            "optional": False,
            "units": "m",
            "mapping": "node",
            "doc": "Land surface topographic elevation",
        },
        "topographic__gradient": {
            "dtype": float,
            "intent": "in",
            "optional": False,
            "units": "m/m",
            "mapping": "link",
            "doc": "Gradient of the ground surface",
        },
        "water__specific_discharge": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m2/s",
            "mapping": "link",
            "doc": "flow discharge component in the direction of the link",
        },
        "water__velocity": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m/s",
            "mapping": "link",
            "doc": "flow velocity component in the direction of the link",
        },
    }

    def __init__():  # ignore this for now, we will add more stuff eventually.
        pass

"""
## The initialization method (`__init__`)
Every Landlab component should have an `__init__` method. The parameter signature should start with a `ModelGrid` object as the first parameter. Following this are component-specific parameters. In our example, the parameters for the kinematic wave model include: precipiation rate, precipitation duration, infiltration rate, and roughness coefficient (Manning's n).

The first thing the component `__init__` should do is call the `super` method. This calls the `__init__` of the component's base class. 

Two things a component `__init__` method common does are (1) store the component's parameters as class attributes, and (2) create the necessary fields. When creating grid fields, it is important to first check to see whether a field with the same name (and mapping) already exists. For example, a driver or another component might have already created `topographic__elevation` when our kinematic wave component is initialized.


"""

def __init__(
    self, grid, precip_rate=1.0, precip_duration=1.0, infilt_rate=0.0, roughness=0.01
):
    """Initialize the KinwaveOverlandFlowModel.

    Parameters
    ----------
    grid : ModelGrid
        Landlab ModelGrid object
    precip_rate : float, optional (defaults to 1 mm/hr)
        Precipitation rate, mm/hr
    precip_duration : float, optional (defaults to 1 hour)
        Duration of precipitation, hours
    infilt_rate : float, optional (defaults to 0)
        Maximum rate of infiltration, mm/hr
    roughness : float, defaults to 0.01
        Manning roughness coefficient, s/m^1/3
    """
    super().__init__(grid)

    # Store parameters and do unit conversion
    self._current_time = 0

    self._precip = precip_rate / 3600000.0  # convert to m/s
    self._precip_duration = precip_duration * 3600.0  # h->s
    self._infilt = infilt_rate / 3600000.0  # convert to m/s
    self._vel_coef = 1.0 / roughness  # do division now to save time

    # Create fields...
    #   Elevation
    self._elev = grid.at_node["topographic__elevation"]

    #   Slope
    self._slope = grid.at_link["topographic__gradient"]

    self.initialize_output_fields()
    self._depth = grid.at_node["surface_water__depth"]
    self._vel = grid.at_link["water__velocity"]
    self._disch = grid.at_link["water__specific_discharge"]

    # Calculate the ground-surface slope (assume it won't change)
    self._slope[self._grid.active_links] = self._grid.calc_grad_at_link(self._elev)[
        self._grid.active_links
    ]
    self._sqrt_slope = np.sqrt(self._slope)
    self._sign_slope = np.sign(self._slope)

"""
## The "go" method, `run_one_step()`
Every Landlab component will have a method that implements the component's action. The go method can have any name you like, but the preferred practice for time-advancing components is to use the standard name `run_one_step()`. Landlab assumes that if a component has a method with this name, it will (a) be the primary "go" method, and (b) will be fully standardized as described here.

The `run_one_step` method should take either zero or one argument. If there is an argument, it should be a duration to run, `dt`; i.e., a timestep length. If the component does not evolve as time passes, this argument may be missing (see, e.g., the FlowRouter, which returns a steady state flow pattern independent of time).

The first step in the algorithm in the example below is to calculate water depth *at the links*, where we will be calculating the water discharge. In this particular case, we'll use the depth at the upslope of the two nodes. The grid method to do this, `map_value_at_max_node_to_link`, is one of many mapping functions available.

We then calculate velocity using the Manning equation, and specific discharge by multiplying velocity by depth.

Mass balance for the cells around nodes is computed using the `calc_flux_div_at_node` grid method.
"""

def run_one_step(self, dt):
    """Calculate water flow for a time period `dt`.

    Default units for dt are *seconds*.
    """
    # Calculate water depth at links. This implements an "upwind" scheme
    # in which water depth at the links is the depth at the higher of the
    # two nodes.
    H_link = self._grid.map_value_at_max_node_to_link(
        "topographic__elevation", "surface_water__depth"
    )

    # Calculate velocity using the Manning equation.
    self._vel = -self._sign_slope * self._vel_coef * H_link**0.66667 * self._sqrt_slope

    # Calculate discharge
    self._disch = H_link * self._vel

    # Flux divergence
    dqda = self._grid.calc_flux_div_at_node(self._disch)

    # Rate of change of water depth
    if self._current_time < self._precip_duration:
        ppt = self._precip
    else:
        ppt = 0.0
    dHdt = ppt - self._infilt - dqda

    # Update water depth: simple forward Euler scheme
    self._depth[self._grid.core_nodes] += dHdt[self._grid.core_nodes] * dt

    # Very crude numerical hack: prevent negative water depth
    self._depth[np.where(self._depth < 0.0)[0]] = 0.0

    self._current_time += dt

"""
## Changes to boundary conditions
"""

"""
Sometimes, (though not in this example), it proves convenient to hard-code assumptions about boundary conditions into the `__init__` method. 

We can resolve this issue by creating an additional component method that updates these components that can be called if the boundary conditions change. Whether the boundary conditions have changed can be assessed with a grid method called `bc_set_code`. This is an `int` which will change if the boundary conditions change.
"""

def __init__(self, grid):
    """Initialize the Component.
    ...
    """
    super().__init__(grid)

    # Store grid and parameters and do unit conversion
    self._bc_set_code = self._grid.bc_set_code
    # ...


def updated_boundary_conditions(self):
    """Call if boundary conditions are updated."""
    # do things necessary if BCs are updated.


def run_one_step(self, dt):
    """Calculate water flow for a time period `dt`."""
    if self._bc_set_code != self.grid.bc_set_code:
        self.updated_boundary_conditions()
        self._bc_set_code = self.grid.bc_set_code
    # Do rest of run one step
    # ...

"""
## The complete component
"""

from landlab import Component


class KinwaveOverlandFlowModel(Component):
    """Calculate water flow over topography.

    Landlab component that implements a two-dimensional
    kinematic wave model. This is an extremely simple, unsophisticated
    model, originally built simply to demonstrate the component creation
    process. Limitations to the present version include: infiltration is
    handled very crudely, the called is responsible for picking a stable
    time step size (no adaptive time stepping is used in the `run_one_step`
    method), precipitation rate is constant for a given duration (then zero),
    and all parameters are uniform in space. Also, the terrain is assumed
    to be stable over time. Caveat emptor!

    Examples
    --------
    >>> from landlab import RasterModelGrid
    >>> rg = RasterModelGrid((4, 5), xy_spacing=10.0)
    >>> z = rg.add_zeros("topographic__elevation", at="node")
    >>> s = rg.add_zeros("topographic__gradient", at="link")
    >>> kw = KinwaveOverlandFlowModel(rg)
    >>> kw.vel_coef
    100.0
    >>> rg.at_node['surface_water__depth']
    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
            0.,  0.,  0.,  0.,  0.,  0.,  0.])
    """

    _name = "KinwaveOverlandFlowModel"

    _unit_agnostic = False

    _info = {
        "surface_water__depth": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m",
            "mapping": "node",
            "doc": "Depth of water on the surface",
        },
        "topographic__elevation": {
            "dtype": float,
            "intent": "in",
            "optional": False,
            "units": "m",
            "mapping": "node",
            "doc": "Land surface topographic elevation",
        },
        "topographic__gradient": {
            "dtype": float,
            "intent": "in",
            "optional": False,
            "units": "m/m",
            "mapping": "link",
            "doc": "Gradient of the ground surface",
        },
        "water__specific_discharge": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m2/s",
            "mapping": "link",
            "doc": "flow discharge component in the direction of the link",
        },
        "water__velocity": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m/s",
            "mapping": "link",
            "doc": "flow velocity component in the direction of the link",
        },
    }

    def __init__(
        self,
        grid,
        precip_rate=1.0,
        precip_duration=1.0,
        infilt_rate=0.0,
        roughness=0.01,
    ):
        """Initialize the KinwaveOverlandFlowModel.

        Parameters
        ----------
        grid : ModelGrid
            Landlab ModelGrid object
        precip_rate : float, optional (defaults to 1 mm/hr)
            Precipitation rate, mm/hr
        precip_duration : float, optional (defaults to 1 hour)
            Duration of precipitation, hours
        infilt_rate : float, optional (defaults to 0)
            Maximum rate of infiltration, mm/hr
        roughness : float, defaults to 0.01
            Manning roughness coefficient, s/m^1/3
        """
        super().__init__(grid)

        # Store parameters and do unit conversion
        self._current_time = 0

        self._precip = precip_rate / 3600000.0  # convert to m/s
        self._precip_duration = precip_duration * 3600.0  # h->s
        self._infilt = infilt_rate / 3600000.0  # convert to m/s
        self._vel_coef = 1.0 / roughness  # do division now to save time

        # Create fields...
        #   Elevation
        self._elev = grid.at_node["topographic__elevation"]

        #   Slope
        self._slope = grid.at_link["topographic__gradient"]

        self.initialize_output_fields()
        self._depth = grid.at_node["surface_water__depth"]
        self._vel = grid.at_link["water__velocity"]
        self._disch = grid.at_link["water__specific_discharge"]

        # Calculate the ground-surface slope (assume it won't change)
        self._slope[self._grid.active_links] = self._grid.calc_grad_at_link(self._elev)[
            self._grid.active_links
        ]
        self._sqrt_slope = np.sqrt(self._slope)
        self._sign_slope = np.sign(self._slope)

    @property
    def vel_coef(self):
        """Velocity coefficient.

        (1/roughness)
        """
        return self._vel_coef

    def run_one_step(self, dt):
        """Calculate water flow for a time period `dt`.

        Default units for dt are *seconds*.
        """
        # Calculate water depth at links. This implements an "upwind" scheme
        # in which water depth at the links is the depth at the higher of the
        # two nodes.
        H_link = self._grid.map_value_at_max_node_to_link(
            "topographic__elevation", "surface_water__depth"
        )

        # Calculate velocity using the Manning equation.
        self._vel = (
            -self._sign_slope * self._vel_coef * H_link**0.66667 * self._sqrt_slope
        )

        # Calculate discharge
        self._disch[:] = H_link * self._vel

        # Flux divergence
        dqda = self._grid.calc_flux_div_at_node(self._disch)

        # Rate of change of water depth
        if self._current_time < self._precip_duration:
            ppt = self._precip
        else:
            ppt = 0.0
        dHdt = ppt - self._infilt - dqda

        # Update water depth: simple forward Euler scheme
        self._depth[self._grid.core_nodes] += dHdt[self._grid.core_nodes] * dt

        # Very crude numerical hack: prevent negative water depth
        self._depth[np.where(self._depth < 0.0)[0]] = 0.0

        self._current_time += dt

from landlab import RasterModelGrid

nr = 3
nc = 4
rg = RasterModelGrid((nr, nc), 10.0)
rg.add_empty("topographic__elevation", at="node")
rg.add_zeros("topographic__gradient", at="link")
rg.at_node["topographic__elevation"][:] = rg.x_of_node.copy()
kinflow = KinwaveOverlandFlowModel(rg, precip_rate=100.0, precip_duration=100.0)

for i in range(100):
    kinflow.run_one_step(1.0)
print("The discharge from node 6 to node 5 should be -0.000278 m2/s:")
print(rg.at_link["water__specific_discharge"][8])
print("The discharge from node 5 to node 4 should be -0.000556 m2/s:")
print(rg.at_link["water__specific_discharge"][7])

"""
Next, we'll test the component on a larger grid and a larger domain.
"""

nr = 62
nc = 42
rg = RasterModelGrid((nr, nc), 10.0)
rg.add_empty("topographic__elevation", at="node")
rg.at_node["topographic__elevation"] = 0.01 * rg.y_of_node
rg.add_zeros("topographic__gradient", at="link")
kinflow = KinwaveOverlandFlowModel(rg, precip_rate=100.0, precip_duration=100.0)
for i in range(1800):
    kinflow.run_one_step(1.0)

"""
Plot the topography:
"""

%matplotlib inline
from landlab.plot import imshow_grid

imshow_grid(rg, "topographic__elevation")

"""
The steady solution should be as follows. The unit discharge at the bottom edge should equal the precipitation rate, 100 mm/hr, times the slope length.

The slope length is the distance from the bottom edge of the bottom-most row of cells, to the top edge of the top-most row of cells. The base row of nodes are at y = 0, and the cell edges start half a cell width up from that, so y = 5 m. The top of the upper-most row of cells is half a cell width below the top grid edge, which is 610 m, so the top of the cells is 605 m. Hence the interior (cell) portion of the grid is 600 m long.

Hence, discharge out the bottom should be 100 mm/hr x 600 m = 0.1 m/hr x 600 m = 60 m2/hr. Let's convert this to m2/s:
"""

q_out = 0.1 * 600 / 3600.0
q_out

"""
The water depth should be just sufficient to carry this discharge with the given slope and roughness. We get this by inverting the Manning equation:

$$q = (1/n) H^{5/3} S^{1/2}$$

$$H^{5/3} = n q S^{-1/2}$$

$$H = (n q)^{3/5} S^{-3/10}$$

The slope gradient is 0.01 (because we set elevation to be 0.01 times the y coordinate). The discharge, as we've already established, is about 0.0167 m2/s, and the roughness is 0.01 (the default value). Therefore,
"""

n = 0.01
q = 0.0167
S = 0.01
H_out = (n * q) ** 0.6 * S**-0.3
H_out

imshow_grid(rg, "surface_water__depth", cmap="Blues")

"""
This looks pretty good. Let's check the values:
"""

rg.at_node["surface_water__depth"][42:84]  # bottom row of core nodes

"""
We see that the depth agrees with the analytical solution to within three decimal places: not bad. Ideally, we would build the above tests into the component as doctests or unit tests. We could also test the transient solutions: rising hydrograph, falling hydrograph. Finally, we haven't tested all the ingredients; for example, we haven't tested what happens when infiltration rate is greater than zero.

Nonetheless, the above example illustrates the basics of component-making. A great next step would be to create a unit test based on this example.
"""



================================================
File: docs/source/tutorials/mappers/mappers.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Mapping values between grid elements

Imagine that you're using Landlab to write a model of shallow water flow over terrain. A natural approach is to place your scalar fields, such as water depth, at the nodes. You then place your vector fields, such as water surface gradient, flow velocity, and discharge, at the links. But your velocity depends on both slope and depth, which means you need to know the depth at the links too. How do you do this?

This tutorial introduces *mappers*: grid functions that map quantities defined on one set of elements (such as nodes) onto another set of elements (such as links). As you'll see, there are a variety of mappers available.


"""

"""
## Mapping from nodes to links

For the sake of example, we'll start with a simple 3-row by 4-column raster grid. The grid will contain a scalar field called `water__depth`, abbreviated `h`. We'll populate it with some example values, as follows:
"""

import numpy as np

from landlab import RasterModelGrid

mg = RasterModelGrid((3, 4), xy_spacing=100.0)
h = mg.add_zeros("surface_water__depth", at="node")
h[:] = 7 - np.abs(6 - np.arange(12))

"""
For the sake of visualizing values at nodes on our grid, we'll define a handy little function:
"""

def show_node_values(mg, u):
    for r in range(mg.number_of_node_rows - 1, -1, -1):
        for c in range(mg.number_of_node_columns):
            print(int(u[c + (mg.number_of_node_columns * r)]), end=" ")
        print()

show_node_values(mg, h)

"""
Let's review the numbering of nodes and links. The lines below will print a list that shows, for each link ID, the IDs of the nodes at the link's tail and head:
"""

for i in range(mg.number_of_links):
    print(i, mg.node_at_link_tail[i], mg.node_at_link_head[i])

"""
### Finding the mean value between two nodes on a link

Suppose we want to have a *link-based* array, called *h_edge*, that contains water depth at locations between adjacent pairs of nodes. For each link, we'll simply take the average of the depth at the link's two nodes. To accomplish this, we can use the `map_mean_of_link_nodes_to_link` grid method. At link 8, for example, we'll average the *h* values at nodes 5 and 6, which should give us a depth of (6 + 7) / 2 = 6.5:
"""

h_edge = mg.map_mean_of_link_nodes_to_link("surface_water__depth")
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
### What's in a name?

The mapping functions have long names, which are designed to make it as clear as possible to understand what each function does. All the mappers start with the verb *map*. Then the relationship is given; in this case, we are looking at the *mean*. Then the elements from which a quantity is being mapped: we are taking values from *link nodes*. Finally, the element to which the new values apply: *link*.

### Mapping minimum or maximum values

We can also map the minimum value of *h*:
"""

h_edge = mg.map_min_of_link_nodes_to_link("surface_water__depth")
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
... or the maximum:
"""

h_edge = mg.map_max_of_link_nodes_to_link("surface_water__depth")
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
### Upwind and downwind

Numerical schemes often use *upwind differencing* or *downwind differencing*. For example, finite difference schemes for equations that include advection may use "upwind" rather than centered differences, in which a scalar quantity (our *h* for example) is taken from whichever side is upstream in the flow field.

How do we know the flow direction? If the flow is driven by the gradient in some scalar field, such as pressure or elevation, one approach is to look at the values of this scalar on either end of the link: the end with the higher value is upwind, and the end with the lower value is downwind.

Suppose for example that our water flow is driven by the water-surface slope (which is often a good approximation for the *energy slope*, though it omits the kinetic energy). Let's define a bed-surface elevation field *z*:
"""

z = mg.add_zeros("topographic__elevation", at="node")
z[:] = 16 - np.abs(7 - np.arange(12))
show_node_values(mg, z)

"""
The water-surface elevation is then the sum of *h* and *z*:
"""

w = z + h
show_node_values(mg, w)

"""
For every link, we can assign the value of *h* from whichever end of the link has the greater *w*:
"""

h_edge = mg.map_value_at_max_node_to_link(w, h)
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
Consider the middle two nodes (5 and 6). Node 6 is higher (22 versus 20). Therefore, the link between them (link 8) should be assigned the value of *h* at node 6. This value happens to be 7.0.

Of course, we could also take the value from the *lower* of the two nodes, which gives link 8 a value of 6.0:
"""

h_edge = mg.map_value_at_min_node_to_link(w, h)
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
### Heads or tails?

It is also possible to map the scalar quantity at either the head node or the tail node to the link:
"""

h_edge = mg.map_link_head_node_to_link("surface_water__depth")
for i in range(mg.number_of_links):
    print(i, h_edge[i])

h_edge = mg.map_link_tail_node_to_link("surface_water__depth")
for i in range(mg.number_of_links):
    print(i, h_edge[i])

"""
### Simple example using centered water depth
The following implements one time-step of a linear-viscous flow model, in which flow velocity is calculated at the links, and the depth at each link is taken as the mean of depth at the two bounding nodes. To make the flow a little tamer, we'll have our fluid be hot, low viscosity basaltic lava instead of water, with a dynamic viscosity of 100 Pa s.
"""

gamma = 25000.0  # unit weight of fluid, N/m2
viscosity = 100.0  # dynamic viscosity in Pa s
grad = mg.calc_grad_at_link(w)
h_edge = mg.map_mean_of_link_nodes_to_link(h)
vel = -(gamma / (3.0 * viscosity)) * h_edge * h_edge * grad
for ln in range(mg.number_of_links):
    print(ln, h_edge[ln], grad[ln], vel[ln])

"""
I'm not sure I love the idea of a 5-m thick lava flow moving at over 100 m/s! (I guess we can take some comfort from the thought that turbulence would probably slow it down)

How different would the numerical solution be using an upwind scheme for flow depth? Let's find out:
"""

h_edge = mg.map_value_at_max_node_to_link(w, h)
vel = -(gamma / (3.0 * viscosity)) * h_edge * h_edge * grad
for ln in range(mg.number_of_links):
    print(ln, h_edge[ln], grad[ln], vel[ln])

"""
Even scarier.

In any event, this example illustrates how you can use Landlab's mapping functions to build mass-conservation models in which the flow rate depends on a gradient and a scalar, both of which can be evaluated at links.
"""



================================================
File: docs/source/tutorials/marine_sediment_transport/simple_submarine_diffuser_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab SimpleSubmarineDiffuser component

This tutorial demonstrates how to use the `SimpleSubmarineDiffuser` component. `SimpleSubmarineDiffuser` models submarine sediment transport using a diffusion approach, in which the diffusivity varies with water depth. The component sets diffusivity to a (nearly) constant value between sea level and the wave-base depth, and to a value that declines exponentially with depth below the wave base. (The diffusivity on land, meaning locations with an elevation above current sea level, is set to an arbitrarily tiny positive value).
"""

"""
## Theory

The mathematics behind `SimpleSubmarineDiffuser` are as follows. The component represents a discretized numerical solution to the PDE:

$$\frac{\partial \eta}{\partial t} = -\nabla \cdot \mathbf{q_s}$$

$$\mathbf{q_s} = -D(h) \nabla\eta$$

where $\eta$ is surface height, $t$ is time, $\mathbf{q_s}$ is volume sediment transport rate per unit width (in terms of bulk volume, i.e., it incorporates porosity), and $D(h)$ is the transport coefficient (a.k.a., diffusivity) that varies with local water depth $h$.

First we define the applied shallow-water diffusivity, $D_s$, in terms of the local water depth $h$ and tidal range $R_t$. If $R_t = 0$, then $D_s$ is uniform where $h \ge 0$ (i.e., underwater), and negligibly tiny elsewhere (i.e., on land). If $R_t > 0$, then a smoothing function is used to allow the applied diffusivity to increase smoothly from a negligibly small value on land (above ~2x high tide) to its base value, $D_{s0}$ (which is the input parameter `shallow_water_diffusivity`) below ~2x low-tide elevation:

$$D_s = (\tanh ( -h / R_t ) + 1) / 2$$

With this equation, $D_s \approx 0.02 D_{s0}$ at twice the high-tide height, and $D_s \approx 0.98 D_{s0}$ at twice the low-tide depth. The basic idea is to account in a simple way for tidal variations.

Within the wave zone, $D = D_s$ (which is to say, it is essentially constant except right around mean sea level). Below the wave-base depth, $h_{wb}$, the diffusivity decreases exponentially:

$$D = \begin{cases}
  D_s &\mbox{where } h > h_{wb} \\
  D_s \exp ( -(h - h_{wb}) / h_{wb} ) & \mbox{where } h \ge h_{wb} \end{cases}$$

"""

"""
## Numerical implementation

`SimpleSubmarineDiffuser` uses a forward-in-time, finite-volume method. It is the same method that the `LinearDiffuser` component uses, because in fact `SimpleSubmarineDiffuser` uses the solver of `LinearDiffuser`. The component is implemented as a class that derives directly from the `LinearDiffuser` class. The `run_one_step()` method of `SimpleSubmarineDiffuser` simply updates the current water depth (given sea level and topography), calculates the diffusivity coefficient, and then calls the `run_one_step()` method for the `LinearDiffuser` to perform the mass balance.

### Technical notes

- To avoid divide-by-zero errors, a tiny positive diffusivity (currently 10$^{-20}$ m$^2$/y) is assigned to nodes on land (or more precisely, added to any additional diffusivity that arises from the tanh function; see above).

- The component assigns diffusivity values to *nodes*, but the `LinearDiffuser` component then translates these to *links*. It maps diffusivity from nodes to links by using the *maximum* value of diffusivity of the nodes bounding each link. This means in practice that links that cross the shoreline will tend to have a higher diffusivity than the equations outlined above might suggest. In future, this could be addressed by modifying `LinearDiffuser` (which, however, could be a compatibility-breaking change unless handled as a user option), or by encoding the solver directly in `SimpleSubmarineDiffuser` as opposed to borrowing the solver of `LinearDiffuser`. 

"""

"""
## Examples

### Example 1: Quasi-1D

The first example uses a quasi-1D setup to represent an initial topography with a triangular cross-section. 
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid
from landlab.components import SimpleSubmarineDiffuser

grid = RasterModelGrid((3, 51))  # grid has just one row of core nodes

# Close top and bottom boundaries
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# We're required to create a topographic__elevation field at nodes
z = grid.add_zeros("topographic__elevation", at="node")

# Here's our triangular island...
z[:] = (25.0 - np.abs(grid.x_of_node - 25.0)) - 15.0

# ...with a flat seabed at 5 m depth
z[z < -5.0] = -5.0

# We'll keep a copy of the starting elevation for later comparison
z0 = z.copy()

# And we'll create a field to track cumulative deposition
cum_depo = grid.add_zeros("cumulative_deposit__thickness", at="node")

xm = grid.x_of_node[51:102]
zm = z[51:102]
plt.plot(xm, zm, "k")
plt.plot([0, 50], [0, 0], "b:")  # add sea level
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

# Instantiate the component
# (note 1 m2/y is a pretty small diffusivity; just for testing here)
ssd = SimpleSubmarineDiffuser(
    grid, sea_level=0.0, wave_base=1.0, shallow_water_diffusivity=1.0
)

for i in range(500):
    ssd.run_one_step(0.2)
    cum_depo += grid.at_node["sediment_deposit__thickness"]

xm = grid.x_of_node[51:102]
zm = z[51:102]
plt.plot(xm, z0[51:102], "k")
cum_depo[cum_depo < 0.0] = 0.0
plt.plot(xm, zm)
plt.plot([0, 50], [0, 0], "b:")
plt.grid(True)
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

plt.fill(xm, cum_depo[51:102] - 5.0, "y")
plt.xlabel("Distance (m)")
plt.ylabel("Sediment thickness (m)")
plt.ylim([-5, 10])

"""
### Example 2: a conical island

The second example is much like the first, but now in 2D using a cone as the initial topography.
"""

grid = RasterModelGrid((51, 51))
z = grid.add_zeros("topographic__elevation", at="node")
midpoint = 25.0

# Here we create the cone shape, again with a floor at 5 m depth
dx = np.abs(grid.x_of_node - midpoint)
dy = np.abs(grid.y_of_node - midpoint)
ds = np.sqrt(dx * dx + dy * dy)
z[:] = (midpoint - ds) - 15.0
z[z < -5.0] = -5.0

cum_depo = grid.add_zeros("total_deposit__thickness", at="node")

grid.imshow(z, cmap="coolwarm", vmin=-10)

# Here's a pointillistic side view
plt.plot(grid.x_of_node, z, ".")
plt.plot([0, 50], [0, 0], "b:")
plt.grid(True)
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

ssd = SimpleSubmarineDiffuser(
    grid, sea_level=0.0, wave_base=1.0, shallow_water_diffusivity=1.0
)

for i in range(100):
    ssd.run_one_step(0.2)
    cum_depo += grid.at_node["sediment_deposit__thickness"]

grid.imshow(z, cmap="coolwarm", vmin=-10)

plt.plot(grid.x_of_node, z, ".")
plt.plot([0, 50], [0, 0], "b:")
plt.grid(True)
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")

# Show the donut-shaped deposit and associated erosion pattern
grid.imshow(cum_depo)

# And show that mass balances (the sum is basically zero, apart
# from a tiny roundoff error)
print(np.sum(cum_depo))



================================================
File: docs/source/tutorials/mass_wasting_runout/landslide_runout_animation.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Landslide Runout Animation

**Simulate the runout extent, sediment transport and topographic change caused by the retrogressive enlargement of a landslide scar in the Cascade Mountains, WA, USA**
"""

"""
In this tutorial, the user models the runout of a landslide that occurred near Mt. St. Helens in Washington State in December of 2021. The landslide was associated with the retrogressive enlargement of an existing landslide scar. The existing landslide scar formed during a much larger landslide in 2009. The 2021 enlargement failed along the upper edge of the 2009 scar and ranout down the center of the 2009 runout path. It intersected the S-1000, a forest road recently reconstructed below the landslide and another forest road below it before coming to rest at a river valley at the base of the slope. 

To model the landslide runout caused by the 2021 enlargement, the user loads a DEM, recorded after te 2009 landslide but before the 2021 enlargement, the mapped extent of the enlargement, defines the failure depth and parameterizes MassWastingRunout (MWR) to match observed runout extent, erosion and deposition caused by the enlargement. At the end of the notebook, a DEM-of-Difference (DoD) of the modeled runout is visually compared with a DoD of the observed runout.
"""

"""
<div>
<img src = "attachment:LandslideRunoutNotebookIntroImage-2.png" width="1350"/>
<div>
"""

"""
## Model overview
- MWR models the downslope progression of mass wasting processes such as debris flows or dry debris avalanches.

- Mass continuity is central to model conceptualization; at any node, the incoming flux (q_I), erosion (E) and aggradation (A) determine outgoing flux (q_O) and ultimately the runout extent and how the landscape evolves. 

<div>
<img src = "attachment:image-2.png" width="200"/>
<div>    

- MWR uses a set of rules and algorithms to numerically represent the release of the mass wasting source material and erosion, deposition and vegetation/debris impacts on the runout process as illustrated below:
"""

"""
<div>
<img src = "attachment:mass_continuity_v7.jpg" width="350"/>
<div>
"""

"""
<strong><em>(a)</em></strong> Release of the initial mass wasting source material nodes (represented by red cells); <strong><em>(b)</em></strong> How q_O at node n (n = 45) is distributed downslope after incoming material q_I (here equal to flux from node 51) has aggraded (A) or eroded (E) node n; <strong><em>(c)</em></strong> Mass continuity determines the change in regolith thickness/topographic elevation. For a full description of the above parameters, see Keck et al. (2024). 
"""

"""
**To begin, first import  packages and components necessary to load MWR inputs, run MWR and visualize model results.**
"""

import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np

from landlab.components import (
    DepressionFinderAndRouter,
    FlowAccumulator,
    FlowDirectorMFD,
)
from landlab.components.mass_wasting_runout import MassWastingRunout
from landlab.io import esri_ascii

"""
**Next, define key MWR parameters S_c, q_c and k and attributes to be tracked by the model.**

In MWR, S_c is a critical slope constraint. For some flows, it may be possible to approximate S_c from the surface slope of observed deposits. The parameter q_c is the threshold flux for deposition, that conceptually represents the flow depth below which flow resistance is large enough to cease the forward momentum of the flow, whether in the form of frictional resistance along the base of the flow or debris and vegetation in the path of the flow. Parameter k scales the erosion rate.<br>

Calibration may be required to determine single values of S_c and q_c that parameterize MWR to a site while other model parameters can be determined directly from a site. For this example, we provide S_c and q_c parameter values determined from the MWR calibration utility, a separate program that tunes MWR modeled runout to match observed runout extent, deposition and erosion patterns. A future notebook will detail how MWR can be calibrated using the MWR calibrator utility.
"""

# Model parameters, determined through calibration using the MWR Calibrator utility
S_c = [0.156]
q_c = 0.766  # m

# Model parameters, determined from field and DoD
k = 0.0337443
typical_flow_thickness_of_erosion_zone = 2  # m
typical_slope_of_erosion_zone = 0.25
max_flow_depth_observed_in_field = 5  # m
Dp = 0.316  # m

# regolith and runout material attributes that will be tracked
tracked_attributes = ["particle__diameter"]

"""
**Next, define the initial model terrain and lanslide location and depth.**

To initiate MWR, the user needs to provide an initial DEM, a regolith depth map and the location and depth of the mass wasting source material (e.g., landslide body). In this example, the required inputs have been prepared using an external GIS system. The initial DEM was created after the 2009 landslide but before the 2021 enlargement. Regolith depth is assumed uniform and equal to 1.2 meters. The depth of the landslide was estimated by subtracting a DEM recorded after the 2021 failure from the initial DEM. The landslide polygon was mapped from airphotos of the 2021 landslide and converted to a gridded representation. The number of rows, number of columns and grid size (10 meter) of each input is the same and all are loaded as fields onto a Landlab raster model grid. Below we load each and add them as fields to a raster model grid. We also load a high-resolution hillshade of the model domain that will be used for visualizing model results.
"""

# GIS generated inputs
DEM_pre = "pre_runout_DEM.asc"
DEM_pre_hs = "pre_runout_DEM_hillshade.asc"  # high (2-meter resolution)
lsnodes = "landslide_polygon.asc"  # nodes within the mapped landslide
DoDo = "DEM_of_Difference.asc"  # observed DEM of difference
ls_depth = "landslide_depth.asc"  # measured depth at each node

# dem
with open(DEM_pre) as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")
z = mg.at_node["topographic__elevation"]

# ls nodes
with open(lsnodes) as fp:
    esri_ascii.load(fp, name="mass__wasting_id", at="node", out=mg)
mg.at_node["mass__wasting_id"] = mg.at_node["mass__wasting_id"].astype(int)

# observed DoD
with open(DoDo) as fp:
    esri_ascii.load(fp, name="dem_dif_o", at="node", out=mg)

# change null values to zero
mg.at_node["dem_dif_o"][mg.at_node["dem_dif_o"] == -9999] = 0

# create a modeled DoD field, to be updated later to show animation of modeled DoD
mg.at_node["dem_dif_m"] = np.zeros(mg.number_of_nodes)

# soil depth
# here using uniform depth of 1.2 meters
depth = np.ones(mg.number_of_nodes) * 1.2
mg.add_field("soil__thickness", depth, at="node")

# set landslide thickness (depth) equal to measured depth from DEM of Difference
with open(ls_depth) as fp:
    esri_ascii.load(fp, name="ls_depth", at="node", out=mg)

lsd = mg.at_node.pop("ls_depth")
lsd = lsd[lsd != -9999]
mg.at_node["soil__thickness"][mg.at_node["mass__wasting_id"] == 1] = -1 * lsd

# high res hillshade for plot background
with open(DEM_pre_hs) as fp:
    mg_hs = esri_ascii.load(fp, name="hillshade_arc", at="node")
mg_hs.at_node["hillshade_arc"][mg_hs.at_node["hillshade_arc"] == -9999] = np.nan

# finds lowest point in dem and sets it as an open node

mg.set_watershed_boundary_condition(z)

# add particle diameter
# representative grain size of regolith
mg.at_node["particle__diameter"] = np.ones(len(mg.node_x)) * Dp

# flow accumulater to get contributing area to each grid cell. We initially use the FlowDirectorD8 option
# to visualize topographic slope but will replace the flow router with the MFD option later in this notebook
# because MWR uses the multi-directional slope.
fa = FlowAccumulator(mg, "topographic__elevation", flow_director="FlowDirectorD8")
fa.run_one_step()

# fill depressions to correct surface area determination
df_4 = DepressionFinderAndRouter(mg)
df_4.map_depressions()

# save a copy of the initial elevation for dem differencing
_ = mg.add_field(
    "topographic__initial_elevation",
    mg.at_node["topographic__elevation"],
    at="node",
    copy=True,
)

"""
**Before we instantiate and run the model, lets visualize some of the loaded inputs to get a feel for the landslide geometry relative to the terrain.**
"""

"""
First we need to define a few functions for visualizing model results.<br>
These functions are only included in this notebook for visualization and are not necessary to run the model.
"""

def plot_node_field_with_shaded_high_res_dem(
    mg,
    mg_hs,
    field,
    save_name=None,
    plot_name=None,
    figsize=(7, 7),
    cmap="terrain",
    fontsize=10,
    alpha=0.5,
    cbr=None,
    norm=None,
    allow_colorbar=True,
    colorbar_label=None,
    var_name=None,
    var_units=None,
    domain_buffer=0,
    **kwds,
):
    if plot_name is None:
        plt.figure(field, figsize=figsize)
    else:
        plt.figure(plot_name, figsize=figsize)

    mg_hs.imshow(
        "hillshade_arc",
        cmap="Greys_r",
        grid_units=("coordinates", "coordinates"),
        shrink=0.75,
        var_name=None,
        var_units=None,
        output=None,
        allow_colorbar=False,
        color_for_background="white",
        color_for_closed="white",
        limits=(0, 360),
    )
    mg.imshow(
        field,
        cmap=cmap,
        grid_units=("coordinates", "coordinates"),
        shrink=0.75,
        var_name=var_name,
        var_units=var_units,
        alpha=alpha,
        output=None,
        color_for_closed=None,
        color_for_background=None,
        norm=norm,
        allow_colorbar=allow_colorbar,
        colorbar_label=colorbar_label,
    )

    plt.xlim(
        [
            mg.x_of_node[mg.core_nodes].min() - 20,
            mg.x_of_node[mg.core_nodes].max() + domain_buffer,
        ]
    )
    plt.ylim(
        [
            mg.y_of_node[mg.core_nodes].min() - 20,
            mg.y_of_node[mg.core_nodes].max() + domain_buffer,
        ]
    )

    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    if cbr is None:
        r_values = mg.at_node[field][mg.core_nodes]
        plt.clim(r_values.min(), r_values.max())
    else:
        plt.clim(cbr[0], cbr[1])

    if save_name is not None:
        plt.savefig(save_name + ".png", dpi=300, bbox_inches="tight")


def get_values_xy(grid, field):
    # convert grid array to input for pcolormesh (from imshow_grid)
    values = grid.at_node[field]
    values = values.reshape(grid.shape)
    y = (
        np.arange(values.shape[0] + 1) * grid.dy
        - grid.dy * 0.5
        + grid.xy_of_lower_left[1]
    )
    x = (
        np.arange(values.shape[1] + 1) * grid.dx
        - grid.dx * 0.5
        + grid.xy_of_lower_left[0]
    )
    return x, y, values


# plotting function
def color_mesh_vals(clim=[-1, 1]):
    x, y, values = get_values_xy(mg, "dem_dif_m")
    myimage = plt.pcolormesh(x, y, values, cmap="bwr", alpha=0.5)
    myimage.set_rasterized(True)
    myimage.axes.set_aspect("equal")
    plt.autoscale(tight=True)
    plt.clim(clim)
    return myimage

"""
As noted above, the landslide is an enlargement of an existing landslide scar that formed in 2009. Downslope of the 2009 scar, a first-to-second order channel drains the center of the 2009 runout path and two forest roads cross the channel. Both road crossing were destroyed by the 2009 runout but were later reconstructed and are large fills that effectively create check dams in the runout path of the 2021 landslide. Note the model is run using a 10-meter grid but for visualization purposes, we show model inputs and results overlayed on top of a high-resolution (2-meter) hillshade of the terrain.
"""

plot_node_field_with_shaded_high_res_dem(
    mg, mg_hs=mg_hs, field="mass__wasting_id", cmap="binary", cbr=[0, 1], fontsize=7
)

"""
In the next figure, we plot topographic slope of the initial DEM. At high slopes, MWR will erode while at low slopes MWR will deposit, where high and low vary as a function of the parameter S_c. You can see that there is an area of moderate-to-low slope (green and blue cells) between the two roads.
"""

plot_node_field_with_shaded_high_res_dem(
    mg=mg,
    mg_hs=mg_hs,
    field="topographic__steepest_slope",
    cmap="gist_ncar",
    cbr=[0, 1],
    fontsize=7,
)

"""
We calibrated MWR to a DoD of the observed runout (shown below). Red indicates a positive change in the elevation of the terrain (aggradation) and blue indicates a negative change (erosion). Notice how the observed runout eroded along the steep reaches and deposited in the moderate to low slope reaches. It also formed thick deposits up-channel of the road crossings. It eroded the upper road surface but not the surface of the lower road. Only a small amount of the observed runout actually flowed into the river at the base of the hillslope.
"""

plot_node_field_with_shaded_high_res_dem(
    mg, mg_hs=mg_hs, field="dem_dif_o", cmap="bwr", alpha=0.5, cbr=[-1, 1], fontsize=7
)

"""
**Now set up an instance of MWR using the newly defined raster model grid and the landslide and watch a calibrated recreation of the observed runout!**

Before we instantiate the model, we need to switch the topographic__steepest_slope and other related flow routing fields from the D8 flow routing option to the multidirectional routing option. MWR uses multi-directional slope. 
"""

# delete d8 flow direction
mg.delete_field(loc="node", name="flow__sink_flag")
mg.delete_field(loc="node", name="flow__link_to_receiver_node")
mg.delete_field(loc="node", name="flow__receiver_node")
mg.delete_field(loc="node", name="topographic__steepest_slope")

# run multi flow director, add slope and receiving node fields
fd = FlowDirectorMFD(mg, diagonals=True, partition_method="slope")
fd.run_one_step()

# set model parameters
MWR = MassWastingRunout(
    grid=mg,
    critical_slope=S_c,
    threshold_flux=q_c,
    erosion_coefficient=k,
    tracked_attributes=tracked_attributes,
    save=True,
    typical_flow_thickness_of_erosion_zone=typical_flow_thickness_of_erosion_zone,
    typical_slope_of_erosion_zone=typical_slope_of_erosion_zone,
    max_flow_depth_observed_in_field=max_flow_depth_observed_in_field,
)

MWR.run_one_step()

"""
Once the model has finished running, view an animation of the landslide runout, here shown as the DoD from each iteration of the model run. <br>
"""

# update function


def update_plot(frame_number, MWR, plot):
    mg.at_node["dem_dif_m"] = (
        MWR.saver.runout_evo_maps[0][frame_number]
        - mg.at_node["topographic__initial_elevation"]
    )
    plot[0].set_array(mg.at_node["dem_dif_m"])
    plot[0].remove()
    plot[0] = color_mesh_vals(clim=[-1, 1])

    return plot


# prepare the first frame
fig = plt.figure(figsize=(8, 8))
nmax = len(MWR.saver.runout_evo_maps[0].keys())
x, y, values = get_values_xy(mg_hs, "hillshade_arc")
myimage = plt.pcolormesh(x, y, values, cmap="Greys_r", alpha=1)
myimage.set_rasterized(True)
myimage.axes.set_aspect("equal")
plt.autoscale(tight=True)
plt.xticks(fontsize=8)
plt.yticks(fontsize=8)
plot = [color_mesh_vals(clim=[-1, 1])]
plt.title("dem_dif_m")
cb = plt.colorbar(norm=True)

animate_10 = animation.FuncAnimation(
    fig,
    update_plot,
    nmax,
    fargs=(MWR, plot),
    blit=True,
    repeat=True,
    cache_frame_data=False,
)

"""
**Now that you've seen an example of how a calibrated MWR can replicate observed runout, try re-running this notebook with different parameter values to see if you can send more sediment into the river valley below the second road crossing!**
"""



================================================
File: docs/source/tutorials/mass_wasting_runout/synthetic_landscape_animation.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Synthetic landscape animation

Simulate the runout extent, sediment transport and topographic change caused by the runout of a rectangular landslide over a synthetic terrain using MassWastingRunout
"""

"""
In this tutorial, the user defines the rectangular geometry of a landslide, parameterizes MassWastingRunout (MWR) and chooses one of 6 synthetic terrains on which the runout of the landslide is modeled.
"""

"""
## Model overview
- MWR models the downslope progression of mass wasting processes such as debris flows or dry debris avalanches.

- Mass continuity is central to model conceptualization; at any node, the incoming flux (q_I), erosion (E) and aggradation (A) determine outgoing flux (q_O) and ultimately the runout extent and how the landscape evolves. 

<div>    
<img src = "attachment:image-2.png" width="200"/>
<div>
    
    
- MWR uses a set of rules and algorithms to numerically represent the release of the mass wasting source material and erosion, deposition and vegetation/debris impacts on the runout process as illustrated below:
"""

"""
<div>
<img src = "attachment:mass_continuity_v7.jpg" width="350"/>
<div>                                                         
"""

"""
<strong><em>(a)</em></strong> Release of the initial mass wasting source material nodes (represented by red cells); <strong><em>(b)</em></strong> How q_O at node n (n = 45) is distributed downslope after incoming material q_I (here equal to flux from node 51) has aggraded (A) or eroded (E) node n; <strong><em>(c)</em></strong> Mass continuity determines the change in regolith thickness/topographic elevation. For a full description of the above parameters, see Keck et al. (2024).  
"""

"""
**To begin, first import  packages and components necessary to load MWR inputs, run MWR and visualize model results.**
"""

import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import cm

from landlab.components import FlowDirectorMFD
from landlab.components.mass_wasting_runout.mass_wasting_runout import MassWastingRunout
from landlab.io import esri_ascii

"""
**Next, define the mass wasting source area (landslide) geometry.**

In this notebook, we define the geometry of the landslide as a rectangular prism. In later notebooks, we will use the geometry of a landslide body observed in the field.
"""

ls_width = 3  # number of cells wide, must be odd number
ls_length = 5  # number of cells long
ls_h = 3  # thickness, m
soil_thickness = 2  # thickness of soil (regolith) covering synthetic terrain, m

"""
**Then, define key MWR parameters S_c, q_c and k.**

In MWR, S_c is a critical slope constraint. For some flows, it may be possible to approximate S_c from the surface slope of observed deposits. The parameter q_c is the threshold flux for deposition, that conceptually represents the flow depth below which flow resistance is large enough to cease the forward momentum of the flow, whether in the form of frictional resistance along the base of the flow or debris and vegetation in the path of the flow. Parameter k scales the erosion rate.<br> We also specify the typical particle diameter found in the regolith because in this example, we will use an erosion rule that varies as a function of the flow grain size.
"""

q_c = 0.2  # threshold flux, m
S_c = 0.03  # critical slope
k = 0.01  # erosion coefficient
Dp = 0.2  # particle diameter, m

"""
**Now, pick which terrain the landslide will runout on.**


The planimetric curvature of each terrain ranges from divergent to steeply convergent. In profile, the terrains include concave-up, convex-up, planar and broken.<br> 
Terrains are shaded with the DEM of Difference (DoD) of previous model results using ls_width = 3, ls_length = 5, ls_h = 3, soil_thickness = 2, qs_max = ls_h, q_c = .25, S_c = 0.03, k = 0.005, and Dp = 0.2. Red indicates a positive change in the elevation of the terrain (aggradation) and blue indicates a negative change (erosion).<br>
"""

terrain_id = "E"

"""
<div>
<img src="attachment:flume_tests_v3.jpg" width="750"/>
</div>    
"""

terrains = {
    "A": "A_PlanarSlope.asc",
    "B": "B_PlanarSlopeWithConstriction.asc",
    "C": "C_WideFlumeWithBench.asc",
    "D": "D_ConvergentConcave.asc",
    "E": "E_VariableConvergenceConcave.asc",
    "F": "F_VaryConvergenceConvex.asc",
}
with open(terrains[terrain_id]) as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")

"""
**Now, define a few functions that will create the landslide from the given dimensions and plot model results.**

These functions are not necessary to run the model and are only included in this notebook for visualizing and setting up the synthetic terrains.
"""

# plotting functions, adapted from flow-director notebooks


def surf_plot(mg, surface="topographic__elevation", title="", zlim=None):
    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    print(f"Zmin{Z.min()}, Zmax{Z.max()}")
    color = cm.gray_r((Z - Z.min()) * 2 / (Z.max() - Z.min()))
    surf = ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
        alpha=0.67,
        shade=True,
    )
    ax.view_init(elev=20, azim=-75)
    ax.set_xlabel("X axis")
    ax.set_ylabel("Y axis")
    ax.set_zlabel("Elevation")
    ax.view_init(elev=20, azim=-75)
    plt.title(title)
    ax.set_box_aspect([0.30, 1, 0.2])
    #     if zlim:
    #         ax.set_zlim(zlim)
    ax.tick_params(axis="both", which="major", labelsize=7)
    return surf


def surf_plot_drape(
    mg,
    surface="topographic__elevation",
    shading="dem_dif_o",
    title="",
    clim=[-1, 1],
    cmtype="diverging",
    zlim=None,
    colorbar=False,
):
    # Plot the surface.
    Z = mg.at_node[surface].reshape(mg.shape)
    S = mg.at_node[shading].reshape(mg.shape)
    # normalize colormap values (0 to 1) so that centered at mid point
    # between clim[0] (min) and clim[1] (max) values
    S_ = S.copy()
    S_[S > clim[1]] = clim[1]
    S_[S < clim[0]] = clim[0]
    ci = (S_ - clim[0]) / (clim[1] - clim[0])
    if cmtype == "diverging":
        color = cm.seismic(ci)  # cm.bwr(ci)
    elif cmtype == "sequential":
        color = cm.terrain(ci)
    color[ci == 0.5] = [
        0.50196078,
        0.50196078,
        0.50196078,
        1,
    ]  # set zero values to grey
    surf = ax.plot_surface(
        mg.x_of_node.reshape(mg.shape),
        mg.y_of_node.reshape(mg.shape),
        Z,
        rstride=1,
        cstride=1,
        facecolors=color,
        linewidth=0.0,
        antialiased=False,
        alpha=0.65,
        shade=False,
    )
    ax.view_init(elev=20, azim=-75)
    plt.title(title)
    ax.set_box_aspect([0.30, 1, 0.2])
    ax.tick_params(axis="both", which="major", labelsize=7)
    if colorbar:
        if cmtype == "diverging":
            m = cm.ScalarMappable(cmap=cm.bwr, norm=surf.norm)
        if cmtype == "sequential":
            m = cm.ScalarMappable(cmap=cm.terrain, norm=surf.norm)
        m.set_array(np.array(clim))
        plt.colorbar(m, ax=ax, shrink=0.25)
    return surf


# functions to define the landslide and select runout profile nodes
def ls_profile_nodes(c, ls_width):
    if ls_width == 1:
        cc = int(c / 2) + 1
        pf = mg.nodes[:, cc]
    elif (ls_width <= c) and (ls_width % 2 == 1):
        cc = []
        for i in range(ls_width):
            dif = -((ls_width) % 2) + i
            cc.append(int(c / 2) + dif + 1)
        cc = np.array(cc)
        pf = mg.nodes[:, int(c / 2) + 1]
    return pf, cc


def landslide_nodes(ls_length, cc):
    # landslide nodes
    lsn = mg.nodes[-(ls_length + 1) : -1, cc]
    return lsn

"""
**Using the selected terrain, grain size and regolith (soil) depth inputs from above, define the raster model grid.**

Here the landslide thickness is set equal to the regolith thickness. Alternatively, the landslide thickness at each node in the landslide could be defined by providing a numpy.array of the landslide thickness values.
"""

# set boundary conditions
# close all boundaries except end of flume
mg.set_closed_boundaries_at_grid_edges(True, True, True, False)
dem = mg.at_node["topographic__elevation"]

# run flow director, add slope and receiving node fields
fd = FlowDirectorMFD(mg, diagonals=True, partition_method="square_root_of_slope")
fd.run_one_step()

# soil thickness
# thickness = np.full(mg.number_of_nodes, soil_thickness)
# mg.add_field("soil__thickness", thickness, at="node")
mg.add_empty("soil__thickness", at="node")
mg.at_node["soil__thickness"].fill(soil_thickness)

# set particle diameter
# mg.at_node["particle__diameter"] = np.ones(len(mg.node_x)) * Dp
mg.add_empty("particle__diameter", at="node")
mg.at_node["particle__diameter"].fill(Dp)

# define the landslide
c = mg.number_of_node_columns - 2
pf, cc = ls_profile_nodes(c, ls_width)
lsn = landslide_nodes(ls_length, cc)

# define landslide location
# mg.at_node["mass__wasting_id"] = np.zeros(mg.number_of_nodes, dtype=int)
mg.add_zeros("mass__wasting_id", at="node", dtype=int)
mg.at_node["mass__wasting_id"][lsn] = 1

# define landslide thickness equal to the regolith thickness
mg.at_node["soil__thickness"][lsn] = ls_h

"""
**Lets take a look at the location of the initial landslide nodes (dark grey area) relative to the flume.**

Here, the flume is colored according to elevation
"""

fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(projection="3d")
surf_plot_drape(
    mg,
    surface="topographic__elevation",
    shading="topographic__elevation",
    title="",
    clim=[
        mg.at_node["topographic__elevation"].min(),
        mg.at_node["topographic__elevation"].max(),
    ],
    cmtype="sequential",
    colorbar=True,
)
ax.scatter(
    mg.node_x[lsn],
    mg.node_y[lsn] + 1,
    mg.at_node["topographic__elevation"][lsn],
    marker=".",
    color="k",
    alpha=1,
    s=100,
)

"""
**Now set up an instance of MWR using the newly defined raster model grid and landslide and run the model!**
"""

# set up the model
MWRu = MassWastingRunout(
    mg,
    critical_slope=[S_c],
    threshold_flux=q_c,
    erosion_coefficient=k,
    max_flow_depth_observed_in_field=ls_h,
    tracked_attributes=["particle__diameter"],
    effective_qsi=True,
    save=True,
    grain_shear=True,
    settle_deposit=False,
)
# run the model
MWRu.run_one_step()

"""
**Once the model has finished running, view the runout extent and how the landslide runout modified the terrain.**

Here the terrain is shown following the runout of the landslide and is now colored according to the DoD. Notice how the landslide removed material at its source, and except for lateral levees, eroded over most of the runout path. The runout material deposited once the slope of the terrain << S_c. Again, red indicates a positive change in the elevation of the terrain (aggradation) and blue indicates a negative change (erosion).
"""

clim = [-ls_h / 2, ls_h / 2]  # colorbar limits for plot, plots below use [-0.5, 0.5]
mg.at_node["dem_dif_o"] = (
    mg.at_node["topographic__elevation"] - mg.at_node["topographic__initial_elevation"]
)
# exagerate topographic change for visualization
mg.at_node["topographic__elevation_with_change"] = (
    mg.at_node["topographic__initial_elevation"] + mg.at_node["dem_dif_o"] * 3
)
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(projection="3d")
surf = surf_plot_drape(
    mg,
    surface="topographic__elevation_with_change",
    shading="dem_dif_o",
    title="",
    clim=clim,
    colorbar=True,
)

"""
**Finally, watch an animation of the runout process that created the final erosion and depositional pattern shown above. The runout is visualized as the DoD of each model iteration.**
"""

# topo with drape
clim = [-ls_h / 2, ls_h / 2]  # color bar range
%matplotlib notebook


def update_plot(frame_number, MWRu, plot):
    mg.at_node["topographic__elevation"] = (
        mg.at_node["topographic__initial_elevation"]
        + (
            MWRu.saver.runout_evo_maps[0][frame_number]
            - mg.at_node["topographic__initial_elevation"]
        )
        * 3
    )  # exagerate change in plot
    mg.at_node["dem_dif_o"] = (
        MWRu.saver.runout_evo_maps[0][frame_number]
        - mg.at_node["topographic__initial_elevation"]
    )
    plot[0].remove()
    plot[0] = surf_plot_drape(
        mg,
        surface="topographic__elevation",
        shading="dem_dif_o",
        title="iteration " + str(frame_number),
        clim=clim,
    )


fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(projection="3d")
nmax = len(MWRu.saver.runout_evo_maps[0].keys())
mg.at_node["topographic__elevation"] = MWRu.saver.runout_evo_maps[0][0]
mg.at_node["dem_dif_o"] = (
    MWRu.saver.runout_evo_maps[0][0] - mg.at_node["topographic__initial_elevation"]
)
plot = [
    surf_plot_drape(
        mg,
        surface="topographic__elevation",
        shading="dem_dif_o",
        title="iteration " + str(0),
        clim=clim,
        colorbar=True,
    )
]
animate = animation.FuncAnimation(
    fig, update_plot, nmax, fargs=(MWRu, plot), repeat=True
)
plt.show()

"""
**Now that you've seen an example, try re-running this notebook with different parameter values, terrains and landslide geometries to see how MWR responds!**
"""



================================================
File: docs/source/tutorials/matrix_creation/numerical_matrix_building_tools.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Building a matrix for numerical methods using a Landlab grid

(Greg Tucker, University of Colorado Boulder, July 2020)

*This notebook explains how to use the matrix-building functions to construct a matrix for a finite-volume or finite-difference solution on a Landlab grid.*

## Introduction

Numerical solutions to differential equations often involve matrices. With grid-based numerical models, like those that Landlab is designed to support, the problem is *discretized* in space: we solve for one or more state variables of interest at a series of discrete spatial locations, such as a grid node or the cell that surrounds it. That process of discretization converts a partial differential equation into a set of ordinary differential equations, with one equation per point. Consider, for example, the one-dimensional diffusion equation:

\begin{equation}
\frac{\partial \eta}{\partial t} = D\frac{\partial^2 \eta}{\partial x^2}
\end{equation}

where $t$ is time, $x$ is distance, $D$ is a transport coefficient, and $\eta$ could be concentration of a dissolved chemical (classic chemical diffusion), the temperature in a solid (heat diffusion), the velocity of flow in a viscous liquid (viscous momentum diffusion), or the height of the land on a hillslope (soil diffusion). If the domain is discretized such that we seek the value of $\eta$ at a series of discrete points, then the above equation for a given point $i$ becomes:

\begin{equation}
\frac{d \eta_i}{d t} = D\frac{d^2 \eta}{d x^2}\bigg\rvert_i
\end{equation}

where the subscript at the right means "evaluated at $i$". Once the right side has been cast in terms of values of $\eta$ at particular points, you end up with a linear system of equations, and matrix methods provide a natural way to solve them. One example among many is an implicit finite-difference solution to the one-dimensional form of the diffusion equation, which involves constructing a matrix and a "right-hand side" vector, inverting the matrix, and multiplying it by the vector to obtain a solution for the state variable at each grid node (for more on that particular example, see *Mathematical Modeling of Earth's Dynamical Systems* by Slingerland and Kump, or *Numerical Recipes* by Press et al.).

When using matrix methods to solve a set of equation at discrete points, whether in 2D or 1D (or even 3D), you typically have an $MxM$ matrix, where $M$ is the number of solution points. Each row in the matrix represents the equation for one of the points. If the equation for a given point includes terms that represent, say, two of its immediately neighboring points, then the columns representing those two points contain non-zero entries. More generally, finite-volume and finite-difference matrices tend be sparse, with only a few non-zero entries in each row: the column that represents the point itself, and the columns representing its immediate neighbors.

Building the matrix therefore requires knowledge of which points are connected to which other points in the grid. In 1D, this is easy. In 2D, it's a bit more complicated. Fortunately, the structure of a Landlab grid lends itself to this task. In particular, we know the connectivity for the *nodes* in the grid. It also turns out that when nodes are the solution points (as is typical), the number of equations---and thus $M$---corresponds exactly to the number of *core nodes* in the grid.

In the following, we first work through the mathematics in a simple example: a finite-volume matrix solution to a steady diffusion equation with a source term, also known as a Poisson equation. We then show some worked examples of the Landlab matrix tools in action.
"""

"""
## Example: steady diffusion with a source term

Consider the diffusion model for hillslope evolution in two dimensions. The equation describes the time evolution of land surface height, $z$, given a transport coefficient $D$ $[L^2/T]$, and relative uplift rate $U$ $[L/T]$ as:

\begin{equation}
\frac{\partial z}{\partial t} = U - \nabla \cdot (-D \nabla z)
\end{equation}

Here $\nabla z$ is the gradient of $z$, which here is a two-element vector (components in the $x$ and $y$ directions, respectively), and $\nabla\cdot$ is the divergence operator. We'll use a matrix method to solve for $z(x)$ when the time derivative is zero. So the equation we want to solve is:

\begin{equation}
U \nabla \cdot (-D \nabla z) = 0
\end{equation}

If $D$ is spatially uniform, we can write this as:

\begin{equation}
\boxed{\nabla^2 z = -U/D}
\end{equation}

This is the equation we're going to discretize and solve. Here $\nabla^2$ is understood to be the divergence-of-the-gradient, and in 1D would just be a second derivative:

\begin{equation}
\frac{d^2z}{dx^2} = -\frac{U}{D}
\end{equation}

The minus sign is important: it indicates upward convexity of the solution when $U$ and $D$ are positive (which they always are in this case).
"""

"""
### Finite-volume discretization

Let's take a step back in the derivation of the diffusion equation to note that it is composed of two parts together. One part is mass conservation:

\begin{equation}
\frac{\partial z}{\partial t} = U - \nabla \cdot \mathbf{q}
\end{equation}

where $\mathbf{q}$ is soil volume flux per unit width $[L^2/T]$. The other part is the flux law:

\begin{equation}
\mathbf{q} = -D\nabla z
\end{equation}

For this example, we'll set the time derivative to zero, meaning we are looking for a steady solution.

Next, we integrate the conservation law over a 2D region $R$. In general, $R$ is a simply connected region. Ultimately for us, it will be a grid cell, which could be a square, a rectangle, a hexagon, or even an irregular polygon.

\begin{equation}
\int\int_R \nabla\cdot \mathbf{q} dR = \int\int_R U dR
\end{equation}

Because $U$ is constant inside the region $R$,

\begin{equation}
\int\int_R \nabla\cdot \mathbf{q} dR = U A_r
\end{equation}

Now we apply Green's theorem, which basically says that an area integral over the divergence of a vector field is equivalent to a line integral of the surface-normal component of that vector around the perimeter of the region. Intuitively, if we consider $\mathbf{q}$ to be a flux in this case, what we're saying is that we can obtain the net total flux over the region (grid cell!) by integrating the flux all around the perimeter. Think of it as keeping track of all the people who enter or leave the perimeter of a playing field.

\begin{equation}
\oint_S \mathbf{q} \cdot\mathbf{n} dS = U A_r
\end{equation}

where $\mathbf{n}$ is an (outward-facing) unit vector perpendicular to the perimeter $S$ that encloses region $R$. For us, again the perimeter is just the perimeter of the grid cell: the four sides of a square or rectangle, or the six side of a hexagon, the $N$ sides of a Voronoi polygon, or whatever. Then the line integral becomes a summation.

We will define a quantity $q$ that represents the face-normal component of $\mathbf{q}$. The sign convention is as follows:

- $q$ is positive if the vector orientation is toward the upper-right half space (including "right" and "up")

- $q$ is negative if the vector orientation is toward the lower-left half space (including "left" and "down")

We will also define a binary variable $\delta$, which is negative if the outward surface-normal points toward the lower-left half space, and positive if it points toward the upper-right half space.

Here's where Landlab grids come into the picture. The two definitions represent the use of *links* in a Landlab grid: when $q$ is positive when it oriented in the link's direction, and negative when oriented in the opposite direction. In a simple raster grid, where the links are all horizontal or vertical, the interpretation is very simple: flow to the right (increasing $x$) is positive, and to the left is negative; flow upward (increasing $y$) is positive, and downward is negative.

More generally, whatever the grid type, links by convention always "point" toward the upper-right half space; hence the general definition of $q$ above. The variable $\delta$ represents the link orientation relative to the cell: positive when the link points out of the cell, negative when it points into the cell. The variable is represented in a Landlab grid by the array `link_dirs_at_node`: one for each link, starting from the "east" (or "right") direction and going counter-clockwise.

Suppose $R$ is a square grid cell of width $\Delta x$. Then:

\begin{equation}
\oint_S \mathbf{f} \cdot\mathbf{n} dR = \sum_{k=1}^4 q_k \delta_k \Delta x
\end{equation}

where $q_k$ is the magnitude of the vector field at face $k$, and $\delta = -1$ if the link at face $k$ points inward, and $+1$ if the link points outward.

For this Poisson problem (i.e., diffusion with zero time derivative), the flux between the two nodes at either end of a link is approximated as the difference in $z$ divided by the distance, which here is $\Delta x$. For each of the four directions:

$q_e = -(D/\Delta x) (z_e - z_i)$

$q_n = -(D/\Delta x) (z_n - z_i)$

$q_e = -(D/\Delta x) (z_i - z_w)$

$q_s = -(D/\Delta x) (z_i - z_s)$

Here the subscript refers to the four cardinal directions. When you work out the summation above, you get:

\begin{equation}
\sum_{k=1}^4 q_k \delta_k \Delta x = -D (z_e + z_n - + z_w + z_s - 4z_i)
\end{equation}

Now plug this back into our governing equation, and divide both sides by $A_r = \Delta x^2$:

\begin{equation}
-D (z_e + z_n - + z_w + z_s - 4z_i) = U
\end{equation}

or

\begin{equation}
\boxed{z_e + z_n - + z_w + z_s - 4z_i = -U/D}
\end{equation}

So the above represents a system of equations: one equation per core node in a Landlab grid. For any given core node, $z_i$ is the elevation of the node itself, and the other four are the elevations of its four neighbors. By the way, for a regular raster grid, this finite-volume setup turns out to be the same as the finite-difference version. Here the directional subscripts will ultimately be replaced with indices of the particular neighboring nodes.
"""

"""
### Example of a finite-volume setup

Suppose we have a raster model grid with 4 rows and 5 columns, so that there are 6 interior nodes. To make it interesting, let's assume that one of the interior nodes is actually a fixed-value boundary. We will also assume that the perimeter nodes are fixed-value boundaries. Fixed-value boundary simply means that we will keep the elevation constant at these nodes. In total, then, there are 5 core nodes at which we wish to solve for $z$. An illustration of the grid, with the lower-left node being node number 0, looks like:

```
o---o---o---o---o
|   |   |   |   |
o---.---.---o---o
|   |   |   |   |
o---.---.---.---o
|   |   |   |   |
o---o---o---o---o
```

In the illustration, `.` is a core node, and `o` is a fixed-value boundary node. The numbering of *nodes* looks like this:

```
15---16---17---18---19
 |    |    |    |    |
10---11---12---13---14
 |    |    |    |    |
 5--- 6--- 7--- 8--- 9
 |    |    |    |    |
 0--- 1--- 2--- 3--- 4
```

Here's a version where we number the *core nodes* consecutively:

```
o---o---o---o---o
|   |   |   |   |
o---3---4---o---o
|   |   |   |   |
o---0---1---2---o
|   |   |   |   |
o---o---o---o---o
```
"""

"""
These numbers correspond to rows in a matrix that we will construct. For each row, the column representing the node itself gets a -4, corresponding to the boxed equation above. For each of its neighboring **core** nodes, the corresponding column gets a +1. For example, the first row in the matrix, representing core node 0 in the above sketch, will have a -4 in column 0. It will have a +1 in column 1, representing the neighbor to its east, and a +1 in column 3, representing the neighbor to its north. Here's what the matrix should look like:

\begin{vmatrix}
-4 &  1 &  0 & 1 & 0 \\
1 & -4 &  1 & 0 & 1 \\
0 &  1 & -4 & 0 & 0 \\
1 &  0 &  0 & -4 & 1 \\
0 &  1 &  0 &  1 & -4 \\
\end{vmatrix}

But what happens when one or more of the four neighbors is not another core node, but rather a fixed-value boundary? That's actually the case for *all* of the core nodes in the above example. To appreciate how this works, recall that we're going to put all the constant terms on the right-hand side of the equation. To write this out, we need a way to notate both core nodes and fixed-value nodes. Here, we'll use a subscript to index by *core node ID* (for the core nodes), and parentheses to index by *node ID* (for the boundary nodes). With that notation in mind, the equations for the example grid above are:

\begin{eqnarray}
z_1 + z_3 + z(5) + z(1) - 4z_0 = -U/D \\
z_2 + z_4 + z_0 + z(2) - 4z_1 = -U/D \\
z(9) + z(13) + z_1 + z(3) - 4z_2 = -U/D \\
z_4 + z(16) + z(10) + z_0 - 4z_3 = -U/D \\
z(13) + z(17) + z_3 + z_1 - 4z_4 = -U/D \\
\end{eqnarray}

With this notation, it's easy to spot the fixed-value boundary nodes, whose entries we'll move to the right-side:

\begin{eqnarray}
- 4z_0 + z_1 + z_3 = -U/D - (z(5) + z(1)) \\
z_0 - 4z_1 + z_2 + z_4 = -U/D - z(2) \\
z_1 - 4z_2 = -U/D - (z(9) + z(13) + z_1 + z(3)) \\
z_0 - 4z_3 + z_4 = -U/D - (z(16) + z(10)) \\
z_1 + z_3 - 4z_4 = -U/D - (z(13) + z(17)) \\
\end{eqnarray}
"""

"""
The above set of equations is represented by the following matrix equation:

\begin{gather}
\begin{bmatrix}
-4 &  1 &  0 & 1 & 0 \\
1 & -4 &  1 & 0 & 1 \\
0 &  1 & -4 & 0 & 0 \\
1 &  0 &  0 & -4 & 1 \\
0 &  1 &  0 &  1 & -4 \\
\end{bmatrix}
\begin{bmatrix}
z_0 \\
z_1 \\
z_2 \\
z_3 \\
z_4
\end{bmatrix} =
\begin{bmatrix}
-U/D - (z(5) + z(1)) \\
-U/D - z(2) \\
-U/D - (z(9) + z(13) + z_1 + z(3)) \\
-U/D - (z(16) + z(10)) \\
-U/D - (z(13) + z(17))
\end{bmatrix}
\end{gather}

or more succinctly,

\begin{equation}
A\mathbf{z} = \mathbf{b}
\end{equation}

for which the solution is

\begin{equation}
\mathbf{z} = A^{-1} \mathbf{b}
\end{equation}

In other words this is the equation that we need to solve by inverting the matrix $A$, which we can do using `numpy.linalg.inv()`. Here's an example:
"""

import numpy as np

mat = np.array(
    [
        [-4, 1, 0, 1, 0],
        [1, -4, 1, 0, 1],
        [0, 1, -4, 0, 0],
        [1, 0, 0, -4, 1],
        [0, 1, 0, 1, -4],
    ]
)
print(np.linalg.inv(mat))

"""
Let's assume for the sake of this example that $U=10^{-4}$ m/yr, $D=10^{-2}$ m$^2$/yr, and all the nodes around the perimeter have zero elevation. What does the solution look like in terms of numbers?
"""

U = 0.0001
D = 0.01
rhs = -(U / D) + np.zeros((5, 1))

# dot product for matrix-vector multiplication
solution = np.dot(np.linalg.inv(mat), rhs)
print(solution)

"""
You can see from this example that once you have your matrix and right-hand side vector, numpy's linear algebra functions make it straightforward to solve the system. The tricky part is building the matrix and the right-side vector in the first place. This is where Landlab's matrix-building utility comes in.
"""

"""
## Landlab's matrix-building functions

To facilitate matrix-based numerical solutions, Landlab's collection of utilities includes two helper functions:

- `get_core_node_matrix(grid, value, rhs=None)` creates and returns a matrix like $A$ above for a Landlab grid, as well as a right-hand-side vector. The matrix is returned as an M x M numpy array, where M is the number of core nodes in the grid. The right-hand-side vector is an M x 1 array. Each row in the matrix represents one core node. The rules for building a row, and the corresponding row in the right-hand-side vector, are:
  - For every *active link* connected to the node, if the link connects to another core node, the corresponding column in the matrix is assigned the value $+1$. For example, in the tiny grid presented earlier, core node 0 is connected to two other core nodes, 1 and 3. Therefore, columns 1 and 3 in row 0 of the matrix are each set to $+1$.
  - The matrix column representing the node itself is assigned a value equal to $-1$ times the number of active links that connect to the node, which represents the number of neighboring nodes that are not closed-boundary nodes. In the example grid above, core node 0 is connected for four active links, and so row 0, column 0 is set to -4.
  - All other matrix entries are zero.
  - For every neighboring *fixed-value boundary* node adjacent to core node $i$, the value at the neighbor node is subtracted from column $i$ of the right-hand side vector. This is how a fixed-value boundary condition is handled. In the example grid above, core node 0 is bordered by two fixed-value boundary nodes (node IDs 1 and 5). The values of $z$ at these two fixed-value nodes are subtracted from row 0 of the right-hand-side boundary vector.
  
- `get_core_node_matrix_var_coef(grid, value, coef_at_link=coef, rhs=None)` does basically the same thing, but allows for a spatially variable coefficient ($D$, or its equivalent in your particular problem). In the example above, we assumed that $D$ was constant, and were therefore able to move it to the right side of the equation. But there are plenty of cases where you might want to allow $D$ to vary in space. This function allows that by taking as an input a 1D array containing a value of $D$ for each grid link. The function ensures that $D$ is factored in appropropriately. (Exercise to the reader: use the example above, but with a spatially variable $D$, to work out what "appropriately" means here).  Note that when $D$ varies in space, it is included on the left side of the equation (i.e., in the matrix $A$) and **not** in the right-side vector.

Both functions return two items: an M x M array (the matrix) and an M x 1 array (for the right-hand-side vector). With both functions, however, it is your job as the user to properly set up your right-hand-side vector. You have two options. The first is to pass in an array as the `rhs` argument. It should be a 1D array of length equal to the number of core nodes. The function will then add the boundary condition information to whatever values you have already put there. The second option is to omit the `rhs` argument. In this case the function will create a "preliminary" version that contains **only** the values needed to handle fixed-value boundary conditions; you must then add the rest of your right-side information to this before solving. For example, in the sample problem above, you would need to add $-U/D$ to each element of your right-hand-side vector, while the function would take care of adding the various boundary $z$ values.

Both functions take either a `RasterModelGrid` or a `HexModelGrid` as the first argument. The matrix-creation functions work for both grid types. Note however that if you have a hex grid, you must multiply your right-hand-side vector by 3/2 (exercise: modify the derivation above, accounting for the area and side length of a hexagon, to demonstrate why this is the case). In principle, the same finite-volume solution method should work for other grid types too, but with modifications to handle spatial variation in cell area, face width, and link length. (If irregular-grid functionality is something you need for your application, we encourage you to develop it and submit a pull request!)

Both functions also take a `value` array containing the node-based values of interest (e.g., $z$ in the sample problem above). This should by a 1D numpy array of length equal to the total number of grid nodes.

"""

"""
## Examples using Landlab matrix functions

### Constant coefficient

The example below uses Landlab to solve the tiny sample problem described above.
"""

import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.utils import get_core_node_matrix

# Define parameter values
U = 0.0001  # uplift rate of material, relative to baselevel, m/yr
D = 0.01  # soil transport coefficient ("diffusivity"), m2/yr

# Create a simple grid
grid = RasterModelGrid((4, 5), xy_spacing=1.0)

# Add a field for topographic elevation
z = grid.add_zeros("topographic__elevation", at="node")

# Convert one of the interior nodes to boundary
grid.status_at_node[13] = grid.BC_NODE_IS_FIXED_VALUE

# Build the matrix and right-hand-side vector
mat, rhs = get_core_node_matrix(grid, z)

# Add the correct data to the right-hand-side vector
rhs -= U / D

# Let's take a look at them
print("Matrix:")
print(mat)
print("Right-side vector:")
print(rhs)

# Solve: invert the matrix using numpy's linalg.inv() function, then take dot product
z_core = np.dot(np.linalg.inv(mat.toarray()), rhs)
print("Solution:")
print(z_core)

# Insert the solution into the elevation field
z[grid.core_nodes] = z_core.flatten()  # flatten because z is a 1D array

# Plot
imshow_grid(grid, z)

"""
Note that the solution for our tiny test grid is the same as before, as it should be.
"""

"""
### Version with a variable coefficient

Next, we repeat the above, but for a case of a spatially variable $D$. We'll first do it with an array of $D$ values, one per link, where the $D$ values are the same as above, just to demonstrate that the solution is the same.
"""

from landlab.utils import get_core_node_matrix

# Define an array of D values
D = 0.01 + np.zeros(
    grid.number_of_links
)  # we could also make this a grid field if desired

# Build the matrix and right-hand-side vector
mat, rhs = get_core_node_matrix(grid, z, coef_at_link=D)

# Add the correct data to the right-hand-side vector: this time D is on the left side, so
# we don't incorporate it in the right-side vector
rhs -= U

# Let's take a look at them
print("Matrix:")
print(mat)
print("Right-side vector:")
print(rhs)

# Solve: invert the matrix using numpy's linalg.inv() function, then take dot product
z_core = np.dot(np.linalg.inv(mat.toarray()), rhs)
print("Solution:")
print(z_core)

# Insert the solution into the elevation field
z[grid.core_nodes] = z_core.flatten()  # flatten because z is a 1D array

# Plot
imshow_grid(grid, z)

"""
Here, the matrix and RHS vector are different, but the solution is the same. We've simply factored $D$ into the left side instead of the right side.

Now let's try making $D$ actually vary in space. For the sake of illustration, we'll assign a high value to the links on the left, and a 100x lower value to the links on the right. What do you think this will do to the topography?
"""

# Define an array of D values
D = np.zeros(grid.number_of_links)  # we could also make this a grid field if desired
D[grid.x_of_node[grid.node_at_link_head] > 2.0] = 0.001
D[grid.x_of_node[grid.node_at_link_head] <= 2.0] = 0.1
print("D values:")
print(D)

# Build the matrix and right-hand-side vector
mat, rhs = get_core_node_matrix(grid, z, coef_at_link=D)

# Add the correct data to the right-hand-side vector: this time D is on the left side, so
# we don't incorporate it in the right-side vector
rhs -= U

# Let's take a look at them
print("Matrix:")
print(mat)
print("Right-side vector:")
print(rhs)

# Solve: invert the matrix using numpy's linalg.inv() function, then take dot product
z_core = np.dot(np.linalg.inv(mat.toarray()), rhs)
print("Solution:")
print(z_core)

# Insert the solution into the elevation field
z[grid.core_nodes] = z_core.flatten()  # flatten because z is a 1D array

# Plot
imshow_grid(grid, z)

"""
Here the lone core cell on the right is surrounded by links at which transport is inefficient; in other words, $D$ is small. Therefore, the cell needs steep slopes on all sides in order to transport out the incoming soil. The other cells are all bordered by at least one link with a high $D$ value, so they don't need much gradient to transport out the incoming material.
"""

"""


### Comparison with 1D analytical solution


In the next example, we'll set up an effectively 1D domain, and compare it with the known analytical solution. We can produce a quasi-1D grid by giving it just 3 rows, two of which are boundary rows, and setting the status of those boundaries to *closed*.

The expected analytical solution is a parabola:

\begin{equation}
z = \frac{UL^2}{D}\left(\frac{x}{L} - \frac{1}{2}\left[\frac{x}{L}\right]^2\right)
\end{equation}

"""

import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.utils import get_core_node_matrix

# Define parameter values
U = 0.0001  # uplift rate of material, relative to baselevel, m/yr
D = 0.01  # soil transport coefficient ("diffusivity"), m2/yr

# Create a simple grid
grid = RasterModelGrid((3, 101), xy_spacing=1.0)

# Add a field for topographic elevation
z = grid.add_zeros("topographic__elevation", at="node")

# Set closed boundaries on north and south
grid.set_closed_boundaries_at_grid_edges(False, True, False, True)

# Build the matrix and right-hand-side vector
mat, rhs = get_core_node_matrix(grid, z)

# Add the correct data to the right-hand-side vector
rhs -= U / D

# Solve: invert the matrix using numpy's linalg.inv() function, then take dot product
z_core = np.dot(np.linalg.inv(mat.toarray()), rhs)

# Insert the solution into the elevation field
z[grid.core_nodes] = z_core.flatten()  # flatten because z is a 1D array

# Calculate the analytical solution
middle_row = np.arange(101, 202, dtype=int)  # middle row of grid nodes
x = grid.x_of_node[middle_row]  # x coordinates: 0, 1, ... 100
L = 50.0  # half-length of domain
za = (U / D) * (x * L - 0.5 * x * x)  # analytical solution

# Plot
import matplotlib.pyplot as plt

plt.plot(x, z[middle_row], "b.")
plt.plot(x, za, "r")
plt.xlabel("Distance (m)")
plt.ylabel("Height (m)")
plt.legend(["numerical", "analytical"])

"""
### Hexagonal grid

One advantage of the finite-volume method is that it isn't limited to rectilinear grids. The next example demonstrates this with a tiny hex grid. This wee little grid has just two core nodes, so our matrix will be 2x2. One change is that we need to multiply the RHS values by 3/2 to account for the hex geometry.
"""

from landlab import HexModelGrid

# Instantiate the grid: here 3 rows, with 3 columns top and bottom and 4 in the middle
hg = HexModelGrid((3, 3))

# Add the elevation field
z = hg.add_zeros("topographic__elevation", at="node")

# Constants, as before
U = 0.0001
D = 0.01
dx = 1.0  # this is the spacing between nodes

# Create the matrix and RHS
mat, rhs = get_core_node_matrix(hg, z)

# Fill in the rest of the RHS vector, including a factor of 3/2 for the hex grid.
rhs[:] += -1.5 * U * dx * dx / D

# Solve
soln = np.dot(np.linalg.inv(mat.toarray()), rhs)
z[hg.core_nodes] = soln.flatten()
print(mat)
print(rhs)
print(z)

"""
We can test this. The uplift rate times the cell area represents the volume rate in. Because this is a steady problem, it should equal the volume rate out. The volume rate out across any outer cell face is equal to the gradient across the face times $D$ times the width of the face. The face width in this case is $3^{-1/2}$. Here, the boundaries are all at zero and the distance between nodes is unity, so the gradient is equal to the elevation value. Hence, the flux out across any one face is:

\begin{equation}
3^{-1/2} Dz
\end{equation}

and the total flux equals the flux of one face times the number of outer faces, of which there happen to be 10. Here's the calculation:
"""

# Test: area times 2 cells times uplift rate should equal number of exposed sides times elevation
area = 0.5 * 3.0**0.5
influx = 2 * area * U
outflux = 10 * D * (1.0 / 3.0**0.5) * z[4]
print(influx)
print(outflux)

"""
So, we have successfully balanced mass.

These examples have used a simple steady diffusion (Poisson) equation, cast in terms of hillslope evolution. The same equation could be used, for example, for a steady 2D heat conduction problem, or a solute injection-and-diffusion problem. And although these examples focus on the steady problem, a similar matrix-based approach can be used for implicit solutions to the time-evolving problem.
"""

"""

### Appendix 1: deriving a finite-element discretization for a hexagonal grid

In a regular hexagonal grid, the summation should look as derived in the following:

\begin{equation}
\oint_S \mathbf{f} \cdot\mathbf{n} dR = U A_r
\end{equation}

where $A_r$ is now the area of a regular hexagon. In terms of the side length, $a$, area is:

$A_r = \frac{3\sqrt{3}}{2}a^2$.

The side length relates to the height, $\Delta x$, (midpoint of one face to midpoint of the opposite face) as:

$\Delta x = \frac{3}{\sqrt{3}}a$, or

$a = \frac{\sqrt{3}}{3}\Delta x = \frac{1}{\sqrt{3}}\Delta x$.

Plugging this in for area,

$A_r = \frac{3\sqrt{3}}{2}\left( \frac{1}{\sqrt{3}} \right)^2 = \frac{\sqrt{3}}{2}\Delta x^2$.


So then our summation looks like:

\begin{equation}
\oint_S \mathbf{f} \cdot\mathbf{n} dR = \sum_{k=1}^6 \mathbf{q_k}\delta_k \frac{1}{\sqrt{3}}\Delta x = U \frac{\sqrt{3}}{2}\Delta x^2
\end{equation}

which simplifies to

\begin{equation}
\sum_{k=1}^6 \mathbf{q_k}\delta_k = U \frac{3}{2}\Delta x
\end{equation}

Then put in the 6 fluxes (here assuming a "horizontal" arrangement):

$q_e \delta_e = -D(1/\Delta x) (\eta_e - \eta_i)$

$q_{nne} \delta_{nne} = -D(1/\Delta x) (\eta_{nne} - \eta_i)$

$q_{nnw} \delta_{nne} = -D(1/\Delta x) (\eta_{nnw} - \eta_i)$

$q_w \delta_w = -D(1/\Delta x) (\eta_w - \eta_i)$

$q_{ssw} \delta_{ssw} = -D(1/\Delta x) (\eta_{ssw} - \eta_i)$

$q_{sse} \delta_{sse} = -D(1/\Delta x) (\eta_{ssw} - \eta_i)$

and so you get:

\begin{equation}
\eta_e + \eta_{nne} + \eta_{nnw} + \eta_w + \eta_{ssw} + \eta_{sse} - 6\eta_i = -\frac{3U}{2D} \Delta x^2
\end{equation}

Conclusion: the only difference between a raster and a hex grid is the factor of 3/2 on the RHS, and of course the fact that you are adding up 6 neighbors instead of 4.
"""

"""

### Appendix 2: Deriving the analytical solution

Let $s = dz/dx$, then

\begin{equation}
\frac{ds}{dx} = -\frac{U}{D}
\end{equation}

Assume we have a linear domain of length $2L$, in which $s(L)=0$. Integrate:

\begin{equation}
s = -\frac{U}{D}x + C_1
\end{equation}

Evaluate the constant of integration:

\begin{equation}
0 = -\frac{U}{D}L + C_1
\end{equation}

and therefore

\begin{equation}
s = \frac{dz}{dx} = \frac{U}{D}(L-x)
\end{equation}

The above implies that gradient is positive when $x<L$, zero when $x=L$, and negative when $x>L$, as expected.

Now integrate again:

\begin{equation}
z = \frac{U}{D}\left(Lx - \frac{x^2}{2}\right) + C_2
\end{equation}

Given $z(x)=z(2L)=0$, $C_2=0$, thus (and factoring out $L^2$):

\begin{equation}
\boxed{z = \frac{UL^2}{D}\left(\frac{x}{L} - \frac{1}{2}\left[\frac{x}{L}\right]^2\right)}
\end{equation}
"""



================================================
File: docs/source/tutorials/network_sediment_transporter/bed_parcel_initializer.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab BedParcelInitializer components to initialize river bed sediment parcels for the NetworkSedimentTransporter component

This tutorial illustrates how to initialize bed sediment to model the transport of coarse sediment through a river network using the NetworkSedimentTransporter Landlab component. 

In this example we will: 
- load a river network shapefile to create a Landlab grid to represent a river network
- initialize sediment 'parcels' on that river network using the four available BedParcelInitializer components
- conduct a simple exploration of the initial parcel attributes
"""

"""
Import the necessary libraries, plus a bit of magic so that we can plot within this notebook:
"""

# import warnings
# warnings.filterwarnings('ignore')

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import xarray as xr

from landlab import ExampleData
from landlab.components import (
    BedParcelInitializerArea,
    BedParcelInitializerDepth,
    BedParcelInitializerDischarge,
    BedParcelInitializerUserD50,
)
from landlab.io import read_shapefile
from landlab.plot import graph, plot_network_and_parcels

%matplotlib inline

"""
## 1. Load a shapefile that represents the river network

First, we need to create a Landlab NetworkModelGrid to represent the river network. Each link on the grid represents a reach of river. Each node represents a break between reaches. All tributary junctions must be associated with grid nodes. 
"""

datadir = ExampleData("io/shapefile", case="redb").base

shp_file = datadir / "a001_network.shp"
points_shapefile = datadir / "a001_nodes_att.shp"

grid = read_shapefile(
    shp_file,
    points_shapefile=points_shapefile,
    node_fields=["usarea_m2", "elev_m"],
    link_fields=["usarea_km2", "Length_m", "Slope"],
    link_field_conversion={
        "usarea_km2": "drainage_area",
        "Slope": "channel_slope",
        "Length_m": "reach_length",
    },
    node_field_conversion={
        "usarea_m2": "drainage_area_m2",
        "elev_m": "topographic__elevation",
    },
    threshold=0.01,
)

"""
Let's plot our simple network: 
"""

graph.plot_graph(grid, at="node,link")

"""
Our network consists of 12 links (`grid.number_of_links`) between 13 nodes (`grid.number_of_nodes`). In the plot above, X and Y represent the plan-view coordinates of the node locations. 

Next, we need to populate the grid with the relevant topographic and hydrologic information: 
"""

grid.at_node["bedrock__elevation"] = grid.at_node["topographic__elevation"].copy()

grid.at_link["channel_width"] = 1 * np.ones(grid.number_of_links)  # m

grid.at_link["flow_depth"] = 0.5 * np.ones(grid.number_of_links)  # m

"""
We must distinguish between topographic elevation (the top surface of the bed sediment) and bedrock elevation (the surface of the river in the absence of modeled sediment).
"""

"""
## 2. Create initial sediment 'parcels' in a DataRecord

We represent sediment in the network as discrete parcels (or packages) of grains of uniform size and characteristics. Each parcel is tracked through the network grid according to sediment transport capacity and stratigraphic constraints. 

Parcels are tracked using the Landlab <a href="http://localhost:8888/notebooks/Documents/GitHub/landlab/notebooks/tutorials/data_record/DataRecord_tutorial.ipynb">DataRecord</a>. 

There are four available components for initiating bed sediment parcels, each of which take different parameters to determine the initial median grain size (d50) of the bed sediment. All initializers return a DataRecord of parcels with a set of parcels with a lognormal distribution of parcel grain sizes. By default, the d84 is 2.1 times d50, though the user can change the with of the grain size distribution. 

### 1. BedParcelInitializerDischarge: set d50 via link discharge and Manning's _n_ roughness
We calculate initial sediment median grain size (d50) for each link using dominant discharge and channel width (via the Snyder et al.(2013) formula). Total parcel volume is function of active layer thickness, which is estimated from grain size (d84). We calculate the parcel volume by setting minimum number of parcels as 100. 
Let's create arrays with all of the essential sediment parcel variables by running the Landlab utility BedParcelInitializer: 
"""

discharge_at_link = np.full(grid.number_of_links, 80.0)

initialize_parcels = BedParcelInitializerDischarge(
    grid, discharge_at_link=discharge_at_link
)
parcels = initialize_parcels()

"""
See the warning? Let's check the maximum median grain size..
"""

D50 = parcels.calc_aggregate_value(xr.Dataset.median, "D", at="link", fill_value=0.0)

np.max(D50)

"""
Yes, a >4 m median grain size is almost certainly not the kind of channel we were trying to model. 

Other notes: channel width is passed to the component via the NetworkModelGrid.  Above, we let the component use the default Manning's _n_ roughness value, 0.035, and critical Shields stress, 0.04. We could change that, or other parameters, if we want: 
"""

discharge_at_link = np.full(grid.number_of_links, 1.0)

initialize_parcels = BedParcelInitializerDischarge(
    grid,
    discharge_at_link=discharge_at_link,
    mannings_n=0.05,
    tau_c_50=0.08,
    D84_D50=3,  # a wider grain size distribution
)
parcels = initialize_parcels()

"""
### 2. BedParcelInitializerDepth: set $D_{50}$ via link flow depth, channel slope, and Shields stress
We calculate initial sediment median grain size (d50) for each link using a formative (e.g. bankfull) flow depth, as in Pfeiffer et al. (2017). The user can change critical Shields stress and a "multiplier" as well, the default values of which are 0.04 and 1, respectively.  
"""

depth = np.full(grid.number_of_links, 0.3)
initialize_parcels = BedParcelInitializerDepth(
    grid,
    flow_depth_at_link=depth,
)
parcels = initialize_parcels()

"""
As with the Discharge method above, here channel slope is passed to the parcel initializer via the grid. 

#### 3. BedParcelInitializerArea: set $D_{50}$ via hydraulic geometry scaling with drainage area
We calculate initial median sediment grain size (d50) for each link using a power law scaling relationship with drainage area. Other parcel attributes as above. 
"""

initialize_parcels = BedParcelInitializerArea(
    grid, drainage_area_coefficient=0.1, drainage_area_exponent=-0.3
)

parcels = initialize_parcels()

"""
### 3. BedParcelInitializerUserD50: 

The user can specify either a d50 for each link in the network, or a single d50 for all links. 
"""

d50_each_link = np.full(grid.number_of_links, 80.0)
# or
single_d50 = 0.05

initialize_parcels = BedParcelInitializerUserD50(
    grid,
    # user_d50 = d50_each_link,
    user_d50=single_d50,
)

parcels = initialize_parcels()

"""
**Many options available for specifying $D_{50}$**
"""

date = "2017-11-08 17:50:00"
starting_time = pd.to_datetime(date)

time = [starting_time]

depth = np.full(grid.number_of_links, 1.2)
slope_depend_Shields = 0.15 * grid.at_link["channel_slope"] ** 0.25
tau_c_multiplier = 2.3

initialize_parcels = BedParcelInitializerDepth(
    grid,
    flow_depth_at_link=depth,
    tau_c_50=slope_depend_Shields,
    tau_c_multiplier=tau_c_multiplier,
    median_number_of_starting_parcels=100,
    extra_parcel_attributes=["lithology", "Be10_c"],
)

parcels = initialize_parcels()

parcels.dataset["lithology"].values = np.full(parcels.number_of_items, "quartzite")
parcels.dataset["Be10_c"].values = np.full(parcels.number_of_items, "222.2")

"""
In order to track sediment motion, we classify parcels as either active (representing mobile surface sediment) or inactive (immobile subsurface) during each timestep. The active parcels are the most recent parcels to arrive in the link. During a timestep, active parcels are transported downstream (increasing their `location_in_link`, which is a normalized value ranging from 0 to 1) according to a sediment transport formula. 

We begin by assigning each parcel an arbitrary (and small) arrival time and location in the link. 

In addition to the required parcel attributes listed above, you can designate optional parcel characteristics, depending on your needs. 
We now collect the arrays into a dictionary of variables, some of which will be tracked through time (`["item_id", "time"]`), and others of which will remain constant through time.
With all of the required attributes collected, we can create the parcels DataRecord. Often, parcels will eventually transport off of the downstream-most link. To track these parcels, we have designated a "`dummy_element`" here, which has index value `-2`. 
"""

"""
### 4. Plot to explore starting parcels

What grain size did we end up with? How many parcels per link (check)? Etc. 

First, how many parcels are on the network?
"""

number_of_pacels = parcels.number_of_items
number_of_pacels

"""
What are the parcel volumes?
"""

print(
    "The largest parcel is",
    np.round(np.max(parcels.dataset["volume"].values), 3),
    "m^3",
)
print(
    "The median parcel is",
    np.round(np.median(parcels.dataset["volume"].values), 3),
    "m^3",
)
print(
    "The smallest parcel is",
    np.round(np.min(parcels.dataset["volume"].values), 3),
    "m^3",
)

"""
Next, what is the median grain size at each link? 

*Note: we're not weighting the calculation by parcel volume, which is a trivial simplification since nearly all parcels are the same volume*
"""

D50 = parcels.calc_aggregate_value(xr.Dataset.median, "D", at="link", fill_value=0.0)

fig = plot_network_and_parcels(
    grid,
    parcels,
    link_attribute=D50,
    link_attribute_title="Bulk parcel D50 (m)",
    network_linewidth=5,
    parcel_alpha=0,
)

"""
What is the volume of sed originating on each link?
"""

vol_on_link = parcels.calc_aggregate_value(
    xr.Dataset.sum,
    "volume",
    at="link",
    # filter_array=parcelfilter, # no need to filter to a specific timestep - we just have one
    fill_value=0.0,
)

fig = plot_network_and_parcels(
    grid,
    parcels,
    link_attribute=vol_on_link,
    link_attribute_title="Vol of sed originating on link x",
    network_linewidth=5,
    parcel_alpha=0,
)

"""
What is the relationship between D50 and channel slope?
"""

plt.plot(grid.at_link["channel_slope"], D50, ".")
plt.xlabel("Channel slope")
plt.ylabel("D50 (m)")



================================================
File: docs/source/tutorials/network_sediment_transporter/create_networkgrid_from_rastergrid.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Create A Network Grid from Raster Grid

This notebook demonstrates how to extract a NetworkModelGrid from a RasterModelGrid using the 'create_network_from_raster' function
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab.grid.create_network import network_grid_from_raster
from landlab.io import esri_ascii
from landlab.plot.graph import plot_graph

"""
## Create a Raster Model Grid

Now let's create a raster model grid from the .asc data
"""

with open("hugo_site.asc") as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
z = grid.at_node["topographic__elevation"]

grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
grid.status_at_node[np.isclose(z, -9999.0)] = grid.BC_NODE_IS_CLOSED

"""
Visualize Basin topography
"""

grid.imshow(
    "topographic__elevation",
    plot_name="Basin topography",
    color_for_closed=None,
    colorbar_label="$z$ [m]",
)

"""
## Create  a Network Model Grid

Now let's create a network model grid using the 'create_network_from_raster' function:
"""

network_grid = network_grid_from_raster(
    grid,
    minimum_channel_threshold=12000.0,
    include=["drainage_area", "topographic__elevation"],
)

"""
## Let's plot our network
"""

"""
The nodes are numbered in *landlab* convention of lower-left to upper-right.
"""

plot_graph(network_grid, at="node")
plt.title("Nodes");

"""
As are the links,
"""

plot_graph(network_grid, at="node,link", with_id="link")
plt.title("Links");

grid.imshow(
    "topographic__elevation",
    plot_name="Basin topography",
    color_for_closed=None,
    colorbar_label="$z$ [m]",
)
ax = plt.gca()
xlim, ylim = ax.get_xlim(), ax.get_ylim()

plot_graph(network_grid, at="link", with_id=False, axes=ax)

ax.set_xlim(xlim)
ax.set_ylim(ylim)

if len(network_grid.nodes_at_link) > (len(network_grid.nodes) - 1):
    print("there are duplicate links")
else:
    print("link count looks good!")

"""
## Reduce the numer of nodes in channel segments

In the above, we have preserved every node in each channel segment. You can reduce the number of nodes in each segment by passing a *reducer* to the *network_grid_from_raster* function. A *reducer* is simply a function that accepts a list of nodes defining a segment. Although you can write your own, *landlab* provides a set of commonly used reducers.
"""

from landlab.grid.create_network import (
    AtMostNodes,
    JustEndNodes,
    SpacingAtLeast,
    spacing_from_drainage_area,
)

"""
As an example, the following will retain only the downstream and upstream node of each segment.
"""

network_grid = network_grid_from_raster(
    grid,
    reducer=JustEndNodes(),
    minimum_channel_threshold=12000.0,
    include=["drainage_area", "topographic__elevation"],
)

plot_graph(network_grid, at="node,link")
plt.title("Nodes and Links");

"""
Reduce to a maximum number of nodes per segment (including end nodes), use *AtMostNodes*,
"""

network_grid = network_grid_from_raster(
    grid,
    reducer=AtMostNodes(count=4),
    minimum_channel_threshold=12000.0,
    include=["drainage_area", "topographic__elevation"],
)

plot_graph(network_grid, at="node,link")
plt.title("Nodes and Links");

"""
Another option is to specify a spacing at each node. The spacing can be either a scalar, meaning the spacing is the same for every node, or can vary from node to node. An example of the latter is a spacing that depends on upstream area at each node.
"""

spacing = spacing_from_drainage_area(grid.at_node["drainage_area"])

network_grid = network_grid_from_raster(
    grid,
    reducer=SpacingAtLeast(grid.xy_of_node, spacing),
    minimum_channel_threshold=12000.0,
    include=["drainage_area", "topographic__elevation"],
)

plot_graph(network_grid, at="node,link", with_id=False)
plt.title("Nodes and Links");



================================================
File: docs/source/tutorials/network_sediment_transporter/network_plotting_examples.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using plotting tools associated with the Landlab NetworkSedimentTransporter component 

This tutorial illustrates how to plot the results of the NetworkSedimentTransporter Landlab component using the `plot_network_and_parcels` tool. 

In this example we will: 
- create a simple instance of the NetworkSedimentTransporter using a *synthetic river network
- create a simple instance of the NetworkSedimentTransporter using an *input shapefile for the river network
- show options for setting the color and line widths of network links
- show options for setting the color of parcels (marked as dots on the network)
- show options for setting the size of parcels
- show options for plotting a subset of the parcels
- demonstrate changing the timestep plotted
- show an example combining many plotting controls

First, import the necessary libraries:
"""

import warnings

warnings.filterwarnings("ignore")

import matplotlib.colors as colors
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import Normalize

from landlab import ExampleData
from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.data_record import DataRecord
from landlab.grid.network import NetworkModelGrid
from landlab.io import read_shapefile
from landlab.plot import plot_network_and_parcels

"""
## 1. Create and run the synthetic example of NST

First, we need to create an implementation of the Landlab NetworkModelGrid to plot. This example creates a synthetic grid, defining the location of each node and link. 
"""

y_of_node = (0, 100, 200, 200, 300, 400, 400, 125)
x_of_node = (0, 0, 100, -50, -100, 50, -150, -100)

nodes_at_link = ((1, 0), (2, 1), (1, 7), (3, 1), (3, 4), (4, 5), (4, 6))

grid1 = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)
grid1.at_node["bedrock__elevation"] = [0.0, 0.05, 0.2, 0.1, 0.25, 0.4, 0.8, 0.8]
grid1.at_node["topographic__elevation"] = [0.0, 0.05, 0.2, 0.1, 0.25, 0.4, 0.8, 0.8]
grid1.at_link["flow_depth"] = 2.5 * np.ones(grid1.number_of_links)  # m
grid1.at_link["reach_length"] = 200 * np.ones(grid1.number_of_links)  # m
grid1.at_link["channel_width"] = 1 * np.ones(grid1.number_of_links)  # m

# element_id is the link on which the parcel begins.
element_id = np.repeat(np.arange(grid1.number_of_links), 30)
element_id = np.expand_dims(element_id, axis=1)

volume = 0.1 * np.ones(np.shape(element_id))  # (m3)
active_layer = np.ones(np.shape(element_id))  # 1= active, 0 = inactive
density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
abrasion_rate = 0 * np.ones(np.size(element_id))  # (mass loss /m)

# Lognormal GSD
medianD = 0.05  # m
mu = np.log(medianD)
sigma = np.log(2)  # assume that D84 = sigma*D50
np.random.seed(0)
D = np.random.lognormal(
    mu, sigma, np.shape(element_id)
)  # (m) the diameter of grains in each parcel

time_arrival_in_link = np.random.rand(np.size(element_id), 1)
location_in_link = np.random.rand(np.size(element_id), 1)

variables = {
    "abrasion_rate": (["item_id"], abrasion_rate),
    "density": (["item_id"], density),
    "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
    "active_layer": (["item_id", "time"], active_layer),
    "location_in_link": (["item_id", "time"], location_in_link),
    "D": (["item_id", "time"], D),
    "volume": (["item_id", "time"], volume),
}

items = {"grid_element": "link", "element_id": element_id}

parcels1 = DataRecord(
    grid1,
    items=items,
    time=[0.0],
    data_vars=variables,
    dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
)

fd1 = FlowDirectorSteepest(grid1, "topographic__elevation")
fd1.run_one_step()

nst1 = NetworkSedimentTransporter(
    grid1,
    parcels1,
    fd1,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)
timesteps = 10  # total number of timesteps
dt = 60 * 60 * 24 * 1  # length of timestep (seconds)
for t in range(0, (timesteps * dt), dt):
    nst1.run_one_step(dt)

"""
## 2. Create and run an example of NST using a shapefile to define the network

First, we need to create an implementation of the Landlab NetworkModelGrid to plot. This example creates a grid based on a polyline shapefile.  
"""

datadir = ExampleData("io/shapefile", case="methow").base

shp_file = datadir / "MethowSubBasin.shp"
points_shapefile = datadir / "MethowSubBasin_Nodes_4.shp"

grid2 = read_shapefile(
    shp_file,
    points_shapefile=points_shapefile,
    node_fields=["usarea_km2", "Elev_m"],
    link_fields=["usarea_km2", "Length_m"],
    link_field_conversion={
        "usarea_km2": "drainage_area",
        "Slope": "channel_slope",
        "Length_m": "reach_length",
    },
    node_field_conversion={
        "usarea_km2": "drainage_area",
        "Elev_m": "topographic__elevation",
    },
    threshold=0.01,
)
grid2.at_node["bedrock__elevation"] = grid2.at_node["topographic__elevation"].copy()
grid2.at_link["channel_width"] = 1 * np.ones(grid2.number_of_links)
grid2.at_link["flow_depth"] = 0.9 * np.ones(grid2.number_of_links)

# element_id is the link on which the parcel begins.
element_id = np.repeat(np.arange(grid2.number_of_links), 50)
element_id = np.expand_dims(element_id, axis=1)

volume = 1 * np.ones(np.shape(element_id))  # (m3)
active_layer = np.ones(np.shape(element_id))  # 1= active, 0 = inactive
density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
abrasion_rate = 0 * np.ones(np.size(element_id))  # (mass loss /m)

# Lognormal GSD
medianD = 0.15  # m
mu = np.log(medianD)
sigma = np.log(2)  # assume that D84 = sigma*D50
np.random.seed(0)
D = np.random.lognormal(
    mu, sigma, np.shape(element_id)
)  # (m) the diameter of grains in each parcel

time_arrival_in_link = np.random.rand(np.size(element_id), 1)
location_in_link = np.random.rand(np.size(element_id), 1)

variables = {
    "abrasion_rate": (["item_id"], abrasion_rate),
    "density": (["item_id"], density),
    "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
    "active_layer": (["item_id", "time"], active_layer),
    "location_in_link": (["item_id", "time"], location_in_link),
    "D": (["item_id", "time"], D),
    "volume": (["item_id", "time"], volume),
}

items = {"grid_element": "link", "element_id": element_id}

parcels2 = DataRecord(
    grid2,
    items=items,
    time=[0.0],
    data_vars=variables,
    dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
)

fd2 = FlowDirectorSteepest(grid2, "topographic__elevation")
fd2.run_one_step()

nst2 = NetworkSedimentTransporter(
    grid2,
    parcels2,
    fd2,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)

for t in range(0, (timesteps * dt), dt):
    nst2.run_one_step(dt)

"""
## 3. Options for link color and link line widths

The dictionary below (`link_color_options`) outlines 4 examples of link color and line width choices: 
1. The default output of `plot_network_and_parcels`
2. Some simple modifications: the whole network is red, with a line width of 7, and no parcels.
3. Coloring links by an existing grid link attribute, in this case the total volume of sediment on the link (`grid.at_link.["sediment_total_volume"]`, which is created by the `NetworkSedimentTransporter`)
4. Similar to #3 above, but taking advantange of additional flexiblity in plotting
"""

network_norm = Normalize(-1, 6)  # see matplotlib.colors.Normalize

link_color_options = [
    {},  # empty dictionary = defaults
    {
        "network_color": "r",  # specify some simple modifications.
        "network_linewidth": 7,
        "parcel_alpha": 0,  # make parcels transparent (not visible)
    },
    {
        "link_attribute": "sediment_total_volume",  # color links by an existing grid link attribute
        "parcel_alpha": 0,
    },
    {
        "link_attribute": "sediment_total_volume",
        "network_norm": network_norm,  # and normalize color scheme
        "link_attribute_title": "Total Sediment Volume",  # title on link color legend
        "parcel_alpha": 0,
        "network_linewidth": 3,
    },
]

"""
Below, we implement these 4 plotting options, first for the synthetic network, and then for the shapefile-delineated network:
"""

for grid, parcels in zip([grid1, grid2], [parcels1, parcels2]):
    for l_opts in link_color_options:
        fig = plot_network_and_parcels(grid, parcels, parcel_time_index=0, **l_opts)
        plt.show()

"""
In addition to plotting link coloring using an existing link attribute, we can pass any array of size link. In this example, we color links using an array of random values. 
"""

random_link = np.random.randn(grid2.size("link"))

l_opts = {
    "link_attribute": random_link,  # use an array of size link
    "network_cmap": "jet",  # change colormap
    "network_norm": network_norm,  # and normalize
    "link_attribute_title": "A random number",
    "parcel_alpha": 0,
    "network_linewidth": 3,
}
fig = plot_network_and_parcels(grid2, parcels2, parcel_time_index=0, **l_opts)
plt.show()

"""
## 4. Options for parcel color

The dictionary below (`parcel_color_options`) outlines 4 examples of link color and line width choices: 
1. The default output of `plot_network_and_parcels`
2. Some simple modifications: all parcels are red, with a parcel size of 10
3. Color parcels by an existing parcel attribute, in this case the sediment diameter of the parcel (`parcels1.dataset['D']`)
4. Color parcels by an existing parcel attribute, but change the colormap. 
"""

parcel_color_norm = Normalize(0, 1)  # Linear normalization
parcel_color_norm2 = colors.LogNorm(vmin=0.01, vmax=1)

parcel_color_options = [
    {},  # empty dictionary = defaults
    {"parcel_color": "r", "parcel_size": 10},  # specify some simple modifications.
    {
        "parcel_color_attribute": "D",  # existing parcel attribute.
        "parcel_color_norm": parcel_color_norm,
        "parcel_color_attribute_title": "Diameter [m]",
        "parcel_alpha": 1.0,
    },
    {
        "parcel_color_attribute": "abrasion_rate",  # silly example, does not vary in our example
        "parcel_color_cmap": "bone",
    },
]

for grid, parcels in zip([grid1, grid2], [parcels1, parcels2]):
    for pc_opts in parcel_color_options:
        fig = plot_network_and_parcels(grid, parcels, parcel_time_index=0, **pc_opts)
        plt.show()

"""
## 5. Options for parcel size
The dictionary below (`parcel_size_options`) outlines 4 examples of link color and line width choices: 
1. The default output of `plot_network_and_parcels`
2. Set a uniform parcel size and color
3. Size parcels by an existing parcel attribute, in this case the sediment diameter (`parcels1.dataset['D']`), and making the parcel markers entirely opaque. 
4. Normalize parcel size on a logarithmic scale, and change the default maximum and minimum parcel sizes. 
"""

parcel_size_norm = Normalize(0, 1)
parcel_size_norm2 = colors.LogNorm(vmin=0.01, vmax=1)

parcel_size_options = [
    {},  # empty dictionary = defaults
    {"parcel_color": "b", "parcel_size": 10},  # specify some simple modifications.
    {
        "parcel_size_attribute": "D",  # use a parcel attribute.
        "parcel_size_norm": parcel_color_norm,
        "parcel_size_attribute_title": "Diameter [m]",
        "parcel_alpha": 1.0,  # default parcel_alpha = 0.5
    },
    {
        "parcel_size_attribute": "D",
        "parcel_size_norm": parcel_size_norm2,
        "parcel_size_min": 10,  # default = 5
        "parcel_size_max": 100,  # default = 40
        "parcel_alpha": 0.1,
    },
]

for grid, parcels in zip([grid1, grid2], [parcels1, parcels2]):
    for ps_opts in parcel_size_options:
        fig = plot_network_and_parcels(grid, parcels, parcel_time_index=0, **ps_opts)
        plt.show()

"""
## 6. Plotting a subset of the parcels

In some cases, we might want to plot only a subset of the parcels on the network. Below, we plot every 50th parcel in the `DataRecord`. 
"""

parcel_filter = np.zeros((parcels2.dataset.dims["item_id"]), dtype=bool)
parcel_filter[::50] = True
pc_opts = {
    "parcel_color_attribute": "D",  # a more complex normalization and a parcel filter.
    "parcel_color_norm": parcel_color_norm2,
    "parcel_color_attribute_title": "Diameter [m]",
    "parcel_alpha": 1.0,
    "parcel_size": 40,
    "parcel_filter": parcel_filter,
}
fig = plot_network_and_parcels(grid2, parcels2, parcel_time_index=0, **pc_opts)
plt.show()

"""
## 7. Select the parcel timestep to be plotted

As a default, `plot_network_and_parcels` plots parcel positions for the last timestep of the model run. However, `NetworkSedimentTransporter` tracks the motion of parcels for all timesteps. We can plot the location of parcels on the link at any timestep using `parcel_time_index`. 
"""

parcel_time_options = [0, 4, 7]

for grid, parcels in zip([grid1, grid2], [parcels1, parcels2]):
    for pt_opts in parcel_time_options:
        fig = plot_network_and_parcels(
            grid, parcels, parcel_size=20, parcel_alpha=0.1, parcel_time_index=pt_opts
        )
        plt.show()

"""
## 7. Combining network and parcel plotting options

Nothing will stop us from making all of the choices at once. 
"""

parcel_color_norm = colors.LogNorm(vmin=0.01, vmax=1)

parcel_filter = np.zeros((parcels2.dataset.dims["item_id"]), dtype=bool)
parcel_filter[::30] = True

fig = plot_network_and_parcels(
    grid2,
    parcels2,
    parcel_time_index=0,
    parcel_filter=parcel_filter,
    link_attribute="sediment_total_volume",
    network_norm=network_norm,
    network_linewidth=4,
    network_cmap="bone_r",
    parcel_alpha=1.0,
    parcel_color_attribute="D",
    parcel_color_norm=parcel_color_norm2,
    parcel_size_attribute="D",
    parcel_size_min=5,
    parcel_size_max=150,
    parcel_size_norm=parcel_size_norm,
    parcel_size_attribute_title="D",
)



================================================
File: docs/source/tutorials/network_sediment_transporter/network_sediment_transporter.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab NetworkSedimentTransporter component

This tutorial illustrates how to model the transport of coarse sediment through a synthetic river network using the NetworkSedimentTransporter Landlab component. 

For an equivalent tutorial demonstrating initialization of the NetworkSedimentTransporter with a *shapefile river network*, [click here](../network_sediment_transporter/network_sediment_transporter_shapefile_network.ipynb).

In this example we will: 
- create a synthetic Landlab grid to represent a river network
- create sediment "parcels" that will transport through the river network, represented as items in a Landlab DataRecord
- run the component
- plot the results of the model run
"""

"""
Import the necessary libraries, plus a bit of magic so that we can plot within this notebook:
"""

import warnings

warnings.filterwarnings("ignore")

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.data_record import DataRecord
from landlab.grid.network import NetworkModelGrid
from landlab.plot import graph, plot_network_and_parcels

%matplotlib inline

"""
## 1. Create the river network model grid

First, we need to create a Landlab NetworkModelGrid to represent the river network. Each link on the grid represents a reach of river. Each node represents a break between reaches. All tributary junctions must be associated with grid nodes. 
"""

y_of_node = (0, 100, 200, 200, 300, 400, 400, 125)
x_of_node = (0, 0, 100, -50, -100, 50, -150, -100)

nodes_at_link = ((1, 0), (2, 1), (1, 7), (3, 1), (3, 4), (4, 5), (4, 6))

grid = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)

plt.figure(0)
graph.plot_graph(grid, at="node,link")

"""
Our network consists of seven links between 8 nodes. X and Y, above, represent the plan-view coordinates of the node locations. Notes_at_link describes the node indices that are connedted by each link. For example, link 2 connects node 1 and node 7. 

Next, we need to populate the grid with the relevant topographic information: 
"""

grid.at_node["topographic__elevation"] = [0.0, 0.08, 0.25, 0.15, 0.25, 0.4, 0.8, 0.8]
grid.at_node["bedrock__elevation"] = [0.0, 0.08, 0.25, 0.15, 0.25, 0.4, 0.8, 0.8]

grid.at_link["flow_depth"] = 2.5 * np.ones(grid.number_of_links)  # m
grid.at_link["reach_length"] = 200 * np.ones(grid.number_of_links)  # m
grid.at_link["channel_width"] = 1 * np.ones(grid.number_of_links)  # m

"""
We must distinguish between topographic elevation (the top surface of the bed sediment) and bedrock elevation (the surface of the river in the absence of modeled sediment). 

Note that "reach_length" is defined by the user, rather than calculated as the minimum distance between nodes. This accounts for channel sinuosity. 

"""

"""
## 2. Create sediment 'parcels' in a DataRecord

We represent sediment in the network as discrete parcels (or packages) of grains of uniform size and characteristics. Each parcel is tracked through the network grid according to sediment transport and stratigraphic constraints. 

Parcels are tracked using the Landlab [DataRecord](../data_record/DataRecord_tutorial.ipynb).

First, let's create arrays with all of the essential sediment parcel variables: 
"""

# element_id is the link on which the parcel begins.
element_id = np.repeat(np.arange(grid.number_of_links), 30)
element_id = np.expand_dims(element_id, axis=1)

volume = 0.05 * np.ones(np.shape(element_id))  # (m3)
active_layer = np.ones(np.shape(element_id))  # 1= active, 0 = inactive
density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
abrasion_rate = 0 * np.ones(np.size(element_id))  # (mass loss /m)

# Lognormal GSD
medianD = 0.085  # m
mu = np.log(medianD)
sigma = np.log(2)  # assume that D84 = sigma*D50
np.random.seed(0)
D = np.random.lognormal(
    mu, sigma, np.shape(element_id)
)  # (m) the diameter of grains in each parcel

"""
In order to track sediment motion, we classify parcels as either active (representing mobile surface sediment) or inactive (immobile subsurface) during each timestep. The active parcels are the most recent parcels to arrive in the link. During a timestep, active parcels are transported downstream (increasing their `location_in_link`, which ranges from 0 to 1) according to a sediment transport formula. 

We begin by assigning each parcel an arbitrary (and small) arrival time and location in the link. 
"""

time_arrival_in_link = np.random.rand(np.size(element_id), 1)
location_in_link = np.random.rand(np.size(element_id), 1)

"""
In addition to the required parcel attributes listed above, you can designate optional parcel characteristics, depending on your needs. For example: 
"""

lithology = ["quartzite"] * np.size(element_id)

"""
We now collect the arrays into a dictionary of variables, some of which will be tracked through time (`["item_id", "time"]`), and others of which will remain constant through time :
"""

variables = {
    "abrasion_rate": (["item_id"], abrasion_rate),
    "density": (["item_id"], density),
    "lithology": (["item_id"], lithology),
    "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
    "active_layer": (["item_id", "time"], active_layer),
    "location_in_link": (["item_id", "time"], location_in_link),
    "D": (["item_id", "time"], D),
    "volume": (["item_id", "time"], volume),
}

"""
With all of the required attributes collected, we can create the parcels DataRecord. Often, parcels will eventually transport off of the downstream-most link. To track these parcels, we have designated a "`dummy_element`" here, which has index value `-2`. 
"""

items = {"grid_element": "link", "element_id": element_id}

parcels = DataRecord(
    grid,
    items=items,
    time=[0.0],
    data_vars=variables,
    dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
)

"""
## 3. Run the NetworkSedimentTransporter

With the parcels and grid set up, we can move on to setting up the model. 
"""

timesteps = 10  # total number of timesteps
dt = 60 * 60 * 24 * 1  # length of timestep (seconds)

"""
Before running the NST, we need to determine flow direction on the grid (upstream and downstream for each link). To do so, we initalize and run a Landlab flow director component: 
"""

fd = FlowDirectorSteepest(grid, "topographic__elevation")
fd.run_one_step()

"""
Then, we initialize the network sediment transporter: 
"""

nst = NetworkSedimentTransporter(
    grid,
    parcels,
    fd,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)

"""
Now we are ready to run the model forward in time: 
"""

for t in range(0, (timesteps * dt), dt):
    nst.run_one_step(dt)
    print("Model time: ", t / dt, "timesteps passed")

"""
## 4. Plot the model results


There are landlab plotting tools specific to the `NetworkSedimentTransporter`. In particular, `plot_network_and_parcels` creates a plan-view map of the network and parcels (represented as dots along the network). We can color both the parcels and the links by attributes.  

Here, we demonstrate one example use of `plot_network_and_parcels`, which creates a plan-view map of the network and parcels (represented as dots along the network). We can color both the parcels and the links by attributes. For a thorough tutorial on the plotting tools, see [this notebook](../network_sediment_transporter/network_plotting_examples.ipynb).

Below, each link (represented as a line) is colored by the total volume of sediment on the link. Each parcel is colored by the parcel grain size. 
"""

fig = plot_network_and_parcels(
    grid,
    parcels,
    parcel_time_index=0,
    parcel_color_attribute="D",
    link_attribute="sediment_total_volume",
    parcel_size=10,
    parcel_alpha=1.0,
)

"""
In addition, the results of the NST can be visualized by directly accessing information about the grid, the parcels, and by accessing variables stored after the run of NST. 

As a simple example, we can plot the total transport distance of all parcels through the model run as a function of parcel diameter. 
"""

plt.loglog(parcels.dataset.D[:, -1], nst._distance_traveled_cumulative, ".")
plt.xlabel("Parcel grain size (m)")
plt.ylabel("Cumulative parcel travel distance")

# Note: some of the smallest grain travel distances can exceed the length of the
# grid by "overshooting" during a single timestep of high transport rate

"""
Great, smaller parcels transport farther! 
"""



================================================
File: docs/source/tutorials/network_sediment_transporter/network_sediment_transporter_NHDPlus_HR_network.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using USGS NHDPlus HR Datasets With the Landlab NetworkSedimentTransporter Component 


This tutorial illustrates how to use [USGS NHDPlus HR datasets](https://www.usgs.gov/core-science-systems/ngp/national-hydrography/nhdplus-high-resolution) with the NetworkSedimentTransporter. Before they can be imported into Landlab, NHDPlus HR shapefiles must be preprocessed in GIS to import hydraulic attributes, fix topological issues, and generate nodes. The "Soque_Links.shp" and "Soque_Nodes.shp" files used in this example were prepared following QGIS procedures archived [here](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/QE7MTG). 

**Part 1**: Here, we demonstrate how to import the files into Landlab, convert the shapefile attributes, and remove flat areas from the topograpghy. 

**Parts 2 - 5**: These cells are copied nearly verbatim from the Landlab notebook _"Using the Landlab NetworkSedimentTransporter component starting with a shapefile river network"_. The only differences are the values of  _timesteps_ (cell 16), _dt_ (cell 16), and _originating_link_ (cell 20). This is to demonstrate how the code in Part 1 allows the files to behave exactly the same as the MethowSubBasin shapefiles used in other notebooks.
"""

import warnings

warnings.filterwarnings(
    "ignore", category=UserWarning, module=".*network_sediment_transporter"
)

import functools

import matplotlib.pyplot as plt
import numpy as np
import xarray as xr
from tqdm import tqdm

from landlab import ExampleData
from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.data_record import DataRecord
from landlab.io import read_shapefile
from landlab.plot import graph, plot_network_and_parcels

"""
## 1. Load the Preprocessed NHDPlus HR Files

First, we load the preprocessed shapefiles.
"""

datadir = ExampleData("io/shapefile", case="soque").base

link_shp = datadir / "Soque_Links.shp"
node_shp = datadir / "Soque_Nodes.shp"

"""
Next, we initiate the grid, identify the pour point node, convert the attribute formats so Landlab can read them, and convert some units.
"""

# Initiate grid
grid = read_shapefile(
    file=link_shp,
    points_shapefile=node_shp,
    link_fields=["TotDASqKm", "Slope", "LengthKM", "MaxElevSmo"],
    node_fields=["TotDASqKm", "Slope", "LengthKM", "MaxElevSmo"],
    link_field_conversion={
        "TotDASqKm": "drainage_area",
        "Slope": "channel_slope",
        "LengthKM": "reach_length",
        "MaxElevSmo": "topographic__elevation",
    },
    node_field_conversion={
        "TotDASqKm": "drainage_area",
        "Slope": "channel_slope",
        "LengthKM": "reach_length",
        "MaxElevSmo": "topographic__elevation",
    },
    threshold=0.01,
    store_polyline_vertices=True,
)

# Identify pour point node ID
watershed_pour_point = np.where(np.isnan(grid.at_node["drainage_area"]))

# Give pour point node the same attributes (plus / minus a small amount) as the node immediately upstream on the main stem
largest_neighbor = np.max(
    grid.at_node["drainage_area"][grid.adjacent_nodes_at_node[watershed_pour_point]]
)
# POUR POINT NODE DRAINAGE AREA IS 0.1% LARGER THAN ITS NEAREST MAINSTEM NEIGHBOR NODE
grid.at_node["drainage_area"][watershed_pour_point] = largest_neighbor * 1.001

smallest_neighbor = np.min(
    grid.at_node["drainage_area"][grid.adjacent_nodes_at_node[watershed_pour_point]]
)

# POUR POINT NODE ELEVATION IS ([NEAREST MAINSTEM NEIGHBOR NODE ELEVATION] - [MINIMUM SLOPE IN NHDPLUS DATASET])
grid.at_node["topographic__elevation"][watershed_pour_point] = (
    smallest_neighbor - np.min(grid.at_link["channel_slope"])
)


# Convert units
grid.at_link["drainage_area"] *= 1000000.0  # Convert km^2 TO m^2
grid.at_node["drainage_area"] *= 1000000.0  # Convert km^2 TO m^2
grid.at_link["reach_length"] *= 1000.0  # Convert km TO m
grid.at_node["reach_length"] *= 1000.0  # Convert km TO m
grid.at_link["topographic__elevation"] /= 100.0  # Convert cm to m
grid.at_node["topographic__elevation"] /= 100.0  # Convert cm to m

"""
Finally, we have to deal with cetain areas of the grid called "flats". These occur where two or more adjacent nodes have the same topographic elevation, creating an effective slope of zero between them. The NHDPlus HR datasets assign these areas a slope value of 1E-5 so that there are not any zeros:
"""

np.nanmin(grid.at_node["channel_slope"])

"""
As you can see, the smallest slope value is 1E-5 (we use the numpy.nanmin function because the value of the pour point node is "nan"). However, the Landlab flow directors independantly use topographic elevation to calculate slope. This can result in zeros that confuse the flow directors. 

We can solve this by performing a "carve". We will loop through each node on the grid and calculate the downstream path from that location. Wherever we encounter a flat, we will adjust the topographic elevation by subtracting a height equal to the length of that reach multiplyed by the minimum slope assigned by the NHDPlus HR datatables (1E-5).
"""

# Create array that will store terminal flat areas for each node
downstream_nodes = np.zeros(grid.number_of_nodes, dtype=int)

# For each node, identify terminal flat node
for i in grid.nodes:
    adjacent_nodes = grid.adjacent_nodes_at_node[i]
    adjacent_nodes = np.append(adjacent_nodes, i)
    adjacent_nodes = np.delete(adjacent_nodes, np.where(adjacent_nodes == -1))
    adjacent_nodes_DA = grid.at_node["drainage_area"][adjacent_nodes]
    downstream_id = np.where(adjacent_nodes_DA == np.max(adjacent_nodes_DA))
    downstream_id = functools.reduce(lambda sub, elem: sub * 10 + elem, downstream_id)
    if np.size(downstream_id) > 1:
        downstream_nodes[i] = -1  # np.nan
    else:
        downstream_nodes[i] = adjacent_nodes[downstream_id]
downstream_nodes[watershed_pour_point] = -1  # np.nan
# downstream_nodes = downstream_nodes.astype(np.int)

# Create array to store new elevations
carve = np.ones(grid.number_of_nodes) * grid.at_node["topographic__elevation"]

# Calculate carve
for i in grid.nodes:
    current_node = i
    q = 1
    while q == 1:
        downstream_node = downstream_nodes[current_node]
        if downstream_node >= 0:
            current_node_elev = carve[current_node]
            downstream_node_elev = carve[downstream_node]
            if downstream_node_elev < current_node_elev:
                current_node = downstream_node
            if downstream_node_elev >= current_node_elev:
                carve[downstream_node] = carve[current_node] - (
                    grid.at_node["channel_slope"][current_node]
                    * grid.at_node["reach_length"][current_node]
                )
            if current_node == watershed_pour_point:
                q = 0
        if downstream_node < 0:
            q = 0

# Record amount carved
carve_delta = grid.at_node["topographic__elevation"] - carve

# Perform carve
grid.at_node["topographic__elevation"] = carve

"""
The variable "carve_delta" records how much height was subtrated from each node. We can use it to view some statistics on how much we altered the topography:
"""

plt.bar(grid.nodes, carve_delta)
plt.xlabel("Node ID")
plt.ylabel("Vertical distance carved (m)")

print("Total number of nodes carved = ", np.count_nonzero(carve_delta))
print(
    "Percent of nodes carved = ",
    (np.count_nonzero(carve_delta) / grid.number_of_nodes) * 100,
    "%",
)
print("Maximum distance carved = ", np.max(carve_delta), "m")
print(
    "Mean distance (+/- 1-sigma) carved = ",
    np.mean(carve_delta[np.nonzero(carve_delta)]),
    "+/-",
    np.std(carve_delta[np.nonzero(carve_delta)]),
    "m",
)

"""
As you can see, the adjustments we made to the topography were very small (no more than a few millimeters at most). This means it is very unlikely that these changes will significantly affect the model behavior. 
"""

"""
## 2. Review the Grid and Add Parameters 

Alright, let's see what fields we read in with this shapefile:
"""

grid.at_link.keys()

grid.at_node.keys()

"""
Great! Looks like we have length (reach length), upstream drainage area (drainage area), x and y verticies of each link/reach (x and y of polyline), and bed elevation (topographic elevation).

Note that "reach_length" is defined by the user, rather than calculated as the minimum distance between nodes. This accounts for channel sinuosity. In this case, "reach_length" could be equivalently calculated as the cumulative distance between verticies defined by x and y of polyline.
"""

graph.plot_graph(grid, at="node,link")

grid.number_of_links

grid.number_of_nodes

"""
Our network consists of 317 links between 318 nodes. In the plot above, X and Y represent the plan-view coordinates of the node locations. 

Next, we need to populate the grid with the relevant topographic and hydrologic information: 
"""

grid.at_node["bedrock__elevation"] = grid.at_node["topographic__elevation"].copy()

grid.at_link["channel_width"] = 1 * np.ones(grid.number_of_links)  # m

grid.at_link["flow_depth"] = 0.5 * np.ones(grid.number_of_links)  # m

"""
We must distinguish between topographic elevation (the top surface of the bed sediment) and bedrock elevation (the surface of the river in the absence of modeled sediment).
"""

"""
## 3. Create sediment 'parcels' in a DataRecord

We represent sediment in the network as discrete parcels (or packages) of grains of uniform size and characteristics. Each parcel is tracked through the network grid according to sediment transport and stratigraphic constraints. 

Parcels are tracked using the Landlab [DataRecord](../data_record/DataRecord_tutorial.ipynb).

First, let's create arrays with all of the essential sediment parcel variables: 
"""

# element_id is the link on which the parcel begins.
element_id = np.repeat(np.arange(grid.number_of_links), 50)
element_id = np.expand_dims(element_id, axis=1)

volume = 1 * np.ones(np.shape(element_id))  # (m3)
active_layer = np.ones(np.shape(element_id))  # 1= active, 0 = inactive
density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
abrasion_rate = 0 * np.ones(np.size(element_id))  # (mass loss /m)

# Lognormal GSD
medianD = 0.15  # m
mu = np.log(medianD)
sigma = np.log(2)  # assume that D84 = sigma*D50
np.random.seed(0)
D = np.random.lognormal(
    mu, sigma, np.shape(element_id)
)  # (m) the diameter of grains in each parcel

"""
In order to track sediment motion, we classify parcels as either active (representing mobile surface sediment) or inactive (immobile subsurface) during each timestep. The active parcels are the most recent parcels to arrive in the link. During a timestep, active parcels are transported downstream (increasing their `location_in_link`, which is a normalized value ranging from 0 to 1) according to a sediment transport formula. 

We begin by assigning each parcel an arbitrary (and small) arrival time and location in the link. 
"""

time_arrival_in_link = np.random.rand(np.size(element_id), 1)
location_in_link = np.random.rand(np.size(element_id), 1)

"""
In addition to the required parcel attributes listed above, you can designate optional parcel characteristics, depending on your needs. For example: 
"""

lithology = ["quartzite"] * np.size(element_id)

"""
We now collect the arrays into a dictionary of variables, some of which will be tracked through time (`["item_id", "time"]`), and others of which will remain constant through time :
"""

variables = {
    "abrasion_rate": (["item_id"], abrasion_rate),
    "density": (["item_id"], density),
    "lithology": (["item_id"], lithology),
    "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
    "active_layer": (["item_id", "time"], active_layer),
    "location_in_link": (["item_id", "time"], location_in_link),
    "D": (["item_id", "time"], D),
    "volume": (["item_id", "time"], volume),
}

"""
With all of the required attributes collected, we can create the parcels DataRecord. Often, parcels will eventually transport off of the downstream-most link. To track these parcels, we have designated a "`dummy_element`" here, which has index value `-2`. 
"""

items = {"grid_element": "link", "element_id": element_id}

parcels = DataRecord(
    grid,
    items=items,
    time=[0.0],
    data_vars=variables,
    dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
)

"""
## 4. Run the NetworkSedimentTransporter

With the parcels and grid set up, we can move on to setting up the model. 
"""

timesteps = 20  # total number of timesteps
dt = 60 * 60 * 24 * 10  # length of timestep (seconds)

"""
Before running the NST, we need to determine flow direction on the grid (upstream and downstream for each link). To do so, we initalize and run a Landlab flow director component: 
"""

fd = FlowDirectorSteepest(grid, "topographic__elevation")
fd.run_one_step()

"""
Then, we initialize the network sediment transporter: 
"""

nst = NetworkSedimentTransporter(
    grid,
    parcels,
    fd,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)

"""
Now we are ready to run the model forward in time: 
"""

for t in tqdm(range(0, (timesteps * dt), dt)):
    nst.run_one_step(dt)

"""
## 5. Plot the model results

There are landlab plotting tools specific to the `NetworkSedimentTransporter`. In particular, `plot_network_and_parcels` creates a plan-view map of the network and parcels (represented as dots along the network). We can color both the parcels and the links by attributes.  

Here, we demonstrate one example use of `plot_network_and_parcels`. For a thorough tutorial on the plotting tools, see [this notebook](../network_sediment_transporter/network_plotting_examples.ipynb).

"""

"""
We can color links by values that we calculate. For example, if we are curious about the fate of sediment that started out on link 300 (in the far northwest corner of the basin), we might want to plot the total volume of sediment that originated on link 300 during a later timestep:
"""

timestep_of_interest = 6
originating_link = 300

# filter the parcels to calculate total volumes of only the parcels that originated in the chosen link
parcelfilter = np.zeros_like(parcels.dataset.element_id, dtype=bool)
parcelfilter[:, timestep_of_interest] = (
    parcels.dataset.element_id[:, 0] == originating_link
)

vol_orig_link = parcels.calc_aggregate_value(
    xr.Dataset.sum, "volume", at="link", filter_array=parcelfilter, fill_value=0.0
)

fig = plot_network_and_parcels(
    grid,
    parcels,
    link_attribute=vol_orig_link,
    link_attribute_title="Vol of sed originating on link x",
    network_linewidth=5,
    parcel_alpha=0,
)

"""
### Non-network plotting
The results of the NST can be visualized by directly accessing information about the grid, the parcels, and by accessing variables stored after the run of NST. 

As a simple example, we can plot the total volume of parcels on the grid through time. As parcels exit the grid, the total volume decreases.  
"""

parcel_vol_on_grid = parcels.dataset["volume"].values
parcel_vol_on_grid[parcels.dataset["element_id"].values == -2] = 0

# plt.figure(figsize=(8,6))
plt.plot(
    np.asarray(parcels.time_coordinates) / (60 * 60 * 24),
    np.sum(parcel_vol_on_grid, axis=0),
    "-",
    linewidth=3,
    alpha=0.5,
)

plt.ylabel("Total volume of parcels on grid $[m^3]$")
plt.xlabel("Time [days]")
plt.show()

"""
We can also plot individual parcel characteristics. The plot below shows the total transport distance of each parcel through the whole model run as a function of the parcel's grain size (during the final timestep). 
"""

plt.loglog(parcels.dataset.D[:, -1], nst._distance_traveled_cumulative, ".")
plt.xlabel("Parcel grain size (m)")
plt.ylabel("Cumulative parcel travel distance (m)")

# Note: some of the smallest grain travel distances can exceed the length of the
# grid by "overshooting" during a single timestep of high transport rate

"""
The plot below is an example of accessing variables associated with the grid (`grid.at_link.X`, or `grid.at_node.X`), as well as a variable associated with this instance of NetworkModelGrid (`nmg.X`):
"""

plt.plot(grid.at_link["channel_slope"], nst.d_mean_active, ".")
plt.xlabel("Channel slope (m/m)")
plt.ylabel("Mean grain size of active layer (m)")



================================================
File: docs/source/tutorials/network_sediment_transporter/network_sediment_transporter_shapefile_network.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab NetworkSedimentTransporter component starting with a shapefile river network

This tutorial illustrates how to model the transport of coarse sediment through a river network using the NetworkSedimentTransporter Landlab component. For an equivalent tutorial demonstrating initialization of the NetworkSedimentTransporter with a *synthetic network model grid*, [here](../network_sediment_transporter/network_sediment_transporter.ipynb).


In this example we will: 
- load a river network shapefile to create a Landlab grid to represent a river network
- create sediment "parcels" that will transport through the river network, represented as items in a Landlab DataRecord
- run the component
- plot the results of the model run
"""

"""
Import the necessary libraries, plus a bit of magic so that we can plot within this notebook:
"""

import warnings

warnings.filterwarnings("ignore")

import matplotlib.pyplot as plt
import numpy as np
import xarray as xr

from landlab import ExampleData
from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.data_record import DataRecord
from landlab.io import read_shapefile
from landlab.plot import graph, plot_network_and_parcels

"""
## 1. Load a shapefile that represents the river network

First, we need to create a Landlab NetworkModelGrid to represent the river network. Each link on the grid represents a reach of river. Each node represents a break between reaches. All tributary junctions must be associated with grid nodes. 
"""

datadir = ExampleData("io/shapefile", case="methow").base

shp_file = datadir / "MethowSubBasin.shp"
points_shapefile = datadir / "MethowSubBasin_Nodes_4.shp"

grid = read_shapefile(
    shp_file,
    points_shapefile=points_shapefile,
    node_fields=["usarea_km2", "Elev_m"],
    link_fields=["usarea_km2", "Length_m"],
    link_field_conversion={
        "usarea_km2": "drainage_area",
        "Slope": "channel_slope",
        "Length_m": "reach_length",
    },
    node_field_conversion={
        "usarea_km2": "drainage_area",
        "Elev_m": "topographic__elevation",
    },
    threshold=0.01,
)

"""
Alright, let's see what fields we read in with this shapefile:
"""

grid.at_link.keys()

grid.at_node.keys()

"""
Great! Looks like we have length (reach length), upstream drainage area (drainage area), x and y verticies of each link/reach (x and y of polyline), and bed elevation (topographic elevation).

Note that "reach_length" is defined by the user, rather than calculated as the minimum distance between nodes. This accounts for channel sinuosity. In this case, "reach_length" could be equivalently calculated as the cumulative distance between verticies defined by x and y of polyline.
"""

graph.plot_graph(grid, at="node,link")

grid.number_of_links

grid.number_of_nodes

"""
Our network consists of 29 links between 30 nodes. In the plot above, X and Y represent the plan-view coordinates of the node locations. 

Next, we need to populate the grid with the relevant topographic and hydrologic information: 
"""

grid.at_node["bedrock__elevation"] = grid.at_node["topographic__elevation"].copy()

grid.at_link["channel_width"] = 1 * np.ones(grid.number_of_links)  # m

grid.at_link["flow_depth"] = 0.5 * np.ones(grid.number_of_links)  # m

"""
We must distinguish between topographic elevation (the top surface of the bed sediment) and bedrock elevation (the surface of the river in the absence of modeled sediment).
"""

"""
## 2. Create sediment 'parcels' in a DataRecord

We represent sediment in the network as discrete parcels (or packages) of grains of uniform size and characteristics. Each parcel is tracked through the network grid according to sediment transport and stratigraphic constraints. 

Parcels are tracked using the Landlab [DataRecord](../data_record/DataRecord_tutorial.ipynb).

First, let's create arrays with all of the essential sediment parcel variables: 
"""

# element_id is the link on which the parcel begins.
element_id = np.repeat(np.arange(grid.number_of_links), 50)
element_id = np.expand_dims(element_id, axis=1)

volume = 1 * np.ones(np.shape(element_id))  # (m3)
active_layer = np.ones(np.shape(element_id))  # 1= active, 0 = inactive
density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
abrasion_rate = 0 * np.ones(np.size(element_id))  # (mass loss /m)

# Lognormal GSD
medianD = 0.15  # m
mu = np.log(medianD)
sigma = np.log(2)  # assume that D84 = sigma*D50
np.random.seed(0)
D = np.random.lognormal(
    mu, sigma, np.shape(element_id)
)  # (m) the diameter of grains in each parcel

"""
In order to track sediment motion, we classify parcels as either active (representing mobile surface sediment) or inactive (immobile subsurface) during each timestep. The active parcels are the most recent parcels to arrive in the link. During a timestep, active parcels are transported downstream (increasing their `location_in_link`, which is a normalized value ranging from 0 to 1) according to a sediment transport formula. 

We begin by assigning each parcel an arbitrary (and small) arrival time and location in the link. 
"""

time_arrival_in_link = np.random.rand(np.size(element_id), 1)
location_in_link = np.random.rand(np.size(element_id), 1)

"""
In addition to the required parcel attributes listed above, you can designate optional parcel characteristics, depending on your needs. For example: 
"""

lithology = ["quartzite"] * np.size(element_id)

"""
We now collect the arrays into a dictionary of variables, some of which will be tracked through time (`["item_id", "time"]`), and others of which will remain constant through time :
"""

variables = {
    "abrasion_rate": (["item_id"], abrasion_rate),
    "density": (["item_id"], density),
    "lithology": (["item_id"], lithology),
    "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
    "active_layer": (["item_id", "time"], active_layer),
    "location_in_link": (["item_id", "time"], location_in_link),
    "D": (["item_id", "time"], D),
    "volume": (["item_id", "time"], volume),
}

"""
With all of the required attributes collected, we can create the parcels DataRecord. Often, parcels will eventually transport off of the downstream-most link. To track these parcels, we have designated a "`dummy_element`" here, which has index value `-2`. 
"""

items = {"grid_element": "link", "element_id": element_id}

parcels = DataRecord(
    grid,
    items=items,
    time=[0.0],
    data_vars=variables,
    dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
)

"""
## 3. Run the NetworkSedimentTransporter

With the parcels and grid set up, we can move on to setting up the model. 
"""

timesteps = 10  # total number of timesteps
dt = 60 * 60 * 24 * 2  # length of timestep (seconds)

"""
Before running the NST, we need to determine flow direction on the grid (upstream and downstream for each link). To do so, we initalize and run a Landlab flow director component: 
"""

fd = FlowDirectorSteepest(grid, "topographic__elevation")
fd.run_one_step()

"""
Then, we initialize the network sediment transporter: 
"""

nst = NetworkSedimentTransporter(
    grid,
    parcels,
    fd,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)

"""
Now we are ready to run the model forward in time: 
"""

for t in range(0, (timesteps * dt), dt):
    nst.run_one_step(dt)

    print("Model time: ", t / (60 * 60 * 24), "days passed")

"""
## 4. Plot the model results

There are landlab plotting tools specific to the `NetworkSedimentTransporter`. In particular, `plot_network_and_parcels` creates a plan-view map of the network and parcels (represented as dots along the network). We can color both the parcels and the links by attributes.  

Here, we demonstrate one example use of `plot_network_and_parcels`. For a thorough tutorial on the plotting tools, see [this notebook](../network_sediment_transporter/network_plotting_examples.ipynb).

"""

"""
We can color links by values that we calculate. For example, if we are curious about the fate of sediment that started out on link 27, we might want to plot the total volume of sediment that originated on link 27 during a later timestep:
"""

timestep_of_interest = 6
originating_link = 27

# filter the parcels to calculate total volumes of only the parcels that originated in the chosen link
parcelfilter = np.zeros_like(parcels.dataset.element_id, dtype=bool)
parcelfilter[:, timestep_of_interest] = (
    parcels.dataset.element_id[:, 0] == originating_link
)

vol_orig_link = parcels.calc_aggregate_value(
    xr.Dataset.sum, "volume", at="link", filter_array=parcelfilter, fill_value=0.0
)

fig = plot_network_and_parcels(
    grid,
    parcels,
    link_attribute=vol_orig_link,
    link_attribute_title="Vol of sed originating on link x",
    network_linewidth=5,
    parcel_alpha=0,
)

"""
### Non-network plotting
The results of the NST can be visualized by directly accessing information about the grid, the parcels, and by accessing variables stored after the run of NST. 

As a simple example, we can plot the total volume of parcels on the grid through time. As parcels exit the grid, the total volume decreases.  
"""

parcel_vol_on_grid = parcels.dataset["volume"].values
parcel_vol_on_grid[parcels.dataset["element_id"].values == -2] = 0

# plt.figure(figsize=(8,6))
plt.plot(
    np.asarray(parcels.time_coordinates) / (60 * 60 * 24),
    np.sum(parcel_vol_on_grid, axis=0),
    "-",
    linewidth=3,
    alpha=0.5,
)

plt.ylabel("Total volume of parcels on grid $[m^3]$")
plt.xlabel("Time [days]")
plt.show()

"""
We can also plot individual parcel characteristics. The plot below shows the total transport distance of each parcel through the whole model run as a function of the parcel's grain size (during the final timestep). 
"""

plt.loglog(parcels.dataset.D[:, -1], nst._distance_traveled_cumulative, ".")
plt.xlabel("Parcel grain size (m)")
plt.ylabel("Cumulative parcel travel distance (m)")

# Note: some of the smallest grain travel distances can exceed the length of the
# grid by "overshooting" during a single timestep of high transport rate

"""
The plot below is an example of accessing variables associated with the grid (`grid.at_link.X`, or `grid.at_node.X`), as well as a variable associated with this instance of NetworkModelGrid (`nmg.X`):
"""

plt.plot(grid.at_link["channel_slope"], nst.d_mean_active, ".")
plt.xlabel("Channel slope (m/m)")
plt.ylabel("Mean grain size of active layer (m)")



================================================
File: docs/source/tutorials/network_sediment_transporter/nst_scaling_profiling.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Profiling and Scaling Analysis of the NetworkSedimentTransporter

Planning to run the NetworkSedimentTransporter (NST) on a large river network, or for a long time? You might wonder: how efficient is this component? 

Most field-scale applications of the NST would likley have 100-500 links in the network and be initialized with at least 100 parcels per link (e.g., up to 50k+ parcels). This number of parcels per link are commonly need to capture the full grain size distribution. 

Because the component may use many parcels on many links, we will want to assess two parts of the components efficiency. First, we will *profile* the code to see what happens each time the component runs. This is useful to see which parts of the computation take the most time and occur the most often. If code is running too slowly, it is usefull to profile it in order to identify which parts may yield the biggest speedups. 

The second goal is *scaling*, or seeing how changes in the number of parcels and links changes run time. If doubling the number of links doubled the run time, we would say that runtime for the component "scales linearly" with the number of links. In computer science this is often called the [time complexity](https://en.wikipedia.org/wiki/Time_complexity) of the code/algorithm. 

The goal of this notebook is to explore profiling and scaling with the NST. We will look at how changing the grid nodes and number of parcels per link impacts the initialization and run time of this component. In order to do this we will need to make some python functions to create variably sized grids. We will also use some common python tools for profiling code. The notebook is organized into three parts:

- Part 1: Create generic, variable sized grids and parcels. 

- Part 2: Profiling the code.

- Part 3: Scaling analysis.

We begin by importaing all needed python modules. 
"""

import cProfile
import io
import pstats
import time
import warnings
from pstats import SortKey

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.data_record import DataRecord
from landlab.grid.network import NetworkModelGrid
from landlab.plot import graph

warnings.filterwarnings("ignore")

"""
## Part 1: Variably-sized grids and parcels

### Part 1a: Grid topology

First, we need the ability to create different sizes of network model grids. We will use these different size grids to assess how long it takes the NST to run with different grid sizes. 

A simple approach is to create a generic grid in which each node has two recievers. Lets start by writing a function that creates the x and y node coordinates and the linking structure for a given number of layers.   

While these grids do not look like typical river networks, they are topologically similar. 

We create a function `create_node_xy_and_links` which takes the following inputs

- `n_layers`
- `x0`
- `y0`
- `x_perc`
- `dy`

and returns three arrays:
- `x_of_node`
- `y_of_node`
- `nodes_at_link`

These inputs and outputs are defined in the function docstring below. The function was designed to produce output that could be directly provided to the [`NetworkModelGrid`](https://landlab.csdms.io/generated/api/landlab.grid.network.html) init function. 
"""

def create_node_xy_and_links(n_layers, x0=0.0, y0=0.0, xperc=0.9, dy=1.0):
    r"""Create node and link structure of a branching binary tree.

    The tree can have an arbitrary number of layers. For example,
    a tree with one layer has three nodes and two links:

    ::

        *   *
         \ /
          *

    The lowest of the nodes is the "origin" node, and has coordinates
    of `(x0, y0)`. The y spacing between layers is given by `dy`. Finally,
    in order to ensure that links do not cross and nodes are not co-located
    a shrinking factor, `xperc` that must be less than 1.0 is specified.

    Each layer has 2^{layer} nodes: Layer 0 has 1 node, layer 1 has 2 nodes,
    layer 2 has 4 nodes.

    A tree with three layers has seven nodes and six links:

    ::

      *   * *   *
       \ /   \ /
        *     *
         \   /
           *

    Parameters
    ----------
    n_layers : int
        Number of layers of the binary tree
    x0 : float
        x coordinate position of the origin node. Default of 0.
    y0=0. : float
        y coordinate position of the origin node. Default of 0.
    xperc : float
        x direction shrinkage factor to prevent co-location of nodes
        and corssing links. Must be between 0.0 and 1.0 noninclusive.
        Default of 0.9.
    dy : float
        y direction spacing between layers. Default of 1.

    Returns
    ------
    x_of_node : list
        Node x coordinates.
    y_of_node : list
        Node y coordinates.
    nodes_at_link : list of (head, tail) tuples
        Nodes at link tail and head.

    """
    assert xperc < 1.0
    assert xperc > 0.0
    nodes_per_layer = np.power(2, np.arange(n_layers + 1))
    np.sum(nodes_per_layer)
    x_of_node = [x0]
    y_of_node = [y0]
    nodes_at_link = []
    id_start_layer = 0
    for nl in np.arange(1, n_layers + 1):
        nodes_last_layer = np.power(2, nl - 1)
        nodes_this_layer = np.power(2, nl)
        dx = xperc * (dy) * (0.5 ** (nl - 1))
        for ni in range(nodes_last_layer):
            head_id = id_start_layer + ni
            tail_id = len(x_of_node)
            x = x_of_node[head_id]
            y = y_of_node[head_id]
            x_of_node.extend([x - dx, x + dx])
            y_of_node.extend([y + dy, y + dy])
            nodes_at_link.extend([(head_id, tail_id), (head_id, tail_id + 1)])
        id_start_layer = len(x_of_node) - nodes_this_layer
    return x_of_node, y_of_node, nodes_at_link

"""
Next, let's demonstrate the different sorts of grids we get with different numbers of layers. We'll look at grids with between 3 and 1023 nodes. 
"""

example_layers = [1, 3, 5, 7, 9]

nodes = []
for i, n_layers in enumerate(example_layers):
    x_of_node, y_of_node, nodes_at_link = create_node_xy_and_links(n_layers)
    grid = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)

    graph.plot_graph(grid, at="node,link", with_id=False)
    nodes.append(grid.number_of_nodes)

"""
We can see the number of nodes grows exponentially with the number of layers. 
"""

plt.plot(example_layers, nodes)
plt.xlabel("Number of Layers")
plt.ylabel("Number of Nodes")
plt.show()

"""
### 1b: Generic grid.

In order to run the NST, our grids need fields related to channel geometry and flow characteristics. Here, we'll create a function that takes only the number of layers and uses the function `create_node_xy_and_links` that we just created, creates a grid, adds, those fields and populate them with generic values. The NST also needs a [`FlowDirectorSteepest`](https://landlab.csdms.io/generated/api/landlab.components.flow_director.flow_director_steepest.html) instance, so we'll create that too. 

Thus, with these two functions we can specifiy the desired number of layers and get both of these objects we need to instantiate the NST. 
"""

def create_nmg_and_fd(n_layers):
    """Create a generic NetworkModelGrid and FlowDirectorSteepest.

    This function will also add the following fields to the NetworkModelGrid.

    - topographic__elevation at node
    - bedrock__elevation at node
    - flow_depth at link
    - reach_length at link
    - channel_width at link.

    Parameters
    ----------
    n_layers : int
        Number of layers of the binary tree

    Returns
    -------
    grid : NetworkModelGrid instance
    fd : FlowDirectorSteepest instance
    """
    x_of_node, y_of_node, nodes_at_link = create_node_xy_and_links(n_layers)
    grid = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)

    _ = grid.add_field("topographic__elevation", grid.y_of_node.copy(), at="node")
    _ = grid.add_field("bedrock__elevation", grid.y_of_node.copy(), at="node")
    _ = grid.add_field(
        "flow_depth", 2.5 * np.ones(grid.number_of_links), at="link"
    )  # m
    _ = grid.add_field(
        "reach_length", 200.0 * np.ones(grid.number_of_links), at="link"
    )  # m
    _ = grid.add_field(
        "channel_width", 1.0 * np.ones(grid.number_of_links), at="link"
    )  # m

    fd = FlowDirectorSteepest(grid)
    fd.run_one_step()
    return grid, fd

"""
### 1c: Generic sets of parcels
Our second to last step in writing functions to create a generic model grid and set of parcels is to create a function that will create our parcels. The parcels are associated with the grid because parcels must be located on a grid element, and thus we will always need the grid to create the parcels. 
"""

def create_parcels(grid, parcels_per_link=5):
    """Create a generic set of parcels.

    The NetworkSedimentTransporter requires a set of parcels with some
    specific attributes (e.g., density) that are used in order to
    calculate travel distances. This function creates the parcels in
    the correct format and populates all necessary attributes. Specifically
    it creates the following attributes:

    - "abrasion_rate"
    - "density"
    - "time_arrival_in_link"
    - "active_layer"
    - "location_in_link"
    - "D"
    - "volume"

    Parameters
    ----------
    grid : NetworkModelGrid
    parcels_per_link : int
        Number of parcels to create for each link. Default of 5.

    Returns
    -------
    parcels : DataRecord

    """
    # element_id is the link on which the parcel begins.
    element_id = np.repeat(np.arange(grid.number_of_links), parcels_per_link)
    element_id = np.expand_dims(element_id, axis=1)

    # scale volume with parcels per link so we end up with a similar quantity of sediment.
    volume = (1.0 / parcels_per_link) * np.ones(np.shape(element_id))  # (m3)

    active_layer = np.zeros(np.shape(element_id))  # 1= active, 0 = inactive
    density = 2650 * np.ones(np.size(element_id))  # (kg/m3)
    abrasion_rate = 0.0 * np.ones(np.size(element_id))  # (mass loss /m)

    # Lognormal GSD
    medianD = 0.085  # m
    mu = np.log(medianD)
    sigma = np.log(2)  # assume that D84 = sigma*D50
    np.random.seed(0)
    D = np.random.lognormal(
        mu, sigma, np.shape(element_id)
    )  # (m) the diameter of grains in each parcel

    time_arrival_in_link = np.random.rand(np.size(element_id), 1)
    location_in_link = np.random.rand(np.size(element_id), 1)

    variables = {
        "abrasion_rate": (["item_id"], abrasion_rate),
        "density": (["item_id"], density),
        "time_arrival_in_link": (["item_id", "time"], time_arrival_in_link),
        "active_layer": (["item_id", "time"], active_layer),
        "location_in_link": (["item_id", "time"], location_in_link),
        "D": (["item_id", "time"], D),
        "volume": (["item_id", "time"], volume),
    }

    items = {"grid_element": "link", "element_id": element_id}

    parcels = DataRecord(
        grid,
        items=items,
        time=[0.0],
        data_vars=variables,
        dummy_elements={"link": [NetworkSedimentTransporter.OUT_OF_NETWORK]},
    )

    return parcels

"""
## Part 2: Profile the code

Next we will create a NST, run it, and profile it using the python built-in profiling tool [cProfile](https://docs.python.org/3.8/library/profile.html).

We create our grid and parcels, instantiate the profile, run the model for 60 timesteps, and then compile the results of profiling. 

We will profile the code in two parts, the instantiation and running. 
"""

# feel free to change these parameters and see
# how it impacts the results
nlayer = 5
timesteps = 50
parcels_per_link = 50

# calculate dt and set seed.
dt = 60 * 60 * 24 * 12  # length of timestep (seconds)
np.random.seed(1234)

pr = cProfile.Profile()
pr.enable()

grid, fd = create_nmg_and_fd(nlayer)

parcels = create_parcels(grid, parcels_per_link=parcels_per_link)

nst = NetworkSedimentTransporter(
    grid,
    parcels,
    fd,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
)

pr.disable()
s = io.StringIO()
sortby = SortKey.CUMULATIVE
ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
ps.print_stats()
print(s.getvalue())

"""
We can see that the majority of the time it took to create the grid, parcels, and the NST component occurs in `xarray` functions. This is good, as those are likely already efficient. 

Next we profile the code as we use the `run_one_step` function that advances the component forward in time. 
"""

pr = cProfile.Profile()
pr.enable()
for t in range(0, (timesteps * dt), dt):
    nst.run_one_step(dt)
pr.disable()
s = io.StringIO()
sortby = SortKey.CUMULATIVE
ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
ps.print_stats()
print(s.getvalue())

"""
We can see that the majority of the time it takes to run the component happens in a function called `_partition_active_and_storage_layers`. This function is used to figure out which parcels are moving and which are not active. 


## Part 3: Scaling
Next we look at how initialization and moving the model forward in time change as we increase the number of nodes and number of parcels on a given link. 

### 3a: Create a timing function.  
To do this we create one final convenience function that will create everything we need for our scaling analysis, run the model, and report how long it took to initialize and run.  
"""

def time_code(nlayer=3, parcels_per_link=100, timesteps=10):
    """Time the initializiation and runtime.

    Parameters
    ----------
    n_layers : int
        Number of layers of the binary tree used to create the
        NetworkModelGrid. Default of 3
    parcels_per_link : int
        Number of parcels to create for each link. Default of 100.
    timesteps : int
        Number of timesteps. Default of 10.

    Returns
    -------
    (number_of_nodes, parcels_per_link, total_parcels) : tuple
        Tuple indicating the key inputs in our scaling analysis. The number
        of nodes, the number of parcels per link, the total number of parcels.
    init_duration : float
        Duration of the initiation step, in seconds.
    r1s_per : float
        Duration of the average run_one_step call, in seconds
    """
    init_start = time.time()

    grid, fd = create_nmg_and_fd(nlayer)

    parcels = create_parcels(grid, parcels_per_link=parcels_per_link)

    dt = 60 * 60 * 24 * 12  # length of timestep (seconds)

    nst = NetworkSedimentTransporter(
        grid,
        parcels,
        fd,
        bed_porosity=0.3,
        g=9.81,
        fluid_density=1000,
        transport_method="WilcockCrowe",
    )
    init_duration = time.time() - init_start

    if timesteps > 0:
        r1s_start = time.time()
        for t in range(timesteps):
            nst.run_one_step(dt)
        r1s_per = (time.time() - r1s_start) / timesteps
    else:
        r1s_per = 0.0

    return (grid.number_of_nodes, parcels_per_link), init_duration, r1s_per

"""
Next, we use or new `time_code` function with a few different grid sizes, a few different parcels per link, and for 10 seconds. Feel free to experiment and change these values. Some of these values have been reduced to ensure that this notebook always works in the Landlab continuous integration. 

### 3b: Time the code while systematically varying inputs
We save the results in a list structured to easily make a [`pandas.Dataframe`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html).
"""

np.random.seed(345)

out = []
# this range for i in reduced for testing.
for i in range(2, 5):
    for j in [10, 20, 50, 100, 200, 500]:
        print(i, j)
        (nn, ppl), init, r1s_per = time_code(nlayer=i, parcels_per_link=j, timesteps=10)
        out.append((nn, ppl, init, r1s_per))

"""
We make a dataframe and investigate the contents with `df.head`. We'll use some shorthand for the column and axis names:

- nnodes = number of nodes in the NetworkModelGrid
- ppl = parcels per link
- init = duration of time (in seconds) of instantiating the grid, parcels, and NST
- r1s_per = duration of time (in seconds) of running the model forward one step in time. 

"""

df = pd.DataFrame(out, columns=["nnodes", "ppl", "init", "r1s_per"])
df = df.pivot(index="nnodes", columns="ppl", values=["init", "r1s_per"])
df.head()

"""
### 3c: Plot the output to see how the code scales. 

First, lets plot the duration of init (left) and run one step (right) as a function of the number of nodes and parcels per link. We will put number of nodes on the x axis and make a line for each different nubmer of parcels per link. For each As is common, we will make these plots in log-log space.
"""

fig, ax = plt.subplots(1, 2, sharex=True, sharey=True, dpi=300)

df["init"].plot(loglog=True, ax=ax[0], title="init duration")
ax[0].set_ylabel("duration (s)")
ax[0].set_xlabel("Number of Nodes")

df["r1s_per"].plot(loglog=True, ax=ax[1], title="run one step duration")
ax[1].set_ylabel("duration (s)")
ax[1].set_xlabel("Number of Nodes")
# plt.savefig("scaling1.png")
plt.show()



================================================
File: docs/source/tutorials/network_sediment_transporter/run_network_generator_OpenTopoDEM.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Generate a Network Model Grid on an OpenTopography DEM

This notebook demonstrates how to create a NetworkModelGrid from a DEM hosted by OpenTopography. In this tutorial we will:
* Download a DEM from OpenTopography
* Reproject the DEM into a meter-based coordinate system (UTM-13)
* Clip the DEM to the largest watershed
* Create a NetworkModelGrid on the river system in this watershed using three different 'network_grid_from_raster' options
"""

import matplotlib.pyplot as plt
import numpy as np
import xarray as xr

from landlab import imshow_grid

"""
## 1. Download DEM from OpenTopography using Topography utility
"""

"""
Create a function to download and save SRTM images using  [BMI_topography](https://bmi-topography.readthedocs.io/en/latest/).
* From: 
https://github.com/landlab/landlab/blob/master/docs/source/tutorials/flow_direction_and_accumulation/PriorityFlood_realDEMs.ipynb
"""

from bmi_topography import Topography

"""
Download (or reload) topography data.
"""

width = 0.05
dem = Topography(
    north=40.16 + width,
    south=40.14 - width,
    east=-105.4 + width,
    west=-105.5 - width,
    output_format="AAIGrid",
    dem_type="SRTMGL3",
)
_ = dem.load()

"""
## 2. Use Rasterio to Reproject DEM
"""

"""
Use rasterio to reproject to UTM Zone 13. Since our DEM was pulled from the CO region, this is the appropriate UTM system, but you can specify a general EPSG code as 'dst_crs' if you wish to reproject to a different area.
* reference: https://rasterio.readthedocs.io/en/latest/api/rasterio.warp.html#rasterio.warp.calculate_default_transform
"""

import rasterio
from rasterio.warp import Resampling, calculate_default_transform

src_crs = "EPSG:4326"  # Source coordinate system (by default, open_topo BMI loads in WGS84 lat/lon)
dst_crs = "EPSG:32613"  # Set a destination coordinate system

"""
This is the resolution in meters of our target DEM, the UTM coordinate system has a native unit of meters.
"""

target_res = 50

(
    transform,
    dim_x_transf,
    dim_y_transf,
) = calculate_default_transform(
    src_crs,
    dst_crs,
    len(dem.da["x"]),
    len(dem.da["y"]),
    left=dem.bbox.west,
    bottom=dem.bbox.south,
    right=dem.bbox.east,
    top=dem.bbox.north,
    resolution=target_res,
)

"""
Let's use this transform to get X and Y vectors along the DEM row=0 and col=0 lines respectively so we know what new x, y coordinates to assign to our transformed `DataArray`.
"""

x_UTM13, _ = rasterio.transform.xy(transform, 0, np.arange(0, dim_x_transf, 1))
_, y_UTM13 = rasterio.transform.xy(transform, np.arange(0, dim_y_transf, 1), [0])

"""
Now reproject using rasterio:
* https://rasterio.readthedocs.io/en/latest/api/rasterio.warp.html#rasterio.warp.reproject
"""

"""
Define an output array to hold our data, this is structured like the `Topography` `DataArray` output.
"""

out = xr.DataArray(
    np.empty((1, dim_y_transf, dim_x_transf)),
    dims=["band", "y_UTM13", "x_UTM13"],
    coords={
        "band": (["band"], [1]),
        "y_UTM13": (["y_UTM13"], y_UTM13),
        "x_UTM13": (["x_UTM13"], x_UTM13),
    },
)

"""
Reproject data into this array.
"""

reproj_array, affine_trans = rasterio.warp.reproject(
    dem.da,
    out,
    src_transform=dem.load().transform,
    src_crs=src_crs,
    src_nodata=dem.da.nodatavals[0],
    dst_nodata=-9999,
    dst_transform=transform,
    dst_crs=dst_crs,
    resampling=Resampling.nearest,
)

"""
## 3. Create Landlab Grid
"""

from landlab import RasterModelGrid

grid = RasterModelGrid(
    (dim_y_transf, dim_x_transf),
    xy_spacing=target_res,
    xy_of_lower_left=(x_UTM13[0], y_UTM13[0]),
    xy_axis_name=("X UTM13", "Y UTM13"),
    xy_axis_units="m",
)
z = np.ravel(np.flipud(reproj_array.values[0]))
grid.at_node["topographic__elevation"] = z

"""
Close the no data values
"""

grid.status_at_node[np.isclose(z, -9999)] = grid.BC_NODE_IS_CLOSED

imshow_grid(
    grid,
    "topographic__elevation",
    plot_name="Downloaded & Projected DEM topo",
    #     color_for_closed=None,
    colorbar_label="$z$ [m]",
)

"""
## 4. Clip Grid to largest watershed using the FlowAccumulator and a watershed mask
"""

from landlab.components import FlowAccumulator
from landlab.utils import get_watershed_masks_with_area_threshold

"""
Run the FlowAccumulator to determine where flow is being directed and accumulated in the watershed
"""

FlowAccumulator(
    grid, flow_director="D8", depression_finder="DepressionFinderAndRouter"
).run_one_step()

"""
### Create a mask to isolate the largest watershed:
Here we use the [get_watershed_mask_with_area_threshhold](https://landlab.csdms.io/generated/api/landlab.utils.watershed.html#landlab.utils.watershed.get_watershed_masks_with_area_threshold) function with a critical threshhold as the maximum drainage area. (This will filter out all watersheds draining to an area smaller than this.) 
"""

mask = get_watershed_masks_with_area_threshold(
    grid, grid.at_node["drainage_area"].max()
)

"""
Set all values outside the largest watershed to a nodata value of -9999:
"""

no_dataval = -9999
grid.at_node["topographic__elevation"] = np.where(
    mask != -1, grid.at_node["topographic__elevation"], no_dataval
)

"""
Set the model boundary conditions to 'closed' outside of the watershed
"""

grid.status_at_node[np.isclose(grid.at_node["topographic__elevation"], no_dataval)] = (
    grid.BC_NODE_IS_CLOSED
)

"""
Visualize clipped DEM:
"""

imshow_grid(
    grid,
    "topographic__elevation",
    plot_name="Basin topography",
    color_for_closed=None,
    colorbar_label="$z$ [m]",
)

"""
### Set a watershed boundary condition for your grid

This function uses the minimum elevation node nearest to the nodata values. This DEM has two possible outlet nodes, which can be identified if you run the following code block. An error is thrown that says 'Grid has multiple potential outlet nodes'. Here, we choose the first node in the list of node IDs shown in the error window. (You may want to plot them on your DEM to verify that they make sense as an outlet node--see below). This error may happen when there are a few very low elevation cells.
* Note: this step is important for deliniating the channel. If you find the code is taking a long time to generate the NetworkModelGrid, check which node you set as the boundary condition.
"""

# grid.set_watershed_boundary_condition(
#     'topographic__elevation',
#     nodata_value=-9999,
#     return_outlet_id=True
# )

grid.set_watershed_boundary_condition_outlet_id(
    [69808],
    "topographic__elevation",
)

"""
## 5. Create a NetworkModelGrid on this topography

Now we will generate a network using the default placement of a NetworkModelGrid node for every corresponding RasterModelGrid node. You may want to coarsen this later when you decide what is an acceptable NetworkModelGrid spacing for a NetworkSedimentTransporter model. (i.e. stability). Some notes:

* Be SURE you have a ballpark minimum channel threshhold: this is a drainage area threshhold that sets the upstream drainage area for which you want to truncate your channel network. Start high, and then reduce for a more complex network that extends to higher elevations.
* Be sure you have your outlet node defined
* You can pass information from the RasterModelGrid nodes to the NetworkModelGrid nodes using the 'include' variable if you have other things attached to your RasterModelGrid that would be helpful for the NetworkModelGrid to know (i.e. slope)
"""

from landlab.grid.create_network import (
    AtMostNodes,
    SpacingAtLeast,
    network_grid_from_raster,
    spacing_from_drainage_area,
)
from landlab.plot.graph import plot_links, plot_nodes

network_grid = network_grid_from_raster(
    grid,
    minimum_channel_threshold=5000000,  # upstream drainage area to truncate network, in m^2
    include=["drainage_area", "topographic__elevation"],
)

imshow_grid(
    grid,
    "topographic__elevation",
    plot_name="Basin topography",
    color_for_closed=None,
    colorbar_label="$z$ [m]",
)
plot_links(network_grid, with_id=False, as_arrow=False, linewidth=0.05)
plot_nodes(network_grid, with_id=False, markersize=0.2)

"""
### Refine Network using Reducers

Now we will use the Reducer options to reduce the number of nodes on the network. This shows an example where 10 nodes are placed on each segment of the river between bifurcations.
"""

network_grid = network_grid_from_raster(
    grid,
    reducer=AtMostNodes(count=10),
    minimum_channel_threshold=5000000,
    include=["drainage_area", "topographic__elevation"],
)
plot_nodes(network_grid, markersize=4)
plot_links(network_grid, as_arrow=False)
plt.title("Nodes and Links");

"""
Realistically, you may want to reduce your NetworkModelGrid node spacing in the steeper, higher elevation areas of the basin for stability of the NetworkSedimentTransporter model. Here, we show an option to define the network node spacing from an upstream drainage area relation that estimates river width from the Frasson et al. 2019 (GRL) power law relationship:

$W=a*DA^b$

where $W$ is width $DA$ is drainage area and $a$ and $b$ are parameters. The function uses default values for a and b reported in the paper from fitting field data, but you  may want to adjust this depending on your river system. Changing n_widths will adjust node spacing by a certain multiple of local river width.
"""

spacing = spacing_from_drainage_area(
    grid.at_node["drainage_area"], a=9.68, b=0.32, n_widths=100
)

network_grid = network_grid_from_raster(
    grid,
    reducer=SpacingAtLeast(grid.xy_of_node, spacing),
    minimum_channel_threshold=5000000,
    include=["drainage_area", "topographic__elevation"],
)

imshow_grid(
    grid,
    "topographic__elevation",
    plot_name="Basin topography",
    color_for_closed=None,
    colorbar_label="$z$ [m]",
)

plot_nodes(network_grid, with_id=False, markersize=4)
plot_links(network_grid, with_id=False, as_arrow=False)
plt.title("Nodes and Links");



================================================
File: docs/source/tutorials/network_sediment_transporter/sediment_pulser_at_links.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using SedimentPulserAtLinks to add sediment parcels to a channel network

This tutorial illustrates how to use SedimentPulserAtLinks with a network model grid and the NetworkSedimentTransporter.

*SedimentPulserAtLinks overiew: the user specifies a list of the link IDs where the parcels will be placed, a list of the number of parcels placed in each link and lists of other parcel attributes. The parcels are placed at random locations in each link.

In this example we will: 

(1) Set up a network model grid with an initial set of parcels, 
(2) Add pulses of sediment to the grid using SedimentPulserAtLinks, and 
(3) Run NetworkSedimentTransporter between pulses
"""

"""
## 1. Setup the work space
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
    BedParcelInitializerArea,
)
from landlab.components.network_sediment_transporter.sediment_pulser_at_links import (
    SedimentPulserAtLinks,
)
from landlab.grid.network import NetworkModelGrid
from landlab.plot import graph, plot_network_and_parcels

"""
## 2. Define the network model grid topology
"""

x_of_node = (0, 0, 100, -50, -100, 50, -150, -100)
y_of_node = (0, 100, 200, 200, 300, 400, 400, 125)
nodes_at_link = ((1, 0), (1, 2), (7, 1), (3, 1), (4, 3), (5, 4), (6, 4))
nmg = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)

"""
to help visualize where the pulses will be sent, plot the network with link and node id numbers 
"""

fig, axs = plt.subplots(1, 1, figsize=(4, 6))
graph.plot_links(nmg, with_id=True)
graph.plot_nodes(nmg, with_id=True)

"""
## 3. Define necessary link and node fields and run a flow director on the grid to add a slope field
"""

nmg.at_link["channel_width"] = np.array([9, 4.5, 7.5, 6, 7.5, 4.5, 6])  # m
nmg.at_link["reach_length"] = np.array(
    [100.0, 103.1, 111.8, 141.4, 111.8, 111.8, 180.3]
)  # m
nmg.at_node["topographic__elevation"] = np.array(
    [0.1, 0.6, 1.0, 1.1, 1.0, 1.6, 2.0, 2.0]
)
nmg.at_link["drainage_area"] = np.array([1, 0.1, 0.625, 0.15, 0.4, 0.075, 0.2])  # km^2
nmg.at_link["flow_depth"] = np.array([2, 1.2, 1.6, 1.3, 1.4, 1.2, 1.3])  # m

# instantiate and run flow director
flow_director = FlowDirectorSteepest(nmg, "topographic__elevation")
flow_director.run_one_step()

# assign bedrock elevations that are below the topographic elev for all but the "headwater" nodes
n_upstream = np.sum(flow_director.flow_link_incoming_at_node() == 1, axis=1)

nmg.at_node["bedrock__elevation"] = nmg.at_node["topographic__elevation"].copy()
nmg.at_node["bedrock__elevation"][n_upstream > 0] -= 0.1

"""
## 4. Create an initial set of parcels on the grid. 
Note, we start with a small number of initial parcels so that parcels from later pulses of material are visible in plots of the parcels and network
"""

initialize_parcels = BedParcelInitializerArea(
    nmg,
    drainage_area_coefficient=0.05,
    drainage_area_exponent=-0.2,
    sed_thickness=1,
    median_number_of_starting_parcels=2,
    rng=1945,
)
parcels = initialize_parcels()

"""
See the warning? Because the NST is designed to model alluvial channel processes, it's problematic to have so few parcels. For the purpose of this tutorial, it makes for simpler visualizations.
"""

"""
View the initial parcels on the network model grid, shaded by grain diameter
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=0,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
## 5. Instantiate and run the NetworkSedimentTransporter component using a flow event with flow depth equal to the link field "flow_depth" that last 24 hours 
"""

nst = NetworkSedimentTransporter(
    nmg,
    parcels,
    flow_director,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
    active_layer_method="Constant10cm",
)

nst.run_one_step(dt=3600 * 24)
sed_thickness_at_nodes = (
    nmg.at_node["topographic__elevation"] - nmg.at_node["bedrock__elevation"]
)

"""
View parcel locations after the flow event
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=1,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)
sed_thickness_at_nodes = (
    nmg.at_node["topographic__elevation"] - nmg.at_node["bedrock__elevation"]
)
sed_thickness_at_nodes

"""
## 6. Instantiate SedimentPulserAtLink
SedimentPulserAtLinks is instantiated with a network model grid and time_to_pulse function that defines the condition when a pulse is permitted. Optionally, a parcel DataRecord can be provided and default parcel attributes can be defined. 
If a parcel DataRecord is not provided, SedimentPulserAtLinks will create a new parcel DataRecord.
"""

def always_time_to_pulse(time):
    """A pulse is permitted (True) for all times"""
    return True


make_pulse = SedimentPulserAtLinks(
    nmg, parcels=parcels, time_to_pulse=always_time_to_pulse, rng=1945
)

"""
## 7. Make the first pulse by specifying the time of the pulse, the link(s) the pulse enters the channel network and the number of parcels sent to each link. 
Here we send a pulse to links 0 and 5 (see first figure for link id's)
Note, all inputs, except time, are lists. 
Also note that any parcel attributes not specified use default values. Default values can be set when SedimentPulserAtLinks is instantiated.
"""

time = nst.time  # time of first pulse
links = [0, 5]  # link
n_parcels_at_link = [10, 30]  # parcels set to link
parcels = make_pulse(time=time, links=links, n_parcels_at_link=n_parcels_at_link)

"""
view the location of the new parcels from the pulse
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=1,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
now apply another 24 hr flow event
"""

nst.run_one_step(dt=3600 * 24)

"""
View parcel locations after the flow event
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=2,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
Notice that after the flow event, the pulse of parcels in link 0 left the channel network. Flow depth in link 0 is much higher than the lower order channels such as links 1, 3, 5 and 6.
"""

"""
## 8. Send a second pulse. This time we'll specify more attributes of the pulse.
We're sending boulders to link 6
"""

time = nst.time  # time
links = [3, 4, 6]  # link
D50 = [0.05, 0.03, 0.5]  # median grain size
n_parcels_at_link = [3, 20, 15]  # parcels sent to link
parcel_volume = [1, 0.5, 2]  # parcel volume

parcels = make_pulse(
    time=time,
    links=links,
    D50=D50,
    n_parcels_at_link=n_parcels_at_link,
    parcel_volume=parcel_volume,
)

"""
view the new parcels
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=2,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
apply another day long flow event
"""

nst.run_one_step(dt=3600 * 24)

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=3,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
note that the boulders did not budge
"""

"""
## 9. Apply one final pulse, this time we'll change the time_to_pulse function
"""

def time_to_pulse_window(time):
    """a pulse is permitted only if the time is between Ptime_min and Ptime_max"""
    Ptime_min = 340000  # seconds
    Ptime_max = 648000
    return time >= Ptime_min and time < Ptime_max


make_pulse._time_to_pulse = time_to_pulse_window

"""
call the instance, this time defining a single pulse of 1000 parcels at link 2
"""

time = nst.time  # time of first pulse
links = [2]  # link
D50 = [0.01]
n_parcels_at_link = [1000]  # parcels set to link
parcel_volume = [1]  # m^3
parcels = make_pulse(
    time=time,
    links=links,
    D50=D50,
    parcel_volume=parcel_volume,
    n_parcels_at_link=n_parcels_at_link,
)

"""
note that it was not a time to pulse, nothing was added to the channel network
apply another day-long flow event
"""

nst.run_one_step(dt=3600 * 24)

"""
## 10. Try pulsing again, note that after the last flow event, time is now within the window described by the time_to_pulse_window function
this time, we send 30 parcels of fine sediment to link 1
"""

time = nst.time  # time of first pulse
links = [1]  # link
D50 = [0.001]
parcel_volume = [1]  # m^3
n_parcels_at_link = [30]  # parcels set to link
parcels = make_pulse(
    time=time,
    links=links,
    D50=D50,
    parcel_volume=parcel_volume,
    n_parcels_at_link=n_parcels_at_link,
)

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=4,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
apply one more flow event, this one 5 days long
"""

nst.run_one_step(dt=3600 * 24 * 5)
sed_thickness_at_nodes = (
    nmg.at_node["topographic__elevation"] - nmg.at_node["bedrock__elevation"]
)
sed_thickness_at_nodes

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=5,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
Note that after the flow event, the fines in link 2 have been flushed out of the network
"""



================================================
File: docs/source/tutorials/network_sediment_transporter/sediment_pulser_each_parcel.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using SedimentPulserEachParcel to add sediment parcels to a channel network

This tutorial illustrates how to use SedimentPulserEachParcel with a network model grid and the NetworkSedimentTransporter. 

* SedimentPulserEachParcel overview: The user specifies the link and distance on link that parcels are placed within a channel network in a Pandas DataFrame.

In this example we will: 

(1) Set up a network model grid with an initial set of parcels, 

(2) Add pulses of sediment to the grid using SedimentPulserEachParcel, and 

(3) Run NetworkSedimentTransporter between pulses
"""

"""
## 1. Setup the work space
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
    BedParcelInitializerArea,
)
from landlab.components.network_sediment_transporter.sediment_pulser_each_parcel import (
    SedimentPulserEachParcel,
)
from landlab.grid.network import NetworkModelGrid
from landlab.plot import graph, plot_network_and_parcels

"""
## 2. Define the network model grid topology
"""

x_of_node = (0, 0, 100, -50, -100, 50, -150, -100)
y_of_node = (0, 100, 200, 200, 300, 400, 400, 125)
nodes_at_link = ((1, 0), (1, 2), (7, 1), (3, 1), (4, 3), (5, 4), (6, 4))
nmg = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)

"""
 to help visualize where the pulses will be sent, plot the network with link and node id numbers 
"""

fig, axs = plt.subplots(1, 1, figsize=(4, 6))
graph.plot_links(nmg, with_id=True)
graph.plot_nodes(nmg, with_id=True)

"""
## 3. Define required link and node fields and run a flow director on the grid to add a slope field
"""

nmg.at_link["channel_width"] = np.array([3, 1.5, 2.5, 2, 2.5, 1.5, 2])  # m
nmg.at_link["channel_slope"] = np.array(
    [0.05, 0.1, 0.06, 0.08, 0.07, 0.1, 0.08]
)  # m / m
nmg.at_link["reach_length"] = np.array(
    [100.0, 103.1, 111.8, 141.4, 111.8, 111.8, 180.3]
)  # m
nmg.at_node["topographic__elevation"] = np.array([0.0, 5, 10, 10, 10, 15, 20, 20])
nmg.at_node["bedrock__elevation"] = np.array([0.0, 5, 10, 10, 10, 15, 20, 20])
nmg.at_link["drainage_area"] = np.array([1, 0.1, 0.625, 0.15, 0.4, 0.075, 0.2])  # km^2
nmg.at_link["flow_depth"] = np.array([0.7, 0.4, 0.6, 0.4, 0.5, 0.4, 0.4])  # m

# instantiate and run flow director
flow_director = FlowDirectorSteepest(nmg, "topographic__elevation")
flow_director.run_one_step()

"""
## 4. Create an initial set of parcels on the grid. 
Note, we start with a small number of initial parcels so that parcels from later pulses of material are visible in plots of the parcels and network
"""

initialize_parcels = BedParcelInitializerArea(
    nmg,
    drainage_area_coefficient=0.1,
    drainage_area_exponent=0.2,
    median_number_of_starting_parcels=2,
)
parcels = initialize_parcels()

"""
### View the initial parcels on the network model grid, shaded by grain diameter
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=0,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
### Viewing the element id of the parcels in the network shows that ParcelInitializer added 15 parcels to the network
"""

parcels.dataset["element_id"]

"""
## 5. Instantiate and run the NetworkSedimentTransporter component using a flow event with flow depth equal to the link field "flow_depth" that last 24 hours 
"""

nst = NetworkSedimentTransporter(
    nmg,
    parcels,
    flow_director,
    bed_porosity=0.3,
    g=9.81,
    fluid_density=1000,
    transport_method="WilcockCrowe",
    active_layer_method="Constant10cm",
)

nst.run_one_step(dt=3600 * 24)

"""
### View parcel locations after the flow event
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=1,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
### Note that none of parcels moved because the partial initializer places all parcels in the inactive layer
"""

"""
## 6. Instantiate SedimentPulserEachParcel
SedimentPulserEachParcel is instantiated with a network model grid. Optionally, default parcel attributes and a parcel DataRecord can be defined. If a parcel DataRecord is not provided, SedimentPulserEachParcel will create a new parcel 
DataRecord.
"""

make_pulse = SedimentPulserEachParcel(
    nmg, parcels=parcels, parcel_volume=1
)  # set the default max parcel_volume as 1 m^3

"""
## 7. create the PulseDF (Pulse DataFrame). 
Each row of the PulseDF contains information on the deposition location and 
volume of a single pulse of sediment. The pulse is divided into 'n' number of 
parcels, where 'n' equals numpy.ceil(pulse volume / max parcel volume)
For details on the format of the PulseDF, see the docstring for
function SedimentPulserEachParcel._sediment_pulse_dataframe 

Here we send a pulse to specific locations on links 1, 3, 5 and 2(see first figure for link id's)>
Note that any parcel attributes not specified use default values. Default values can be set when SedimentPulserAtLinks is instantiated.
"""

time = nst.time
# volume of each pulse
PulseDF = pd.DataFrame(
    {
        "pulse_volume": [50, 5, 10, 15],
        # pulses enter channel network at these links
        "link_#": [1, 3, 5, 2],
        # the normalized distance on the link (distance from link inlet / link length)
        "normalized_downstream_distance": [0.8, 0.7, 0.5, 0.2],
    }
)

parcels = make_pulse(time, PulseDF)

"""
### view the location of the new parcels from the pulse. 
Note that all parcels from a pulse are placed at the same point in the network and appear as 4 points on the plot

"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=1,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
### Viewing the element id of the parcels in the network shows that we actually added roughly 80 new parcels
"""

parcels.dataset["element_id"]

"""
### now apply another 24 hr flow event
"""

nst.run_one_step(dt=3600 * 24)

"""
### View parcel locations after the flow event
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=2,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
Notice that after the flow event, the parcels at each pulse location spread out.
"""

"""
## 8. Send a second pulseDF

This pulseDF includes two pulses:

(1) A 30 m^3 landslide in thin-bedded siltstone near the channel head (inlet) of link 3

(2) A 50 m^3 bedrock landslide in fractured, massive sandstone beds near the outlet of link 6

"""

time = nst.time
PulseDF = pd.DataFrame(
    {
        "pulse_volume": [30, 50],  # pulse volume
        "link_#": [3, 6],  # link id
        "normalized_downstream_distance": [0.1, 0.9],  # distance on link
        "D50": [0.02, 0.5],  # median grain size
        "abrasion_rate": [0.1, 0.01],  # abrasion rate
        "parcel_volume": [0.25, 2],
    }
)  # parcel volume

parcels = make_pulse(time, PulseDF)

"""
### view the new parcels
"""

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=2,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
### apply another day long flow event
"""

nst.run_one_step(dt=3600 * 24)

fig = plot_network_and_parcels(
    nmg,
    parcels,
    parcel_time_index=3,  # index of time, not the time value
    parcel_color_attribute="D",
    parcel_size=10,
    parcel_alpha=1.0,
    figsize=(3, 6),
)

"""
### Notice how parcels containing the boulder size grains in link 6 did not move but the parcels containing gravel sized grains in link 3 do.
"""



================================================
File: docs/source/tutorials/normal_fault/normal_fault_component_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to the NormalFault component

This tutorial provides an introduction to the `NormalFault` component in the Landlab toolkit. This component takes the following parameters. 

    Parameters
    --------
    grid : ModelGrid
    faulted_surface : str or ndarray of shape `(n_nodes, )` or list of str
        or ndarrays. 
        Surface that is modified by the NormalFault component. Can be a
        field name or array or a list of strings or ndarrays if the fault.
        should uplift more than one field. Default value is 
        `topographic__elevation`.
    fault_throw_rate_through_time : dict, optional
        Dictionary that specifies the time varying throw rate on the fault.
        Expected format is:
        ``fault_throw_rate_through_time = {'time': array, 'rate': array}``
        Default value is a constant rate of 0.001 (units not specified).
    fault_dip_angle : float, optional
        Dip angle of the fault in degrees.  Default value is 90 degrees.
    fault_trace : dictionary, optional
        Dictionary that specifies the coordinates of two locations on the
        fault trace. Expected format is
        ``fault_trace = {'x1': float, 'y1': float, 'x2': float, 'y2': float}``
        where the vector from ``(x1, y1)`` to ``(x2, y2)`` defines the
        strike of the fault trace. The orientation of the fault dip relative
        to the strike follows the right hand rule.
        Default is for the fault to strike NE.
    include_boundaries : boolean, optional
        Flag to indicate if model grid boundaries should be uplifted. If
        set to ``True`` uplifted model grid boundaries will be set to the
        average value of their upstream nodes. Default value is False.


The `NormalFault` component will divide the model domain into two regions, a 'faulted nodes' region which will experience vertical rock uplift at a rate of 

$t \cdot \sin (d)$

where $t$ is the fault throw rate and $d$ is the fault dip angle. 

While dip angles less than 90 degrees are permitted, in its present implementation, the `NormalFault` component does not translate field information laterally. 

The fault orientation is specified by two coordinate pairs: (x1, y1) and (x2, y2). The strike of the fault, specified with the right-hand rule convention, is the vector from (x1, y1) to (x2, y2). Give that this component creates a normal fault, in which the footwall moves up relative to the hanging wall, this means that the nodes that are counterclockwise from the strike are the uplifted nodes. 

To start, let's import necessary Landlab and Python modules. 
"""

# start by importing necessary modules
import matplotlib.pyplot as plt
import numpy as np

from landlab import HexModelGrid, RasterModelGrid
from landlab.components import FastscapeEroder, FlowAccumulator, NormalFault
from landlab.plot import imshow_grid

%matplotlib inline

"""
First we will make a default `NormalFault`.
"""

grid = RasterModelGrid((6, 6), xy_spacing=10)

grid.add_zeros("topographic__elevation", at="node")

nf = NormalFault(grid)

plt.figure()
imshow_grid(grid, nf.faulted_nodes.astype(int), cmap="viridis")
plt.plot(grid.x_of_node, grid.y_of_node, "c.")
plt.show()

"""
 This fault has a strike of NE and dips to the SE. Thus the uplifted nodes (shown in yellow) are in the NW half of the domain.  

The default `NormalFault` will not uplift the boundary nodes. We change this by using the keyword argument `include_boundaries`. If this is specified, the elevation of the boundary nodes is calculated as an average of the faulted nodes adjacent to the boundaries. This occurs because most Landlab erosion components do not operate on boundary nodes. 
"""

nf = NormalFault(grid, include_boundaries=True)

plt.figure()
imshow_grid(grid, nf.faulted_nodes.astype(int), cmap="viridis")
plt.plot(grid.x_of_node, grid.y_of_node, "c.")
plt.show()

"""
We can add functionality to the `NormalFault` with other keyword arguments. We can change the fault strike and dip, as well as specify a time series of fault uplift through time. 
"""

grid = RasterModelGrid((60, 100), xy_spacing=10)
z = grid.add_zeros("topographic__elevation", at="node")

nf = NormalFault(grid, fault_trace={"x1": 0, "y1": 200, "y2": 30, "x2": 600})

imshow_grid(grid, nf.faulted_nodes.astype(int), cmap="viridis")

"""
By reversing the order of (x1, y1) and (x2, y2) we can reverse the location of the upthrown nodes (all else equal). 
"""

grid = RasterModelGrid((60, 100), xy_spacing=10)
z = grid.add_zeros("topographic__elevation", at="node")

nf = NormalFault(grid, fault_trace={"y1": 30, "x1": 600, "x2": 0, "y2": 200})

imshow_grid(grid, nf.faulted_nodes.astype(int), cmap="viridis")

"""
We can also specify complex time-rock uplift rate histories, but we'll explore that later in the tutorial. 

Next let's make a landscape evolution model with a normal fault. Here we'll use a HexModelGrid to highlight that we can use both raster and non-raster grids with this component. 

We will do a series of three numerical experiments and will want to keep a few parameters constant. Since you might want to change them, we are making it easier to change all of them together. They are defined in the next block:
"""

# here are the parameters to change
K = 0.0005  # stream power coefficient, bigger = streams erode more quickly
U = 0.0001  # uplift rate in meters per year

dt = 1000  # time step in years
dx = 10  # space step in meters

nr = 60  # number of model rows
nc = 100  # number of model columns

# instantiate the grid
grid = HexModelGrid((nr, nc), dx, node_layout="rect")

# add a topographic__elevation field with noise
z = grid.add_zeros("topographic__elevation", at="node")
z[grid.core_nodes] += 100.0 + np.random.randn(grid.core_nodes.size)

fr = FlowAccumulator(grid)
fs = FastscapeEroder(grid, K_sp=K)
nf = NormalFault(grid, fault_trace={"x1": 0, "x2": 800, "y1": 0, "y2": 500})

# Run this model for 300 100-year timesteps (30,000 years).
for i in range(300):
    nf.run_one_step(dt)
    fr.run_one_step()
    fs.run_one_step(dt)
    z[grid.core_nodes] += 0.0001 * dt

# plot the final topography
imshow_grid(grid, z)

"""
As we can see, the upper left portion of the grid has been uplifted an a stream network has developed over the whole domain. 

How might this change when we also uplift the boundaries nodes?
"""

# instantiate the grid
grid = HexModelGrid((nr, nc), 10, node_layout="rect")

# add a topographic__elevation field with noise
z = grid.add_zeros("topographic__elevation", at="node")
z[grid.core_nodes] += 100.0 + np.random.randn(grid.core_nodes.size)

fr = FlowAccumulator(grid)
fs = FastscapeEroder(grid, K_sp=K)
nf = NormalFault(
    grid, fault_trace={"x1": 0, "x2": 800, "y1": 0, "y2": 500}, include_boundaries=True
)

# Run this model for 300 100-year timesteps (30,000 years).
for i in range(300):
    nf.run_one_step(dt)
    fr.run_one_step()
    fs.run_one_step(dt)
    z[grid.core_nodes] += U * dt

# plot the final topography
imshow_grid(grid, z)

"""
We can see that when the boundary nodes are not included, the faulted region is impacted by the edge boundary conditions differently. Depending on your application, one or the other of these boundary condition options may suite your problem better. 

The last thing to explore is the use of the `fault_rate_through_time` parameter. This allows us to specify generic fault throw rate histories. For example, consider the following history, in which every 100,000 years there is a 10,000 year period in which the fault is active. 
"""

time = (
    np.array(
        [
            0.0,
            7.99,
            8.00,
            8.99,
            9.0,
            17.99,
            18.0,
            18.99,
            19.0,
            27.99,
            28.00,
            28.99,
            29.0,
        ]
    )
    * 10
    * dt
)
rate = np.array([0, 0, 0.01, 0.01, 0, 0, 0.01, 0.01, 0, 0, 0.01, 0.01, 0])

plt.figure()
plt.plot(time, rate)
plt.plot([0, 300 * dt], [0.001, 0.001])
plt.xlabel("Time [years]")
plt.ylabel("Fault Throw Rate [m/yr]")
plt.show()

"""
The default value for uplift rate is 0.001 (units unspecified as it will depend on the x and t units in a model, but in this example we assume time units of years and length units of meters). 

This will result in a total of 300 m of fault throw over the 300,000 year model time period. This amount of uplift can also be accommodated by faster fault motion that occurs over shorter periods of time. 

Next we plot the cumulative fault throw for the two cases. 
"""

t = np.arange(0, 300 * dt, dt)
rate_constant = np.interp(t, [0, 300 * dt], [0.001, 0.001])
rate_variable = np.interp(t, time, rate)

cumulative_rock_uplift_constant = np.cumsum(rate_constant) * dt
cumulative_rock_uplift_variable = np.cumsum(rate_variable) * dt

plt.figure()
plt.plot(t, cumulative_rock_uplift_constant)
plt.plot(t, cumulative_rock_uplift_variable)
plt.xlabel("Time [years]")
plt.ylabel("Cumulative Fault Throw [m]")
plt.show()

"""
A technical note: Beyond the times specified, the internal workings of the `NormalFault` will use the final value provided in the rate array. 

Let's see how this changes the model results. 
"""

# instantiate the grid
grid = HexModelGrid((nr, nc), 10, node_layout="rect")

# add a topographic__elevation field with noise
z = grid.add_zeros("topographic__elevation", at="node")
z[grid.core_nodes] += 100.0 + np.random.randn(grid.core_nodes.size)

fr = FlowAccumulator(grid)
fs = FastscapeEroder(grid, K_sp=K)
nf = NormalFault(
    grid,
    fault_throw_rate_through_time={"time": time, "rate": rate},
    fault_trace={"x1": 0, "x2": 800, "y1": 0, "y2": 500},
    include_boundaries=True,
)

# Run this model for 300 100-year timesteps (30,000 years).
for i in range(300):
    nf.run_one_step(dt)
    fr.run_one_step()
    fs.run_one_step(dt)
    z[grid.core_nodes] += U * dt

# plot the final topography
imshow_grid(grid, z)

"""
As you can see the resulting topography is very different than in the case with continuous uplift. 

For our final example, we'll use `NormalFault` with a more complicated model in which we have both a soil layer and bedrock. In order to move, material must convert from bedrock to soil by weathering.

First we import remaining modules and set some parameter values
"""

from landlab.components import DepthDependentDiffuser, ExponentialWeatherer

# here are the parameters to change
K = 0.0005  # stream power coefficient, bigger = streams erode more quickly
U = 0.0001  # uplift rate in meters per year
max_soil_production_rate = (
    0.001  # Maximum weathering rate for bare bedrock in meters per year
)
soil_production_decay_depth = 0.7  # Characteristic weathering depth in meters
linear_diffusivity = 0.01  # Hillslope diffusivity and m2 per years
soil_transport_decay_depth = 0.5  # Characteristic soil transport depth in meters

dt = 100  # time step in years
dx = 10  # space step in meters

nr = 60  # number of model rows
nc = 100  # number of model columns

?ExponentialWeatherer

"""
Next we create the grid and run the model. 
"""

# instantiate the grid
grid = HexModelGrid((nr, nc), 10, node_layout="rect")

# add a topographic__elevation field with noise
z = grid.add_zeros("topographic__elevation", at="node")
z[grid.core_nodes] += 100.0 + np.random.randn(grid.core_nodes.size)

# create a field for soil depth
d = grid.add_zeros("soil__depth", at="node")

# create a bedrock elevation field
b = grid.add_zeros("bedrock__elevation", at="node")
b[:] = z - d

fr = FlowAccumulator(grid, depression_finder="DepressionFinderAndRouter", routing="D4")
fs = FastscapeEroder(grid, K_sp=K)
ew = ExponentialWeatherer(
    grid,
    soil_production_decay_depth=soil_production_decay_depth,
    soil_production_maximum_rate=max_soil_production_rate,
)

dd = DepthDependentDiffuser(
    grid,
    linear_diffusivity=linear_diffusivity,
    soil_transport_decay_depth=soil_transport_decay_depth,
)

nf = NormalFault(
    grid,
    fault_throw_rate_through_time={"time": [0, 30], "rate": [0.001, 0.001]},
    fault_trace={"x1": 0, "x2": 800, "y1": 0, "y2": 500},
    include_boundaries=False,
)

# Run this model for 300 100-year timesteps (30,000 years).
for i in range(300):
    # Move normal fault
    nf.run_one_step(dt)

    # Route flow
    fr.run_one_step()

    # Erode with water
    fs.run_one_step(dt)

    # We must also now erode the bedrock where relevant. If water erosion
    # into bedrock has occurred, the bedrock elevation will be higher than
    # the actual elevation, so we simply re-set bedrock elevation to the
    # lower of itself or the current elevation.
    b = grid.at_node["bedrock__elevation"]
    b[:] = np.minimum(b, grid.at_node["topographic__elevation"])

    # Calculate regolith-production rate
    ew.calc_soil_prod_rate()

    # Generate and move soil around. This component will update both the
    # soil thickness and topographic elevation fields.
    dd.run_one_step(dt)

    # uplift the whole domain, we need to do this to both bedrock and topography
    z[grid.core_nodes] += U * dt
    b[grid.core_nodes] += U * dt

# plot the final topography
imshow_grid(grid, "topographic__elevation")

"""
We can also examine the soil thickness and soil production rate. Here in the soil depth, we see it is highest along the ridge crests.  
"""

# and the soil depth
imshow_grid(grid, "soil__depth", cmap="viridis")

"""
The soil production rate is highest where the soil depth is low, as we would expect given the exponential form. 
"""

# and the soil production rate
imshow_grid(grid, "soil_production__rate", cmap="viridis")



================================================
File: docs/source/tutorials/output/writing_legacy_vtk_files.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Writing with legacy vtk files

*(GE Tucker, CU Boulder, first version June 2023)*

The [Visualization Toolkit (VTK)](https://docs.vtk.org/en/latest/) is an open-source software system for visualization. It offers two file formats: one based on XML, and the other---the so-called **legacy VTK** format---using a simple text-based format. These file formats are readable by visualization packages such as [ParaView](https://www.paraview.org/), so it is useful to be able to output VTK format for Landlab grids and fields. This tutorial demonstrates Landlab's legacy VTK file-output capability.

## The format

To quote from the VTK [documentation](https://docs.vtk.org/en/latest/design_documents/VTKFileFormats.html): 

"*The legacy VTK file formats consist of five basic parts.*

1. *The first part is the file version and identifier. This part contains the single line: vtk DataFile Version x.x. This line must be exactly as shown with the exception of the version number x.x, which will vary with different releases of VTK. (Note: the current version number is 3.0. Version 1.0 and 2.0 files are compatible with version 3.0 files.)*

2. *The second part is the header. The header consists of a character string terminated by end-of-line character \n. The header is 256 characters maximum. The header can be used to describe the data and include any other pertinent information.*

3. *The next part is the file format. The file format describes the type of file, either ASCII or binary. On this line the single word ASCII or BINARY must appear.*

4. *The fourth part is the dataset structure. The geometry part describes the geometry and topology of the dataset. This part begins with a line containing the keyword DATASET followed by a keyword describing the type of dataset.Then, depending upon the type of dataset, other keyword/data combinations define the actual data.*

5. *The final part describes the dataset attributes. This part begins with the keywords POINT_DATA or CELL_DATA, followed by an integer number specifying the number of points or cells, respectively. (It doesn’t matter whether POINT_DATA or CELL_DATA comes first.) Other keyword/data combinations then define the actual dataset attribute values (i.e., scalars, vectors, tensors, normals, texture coordinates, or field data).*"

"""

"""
## Hex grid example

This example creates and outputs a tiny hex grid, along with two fields: `topographic__elevation` and `surface_water__depth`.
"""

import numpy as np

import landlab.io.legacy_vtk as vtk
from landlab import HexModelGrid, RasterModelGrid

# Create a tiny grid with 1 core node and 6 boundary nodes
grid = HexModelGrid((3, 2))

# Add two fields with made-up values
topo = grid.add_zeros("topographic__elevation", at="node")
topo[3] = 1.0
grid.at_node["surface_water__depth"] = np.arange(grid.number_of_nodes)

# Write output in legacy VTK format
vtk_file = vtk.dump(grid)

"""
Let's see what the output looks like:
"""

print(vtk_file)

"""
## Raster grid example
"""

# Create a tiny grid with 1 core node and 6 boundary nodes
grid = RasterModelGrid((3, 3))

# Add two fields with made-up values
topo = grid.add_zeros("topographic__elevation", at="node")
topo[4] = 1.0
grid.at_node["surface_water__depth"] = np.arange(grid.number_of_nodes)

# Write output in legacy VTK format
vtk_file = vtk.dump(grid)

print(vtk_file)

"""
Notice that this has saved the grid's *nodes* and *patches* (VTK uses the terms *points* and *cells*). If you would like to save the dual grid, you can do this through the ``at`` keyword. The default (`at="node"`) is to save the main grid but you can use `at="corner"` to save the dual grid.
"""

print(vtk.dump(grid, at="corner"))

"""
If your grid contains many fields, you may not want to save all of them. You can specify which fields to save through the `include` and `exclude` keywords. These operate much like UNIX filename pattern matching and are the same as described in the ``fields`` method of your grid. As an example, the following with exclude any fields that contain the string "surface_water".  
"""

print(vtk.dump(grid, exclude="*surface_water*"))

"""
The VTK format assumes points (i.e. either *nodes* or *corners*) are defined by *x*, *y*, and *z* coordinates. The default is to assign a value of 0 to all *z* coordinates. You can, however, change this behavior and assign your own data. For example, the following code uses the `topo` array for the *z* coordinate of each of the *nodes*.
"""

print(vtk.dump(grid, z_coord=topo))



================================================
File: docs/source/tutorials/overland_flow/coupled_rainfall_runoff.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# A coupled rainfall-runoff model in Landlab
"""

"""
This tutorial demonstrates a very simple synthetic rainfall-runoff model in Landlab, using the `SpatialPrecipitationDistribution` and `OverlandFlow` components. This assumes no infiltration, but it could be added by modifying the `rainfall__flux` field appropriately.

First, import the modules we'll need.
"""

import os

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import OverlandFlow, SpatialPrecipitationDistribution
from landlab.io import esri_ascii

"""
Set up a grid and load some arbitrary existing catchment elevation data. A functional version of this might use a real gauged catchment for comparison to reality.
"""

# here we use an arbitrary, very small, "real" catchment
with open("hugo_site.asc") as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")
z = mg.at_node["topographic__elevation"]

mg.status_at_node[mg.nodes_at_right_edge] = mg.BC_NODE_IS_FIXED_VALUE
mg.status_at_node[np.isclose(z, -9999.0)] = mg.BC_NODE_IS_CLOSED

mg.imshow(z, colorbar_label="Elevation (m)")

"""
Build a mocked-up rainfall distribution using the `SpatialPrecipitationDistribution` component.

It would be trivial to replace this with an imported real rainfall field - and we save and reload the pattern to highlight how this might work.
"""

rain = SpatialPrecipitationDistribution(mg)
np.random.seed(26)  # arbitrary to get a cool-looking storm out every time

# get the storm simulator to provide a storm
# There's only one storm generated here in the time series, so easy enough to do.
# first, check the directory we need for saving exists, and make it if not:
if not os.path.exists("./rainfall"):
    os.makedirs("./rainfall")

# storm lengths in hrs
for storm_t, interstorm_t in rain.yield_storms(style="monsoonal"):
    mg.at_node["rainfall__flux"] *= 0.001  # because the rainfall comes out in mm/h
    # to make the storm heavier and more interesting!
    mg.at_node["rainfall__flux"] *= 10.0
    plt.figure()
    # plot up this storm
    mg.imshow("rainfall__flux", cmap="gist_ncar", colorbar_label="Rainfall flux (m/h)")
    plt.show()
    with open("./rainfall/rainfall.asc", "w") as fp:
        esri_ascii.dump(mg, fp, name="rainfall__flux", at="node")

"""
Now, load the rainfall files and set up the model, telling the flood router to accept the rainfalls in the file(s) as inputs. 

In the first instance, this is set up as an instantaneous storm, with all the water dropped over the catchment in one go. Below, we modify this assumption to allow time distributed rainfall.
"""

for filename in os.listdir("./rainfall"):  # for each file in the folder
    if filename.endswith(".asc"):  # ...that ends with .asc...
        if "rainfall__flux" in mg.at_node:
            mg.at_node.pop("rainfall__flux")

        with open(os.path.join("./rainfall", filename)) as fp:
            esri_ascii.load(fp, name="rainfall__flux", at="node", out=mg)
    else:
        continue

    mg.add_zeros("surface_water__depth", at="node")
    # a veneer of water stabilises the model
    mg.at_node["surface_water__depth"].fill(1.0e-12)
    mg.at_node["surface_water__depth"] += mg.at_node["rainfall__flux"] * storm_t
    of = OverlandFlow(mg, steep_slopes=True)

    # storm_t here is the duration of the rainfall, from the rainfall component
    # We're going to assume the rainfall arrives effectively instantaneously, but
    # adding discharge during the run is completely viable

    node_of_max_q = 2126  # established by examining the output of a previous run
    outlet_depth = []
    outlet_times = []
    post_storm_elapsed_time = 0.0
    last_storm_loop_tracker = 0.0
    while post_storm_elapsed_time < 0.5 * 3600.0:  # plot 30 mins-worth of runoff
        dt = of.calc_time_step()
        of.run_one_step(dt=dt)
        post_storm_elapsed_time += dt
        storm_loop_tracker = post_storm_elapsed_time % 180.0  # show every 3 min
        # NB: Do NOT allow this plotting if there are multiple files in the folder
        if storm_loop_tracker < last_storm_loop_tracker:
            plt.figure()
            mg.imshow("surface_water__depth", var_name="Stage (m)")
            plt.title("Stage at t=" + str(post_storm_elapsed_time // 1) + "s")
        last_storm_loop_tracker = storm_loop_tracker
        outlet_depth.append(mg.at_node["surface_water__depth"][node_of_max_q])
        outlet_times.append(post_storm_elapsed_time)

"""
Now, plot the time series at the outlet (defined as the node that experiences peak stage):
"""

plt.plot(outlet_times, outlet_depth, "-")
plt.xlabel("Time elapsed (s)")
plt.ylabel("Flood stage (m)")

"""
We can relax the assumption that all this discharge is delivered instantaneously at the start of the run with some tweaking of the driver:
"""

for filename in os.listdir("./rainfall"):  # for each file in the folder
    if filename.endswith(".asc"):  # ...that ends with .asc...
        if "rainfall__flux" in mg.at_node:
            mg.at_node.pop("rainfall__flux")
        with open(os.path.join("./rainfall", filename)) as fp:
            esri_ascii.load(fp, name="rainfall__flux", at="node", out=mg)
    else:
        continue

    mg.at_node["surface_water__depth"].fill(1.0e-12)

    of = OverlandFlow(mg, steep_slopes=True)
    node_of_max_q = 2126
    total_mins_to_plot = 60.0  # plot 60 mins-worth of runoff
    plot_interval_mins = 10.0  # show every 10 min
    min_tstep_val = 1.0  # necessary to get the model going cleanly
    outlet_depth = []
    outlet_times = []
    storm_elapsed_time = 0.0
    total_elapsed_time = 0.0
    last_storm_loop_tracker = 0.0
    while total_elapsed_time < total_mins_to_plot * 60.0:
        dt = of.calc_time_step()
        remaining_total_time = total_mins_to_plot * 60.0 - total_elapsed_time
        if storm_elapsed_time < storm_t * 3600.0:
            remaining_storm_time = storm_t * 3600.0 - storm_elapsed_time
            dt = min((dt, remaining_total_time, remaining_storm_time, min_tstep_val))
        else:
            dt = min((dt, remaining_total_time, min_tstep_val))
        of.run_one_step(dt=dt)
        total_elapsed_time += dt
        storm_elapsed_time += dt
        storm_loop_tracker = total_elapsed_time % (plot_interval_mins * 60.0)
        # NB: Do NOT allow this plotting if there are multiple files in the folder
        if storm_loop_tracker < last_storm_loop_tracker:
            plt.figure()
            mg.imshow("surface_water__depth", var_name="Stage (m)")
            plt.title("Stage at t=" + str(total_elapsed_time // 1) + "s")
        last_storm_loop_tracker = storm_loop_tracker
        outlet_depth.append(mg.at_node["surface_water__depth"][node_of_max_q])
        outlet_times.append(total_elapsed_time)
        if storm_elapsed_time < storm_t * 3600.0:
            mg.at_node["surface_water__depth"] += (
                mg.at_node["rainfall__flux"] * dt / 3600.0
            )

plt.plot(outlet_times, outlet_depth, "-")
plt.xlabel("Time elapsed (s)")
plt.ylabel("Flood stage (m)")

"""
As expected, a more realistic spread of the rainfall across the storm gives a longer and more subdued flood pulse.

(An aside: the levelling off of the tail at h~0.125m is likely due to the permanent filling of a depression in the topography - the same thing is probably causing the deep pixels in the flow maps - or are these numerical instabilities? Resolving this is left as an exercise for the reader...)
"""



================================================
File: docs/source/tutorials/overland_flow/how_to_d4_pitfill_a_dem.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# How to do "D4" pit-filling on a digital elevation model (DEM)

*(Greg Tucker, July 2021)*

Digital elevation models (DEMs) often contain "pits": cells or groups of cells that represent depressions, and are surrounded by higher-elevation cells. Sometimes these pits represent real landscape features, such as sinkholes in a karst landscape, or "pools" along a dry river channel. In other cases, they are artifacts of errors in the original data or of data processing. Sometimes they reflect a truncated representation of elevation values. For example, some DEMs use integer values to represent elevation in meters. Adjacent cells that differ by less than a meter in elevation can register as having exactly the same elevation in an integer DEM, making the drainage pathways in ambiguous.

For some overland flow models, depressions in a DEM are no problem: water will simply pool in the depressions and overspill when the depression is full. But overland flow models that use the kinematic wave approximation, in which the ground-surface slope is used as a proxy for the hydraulic energy slope, can not do this. Therefore, 2D overland flow models, like the Landlab components `KinwaveOverlandFlowModel` and `KinwaveImplicitOverlandFlow`, require a DEM that has had its pits and flat areas digitally removed before they can be run reliably.

This tutorial describes how to do this using Landlab's flow-routing and pit-filling components.

"""

"""
First, some imports:
"""

from landlab.components import FlowAccumulator
from landlab.io import esri_ascii

"""
Read the un-filled DEM, which happens to be in Arc/Info ASCII Grid format (a.k.a., ESRI ASCII). We will use the `set_watershed_boundary_condition` function to set all nodes with an elevation value equal to a "no data" code (default -9999) to closed boundaries, and any nodes with valid elevation values that lie on the grid's perimeter to open (fixed value) boundaries. You can learn more about the raster version of this handy function [here](https://landlab.csdms.io/generated/api/landlab.grid.raster.html#landlab.grid.raster.RasterModelGrid.set_watershed_boundary_condition). 
"""

# Read a small DEM
with open("hugo_site.asc") as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")

# This sets nodes with a no-data code (default -9999) to closed boundary status
# (For a perimeter node to be considered )
grid.set_watershed_boundary_condition(grid.at_node["topographic__elevation"])

"""
Having read the DEM and set its boundary conditions, we now instantiate and run `FlowAccumulator`. We will tell it to use "D4" routing, which is indicated by the parameter choice `flow_director = FlowDirectorSteepest`. (Note that the term "steepest" means "choose the steepest drop among all directly adjacent nodes". In a RasterModelGrid, there are normally four neighboring nodes, and so when `FlowDirectorSteepest` is applied to a raster grid, it does 'D4' routing. When it is applied to a hex grid, for example, it chooses among six possible directions. This variation in the number of potential directions depending on grid type is why it this particular flow-direction method is called "steepest" rather than "D4". For more on this, see the tutorials *the_FlowDirectors* and *compare_FlowDirectors*.)

First, we will run the flow accumulator without any depression handling, in order to visualize the drainage in this case:
"""

fa_no_fill = FlowAccumulator(grid, flow_director="FlowDirectorSteepest")
fa_no_fill.run_one_step()

grid.imshow("drainage_area", colorbar_label="Drainage area (m2)")

"""
Notice that there are interruptions in the drainage patterns: places where drainage area abruptly drops in the downstream direction. These spots represent drainages that terminate in pits.
"""

"""
Now we'll repeat the process, but this time we will also tell the `FlowAccumulator` to use the `LakeMapperBarnes` component for depression handling. (Note that we could run `LakeMapperBarnes` separately, but because depression handling and flow accumulation work together, the `FlowAccumulator` provides a way to directly "embed" a depression handler and its arguments, which is the approach used here; you can learn more about this in the tutorial *the_FlowAccumulator*.) We can examine the parameters of `LakeMapperBarnes`:
"""

from landlab.components import LakeMapperBarnes

print(LakeMapperBarnes.__init__.__doc__)

"""
If we don't wish to accept the built-in defaults, we can send any of these parameters as additional arguments to the `FlowAccumulator` constructor. For this application, we want:

- `surface = topographic__elevation`: use the topography (this is the default)
- `method = 'Steepest'`: use D4 routing (the default)
- `fill_flat = False`: we want a slight slope assigned to otherwise flat areas
- `fill_surface = 'topographic__elevation'`: fill the topography (the default)
- `redirect_flow_steepest_descent = True`: so we can plot the revised drainage
- `reaccumulate_flow = True`: so we can plot the revised drainage
"""

fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorSteepest",
    depression_finder="LakeMapperBarnes",
    surface="topographic__elevation",
    method="Steepest",
    fill_flat=False,
    fill_surface="topographic__elevation",
    redirect_flow_steepest_descent=True,
    reaccumulate_flow=True,
)

original_elev = grid.at_node[
    "topographic__elevation"
].copy()  # keep a copy of the original
fa.run_one_step()
grid.imshow("drainage_area", colorbar_label="Drainage area (m2)")

"""
Now we have a continuous drainage system that passes smoothly over the now-filled pits. Drainage from every cell in the watershed can reach the outlet. By plotting the difference between the original and modified topography, we can inspect the depth and spatial patterns of pit filling:
"""

grid.imshow(
    grid.at_node["topographic__elevation"] - original_elev,
    colorbar_label="fill depth (m)",
)



================================================
File: docs/source/tutorials/overland_flow/overland_flow_driver.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The deAlmeida Overland Flow Component 
"""

"""
This notebook illustrates running the deAlmeida overland flow component in an extremely simple-minded way on a real topography, then shows it creating a flood sequence along an inclined surface with an oscillating water surface at one end.

First, import what we'll need:
"""

import matplotlib.pyplot as plt
from tqdm.notebook import tqdm

from landlab.components.overland_flow import OverlandFlow
from landlab.io import esri_ascii

"""
Pick the initial and run conditions
"""

run_time = 100  # duration of run, (s)
h_init = 0.1  # initial thin layer of water (m)
n = 0.01  # roughness coefficient, (s/m^(1/3))
g = 9.8  # gravity (m/s^2)
alpha = 0.7  # time-step factor (nondimensional; from Bates et al., 2010)
u = 0.4  # constant velocity (m/s, de Almeida et al., 2012)
run_time_slices = (10, 50, 100)

"""
Elapsed time starts at 1 second. This prevents errors when setting our boundary conditions.
"""

elapsed_time = 1.0

"""
Use Landlab methods to import an ARC ascii grid, and load the data into the field that the component needs to look at to get the data. This loads the elevation data, z, into a "field" in the grid itself, defined on the nodes.
"""

with open("Square_TestBasin.asc") as fp:
    rmg = esri_ascii.load(fp, name="topographic__elevation", at="node")
rmg.set_closed_boundaries_at_grid_edges(True, True, True, True)

"""
We can get at this data with this syntax:
"""

rmg.at_node["topographic__elevation"]

"""
Note that the boundary conditions for this grid mainly got handled with the final line of those three, but for the sake of completeness, we should probably manually "open" the outlet. We can find and set the outlet like this:
"""

# This DEM was generated using Landlab and the outlet node ID was known
my_outlet_node = 100
rmg.status_at_node[my_outlet_node] = 1  # 1 is the code for fixed value

"""
Now initialize a couple more grid fields that the component is going to need:
"""

rmg.add_zeros("surface_water__depth", at="node")  # water depth (m)

rmg.at_node["surface_water__depth"] += h_init

"""
Let's look at our watershed topography
"""

rmg.imshow("topographic__elevation")

"""
Now instantiate the component itself
"""

# for stability in steeper environments, we set the steep_slopes flag to True
of = OverlandFlow(rmg, steep_slopes=True)

"""
Now we're going to run the loop that drives the component:
"""

with tqdm(total=run_time) as pbar:
    while elapsed_time < run_time:
        # First, we calculate our time step.
        dt = of.calc_time_step()

        # Now, we can generate overland flow.
        of.overland_flow()

        # Increased elapsed time
        elapsed_time += dt

        pbar.update(dt)

rmg.imshow("surface_water__depth", cmap="Blues")

"""
Now let's get clever, and run a set of time slices:
"""

elapsed_time = 1.0
for t in run_time_slices:
    while elapsed_time < t:
        # First, we calculate our time step.
        dt = of.calc_time_step()
        # Now, we can generate overland flow.
        of.overland_flow()
        # Increased elapsed time
        elapsed_time += dt
    plt.figure(t)
    rmg.imshow("surface_water__depth", cmap="Blues")



================================================
File: docs/source/tutorials/overland_flow/kinwave_implicit/kinwave_implicit_overland_flow.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The Implicit Kinematic Wave Overland Flow Component 
"""

"""
## Overview

This notebook demonstrates the `KinwaveImplicitOverlandFlow` Landlab component. The component implements a two-dimensional kinematic wave model of overland flow, using a digital elevation model or other source of topography as the surface over which water flows.

### Theory

The kinematic wave equations are a simplified form of the 2D shallow-water equations in which energy slope is assumed to equal bed slope. Conservation of water mass is expressed in terms of the time derivative of the local water depth, $H$, and the spatial derivative (divergence) of the unit discharge vector $\mathbf{q} = UH$ (where $U$ is the 2D depth-averaged velocity vector):

$$\frac{\partial H}{\partial t} = R - \nabla\cdot \mathbf{q}$$

where $R$ is the local runoff rate [L/T] and $\mathbf{q}$ has dimensions of volume flow per time per width [L$^2$/T]. The discharge depends on the local depth, bed-surface gradient $\mathbf{S}=-\nabla\eta$ (this is the kinematic wave approximation; $\eta$ is land surface height), and a roughness factor $C_r$:

$$\mathbf{q} = \frac{1}{C_r} \mathbf{S} H^\alpha |S|^{-1/2}$$

Reads may recognize this as a form of the Manning, Chezy, or Darcy-Weisbach equation. If $\alpha = 5/3$ then we have the Manning equation, and $C_r = n$ is "Manning's n". If $\alpha = 3/2$ then we have the Chezy/Darcy-Weisbach equation, and $C_r = 1/C = (f/8g)^{1/2}$ represents the Chezy roughness factor $C$ and the equivalent Darcy-Weisbach factor $f$.

### Numerical solution

The solution method used by this component is locally implicit, and works as follows. At each time step, we iterate from upstream to downstream over the topography. Because we are working downstream, we can assume that we know the total water inflow to a given cell. We solve the following mass conservation equation at each cell:

$$\frac{H^{t+1} - H^t}{\Delta t }= \frac{Q_{in}}{A} - \frac{Q_{out}}{A} + R$$

where $H$ is water depth at a given grid node, $t$ indicates time step number, $\Delta t$ is time step duration, $Q_{in}$ is total inflow discharge, $Q_{out}$ is total outflow discharge, $A$ is cell area, and $R$ is local runoff rate (precipitation minus infiltration; could be negative if runon infiltration is occurring).

The specific outflow discharge leaving a cell along one of its faces is:

$$q = (1/C_r) H^\alpha S^{1/2}$$

where $S$ is the downhill-positive gradient of the link that crosses this particular face. Outflow discharge is zero for links that are flat or "uphill" from the given node. Total discharge out of a cell is then the sum of (specific discharge x face width) over all outflow faces:

$$Q_{out} = \sum_{i=1}^N (1/C_r) H^\alpha S_i^{1/2} W_i$$

where $N$ is the number of outflow faces (i.e., faces where the ground slopes downhill away from the cell's node), and $W_i$ is the width of face $i$.

We use the depth at the cell's node, so this simplifies to:

$$Q_{out} = (1/C_r) H'^\alpha \sum_{i=1}^N S_i^{1/2} W_i$$

Notice that we know everything here except $H'$. The reason we know $Q_{out}$ is that it equals $Q_{in}$ (which is either zero or we calculated it previously) plus $RA$.

We define $H$ in the above as a weighted sum of the "old" (time step $t$) and "new" (time step $t+1$) depth values:

$$H' = w H^{t+1} + (1-w) H^t$$

If $w=1$, the method is fully implicit. If $w=0$, it is a simple forward explicit method.

When we combine these equations, we have an equation that includes the unknown $H^{t+1}$ and a bunch of terms that are known. If $w\ne 0$, it is a nonlinear equation in $H^{t+1}$, and must be solved iteratively. We do this using a root-finding method in the scipy.optimize library.

In order to implement the algorithm, we must already know which of neighbors of each node are lower than the neighbor, and what the slopes between them are. We accomplish this using the `FlowAccumulator` and `FlowDirectorMFD` components. Running the `FlowAccumulator` also generates a sorted list (array) of nodes in drainage order.

### The component

Import the needed libraries, then inspect the component's docstring:
"""

import matplotlib.pyplot as plt
import numpy as np
from tqdm.notebook import trange

from landlab import RasterModelGrid
from landlab.components.overland_flow import KinwaveImplicitOverlandFlow
from landlab.io import esri_ascii

print(KinwaveImplicitOverlandFlow.__doc__)

"""
The docstring for the `__init__` method will give us a list of parameters:
"""

print(KinwaveImplicitOverlandFlow.__init__.__doc__)

"""
## Example 1: downpour on a plane

The first example tests that the component can reproduce the expected steady flow pattern on a sloping plane, with a gradient of $S_p$. We'll adopt the Manning equation. Once the system comes into equilibrium, the discharge should increase width distance down the plane according to $q = Rx$. We can use this fact to solve for the corresponding water depth:

$$(1/n) H^{5/3} S^{1/2} = R x$$

which implies

$$H = \left( \frac{nRx}{S^{1/2}} \right)^{3/5}$$

This is the analytical solution against which to test the model.
"""

"""
Pick the initial and run conditions
"""

# Process parameters
n = 0.01  # roughness coefficient, (s/m^(1/3))
dep_exp = 5.0 / 3.0  # depth exponent
S = 0.01  # slope of plane
R = 72.0  # runoff rate, mm/hr

# Run-control parameters
run_time = 240.0  # duration of run, (s)
nrows = 5  # number of node rows
ncols = 11  # number of node columns
dx = 2.0  # node spacing, m
dt = 10.0  # time-step size, s
plot_every = 60.0  # plot interval, s

# Derived parameters
num_steps = int(run_time / dt)

"""
Create grid and fields:

"""

# create and set up grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, True, True)  # open only on east

# add required field
elev = grid.add_zeros("topographic__elevation", at="node")

# set topography
elev[grid.core_nodes] = S * (np.amax(grid.x_of_node) - grid.x_of_node[grid.core_nodes])

"""
Plot topography, first in plan view...
"""

grid.imshow(elev)

"""
...then as a cross-section:
"""

plt.plot(grid.x_of_node, elev)
plt.xlabel("Distance (m)")
plt.ylabel("Height (m)")
plt.grid(True)

# Instantiate the component
olflow = KinwaveImplicitOverlandFlow(
    grid, runoff_rate=R, roughness=n, depth_exp=dep_exp
)

# Helpful function to plot the profile


def plot_flow_profile(grid, olflow):
    """Plot the middle row of topography and water surface
    for the overland flow model olflow."""
    nc = grid.number_of_node_columns
    nr = grid.number_of_node_rows
    startnode = nc * (nr // 2) + 1
    midrow = np.arange(startnode, startnode + nc - 1, dtype=int)
    topo = grid.at_node["topographic__elevation"]
    plt.plot(
        grid.x_of_node[midrow],
        topo[midrow] + grid.at_node["surface_water__depth"][midrow],
        "b",
    )
    plt.plot(grid.x_of_node[midrow], topo[midrow], "k")
    plt.xlabel("Distance (m)")
    plt.ylabel("Ground and water surface height (m)")

"""
Run the component forward in time, plotting the output in the form of a profile:
"""

next_plot = plot_every
for i in range(num_steps):
    olflow.run_one_step(dt)
    if (i + 1) * dt >= next_plot:
        plot_flow_profile(grid, olflow)
        next_plot += plot_every

# Compare with analytical solution for depth
Rms = R / 3.6e6  # convert to m/s
nc = grid.number_of_node_columns
x = grid.x_of_node[grid.core_nodes][: nc - 2]
Hpred = (n * Rms * x / (S**0.5)) ** 0.6
plt.plot(x, Hpred, "r", label="Analytical")
plt.plot(
    x,
    grid.at_node["surface_water__depth"][grid.core_nodes][: nc - 2],
    "b--",
    label="Numerical",
)
plt.xlabel("Distance (m)")
plt.ylabel("Water depth (m)")
plt.grid(True)
plt.legend()

"""
## Example 2: overland flow on a DEM

For this example, we'll import a small digital elevation model (DEM) for a site in New Mexico, USA.
"""

# Process parameters
n = 0.1  # roughness coefficient, (s/m^(1/3))
dep_exp = 5.0 / 3.0  # depth exponent
R = 72.0  # runoff rate, mm/hr

# Run-control parameters
rain_duration = 240.0  # duration of rainfall, s
run_time = 480.0  # duration of run, s
dt = 10.0  # time-step size, s
dem_filename = "../hugo_site_filled.asc"

# Derived parameters
num_steps = int(run_time / dt)

# set up arrays to hold discharge and time
time_since_storm_start = np.arange(0.0, dt * (2 * num_steps + 1), dt)
discharge = np.zeros(2 * num_steps + 1)

# Read the DEM file as a grid with a 'topographic__elevation' field
with open(dem_filename) as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
elev = grid.at_node["topographic__elevation"]

# Configure the boundaries: valid right-edge nodes will be open;
# all NODATA (= -9999) nodes will be closed.
grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
grid.status_at_node[np.isclose(elev, -9999.0)] = grid.BC_NODE_IS_CLOSED

# display the topography
grid.imshow(elev, colorbar_label="Elevation (m)", cmap="pink")

"""
It would be nice to track discharge at the watershed outlet, but how do we find the outlet location? We actually have several valid nodes along the right-hand edge. Then we'll keep track of the field `surface_water_inflow__discharge` at these nodes. We can identify the nodes by the fact that they are (a) at the right-hand edge of the grid, and (b) have positive elevations (the ones with -9999 are outside of the watershed).
"""

indices = np.where(elev[grid.nodes_at_right_edge] > 0.0)[0]
outlet_nodes = grid.nodes_at_right_edge[indices]
print(f"Outlet nodes: {outlet_nodes}")
print(f"Elevations of the outlet nodes: {elev[outlet_nodes]}")

# Instantiate the component
olflow = KinwaveImplicitOverlandFlow(
    grid, runoff_rate=R, roughness=n, depth_exp=dep_exp
)

discharge_field = grid.at_node["surface_water_inflow__discharge"]

for i in trange(num_steps):
    olflow.run_one_step(dt)
    discharge[i + 1] = np.sum(discharge_field[outlet_nodes])

plt.plot(time_since_storm_start[:num_steps], discharge[:num_steps])
plt.xlabel("Time (s)")
plt.ylabel("Discharge (cms)")
plt.grid(True)

grid.imshow(
    grid.at_node["surface_water__depth"], cmap="Blues", colorbar_label="Water depth (m)"
)

"""
Now turn down the rain and run it a bit longer...
"""

olflow.runoff_rate = 1.0  # just 1 mm/hr

for i in trange(num_steps, 2 * num_steps):
    olflow.run_one_step(dt)
    discharge[i + 1] = np.sum(discharge_field[outlet_nodes])

plt.plot(time_since_storm_start, discharge)
plt.xlabel("Time (s)")
plt.ylabel("Discharge (cms)")
plt.grid(True)

grid.imshow(
    grid.at_node["surface_water__depth"],
    cmap="Blues",
    colorbar_label="Water depth (m)",
)

"""
Voila! A fine hydrograph, and a water-depth map that shows deeper water in the channels (and highlights depressions in the topography).
"""



================================================
File: docs/source/tutorials/overland_flow/linear_diffusion_overland_flow/linear_diffusion_overland_flow_router.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# The Linear Diffusion Overland Flow Router
"""

"""
## Overview

This notebook demonstrates the `LinearDiffusionOverlandFlowRouter` Landlab component. The component implements a two-dimensional model of overland flow, based on a linearization of the diffusion-wave approximation of the shallow-water equations.

### Theory

#### Flow direction, depth, and velocity

The diffusion-wave equations are a simplified form of the 2D shallow-water equations in which energy slope is assumed to equal water-surface slope. Conservation of water mass is expressed in terms of the time derivative of the local water depth, $H$, and the spatial derivative (divergence) of the unit discharge vector $\mathbf{q} = UH$ (where $U$ is the 2D depth-averaged velocity vector):

$$\frac{\partial H}{\partial t} = R - \nabla\cdot \mathbf{q}$$

where $R$ is the local runoff rate [L/T] and $\mathbf{q}$ has dimensions of volume flow per time per width [L$^2$/T]. The flow velocity is calculated using a linearized form of the Manning friction law:

$$\mathbf{U} = \frac{H^{4/3}}{n^2 u_c} \nabla w$$

$$w = \eta + H$$

Here $\eta(x,y,t)$ is ground-surface elevation, $w(x,y,t)$ is water-surface elevation, $n$ is the Manning friction coefficient, and $u_c$ is a characteristic scale velocity (see, e.g., Mariotti, 2018). Thus, there are two parameters governing flow speed: $n$ and $u_c$. The may, however, be treated as a single lumped parameter $n^2 u_c$.

#### Rainfall and infiltration

Runoff rate is calculated as the difference between the rates of precipitation, $P$, and infiltration, $I$. The user specifies a precipitation rate (which is a public variable that can be modified after instantiation), and a maximum infiltration rate, $I_c$. The actual infiltration rate depends on the available surface water, and is calculated in a way that allows it to approach zero as the surface-water depth approaches zero:

$$I = I_c \left( 1 - e^{-H/H_i} \right)$$

where $H_i$ is a characteristic water depth, defined such that the actual infiltration rate is about 95% of $I_c$ when $H = 3 H_i$.
"""

"""
### Numerical Methods

#### Finite-volume representation

The component uses an explicit, forward-Euler finite-volume method. The solution for water depth at a new time step $k+1$ is calculated from:

$$H_i^{k+1} = H_i^k + \Delta t \left[ \frac{dH_i}{dt} \right]_i^k$$

The time derivative at step $k$ is calculated as:

$$\left[ \frac{dH_i}{dt} \right]_i^k = R - I - \frac{1}{\Lambda_i} \sum_{j=1}^{N_i} \lambda_{ij} q_{ij}$$

where $R$ is rainfall rate, $I$ is infiltration rate (calculated as above), $\Lambda_i$ is the horizontal surface area of the cell enclosing node $i$, $\lambda_{ij}$ is the length of the cell face between node $i$ and its $j$-th neighbor, and $q_{ij}$ is the specific water discharge along the link that connects node $i$ and its $j$-th neighbor.

For a raster grid, this treatment is equivalent to a centered-in-space finite-difference arrangement. For more on finite-difference solutions to diffusion problems, see for example Slingerland and Kump (2011) and Press et al. (1986).

#### Time-step limiter

Because of the linearization described above, the flow model is effectively a diffusion problem with a space- and time-varying diffusivity, because the effective diffusivity $D$ depends on water depth:

$$D = \frac{H^{7/3}}{n^2 u_c}$$

One numerical challenge is that, according to the Courant-Levy-Friedrichs (CFL) criterion, the maximum stable time step will depend on water depth, which varies in space and time. To prevent instability, the solution algorithm calculates at every iteration a maximum value for $D$ using the current maximum water depth (or a very small minimum value, whichever is larger, to prevent blowup in the case of zero water depth). The maximum step size is then calculated as:

$$\Delta t_\text{max} = \alpha \frac{L_\text{min}^2}{2 D}$$

where $L_\text{min}$ is the length of the shortest link in the grid (which is just equal to node spacing, $\Delta x$, for a uniform raster or hex grid). The stability factor $\alpha$ is a user-controllable parameter that defaults to 0.2, and must be $\le 1$.

If $\Delta t_\text{max}$ is less than the user-specified "global" time step duration, the algorithm iterates repeatedly with time steps of size $\Delta t_\text{max}$ (or the remaining time in the global step, whichever is smaller) until the global time step duration has been completed.

"""

"""
### The component

Import the needed libraries, then inspect the component's docstring:
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid
from landlab.components.overland_flow import LinearDiffusionOverlandFlowRouter
from landlab.io import esri_ascii

"""
Use the `help` function to get a description of the `LinearDiffusionOverlandFlowRouter` component. If you scroll down to the `__init__` section, you will see a list of parameters.
"""

help(LinearDiffusionOverlandFlowRouter)

"""
## Example 1: downpour on a single cell

The first example tests that the component can reproduce the expected steady flow depth for rain on a single cell. The input water flow rate, in $m^3 / s$, is:

$$Q_\text{in} = P \Delta x^2$$

The output flow rate is

$$Q_\text{out} = \frac{\Delta x}{n^2 u_c} H^{7/3} S_w$$

where $S_w$ is the water surface slope. We can write the water-surface slope in terms of the water height of the (one) core node (which just equals $H$, because the ground elevation is zero) and the water height at the adjacent open-boundary node, which is zero, so

$$S_w = \frac{H}{\Delta x}$$

We can therefore plug this into the equation for $Q_\text{out}$ and solve for the expected equilibrium depth:

$$H = \left(\Delta x^2 P n^2 u_c \right)^{3/10}$$
"""

"""
Pick the initial and run conditions
"""

# Process parameters
n = 0.01  # roughness coefficient, (s/m^(1/3))
vel_scale = 1.0  # velocity scale, m/s
R = 72.0 / (3600.0 * 1000.0)  # runoff rate, m/s

# Run-control parameters
run_time = 360.0  # duration of run, (s)
nrows = 3  # number of node rows
ncols = 3  # number of node columns
dx = 2.0  # node spacing, m
dt = 20.0  # time-step size, s
plot_every = 60.0  # plot interval, s

# Derived parameters
num_steps = int(run_time / dt)

"""
Create grid and fields:

"""

# create and set up grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
grid.set_closed_boundaries_at_grid_edges(False, True, True, True)  # open only on east

# add required field
elev = grid.add_zeros("topographic__elevation", at="node")

# Instantiate the component
olflow = LinearDiffusionOverlandFlowRouter(
    grid, rain_rate=R, roughness=n, velocity_scale=vel_scale
)

# Helpful function to plot the profile


def plot_flow_profile(grid, olflow):
    """Plot the middle row of topography and water surface
    for the overland flow model olflow."""
    nc = grid.number_of_node_columns
    nr = grid.number_of_node_rows
    startnode = nc * (nr // 2) + 1
    midrow = np.arange(startnode, startnode + nc - 1, dtype=int)
    topo = grid.at_node["topographic__elevation"]
    plt.plot(
        grid.x_of_node[midrow],
        topo[midrow] + grid.at_node["surface_water__depth"][midrow],
        "b",
    )
    plt.plot(grid.x_of_node[midrow], topo[midrow], "k")
    plt.xlabel("Distance (m)")
    plt.ylabel("Ground and water surface height (m)")

"""
Run the component forward in time, plotting the output in the form of a profile:
"""

next_plot = plot_every
HH = []  # keep track of depth through time
for i in range(num_steps):
    olflow.run_one_step(dt)
    if (i + 1) * dt >= next_plot:
        plot_flow_profile(grid, olflow)
        next_plot += plot_every
    HH.append(grid.at_node["surface_water__depth"][4])

# Compare with analytical solution for depth
expected_depth = (dx * dx * R * n * n * vel_scale) ** 0.3
computed_depth = grid.at_node["surface_water__depth"][4]

print(f"Expected depth = {expected_depth} m")
print(f"Computed depth = {computed_depth} m")

plt.plot(np.linspace(0, run_time, len(HH)), HH)
plt.xlabel("Time (s)")
plt.ylabel("Water depth (m)")

"""
## Example 2: overland flow on a DEM

For this example, we'll import a small digital elevation model (DEM) for a site in New Mexico, USA, with 10 m cells.
"""

# Process parameters
n = 0.1  # roughness coefficient, (s/m^(1/3))
uc = 1.0  # characteristic velocity scale (m/s)
R1 = 72.0 / (3600.0 * 1000.0)  # initial rainfall rate, m/s (converted from mm/hr)
R2 = 0.0 / (3600.0 * 1000.0)  # later rainfall rate, m/s (converted from mm/hr)
infilt_cap = 10.0 / (3600 * 1000.0)  # infiltration capacity, m/s (converted from mm/hr)

# Run-control parameters
heavy_rain_duration = 300.0  # duration of heavy rainfall, s
run_time = 1200.0  # duration of run, s
dt = 20.0  # time-step size, s
dem_filename = "../hugo_site.asc"

# Derived parameters
num_steps = int(run_time / dt)

# set up arrays to hold discharge, time, and rain rate
time_since_storm_start = np.linspace(0.0, run_time, num_steps + 1)
discharge = np.zeros(num_steps + 1)
rain_rate = np.zeros(num_steps + 1)
rain_rate[:] = R1
rain_rate[time_since_storm_start >= heavy_rain_duration] = R2

# Read the DEM file as a grid with a 'topographic__elevation' field
with open(dem_filename) as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
elev = grid.at_node["topographic__elevation"]

# Configure the boundaries: valid right-edge nodes will be open;
# all NODATA (= -9999) nodes will be closed.
grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
grid.status_at_node[np.isclose(elev, -9999.0)] = grid.BC_NODE_IS_CLOSED

# display the topography
grid.imshow(elev, colorbar_label="Elevation (m)", cmap="pink")

"""
It would be nice to track discharge at the watershed outlet, but how do we find the outlet location? We actually have several valid nodes along the right-hand edge. Then we'll keep track of the field `water__specific_discharge` at the active links that connect to these boundary nodes. We can identify the nodes by the fact that they are (a) at the right-hand edge of the grid, and (b) have positive elevations (the ones with -9999 are outside of the watershed). We can identify the relevant active links as those connected to the outlet nodes that have active status (meaning they do not connect to any closed boundary nodes).
"""

indices = np.where(elev[grid.nodes_at_right_edge] > 0.0)[0]
outlet_nodes = grid.nodes_at_right_edge[indices]
print(f"Outlet nodes: {outlet_nodes}")
print(f"Elevations of the outlet nodes: {elev[outlet_nodes]}")

links_at_outlets = grid.links_at_node[outlet_nodes]
links_to_track = links_at_outlets[
    grid.status_at_link[links_at_outlets] == grid.BC_LINK_IS_ACTIVE
].flatten()
print(f"Links at which to track discharge: {links_to_track}")

# Instantiate the component
olflow = LinearDiffusionOverlandFlowRouter(
    grid, rain_rate=R, infilt_rate=infilt_cap, roughness=n, velocity_scale=vel_scale
)

def cfl():
    hmax = np.amax(grid.at_node["surface_water__depth"])
    D = hmax ** (7.0 / 3.0) / (n * n * uc)
    return 0.5 * dx * dx / D

q = grid.at_link["water__specific_discharge"]

for i in range(num_steps):
    olflow.rain_rate = rain_rate[i]
    olflow.run_one_step(dt)
    discharge[i + 1] = np.sum(q[links_to_track]) * dx

plt.plot(time_since_storm_start / 60.0, discharge)
plt.xlabel("Time (min)")
plt.ylabel("Discharge (cms)")
plt.grid(True)

grid.imshow(
    grid.at_node["surface_water__depth"], cmap="Blues", colorbar_label="Water depth (m)"
)

"""
Voila! A fine hydrograph, and a water-depth map that shows deeper water in the channels (and highlights depressions and low-gradient spots in the topography).
"""

"""
## References

Mariotti, G. (2018). Marsh channel morphological response to sea level rise and sediment supply. Estuarine, Coastal and Shelf Science, 209, 89-101.

Press, W. H., Vetterling, W. T., Teukolsky, S. A., & Flannery, B. P. (1986). Numerical recipes. Cambridge: Cambridge university press.

Slingerland, R., & Kump, L. (2011). Mathematical Modeling of Earth's Dynamical Systems. Princeton University Press.
"""



================================================
File: docs/source/tutorials/overland_flow/overland_flow_erosion/ol_flow_erosion_components.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Components for modeling overland flow erosion 

*(G.E. Tucker, July 2021)*

There are two related components that calculate erosion resulting from surface-water flow, a.k.a. overland flow: `DepthSlopeProductErosion` and `DetachmentLtdErosion`. They were originally created by Jordan Adams to work with the `OverlandFlow` component, which solves for water depth across the terrain. They are similar to the `StreamPowerEroder` and `FastscapeEroder` components in that they calculate erosion resulting from water flow across a topographic surface, but whereas these components require a flow-routing algorithm to create a list of node "receivers", the `DepthSlopeProductErosion` and `DetachmentLtdErosion` components only require a user-identified slope field together with an at-node depth or discharge field (respectively).
"""

"""
## `DepthSlopeProductErosion`

This component represents the rate of erosion, $E$, by surface water flow as:

$$E = k_e (\tau^a - \tau_c^a)$$

where $k_e$ is an erodibility coefficient (with dimensions of velocity per stress$^a$), $\tau$ is bed shear stress, $\tau_c$ is a minimum bed shear stress for any erosion to occur, and $a$ is a parameter that is commonly treated as unity.

For steady, uniform flow, 

$$\tau = \rho g H S$$,

with $\rho$ being fluid density, $g$ gravitational acceleration, $H$ local water depth, and $S$ the (postive-downhill) slope gradient (an approximation of the sine of the slope angle).

The component uses a user-supplied slope field (at nodes) together with the water-depth field `surface_water__depth` to calculate $\tau$, and then the above equation to calculate $E$. The component will then modify the `topographic__elevation` field accordingly. If the user wishes to apply material uplift relative to baselevel, an `uplift_rate` parameter can be passed on initialization.

We can learn more about this component by examining its internal documentation. To get an overview of the component, we can examine its *header docstring*: internal documentation provided in the form of a Python docstring that sits just below the class declaration in the source code. This text can be displayed as shown here:
"""

from tqdm.notebook import trange

from landlab.components import DepthSlopeProductErosion

print(DepthSlopeProductErosion.__doc__)

"""
A second useful source of internal documentation for this component is its *init docstring*: a Python docstring that describes the component's class `__init__` method. In Landlab, the init docstrings for components normally provide a list of that component's parameters. Here's how to display the init docstring:
"""

print(DepthSlopeProductErosion.__init__.__doc__)

"""
### Example

In this example, we load the topography of a small drainage basin, calculate a water-depth field by running overland flow over the topography using the `KinwaveImplicitOverlandFlow` component, and then calculating the resulting erosion.

Note that in order to accomplish this, we need to identify which variable we wish to use for slope gradient. This is not quite as simple as it may sound. An easy way to define slope is as the slope between two adjacent grid nodes. But using this approach means that slope is defined on the grid *links* rathter than *nodes*. To calculate slope magnitude at *nodes*, we'll define a little function below that uses Landlab's `calc_grad_at_link` method to calculate gradients at grid links, then use the `map_link_vector_components_to_node` method to calculate the $x$ and $y$ vector components at each node. With that in hand, we just use the Pythagorean theorem to find the slope magnitude from its vector components.

First, though, some imports we'll need:
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import KinwaveImplicitOverlandFlow
from landlab.grid.mappers import map_link_vector_components_to_node
from landlab.io import esri_ascii

def slope_magnitude_at_node(grid, elev):
    # calculate gradient in elevation at each link
    grad_at_link = grid.calc_grad_at_link(elev)

    # set the gradient to zero for any inactive links
    # (those attached to a closed-boundaries node at either end,
    # or connecting two boundary nodes of any type)
    grad_at_link[grid.status_at_link != grid.BC_LINK_IS_ACTIVE] = 0.0

    # map slope vector components from links to their adjacent nodes
    slp_x, slp_y = map_link_vector_components_to_node(grid, grad_at_link)

    # use the Pythagorean theorem to calculate the slope magnitude
    # from the x and y components
    slp_mag = (slp_x * slp_x + slp_y * slp_y) ** 0.5

    return slp_mag, slp_x, slp_y

"""
(See [here](https://landlab.csdms.io/generated/api/landlab.grid.gradients.html#landlab.grid.gradients.calc_grad_at_link) to learn how `calc_grad_at_link` works, and [here](https://landlab.csdms.io/generated/api/landlab.grid.raster_mappers.html#landlab.grid.raster_mappers.map_link_vector_components_to_node_raster) to learn how 
`map_link_vector_components_to_node` works.)

Next, define some parameters we'll need.

To estimate the erodibility coefficient $k_e$, one source is:

[http://milford.nserl.purdue.edu/weppdocs/comperod/](http://milford.nserl.purdue.edu/weppdocs/comperod/)

which reports experiments in rill erosion on agricultural soils. Converting their data into $k_e$, its values are on the order of 1 to 10 $\times 10^{-6}$ (m / s Pa), with threshold ($\tau_c$) values on the order of a few Pa.
"""

# Process parameters
n = 0.1  # roughness coefficient, (s/m^(1/3))
dep_exp = 5.0 / 3.0  # depth exponent
R = 72.0  # runoff rate, mm/hr
k_e = 4.0e-6  # erosion coefficient (m/s)/(kg/ms^2)
tau_c = 3.0  # erosion threshold shear stress, Pa

# Run-control parameters
rain_duration = 240.0  # duration of rainfall, s
run_time = 480.0  # duration of run, s
dt = 10.0  # time-step size, s
dem_filename = "../hugo_site_filled.asc"

# Derived parameters
num_steps = int(run_time / dt)

# set up arrays to hold discharge and time
time_since_storm_start = np.arange(0.0, dt * (2 * num_steps + 1), dt)
discharge = np.zeros(2 * num_steps + 1)

"""
Read an example digital elevation model (DEM) into a Landlab grid and set up the boundaries so that water can only exit out the right edge, representing the watershed outlet.
"""

# Read the DEM file as a grid with a 'topographic__elevation' field
with open(dem_filename) as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
elev = grid.at_node["topographic__elevation"]

# Configure the boundaries: valid right-edge nodes will be open;
# all NODATA (= -9999) nodes will be closed.
grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
grid.status_at_node[np.isclose(elev, -9999.0)] = grid.BC_NODE_IS_CLOSED

"""
Now we'll calculate the slope vector components and magnitude, and plot the vectors as quivers on top of a shaded image of the topography:
"""

slp_mag, slp_x, slp_y = slope_magnitude_at_node(grid, elev)
grid.imshow(elev)
plt.quiver(grid.x_of_node, grid.y_of_node, slp_x, slp_y)

"""
Let's take a look at the slope magnitudes:
"""

grid.imshow(slp_mag, colorbar_label="Slope gradient (m/m)")

"""
Now we're ready to instantiate a `KinwaveImplicitOverlandFlow` component, with a specified runoff rate and roughness:
"""

# Instantiate the component
olflow = KinwaveImplicitOverlandFlow(
    grid, runoff_rate=R, roughness=n, depth_exp=dep_exp
)

"""
The `DepthSlopeProductErosion` component requires there to be a field called `slope_magnitude` that contains our slope-gradient values, so we will we will create this field and assign `slp_mag` to it (the `clobber` keyword says it's ok to overwrite this field if it already exists, which prevents generating an error message if you run this cell more than once):
"""

grid.add_field("slope_magnitude", slp_mag, at="node", clobber=True)

"""
Now we're ready to instantiate a `DepthSlopeProductErosion` component:
"""

dspe = DepthSlopeProductErosion(grid, k_e=k_e, tau_crit=tau_c, slope="slope_magnitude")

"""
Next, we'll make a copy of the starting terrain for later comparison, then run overland flow and erosion:
"""

starting_elev = elev.copy()

for i in trange(num_steps):
    olflow.run_one_step(dt)
    dspe.run_one_step(dt)
    slp_mag[:], slp_x, slp_y = slope_magnitude_at_node(grid, elev)

"""
We can visualize the instantaneous erosion rate at the end of the run, in m/s:
"""

grid.imshow(dspe._E, colorbar_label="erosion rate (m/s)")

"""
We can also inspect the cumulative erosion during the event by differencing the before and after terrain:
"""

grid.imshow(starting_elev - elev, colorbar_label="cumulative erosion (m)")

"""
Note that because this is a bumpy DEM, much of the erosion has occurred on (probably digital) steps in the channels. But we can see some erosion across the slopes as well.
"""

"""
## `DetachmentLtdErosion`

This component is similar to `DepthSlopeProductErosion` except that it calculates erosion rate from discharge and slope rather than depth and slope. The vertical incision rate, $I$ (equivalent to $E$ in the above; here we are following the notation in the component's documentation) is:

$$I = K Q^m S^n - I_c$$

where $K$ is an erodibility coefficient (with dimensions of velocity per discharge$^m$; specified by parameter `K_sp`), $Q$ is volumetric discharge, $I_c$ is a threshold with dimensions of velocity, and $m$ and $n$ are exponents. (In the erosion literature, the exponents are sometimes treated as empirical parameters, and sometimes set to particular values on theoretical grounds; here we'll just set them to unity.)

The component uses the fields `surface_water__discharge` and `topographic__slope` for $Q$ and $S$, respectively. The component will modify the `topographic__elevation` field accordingly. If the user wishes to apply material uplift relative to baselevel, an `uplift_rate` parameter can be passed on initialization.

Here are the header and constructor docstrings:
"""

from landlab.components import DetachmentLtdErosion

print(DetachmentLtdErosion.__doc__)

print(DetachmentLtdErosion.__init__.__doc__)

"""
The example below uses the same approach as the previous example, but now using `DetachmentLtdErosion`. Note that the value for parameter $K$ (`K_sp`) is just a guess. Use of exponents $m=n=1$ implies the use of total stream power.
"""

# Process parameters
n = 0.1  # roughness coefficient, (s/m^(1/3))
dep_exp = 5.0 / 3.0  # depth exponent
R = 72.0  # runoff rate, mm/hr
K_sp = 1.0e-7  # erosion coefficient (m/s)/(m3/s)
m_sp = 1.0  # discharge exponent
n_sp = 1.0  # slope exponent
I_c = 0.0001  # erosion threshold, m/s

# Run-control parameters
rain_duration = 240.0  # duration of rainfall, s
run_time = 480.0  # duration of run, s
dt = 10.0  # time-step size, s
dem_filename = "../hugo_site_filled.asc"

# Derived parameters
num_steps = int(run_time / dt)

# set up arrays to hold discharge and time
time_since_storm_start = np.arange(0.0, dt * (2 * num_steps + 1), dt)
discharge = np.zeros(2 * num_steps + 1)

# Read the DEM file as a grid with a 'topographic__elevation' field
with open(dem_filename) as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
elev = grid.at_node["topographic__elevation"] = elev

# Configure the boundaries: valid right-edge nodes will be open;
# all NODATA (= -9999) nodes will be closed.
grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_FIXED_VALUE
grid.status_at_node[np.isclose(elev, -9999.0)] = grid.BC_NODE_IS_CLOSED

slp_mag, slp_x, slp_y = slope_magnitude_at_node(grid, elev)
grid.add_field("topographic__slope", slp_mag, at="node", clobber=True)

# Instantiate the component
olflow = KinwaveImplicitOverlandFlow(
    grid, runoff_rate=R, roughness=n, depth_exp=dep_exp
)

dle = DetachmentLtdErosion(
    grid, K_sp=K_sp, m_sp=m_sp, n_sp=n_sp, entrainment_threshold=I_c
)

starting_elev = elev.copy()

for i in trange(num_steps):
    olflow.run_one_step(dt)
    dle.run_one_step(dt)
    slp_mag[:], slp_x, slp_y = slope_magnitude_at_node(grid, elev)

grid.imshow(starting_elev - elev, colorbar_label="cumulative erosion (m)")




================================================
File: docs/source/tutorials/overland_flow/soil_infiltration_green_ampt/infilt_green_ampt_with_overland_flow.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Green-Ampt infiltration and kinematic wave overland flow

This tutorial shows how to create a simple model of rainfall, infiltration, runoff, and overland flow, using two hydrologic components: `SoilInfiltrationGreenAmpt` and `KinwaveImplicitOverlandFlow`.

*(Greg Tucker, September 2021)*
"""

from tqdm.notebook import trange

from landlab.components import KinwaveImplicitOverlandFlow, SoilInfiltrationGreenAmpt
from landlab.io import esri_ascii

"""
## Theory

The Green-Ampt method was introduced by Green and Ampt (1911) as a means of approximating the rate of water infiltration into soil from a layer of surface water. The method represents infiltration in terms of a wetting front that descends into the soil as infiltration progresses. A description of the method can be found in many hydrology textbooks, and in various online resources. The following is a brief summary, using the notation of Julien et al. (1995). The dimensions of each variable are indicated in square brackets, using the common convention that [L] means length, [M] is mass, and [T] is time.

The Green-Ampt method approximates the rate of water infiltration into the soil, $f$ (dimensions of [L/T], representing water volume per unit surface area). Infiltration is driven by two effects:  gravitational force, and downward suction (the "paper towel effect") due to a gradient in moisture at the wetting front. The method treats the infiltration rate as a function of the following parameters:

- $K$ - saturated hydraulic conductivity [L/T]
- $H_f$ - capillary pressure head at the wetting front [L]
- $\phi$ - total soil porosity [-]
- $\theta_r$ - residual saturation [-]
- $\theta_e$ - effective porosity $= \phi - \theta_r$ [-]
- $\theta_i$ - initial soil moisture content [-]
- $M_d$ - moisture deficit $=\theta_e - \theta_i$ [-]
- $F$ - total infiltrated water depth [L]

The equation for infiltration rate is:

$$f = K \left( 1 + \frac{H_fM_d}{F} \right)$$

The first term in parentheses represents gravity and the second represents pore suction. If there were no pore suction effect, water would simply infiltrate downward at a rate equal to the  hydraulic conductivity, $K$. The suction effect increases this, but it becomes weaker as the cumulative infiltration depth $F$ grows. Effectively, the second term approximates the pore-pressure gradient, which declines as the wetting front descends.

The version used in this component adds a term for the weight of the surface water with depth $H$:

$$f = K \left( 1 + \frac{H_fM_d}{F} + \frac{H}{F} \right)$$

The component uses a simple forward-difference numerical scheme, with time step duration $\Delta t$, in which the infiltration depth during one step is the lesser of the rate calculated above times $\Delta t$, or the available surface water, $H$:

$$\Delta F = \min( f\Delta t, H)$$

Note that the cumulative infitration $F$ must be greater than zero in order to avoid division by zero; therefore, one should initialize the `soil_water_infiltration__depth` to a small positive value.
"""

"""
## Example

### Read in topography from a sample DEM

This is a lidar digital elevation model (DEM) from the West Bijou Creek escarpment on the Colorado High Plains, coarsened to 5 m grid resolution.

Note: it is convenient to use local grid coordinates rather than UTM coordinates, which are what the DEM provides. Therefore, after reading topography data into a grid called `demgrid`, which uses UTM coordinates, we copy over the elevation data into a second grid (`grid`) of the same dimensions that uses local coordinates (i.e., the lower left corner is (0, 0)).
"""

# Create Landlab model grid and assign the DEM elevations to it,
# then display the terrain.
with open("bijou_gully_subset_5m_edit_dx_filled.asc") as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
grid.imshow(grid.at_node["topographic__elevation"], colorbar_label="Elevation (m)")

"""
### Simulate a heavy 5-minute storm

The next bits of code use the `SoilInfiltrationGreenAmpt` and `KinwaveImplicitOverlandFlow` components to model infiltration and runoff during a 5-minute, 90 mm/hr storm.
"""

# Create and initialize required input fields for infiltration
# component: depth of surface water, and depth (water volume per
# area) of infiltrated water.
depth = grid.add_zeros("surface_water__depth", at="node")
infilt = grid.add_zeros("soil_water_infiltration__depth", at="node")
infilt[:] = 1.0e-4  # small amount infiltrated (0.1 mm)

# Instantiate an infiltration component
ga = SoilInfiltrationGreenAmpt(grid)

# Instantiate an overland flow component
kw = KinwaveImplicitOverlandFlow(
    grid, runoff_rate=90.0, roughness=0.1, depth_exp=5.0 / 3.0
)

# Set time step and storm duration
dt = 10.0  # time step, sec
storm_duration = 300.0  # storm duration, sec

nsteps = int(storm_duration / dt)

# Run it for 10 minutes of heavy rain
for i in trange(nsteps):
    kw.run_one_step(dt)
    ga.run_one_step(dt)

"""
### Plot the cumulative infiltration

The plot below illustrates how the convergence of water in the branches of the gully network leads to greater infiltration, with less infiltration on steeper slopes and higher points in the landscape.
"""

grid.imshow(1000.0 * infilt, colorbar_label="Infiltration depth (mm)", cmap="GnBu")

"""
## Optional parameters

The `SoilInfiltrationGreenAmpt` component provides a variety parameters that can be set by the user. A list and description of these can be found in the component's `__init__` docstring, which is printed below:
"""

print(SoilInfiltrationGreenAmpt.__init__.__doc__)

"""
## References

Green, W. H., & Ampt, G. A. (1911). Studies on Soil Phyics. The Journal of Agricultural Science, 4(1), 1-24.

Julien, P. Y., Saghaﬁan, B., and Ogden, F. L. (1995) Raster-based hydrologic modeling of spatially-varied surface runoff, J. Am. Water Resour. As., 31, 523–536, doi:10.1111/j.17521688.1995.tb04039.x.

Rengers, F. K., McGuire, L. A., Kean, J. W., Staley, D. M., and Hobley, D. (2016) Model simulations of flood and debris flow timing in steep catchments after wildfire, Water Resour. Res., 52, 6041–6061, doi:10.1002/2015WR018176.
"""



================================================
File: docs/source/tutorials/plotting/animate-landlab-output.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Animate Landlab output
<hr>

<p><small>More Landlab tutorials:
<a href="https://landlab.csdms.io/tutorials/">https://landlab.csdms.io/tutorials/</a></small></p>

<hr>
"""

"""
WARNING: This tutorial is not tested. This is because it relys on ffmpeg and imagemagik. 

It has not been updated to work with Landlab 2.0


## Introduction
This tutorial presents a workflow to animate model output. The workflow is presented in two phases of a Landlab model.

This workflow requires software that might not be installed on your computer. The software is open-source and freely available for Linux, MacOS, and Windows. The following software is required for the model phases of this tutorial:
* **Phase 1**: A mp4 video format is produced using FFMpeg (use `conda install ffmpeg`, or the pip equivalent, or visit https://www.ffmpeg.org/download.html).
* **Phase 2**: A gif video format is produced using ImageMagick (use `conda install imagemagick`, or the pip equivalent, or visit https://www.imagemagick.org/script/download.php).
"""

"""
## Prepare the model for both phases

Import the modules called by this tutorial.
"""

import matplotlib.animation as animation
import matplotlib.pylab as plt
import numpy as np
from IPython.display import HTML, Image

from landlab import RasterModelGrid
from landlab.components import FastscapeEroder, FlowAccumulator
from landlab.plot import imshow_grid

"""
Create a grid with random elevation, set boundary conditions, and initialize components.
"""

mg = RasterModelGrid((40, 40), 100)
z = mg.add_zeros("topographic__elevation", at="node")
z += np.random.rand(z.size)

outlet_id = int(mg.number_of_node_columns * 0.5)
mg.set_watershed_boundary_condition_outlet_id(outlet_id, z)
mg.at_node["topographic__elevation"][outlet_id] = 0

fr = FlowAccumulator(mg)
sp = FastscapeEroder(mg, K_sp=3e-5, m_sp=0.5, n_sp=1)

"""
Set model time and uplift parameters.
"""

simulation_duration = 1e6
dt = 1000
n_timesteps = int(simulation_duration // dt) + 1
timesteps = np.linspace(0, simulation_duration, n_timesteps)

uplift_rate = 0.001
uplift_per_timestep = uplift_rate * dt

"""
## Phase 1: Animate elevation change using imshow_grid

We first prepare the animation movie file. The model is run and the animation frames are captured together.
"""

# Create a matplotlib figure for the animation.
fig, ax = plt.subplots(1, 1)

# Initiate an animation writer using the matplotlib module, `animation`.
# Set up to animate 6 frames per second (fps)
writer = animation.FFMpegWriter(fps=6)

# Setup the movie file.
writer.setup(fig, "first_phase.mp4")

for t in timesteps:
    # Uplift and erode.
    z[mg.core_nodes] += uplift_per_timestep
    fr.run_one_step()
    sp.run_one_step(dt)

    # Update the figure every 50,000 years.
    if t % 5e4 == 0:
        imshow_grid(mg, z, colorbar_label="elevation (m)")
        plt.title(f"{t * 1e-3:.0f} kiloyears")

        # Capture the state of `fig`.
        writer.grab_frame()

        # Remove the colorbar and clear the axis to reset the
        # figure for the next animation timestep.
        plt.gci().colorbar.remove()
        ax.cla()

plt.close()

"""
### Finish the animation

The method, `writer.finish` completes the processing of the movie and saves then it.
"""

writer.finish()

"""
This code loads the saved mp4 and presents it in a Jupyter Notebook.
"""

HTML(
    """<div align="middle"> <video width="80%" controls loop>
     <source src="first_phase.mp4" type="video/mp4"> </video></div>"""
)

"""
## Phase 2: Animate multiple visualizations of elevation change over time

In the second model phase, we will create an animation similar to the one above, although with the following differences:
* The uplift rate is greater.
* The animation file format is `gif`.
* The figure has two subplots.
* The data of one of the subplots is updated rather than recreating the plot from scratch for each frame.
* The animation frame rate (fps) is lower.
"""

"""
Increase uplift rate prior to running the second phase of the model.
"""

increased_uplift_per_timestep = 10 * uplift_per_timestep

"""
### Run the second phase of the model

Here we layout the figure with a left and right subplot.
* The left subplot will be an animation of the grid similar to phase 1. We will recreate the image of this subplot for each animation frame.
* The right subplot will be a line plot of the mean elevation over time. We will layout the subplot elements (labels, limits) before running the model, and then extend the plot line at each animation frame.

`axes[0]` and `axes[1]` refer to the left and right subplot, respectively.

A gif formatted movie is created in this model phase using the software, ImageMagick.
"""

# Create a matplotlib figure for the animation.
fig2, axes = plt.subplots(1, 2, figsize=(9, 3))
fig2.subplots_adjust(top=0.85, bottom=0.25, wspace=0.4)

# Layout right subplot.

time = 0

(line,) = axes[1].plot(time, z.mean(), "k")

axes[1].set_title("mean elevation over time")
axes[1].set_xlim([0, 1000])
axes[1].set_ylim([0, 1000])
axes[1].set_xlabel("time (kyr)")
axes[1].set_ylabel("elevation (m)")

# Initiate a writer and set up a movie file.
writer = animation.ImageMagickWriter(fps=2)
writer.setup(fig2, "second_phase.gif")

for t in timesteps:
    # Uplift and erode.
    z[mg.core_nodes] += increased_uplift_per_timestep
    fr.run_one_step()
    sp.run_one_step(dt)

    # Update the figure every 50,000 years.
    if t % 5e4 == 0:
        fig2.sca(axes[0])
        fig2.suptitle(f"{t * 1e-3:.0f} kiloyears")

        # Plot the left subplot.
        axes[0].set_title("topography")
        imshow_grid(mg, z, colorbar_label="elevation (m)")
        colorbar = plt.gci().colorbar

        # Update the right subplot.
        line.set_xdata(np.append(line.get_xdata(), t * 1e-3))
        line.set_ydata(np.append(line.get_ydata(), z.mean()))

        # Capture the state of `fig2`.
        writer.grab_frame()

        # Reset the figure for the next animation time step.
        plt.cla()
        colorbar.remove()

writer.finish()

plt.close()

"""
This code loads the saved mp4 and presents it in a Jupyter Notebook.
"""

Image(filename="second_phase.gif")



================================================
File: docs/source/tutorials/plotting/landlab-plotting.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Plotting grid data with Landlab
"""

"""
This tutorial illustrates how you can plot spatial data in Landlab, focusing in particular on Landlab's `imshow_grid` plotter and associated functions. Landlab's plotters are built onto the widely used Matplotlib Python package.

We start by importing the *NumPy* library, which we'll use in producing some data to plot:
"""

import numpy as np

"""
From Landlab, we'll need a grid on which to plot data, and a plotting function. We'll start with just `imshow_grid`, but be aware that similar but more specifically named functions like `imshow_grid_at_node` are also available. These all wrap the same basic Landlab functionality, so we're taking the most general method.

Note that you can use `imshow_grid` as a function or as a method of any *landlab* grid. For example, the following two usages can be used interchangably,
```python
>>> grid.imshow(values)
```
```python
>>> imshow_grid(grid, values)
```
"""

from landlab import RadialModelGrid, RasterModelGrid

"""
We'll also need some functions from `matplotlib` proper to help us handle our graphical output:
"""

import matplotlib.pyplot as plt

"""
## Plotting in 2D
"""

"""
The `imshow` plotter method is Landlab's primary function for plotting data distributed across the grid. It's pretty powerful, and comes with a fairly extensive suite of options to control the appearance of your output. You can see the full list of options in the `imshow_grid` documentation.

However, most simply, it just takes `grid.imshow(data)`. Data can be either a field name string, or an array of the data itself.
"""

%matplotlib inline
rmg = RasterModelGrid((50, 50), 1.0)
rmg.imshow(rmg.x_of_node)  # plot the x distances at nodes
plt.show()

"""
Those units for the axis are taken from the grid property `axis_units`, which is a tuple that we can set. Alternatively, pass a tuple directly to the plotter with the keyword `grid_units`.

While we're at it, let's plot from a field instead of an array, and also mix up the default color scheme. The `cmap` keyword can take any input that you could also supply to matplotlib; see, e.g., http://matplotlib.org/examples/color/colormaps_reference.html.
"""

rmg.axis_units = ("km", "km")
_ = rmg.add_field(
    "myfield", (rmg.x_of_node**2 + rmg.y_of_node**2) ** 0.5, at="node", clobber=True
)
rmg.imshow("myfield", cmap="bone")
plt.show()

"""
The plotter works just fine with both raster grids and irregular grids. Name a plot with the `var_name` keyword.
"""

radmg = RadialModelGrid(n_rings=10, spacing=10.0)
plt.subplot(121)
rmg.imshow(rmg.y_of_node, allow_colorbar=False, plot_name="regular grid")
plt.subplot(122)
radmg.imshow(radmg.x_of_node, allow_colorbar=False, plot_name="irregular grid")
plt.show()

"""
Now, let's look at some of the other more advanced options `imshow` can provide.

`imshow` offers plenty of keyword options for modifying the colorbar, including `var_name`, `var_units`, `symmetric_cbar`, `vmin`, `vmax`, and `shrink`. We've already seen `allow_colorbar`, which lets you suppress the bar entirely. Let's see some in action.
"""

radz = (radmg.x_of_node**2 + radmg.y_of_node**2) ** 0.5
radz = radz.max() - radz - 0.75 * radz.mean()
# let's plot these elevations truncated at radz >= 0
radmg.imshow(
    radz,
    grid_units=("m", "m"),
    vmin=0.0,
    shrink=0.75,
    var_name="radz",
    var_units="no units",
)
plt.show()

"""
Now let's explore color control. The grid takes the keyword `color_for_background`, which as you'd expect, colors any exposed part of the frame without cells over it. It knows the same color representations as matplotlib, e.g., (0., 0., 0.5), '0.3', 'b', 'yellow'.
"""

radmg.imshow(radmg.y_of_node, color_for_background="0.3")
plt.show()

"""
The plotter knows about boundary condition status, and we can control the colour of such nodes as well. This is useful if plotting an irregular watershed on a raster, for example. Here, `None` means transparent, as we will see in the next example.
"""

rmg2 = RasterModelGrid((50, 50), (1.0, 2.0))
myvals = ((rmg2.x_of_node - 50.0) ** 2 + (rmg2.y_of_node - 25.0) ** 2) ** 0.5
rmg2.status_at_node[myvals > 30.0] = rmg2.BC_NODE_IS_CLOSED
rmg2.imshow(myvals, color_for_closed="blue", shrink=0.6)

"""
Finally, note that the plotter recognises any masked node in a masked array as a closed node. This can be used as a convenient way to make grid overlays, as follows:
"""

mymask_1stcondition = np.logical_or(rmg.x_of_node < 15, rmg.x_of_node > 35)
mymask_2ndcondition = np.logical_or(rmg.y_of_node < 15, rmg.y_of_node > 35)
mymask = np.logical_or(mymask_1stcondition, mymask_2ndcondition)
overlay_data = np.ma.array(rmg.y_of_node, mask=mymask, copy=False)
rmg.imshow(rmg.x_of_node)
rmg.imshow(overlay_data, color_for_closed=None, cmap="winter")
plt.show()

"""
## Plotting in 1D
"""

"""
Landlab basically lets you get on with it for yourself if plotting cross sections, or otherwise in 1D. We recommend the basic matplotlib plotting suite. Often `plot()` is totally adequate.

For a simple grid cross section, just reshape the data array back to a raster and take a slice:
"""

# Note, in Landlab 2.0 a new component that will permit profiles based on endpoints
# will be added to the component library.

mg = RasterModelGrid((30, 30))
z = (mg.x_of_node**2 + mg.y_of_node**2) ** 0.5
z = z.max() - z
z_raster = z.reshape(mg.shape)
x_raster = mg.x_of_node.reshape(mg.shape)
for i in range(0, 30, 5):
    plt.plot(x_raster[i, :], z_raster[i, :])
plt.title("east-west cross sections though z")
plt.xlabel("x (m)")
plt.ylabel("z (m)")
plt.show()

"""
Additionally, Landlab makes available a stream profiler tool. It finds the highest drainage area node in a landscape whenever it's called, then follows the drainage structure back upstream from that node, always choosing the upstream node with the highest drainage area. This means we can do things like this:
"""

from landlab.components import ChannelProfiler, FastscapeEroder, FlowAccumulator

mg = RasterModelGrid((100, 100), 1000.0)
mg.axis_units = ("m", "m")
z = mg.add_zeros("topographic__elevation", at="node")
z += np.random.rand(mg.number_of_nodes)  # roughen the initial surface

fr = FlowAccumulator(mg)
sp = FastscapeEroder(mg, K_sp=1.0e-5)
dt = 50000.0

for ndt in range(100):
    z[mg.core_nodes] += 10.0
    fr.run_one_step()
    sp.run_one_step(dt)
    if ndt % 5 == 0:
        print(ndt)

prf = ChannelProfiler(
    mg, number_of_watersheds=4, main_channel_only=False, minimum_channel_threshold=1e7
)
prf.run_one_step()

plt.figure(1)
prf.plot_profiles()
plt.show()

plt.figure(1)
prf.plot_profiles_in_map_view()
plt.show()



================================================
File: docs/source/tutorials/python_intro/python_intro.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# A super-brief intro to Python and NumPy
"""

"""
Python is:
* interpreted (high level)
* readable
* concise
* cross-platform
* dynamically typed
* object oriented
* automatically memory-managed

Almost all of the below is explained much more fully at various places online. For a nice entry level tutorial set, try the Software Carpentry intros:
http://swcarpentry.github.io/python-novice-inflammation/

The main Python documentation is also an extremely readable source of knowledge. Just Google!
"""

"""
## PROGRAM FILES AND INTERACTIVE ENVIRONMENTS
Put Python code in .py text files (AKA "scripts").
Run these from a shell, as:

> python myscript.py

OR

Use one of Python's interactive environments (e.g., iPython)

> ipython

In an interactive environment:

* Run code line-by-line, preserving variables
* Run your scripts, using the magic command `%run` (and preserve the variables)

This Jupyter notebook is an interactive environment.
"""

"""
## MODULES
Python has some built-in functions, but everything else comes in a library module.

* See the built-in functions here: https://docs.python.org/2/library/functions.html

Modules are *imported*, then the functions they hold run with a *dot* syntax:
"""

import math  # comments with a hash

x = math.cos(2.0 * math.pi)
print(x)  # print is a built-in function

"""
OR import the functions and properties individually:
"""

from numpy import cos, pi  # numpy, numeric python, also has these functions

x = cos(2.0 * pi)
print(x)

"""
Get help in an interactive shell with a trailing ``?``, quit it with ``q``
"""

?pi

"""
## TYPES
Python distinguishes:
* integer (int), e.g., 3,
* float (float), e.g., 1.0 or 2.5,
* boolean (bool), e.g., True
* complex (complex), e.g., 3.2 + 2.4*i*,
* strings (str), e.g., 'Hello world!'

You may also encounter NumPy types, like `numpy.float64`
"""

type(pi)

"""
Typecasting (switching between types on-the-fly) is automatic where possible, but can be time-expensive if you want efficient code.

Python's inbuilt *data structures* are:
* tuples, with *parentheses*—immutable (you can't change values once they exist)
* lists, with *square brackets*—mutable (you can change values once they exist)
* sets, as set()—unordered collection with no duplicates
* dictionaries, with *curly brackets*—associated pairs of key:value

Note that all these data structures let you happily mix data types… But the cost is that Python runs more slowly than, e.g., C++.
"""

mytuple = (0, 1, 2, 3)
print(
    f"You can index: {mytuple[1]}"
)  # this uses a string method which replaces {} with the argument of format

"""
Tuples are immutable, meaning that you cannot reassign values to them. Python will give `TypeError` if you try to do so. We can test this using a `try...except` block: if a `TypeError` occurs in the assignment statement below, we should see the printed message:
"""

try:
    mytuple[0] = 100
except TypeError:
    print("A TypeError occurred")

"""
... and indeed we do.
"""

mylist = [0, 1, 2, 3]
print("This time reassignment works:")
mylist[0] = "I can store a string!"
print(mylist)

myset = {0, 1, 2, 3}
print(myset)

myset.add("string!")  # you can use both ' and " to declare a string
print(f"Adding is easy: {myset}")

myset.add(0)
print(f"But remember, duplicates don't count! {myset}")

"""
Almost anything can be a key or a value:
"""

mydict = {"firstkey": 1, "secondkey": 2, 3: "three"}
print(mydict)

print(mydict["firstkey"])
print(mydict["secondkey"])
print(mydict[3])

print(f"Get the keys (note lack of ordering): {mydict.keys()}")
print(f"Get the values: {mydict.values()}")

try:
    print("The next line should generate a KeyError...")
    print(f" {mydict[2]}")
except KeyError:
    print("...and indeed it did.")

"""
## INDEXING
* Indexing starts from 0
* Index with square brackets [start : stop : step]
* "stop" is *exclusive* of the named index
* Colon alone means "all of these" or "to the start/end"
"""

x = list(range(10))
print(f"x[3] gives {x[3]}")
print(f"x[1:5:2] gives {x[1:5:2]}")

print(f"x[8:] gives {x[8:]}")
print(f"x[:7] gives {x[:7]}")
print(f"x[::3] gives {x[::3]}")

"""
## PYTHON IS LIKE, BUT ISN'T, MATLAB
- This is a *power*:
"""

x = 10.0**2  # …or…
import numpy as np

x = np.square(10.0)  # NEVER 10.^2.

"""
Likewise, it's also useful to know about the "truncation" (``//``) and "remainder" (``%``) division operators:
"""

print(f"truncate: {(13 // 4)}")
print(f"remainder: {(13 % 4)}")

"""
- End indices are NOT inclusive
"""

len(range(0, 100))  # in Matlab this would be 101

[
    x for x in range(5)
]  # this is called "list comprehension", and is a readable way to make a list

"""
- Intelligent memory management means Python will pass objects *by reference* where possible. In other words, if you set two things equal and then later change the first one, the second one will also change (and vice versa):
"""

x = [0] * 3
y = [1, 2, 3]
print(f"x starts as {x}")
print(f"y starts as {y}")

x = y
print(f"After setting equal, x is {x}")

y[1] = 100
print(f"After modifying y, x is {x}")

# one way to stop this automatic behaviour is by forcing a copy with [:]
x = y[:]
print(x)
print(y)

y[1] = 1000000
print(f"After forcing a copy, x is still {x} but y is now {y}")

"""
- In Matlab, assigning a value to a variable triggers output unless you suppress it with a semi-colon at the end of the line; this isn't necessary in Python:
"""

x = range(10)  # …see?

"""
- Python doesn't use brackets to delineate code blocks. It uses *indentation* with a fixed number of spaces (normally 4). This also applies to ``for`` loops, ``while`` loops, ``if`` statements, ``try/except`` statements, class declarations, function declarations, etc.
"""

def myfunction(arg1, arg2, **kwds):
    # **kwds is a special (optional) dictionary input type,
    # that you can use as an input "wildcard"
    try:
        print_this = kwds["printme"]
    except KeyError:
        x = arg1 * arg2
        return x  # ...no brackets needed; both lines have 4 space indents
    else:
        print(print_this)

print("first time:")
myfunction(3.0, 4.0)

print("second time…")
myfunction(5, 6, printme="Printed this time!")

"""
- Python's plotting is a blatant clone of matlab's, and lives in the library matplotlib.pyplot:
"""

%matplotlib inline
# that command tells this notebook to put plots into the notebook
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(10)  # like range(), but produces a numpy array
y = np.random.rand(10)  # ten random floats, 0->1
plt.plot(x, y, "*--")
plt.xlabel("xaxis")
plt.ylabel("yaxis")
plt.title("my plot!")

"""
## NumPy and Landlab
"""

"""
Landlab makes extensive use of the NumPy (Numeric Python) libraries. These allow significant acceleration of standard Python processes on matrix-like data arrays. Here we look at some of the key features and differences with pure Python along with some NumPy best-practice.
"""

import numpy as np

"""
Initialize NumPy arrays from standard Python iterables (lists, tuples):
"""

myarray = np.array([0, 1, 3, 6, 18])

"""
…or with one of the many standard array creation methods in NumPy. Particularly useful ones are:
"""

a = np.zeros(10, dtype=int)
print(f"a: {a}")

b = np.ones(5, dtype=bool)
print(f"b: {b}")

c = np.random.rand(10)
print(f"c: {c}")

d = np.arange(5.0)
print(f"d: {d}")

e = np.empty((3, 3), dtype=float)
e.fill(100.0)
print(f"e: {e}")

"""
Arrays also have some built-in methods and properties. We see 'fill' above, but also noteworthy are:
"""

print(f"e has shape: {(e.shape)}")
print(f"e has size: {e.size} ")  # preferred to len() when working with arrays
c.max(), c.min(), c.mean(), c.sum()

f = c.copy()
print(f"flatten: {e.flatten()}")

"""
Slicing works like (better than?) in pure Python:
"""

print(d[2:])

e[1, 1] = 5.0
print(e)

print(e[1:, 1:])

"""
Note that logical operations with NumPy tend to require NumPy-native functions, rather than pure Python `and`, `or`, `not` etc.
"""

bool1 = np.array([True, True, False, False])
bool2 = np.array([True, False, True, False])
print(f"AND: {np.logical_and(bool1, bool2)}")
print(f"OR: {np.logical_or(bool1, bool2)}")
print(f"NOT: {np.logical_not(bool1)}")

print(f"ANY: {np.any(bool1)}")
print(f"ALL: {np.all(bool1)}")

"""
Now, let's demonstrate the speed of NumPy over pure Python:
"""

f_list = range(1000)
f_array = np.arange(1000, dtype=int)


def addone_py(list_in):
    for i in list_in:
        i += 1


def addone_np(array_in):
    array_in += 1

print("time for list:")
%timeit addone_py(f_list)  # a magic command for timing things

print("time for array:")
%timeit addone_np(f_array)

"""
In particular, never loop to do a logical test:
"""

# NOT THIS:
myoutput_slow = np.zeros(10, dtype=float)
for i in range(len(c)):  # c is our random number array
    if c[i] > 0.5:
        myoutput_slow[i] = c[i]

# DO THIS INSTEAD:
myoutput_fast = np.zeros(10, dtype=float)
greater_than_half = c > 0.5
myoutput_fast[greater_than_half] = c[greater_than_half]

print(np.all(np.equal(myoutput_slow, myoutput_fast)))

"""
The online NumPy help is actually an extremely readable resource, and is highly recommended to find out more about the family of available NumPy methods.
"""



================================================
File: docs/source/tutorials/reading_dem_into_landlab/reading_dem_into_landlab.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# How to read a DEM as a Landlab grid
"""

"""
This tutorial demonstrates how to create and initialize a Landlab grid using a Digital Elevation Model (DEM). The DEM is in ESRI's Ascii Grid format. The procedure both creates a new grid, and adds a field to the grid containing the DEM data. Note that there are other approaches to construct a Landlab grid, including the use of the `gdal` library to read a DEM into a numpy array, followed by  initializing a Landlab RasterModelGrid of the correct size and then adding the array as a grid field. This tutorial, however, describes an approach that uses the *Landlab* `esri_ascii` functions.

The starting point is to obtain a DEM in Ascii Grid format, or
convert it to this format. The format consists of a 6-line header
followed by a series of elevation values. Here we'll work with a
small example DEM file called *west_bijou_gully.asc*. The header
for this file is as follows:

```
ncols        43
nrows        89
xllcorner    559705.000000000000
yllcorner    4380220.000000000000
cellsize     3
NODATA_value 0
```

Here, our objective is to translate the contents of this file into a *Landlab* ``RasterModelGrid``. We'll do this using the ``esri_ascii.load`` function. Here's how to use it:
"""

from landlab import RasterModelGrid
from landlab.io import esri_ascii
from landlab.utils.add_halo import add_halo

"""
In the line above, we go to Landlab's input/output library ("io") and import the function. Next, let's look at the basic documentation:
"""

# load?

"""
Ok, this tells us we need to supply the name of the file. If we want to attach the data to the grid as a field, we also give a name for the field as the ``name`` parameter as well as the location where these values are defined. For example:
"""

with open("west_bijou_gully.asc") as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")
z = mg.at_node["topographic__elevation"]

"""
Let's plot the grid we created:
"""

mg.imshow("topographic__elevation")

"""
This plot illustrates the shape of the watershed, but we can't see the topography because the nodata values have a value of zero, which skews the colormap.  We can change the range of the colormap but first we need to figure out what the range of data values are. 

(Note: uncomment the commented line below if you want to see all the options available in ``imshow``)
"""

import numpy as np

min_z = np.min(z[np.where(z > 0)])
max_z = np.max(z[np.where(z > 0)])

mg.imshow("topographic__elevation", limits=(min_z, max_z))

"""
We can also query a bit of information:
"""

mg.number_of_node_rows

mg.number_of_node_columns

"""
## Boundary condition handling

### The rest of this tutorial illustrates setting boundary conditions on DEMs and using the halo option for reading in DEMs without nodata values around the edges.

Because this is a watershed, we probably want to set *watershed boundary conditions.*  For more on setting watershed boundary conditions on rasters, see [this tutorial](../boundary_conditions/set_watershed_BCs_raster.ipynb)

In essence, the `set_watershed_boundary_condition` function identifies the non-NODATA grid node with the lowest elevation. This node is assumed to be the watershed outlet. The boundary status of the outlet node is converted from "core" to "fixed value," meaning that it is now a boundary node. All NODATA nodes are flagged as "closed," and as a result all links that connect to them are flagged as "inactive." These codes can then be used by components and models to restrict certain numerical operations to a subset of grid elements; for example, one might calculate a topographic gradient only at active links, or update elevation values only on core nodes. (For more on boundary condition handling in general, see the tutorials in the boundary_conditions folder.

We also replot the watershed, this time coloring by the node status, which illustrates the boundary condition at each node.
"""

mg.set_watershed_boundary_condition(z, 0)
mg.imshow(mg.status_at_node, color_for_closed="blue")

"""
All of the closed boundary nodes are shown in blue.  Without the `color_for_closed` option they would plot as the minimum value, or black.  A value of 0 node status means that the node is a core node, or operational, and a value of 1 means that the node is a fixed value boundary. The singular node with a value of 1 (white in the plot) is assumed to be the watershed outlet.
"""

"""
### Access DEM header

It is helpful to know the NODATA value and other values in the header.  Sure you could just open the file, but it might be huge.  Here is how to access those values.
"""

with open("synthetic_landscape.asc") as fp:
    info = esri_ascii.parse(fp.read())
info

"""
This illustrates that the nodata value for this particular DEM file is -9.
"""

"""
### Adding a halo

Next we illustrate reading in a DEM that is not a watershed, and use of the halo option.
"""

with open("synthetic_landscape.asc") as fp:
    mg1 = esri_ascii.load(fp, name="topographic__elevation", at="node")
mg1.imshow(mg1.at_node["topographic__elevation"])

"""
This landscape has data values at all of its points.  (Recall that the nodata_value is -9, but all of the values plotted here are >= 0.)

If we set an open boundary on the bottom or south side, and the rest of the boundaries as closed, as illustrated below, some of our data values will become closed boundaries, and operations will not be carried out at these nodes.  This is illustrated in the map of boundary status values, which has the three blue sides indicating that the boundaries along these sides are closed.

Note that the default is that the perimeter will have fixed value node status, or a value of 1.
"""

mg1.set_closed_boundaries_at_grid_edges(True, True, True, False)
mg1.imshow(mg1.status_at_node, color_for_closed="blue")

"""
The implication of this map is that the right, top and left edges are closed now, and therefore these node values will not be operated on (assuming that the author of the component or model has written their program to restrict certain calculations to core nodes only). Similarly, the bottom row is fixed value, so it also won't be operated on.

Supposed we want to include some or all of these DEM grid points in model operations.  We need to set them as core nodes, but we can't have core nodes on the perimeter of a grid.  One solution is to add a "halo" of extra nodes around the grid's perimeter.  The halo option adds a perimeter of nodes around the data that are read in from the esri_ascii file.  This is helpful when there are valid data values at the edges of a grid.  By default, the elevation values associated with halo perimeter nodes will be assigned the DEM's NODATA code value (for example, -9999 is a common choice for a NODATA code).

The ``esri_ascii.lazy_load`` function parses the ESRI ASCII file in the same way as the ``load`` function does but, instead of creating a new grid, it returns the info needed to create a new grid and leaves grid creation up to you.
"""

with open("synthetic_landscape.asc") as fp:
    grid_info, data = esri_ascii.lazy_load(fp, at="node", name="topographic__elevation")

data = add_halo(data.reshape(grid_info.shape), halo_value=-9.0)

mg2 = RasterModelGrid(
    data.shape,
    xy_spacing=grid_info.xy_spacing,
    xy_of_lower_left=grid_info.xy_of_lower_left,
)
mg2.at_node["topographic__elevation"] = data

mg2.imshow(data)

"""
### Now setting the boundary conditions ... 

In this case, we will set all of the edges as closed.  We will set the bottom of the two channels (points x=15, y=5 and x=35, y=5) as fixed-value boundaries.  One could also set all of the data values in the second row from the bottom as fixed value.  Appropriate boundary conditions obviously depend on the environmental conditions that one is modeling.

Note there are multiple ways to do this.  I happen to know that the node id of the two channel bottoms are 15 and 19.  So we will set those as fixed value individually.  We will also illustrate another useful boundary condition function, which sets all nodata values to closed. 
"""

mg2.set_nodata_nodes_to_closed(mg2.at_node["topographic__elevation"], -9.0)

mg2.status_at_node[15] = mg2.BC_NODE_IS_FIXED_VALUE
mg2.status_at_node[19] = mg2.BC_NODE_IS_FIXED_VALUE
mg2.imshow(mg2.status_at_node, color_for_closed="blue")

"""
There are lots of ways we could have done this.  In a more complicated DEM we would probably want to search for the smallest z values in the second row in order to figure out which should be fixed values.  For more on setting raster boundary conditions see this [tutorial](../boundary_conditions/set_BCs_on_raster_perimeter.ipynb)
"""



================================================
File: docs/source/tutorials/river_flow_dynamics/river_flow_dynamics_tutorial.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# 2D Surface Water Flow component

"""

"""
## Overview

This notebook demonstrate the usage of the `river flow dynamics` Landlab component. The component runs a semi-implicit, semi-Lagrangian finite-volume approximation to the depth-averaged 2D shallow-water equations of Casulli and Cheng (1992) and related work.

### Theory

The depth-averaged 2D shallow-water equations are the simplification of the Navier-Stokes equations, which correspond to the balance of momentum and mass in the fluid. It is possible to simplify these equations by assuming a well-mixed water column and a small water depth to width ratio, where a vertical integration results in depth-averaged equations. These require boundary conditions at the top and bottom of the water column, which are provided by the wind stress and the Manning-Chezy formula, respectively:

$$
\frac{\partial U}{\partial t}
+ U\frac{\partial U}{\partial x} + V\frac{\partial U}{\partial y}
= 
- g\frac{\partial \eta}{\partial x}
+ \epsilon\left(\frac{\partial^2 U}{\partial x^2} + \frac{\partial^2 U}{\partial y^2}\right)
+ \frac{\gamma_T(U_a - U)}{H} - g\frac{\sqrt{U^2 + V^2}}{Cz^2}U + \mathbf{f}V
$$

$$
\frac{\partial V}{\partial t}
+ U\frac{\partial V}{\partial x} + V\frac{\partial V}{\partial y}
= 
- g\frac{\partial \eta}{\partial y}
+ \epsilon\left(\frac{\partial^2 V}{\partial x^2} + \frac{\partial^2 V}{\partial y^2}\right)
+ \frac{\gamma_T(V_a - V)}{H} - g\frac{\sqrt{U^2 + V^2}}{Cz^2}V + \mathbf{f}U
$$

$$
\frac{\partial \eta}{\partial t}
+ \frac{\partial (HU)}{\partial x} + \frac{\partial (HV)}{\partial y}
= 0
$$

where $U$ is the water velocity in the $x$-direction, $V$ is the water velocity in the $y$-direction, $H$ is the water depth, $\eta$ is the water surface elevation, $Cz$ is the Chezy friction coefficient, and $t$ is time. For the constants $g$ is the gravity acceleration, $\epsilon$ is the horizontal eddy viscosity, $\mathbf{f}$ is the Coriolis parameter, $\gamma_T$ is the wind stress coefficient, and $U_a$ and $V_a$ are the prescribed wind velocities.

### Numerical representation

A semi-implicit, semi-Lagrangian, finite volume numerical approximation represents the depth averaged, 2D shallow-water equations described before. The water surface elevation, $\eta$, is defined at the center of each computational volume (nodes). Water depth, $H$, and velocity components, $U$ and $V$, are defined at the midpoint of volume faces (links). The finite volume structure provides a control volume representation that is inherently mass conservative.

The combination of a semi-implciit water surface elevation solution and a semi-Lagrangian representation of advection provides the advantages of a stable solution and of time steps that exceed the CFL criterion. In the semi-implicit process, $\eta$ in the momentum equations, and the velocity divergence in the continuity equation, are treated implicitly. The advective terms in the momentum equations, are discretized explicitly. See the cited literature for more details.

### The component

Import the needed libraries:
"""

import matplotlib.pyplot as plt
import numpy as np
from IPython.display import clear_output
from tqdm import trange

from landlab import RasterModelGrid
from landlab.components import RiverFlowDynamics
from landlab.io import esri_ascii

"""
## Information about the component

Using the class name as argument for the `help` function returns descriptions of the various methods and parameters.
"""

help(RiverFlowDynamics)

"""
## Examples

-- --

### Example 1: Flow in a rectangular channel 6.0 m long

This first basic example illustrates water flowing through a rectangular channel 1.0 $m$ wide and 6.0 $m$ long. Our channel is made in concrete, so we choose a Manning's roughness coefficient equal to 0.012 $s/m^\frac{1}{3}$, and it has a slope of 0.01 $m/m$.

We specify some basic parameters such as the grid resolution, time step duration, number of time steps, and the domain dimensions by specifying the number of columns and rows. 
"""

# Basic parameters
mannings_n = 0.012  # Manning's roughness coefficient, [s/m^(1/3)]
channel_slope = 0.01  # Channel slope [m/m]

# Simulation parameters
n_timesteps = 1000  # Number of timesteps
dt = 0.1  # Timestep duration, [s]
nrows = 20  # Number of node rows
ncols = 60  # Number of node cols
dx = 0.1  # Node spacing in the x-direction, [m]
dy = 0.1  # Node spacing in the y-direction, [m]

"""
Create the grid:
"""

# Create and set up the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=(dx, dy))

"""
Create the elevation field and define the topography to represent our rectangular channel:
"""

# The grid represents a basic rectangular channel with slope equal to 0.01 m/m
te = grid.add_field(
    "topographic__elevation", 1.0 - channel_slope * grid.x_of_node, at="node"
)
te[grid.y_of_node > 1.5] = 2.5
te[grid.y_of_node < 0.5] = 2.5

"""
We show a top view of the domain:
"""

# Showing the topography
grid.imshow("topographic__elevation")

"""
The channel is empty at the beginning of the simulation, so we create the fields for the water surface elevation, depth and velocity:
"""

# We establish the initial conditions, which represent an empty channel
h = grid.add_zeros("surface_water__depth", at="node")

# Water velocity is zero in everywhere since there is no water yet
vel = grid.add_zeros("surface_water__velocity", at="link")

# Calculating the initial water surface elevation from water depth and topographic elevation
wse = grid.add_field("surface_water__elevation", te, at="node")

"""
Then, we specify the nodes at which water is entering into the domain, and also the associated links. These are going to be the entry boundary conditions for water depth and velocity. In this case, water flows from left to right at 0.5 $m$ depth, with a velocity of 0.45 $m/s$:
"""

# We set fixed boundary conditions, specifying the nodes and links in which the water is flowing into the grid
fixed_entry_nodes = np.array([300, 360, 420, 480, 540, 600, 660, 720, 780, 840, 900])
fixed_entry_links = grid.links_at_node[fixed_entry_nodes][:, 0]

# We set the fixed values in the entry nodes/links
entry_nodes_h_values = np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])
entry_links_vel_values = np.array(
    [0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45]
)

"""
And now we show the boundary condition in the cross-section:
"""

plt.plot(
    grid.y_of_node[fixed_entry_nodes], entry_nodes_h_values + te[fixed_entry_nodes]
)
plt.plot(grid.y_of_node[grid.nodes_at_left_edge], te[grid.nodes_at_left_edge])
plt.title("Cross-section")
plt.xlabel("Distance [m]")
plt.ylabel("Elevation [m]")
plt.axis([0.25, 1.75, 0.75, 2.75])
plt.grid(True)

"""
We construct our component by passing the arguments we defined previously:
"""

# Finally, we run the model and let the water fill our channel
rfd = RiverFlowDynamics(
    grid,
    dt=dt,
    mannings_n=mannings_n,
    fixed_entry_nodes=fixed_entry_nodes,
    fixed_entry_links=fixed_entry_links,
    entry_nodes_h_values=entry_nodes_h_values,
    entry_links_vel_values=entry_links_vel_values,
)

"""
And finally, we run the simulation for 100 timesteps (10 seconds).

"""

# Set the animation frequency to n_timesteps if you
# don't want to plot the water depth
# display_animation_freq = n_timesteps
display_animation_freq = 5

grid.imshow("surface_water__depth", output=True)
for timestep in trange(n_timesteps):
    rfd.run_one_step()

    if timestep % display_animation_freq == 0:
        clear_output(wait=True)  # This will clear the previous image
        grid.imshow("surface_water__depth", output=True)

"""
Exploring the water depth results at the latest time:
"""

grid.imshow("surface_water__depth")

"""
And the water surface elevation:
"""

grid.imshow("surface_water__elevation")

"""
-- --
## Example 2: Surface water flowing over a DEM

On this case, we will import a digital elevation model (DEM) for a side-channel of the Kootenai River, Idaho, US.
"""

# Getting the grid and some parameters
asc_file = "DEM-kootenai_37x50_1x1.asc"
with open(asc_file) as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation")
te = grid.at_node["topographic__elevation"]

"""
Again, we specify some basic parameters such as the time step number and duration. For simplicity, we will keep our previous Manning's coefficient. Notice that we already loaded all the required libraries.
"""

# Basic parameters
mannings_n = 0.012  # Manning's roughness coefficient, [s/m^(1/3)]

# Simulation parameters
n_timesteps = 75  # Number of timesteps
dt = 1.0  # Timestep duration, [s]

"""
Let's see our new topography:
"""

# Showing the topography
grid.imshow("topographic__elevation")

"""
Our side-channel is empty at the beggining of the simulation, so we create the proper fields:
"""

# We establish the initial conditions, which represent an empty channel
h = grid.add_zeros("surface_water__depth", at="node")

# Water velocity is zero in everywhere since there is no water yet
vel = grid.add_zeros("surface_water__velocity", at="link")

# Calculating the initial water surface elevation from water depth and topographic elevation
wse = grid.add_field("surface_water__elevation", te, at="node")

"""
Then, we specify the nodes at which water is entering into the domain, and also the associated links. These are going to be our entry boundary conditions for water depth and velocity. On this case, water flows from right to left:
"""

# We set fixed boundary conditions, specifying the nodes and links in which the water is flowing into the grid
fixed_entry_nodes = grid.nodes_at_right_edge
fixed_entry_links = grid.links_at_node[fixed_entry_nodes][:, 2]

# We set the fixed values in the entry nodes/links
entry_nodes_h_values = np.array(
    [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.04998779,
        0.05999756,
        0.03997803,
        0.0,
        0.0,
        0.0,
        0.05999756,
        0.10998535,
        0.12994385,
        0.09997559,
        0.15997314,
        0.23999023,
        0.30999756,
        0.36999512,
        0.45996094,
        0.50994873,
        0.54998779,
        0.59997559,
        0.63995361,
        0.65997314,
        0.65997314,
        0.60998535,
        0.5,
        0.13995361,
        0.0,
    ]
)
entry_links_vel_values = np.array(
    [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        0.0,
        0.0,
        0.0,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        -2.58638018,
        0.0,
    ]
)

"""
Now we can plot our entry boundary condition in the cross-section:
"""

plt.plot(
    grid.y_of_node[fixed_entry_nodes], entry_nodes_h_values + te[fixed_entry_nodes]
)
plt.plot(grid.y_of_node[grid.nodes_at_right_edge], te[grid.nodes_at_right_edge])
plt.title("Entry cross-section")
plt.xlabel("Distance [m]")
plt.ylabel("Elevation [m]")
plt.grid(True)

"""
Then we create the component by passing the arguments defined previously:
"""

# Finally, we run the model and let the water fill our channel
rfd = RiverFlowDynamics(
    grid,
    dt=dt,
    mannings_n=mannings_n,
    fixed_entry_nodes=fixed_entry_nodes,
    fixed_entry_links=fixed_entry_links,
    entry_nodes_h_values=entry_nodes_h_values,
    entry_links_vel_values=entry_links_vel_values,
)

"""
And we run 75 time steps of 1 $s$ duration (around 1 minute of computing time):
"""

# Set the animation frequency to n_timesteps if you
# don't want to plot the water depth
# display_animation_freq = n_timesteps
display_animation_freq = 5

grid.imshow("surface_water__depth", output=True)
for timestep in trange(n_timesteps):
    rfd.run_one_step()

    if timestep % display_animation_freq == 0:
        clear_output(wait=True)  # This will clear the previous image
        grid.imshow("surface_water__depth", output=True)

"""
Finally, we can explore the results by plotting the resulting water depth:
"""

grid.imshow("surface_water__depth")

"""
-- --
### And that's it! 

Nice work completing this tutorial. You know now how to use the `RiverFlowDynamics` Landlab component to run your own simulations :)

-- --


"""

"""
### Click here for more <a href="https://landlab.csdms.io/tutorials/">Landlab tutorials</a>
"""



================================================
File: docs/source/tutorials/river_flow_dynamics/river_flow_dynamics_tutorial2.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# 2D Surface Water Flow component

"""

"""
# River Flow Dynamics Simulation with Landlab
"""

"""
<hr>
<small>For more Landlab tutorials, click here: <a href="https://landlab.csdms.io/tutorials/">https://landlab.csdms.io/tutorials/</a></small>
<hr>
"""

"""
## Overview

This notebook demonstrate the usage of the `river flow dynamics` Landlab component. The component runs a semi-implicit, semi-Lagrangian finite-volume approximation to the depth-averaged 2D shallow-water equations of Casulli and Cheng (1992) and related work.

This notebook demonstrates how to simulate river flow dynamics using the Landlab library, implementing the semi-implicit, semi-Lagrangian finite-volume approximation of the depth-averaged shallow water equations (Casulli and Cheng, 1992).


## Setup and Imports

Import the needed libraries:
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid
from landlab.components import RiverFlowDynamics  # Note: Using updated CamelCase naming
from landlab.plot.imshow import imshow_grid

"""
## Create Grid and Set Initial Conditions

First, let's create a rectangular grid for our flow dynamics calculations:
"""

nRows = 20
nCols = 60
cellSize = 0.1

"""
Creating the grid
"""

grid = RasterModelGrid((nRows, nCols), xy_spacing=(cellSize, cellSize))

"""
## Setting up the initial topographic elevation
"""

te = grid.add_zeros("topographic__elevation", at="node")
te += 0.059 - 0.01 * grid.x_of_node
te[grid.y_of_node > 1.5] = 1.0
te[grid.y_of_node < 0.5] = 1.0

"""
## Visualizing the initial topography
"""

plt.figure(figsize=(12, 4))
imshow_grid(grid, "topographic__elevation")
plt.title("Initial Topographic Elevation")
plt.colorbar(label="Elevation (m)")
plt.show()

"""
Visualizing the middle bed profile
"""

middleBedProfile = np.reshape(te, (nRows, nCols))[10, :]
plt.figure(figsize=(12, 3))
plt.plot(middleBedProfile)
plt.title("Middle Longitudinal Section of Bed Profile")
plt.xlabel("Distance (cells)")
plt.ylabel("Elevation (m)")
plt.grid(True)
plt.show()

"""
## Initializing Required Fields

Create water depth field (initially empty channel)
"""

h = grid.add_zeros("surface_water__depth", at="node")

"""
Create velocity field (initially zero)
"""

vel = grid.add_zeros("surface_water__velocity", at="link")

"""
Calculate initial water surface elevation
"""

wse = grid.add_zeros("surface_water__elevation", at="node")
wse += h + te

"""
## Setting up the boundary conditions
"""

fixed_entry_nodes = np.arange(300, 910, 60)
fixed_entry_links = grid.links_at_node[fixed_entry_nodes][:, 0]

"""
Set fixed values for entry nodes/links
"""

entry_nodes_h_values = np.full(11, 0.5)  # 0.5m water depth
entry_links_vel_values = np.full(11, 0.45)  # 0.45 m/s velocity

"""
## Run Simulation

Initialize the RiverFlowDynamics component
"""

rfd = RiverFlowDynamics(
    grid,
    dt=0.1,
    mannings_n=0.012,
    fixed_entry_nodes=fixed_entry_nodes,
    fixed_entry_links=fixed_entry_links,
    entry_nodes_h_values=entry_nodes_h_values,
    entry_links_vel_values=entry_links_vel_values,
)

"""
Run the simulation for 100 timesteps (10 seconds)
"""

n_timesteps = 100
for timestep in range(n_timesteps):
    rfd.run_one_step()

"""
## Analyze Results

Get flow depth along center of channel
"""

flow_depth = np.reshape(grid["node"]["surface_water__depth"], (nRows, nCols))[10, :]

"""
Plot flow depth
"""

plt.figure(figsize=(12, 4))
plt.plot(flow_depth, label="Simulated")
plt.title("Flow Depth Along Channel Centerline")
plt.xlabel("Distance (cells)")
plt.ylabel("Depth (m)")
plt.grid(True)
plt.legend()
plt.show()

"""
Get and plot velocity along center of channel
"""

linksAtCenter = grid.links_at_node[np.array(np.arange(600, 660))][:-1, 0]
flow_velocity = grid["link"]["surface_water__velocity"][linksAtCenter]

plt.figure(figsize=(12, 4))
plt.plot(flow_velocity, label="Simulated")
plt.title("Flow Velocity Along Channel Centerline")
plt.xlabel("Distance (cells)")
plt.ylabel("Velocity (m/s)")
plt.grid(True)
plt.legend()
plt.show()

"""
## Visualization of Final State

Create a figure with two subplots and then let's plot final water depth
"""

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

# Plot final water depth
plt.subplot(2, 1, 1)
im1 = imshow_grid(grid, "surface_water__depth")
plt.title("Final Water Depth")
plt.colorbar(label="Depth (m)")

# Plot final water surface elevation
plt.subplot(2, 1, 2)
im2 = imshow_grid(grid, "surface_water__elevation")
plt.title("Final Water Surface Elevation")
plt.colorbar(label="Elevation (m)")

plt.tight_layout()
plt.show()

"""
-- --
### And that's it! 

Nice work completing this tutorial. You know now how to use the `RiverFlowDynamics` Landlab component to run your own simulations :)

-- --


"""

"""
### Click here for more <a href="https://landlab.csdms.io/tutorials/">Landlab tutorials</a>
"""



================================================
File: docs/source/tutorials/species_evolution/Introduction_to_SpeciesEvolver.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Introduction to the SpeciesEvolver component
<hr>

The links between the evolution of life and landscapes can be explored with SpeciesEvolver. This component tracks and evolves `Taxon` objects populated within a model grid. `Taxon` objects can represent species and other taxonomic levels.

In this tutorial we will build and run a model that exemplifies SpeciesEvolver functionality. You will have the opportunity to
* Populate a model grid with taxa.
* Evolve taxa in response to climate change.
* View the SpeciesEvolver record that stores model variables over time.
* Plot some model output.

This tutorial demonstrates the default, simplest capabilities of SpeciesEvolver. See the documentation for information upon other capabilities, including subclassing the ``Taxon`` class, enabling you to design different approaches to landscape-life evolution modeling.

For simpicity, the model we will construct uses only one Landlab process component: SpeciesEvolver. This component, as other Landlab components, are intended to be coupled for dynamic modeling of surface processes.
"""

"""
## Example model: climate change impacts on taxa distribution and evolution

### Premise

Ecosystems zonate by elevation in large part because surface air temperature decreases with altitude. Long term temperature change alters the landscape connectivity within elevations zones, and connectivity affects gene flow, leading to the question: ***How is vegetation macroevolution impacted by temperature changes?***

### Approach

We model the macroevolutionary processes of taxa in response to temperature change. The type of taxa is described as vegetation species in the text of this notebook. Although, nothing in the code designates the taxa as vegetation or as a species taxonomic level.

The model progresses in terms of time steps with an unprescribed duration. Initial conditions are set in time 0. The initial topography is loaded from a previously run model and does not change for the duration of the model in this notebook. Note that SpeciesEvolver can be used with a prescribed irregular or regular time step duration, e.g. a number of years.

In this model, air surface temperature at each time step is set by elevation using a lapse rate, the decrease of temperature with elevation. The temperature at base level in time 0 is 26&deg;C. The temperature throughout the grid is calculated using the base level temperature and the lapse rate. The temperature is decreased by 5&deg;C in both times 1 and 2.

At each time step, species distribution is set only by temperature, for simplicity of demonstration. The change in connectivity of species populations drive macroevolutionary processes built into the programmed species.

SpeciesEvolver is built to be adapted for many model approaches, especially for different taxon properties and behaviors. We will use `ZoneTaxon` in this notebook. This `Taxon` type is distributed with SpeciesEvolver and relies on `Zone` objects to evaluate evolutionary processes. The macroevolutionary processes built into `ZoneTaxon` are
* dispersal: movement of a taxon from one area to another
* speciation: production of child taxa by parent taxa
* extinction: end of taxa existence

In this model, the geographic range of species exists with the temperatures, 18&deg;C and 24&deg;C inclusive, meaning the extent of zones is bounded by this interval at each time step, and all species exist only within these temperatures at each time step.

Also in this model, speciation is simulated only as allopatric speciation that occurs as populations of a taxon become geographically isolated. Speciation triggered not by geographic isolation (sympatric speciation) is not modeled here, although it can be readily implemented by extending the speciation method of `ZoneTaxon` (see the documentation of this class).

### Summary

In this model, we

* Set surface air temperture across a model grid as a function of elevation.
* Populate species within the grid. These species exist within a fixed temperature interval.
* Simulate three time steps where surface air temperature changes in the latter two steps, which drives species response to this change.
* Examine how the number of species, *i.e.* "taxa richness" changes as the model progresses.
"""

"""
## Import modules

The zones of `ZoneTaxon` are managed by a `ZoneController`, so we must import this class along with the SpeciesEvolver component and the other modules used in this notebook.
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import Profiler, SpeciesEvolver
from landlab.components.species_evolution import ZoneController
from landlab.io import esri_ascii

"""
## Prepare the grid

### Load topography

Here the topography of the model grid is loaded from a file. The topography was previously developed using a model built with Landlab. An initial surface was uplifted, stream erosion was conducted using the FastscapeEroder component, and hillslope diffusion was conducted using the LinearDiffuser component. The model was run until topography reached steady state.
"""

# Create a model grid and set a topographic elevation field.
with open("model_grid_steady_state_elevation.txt") as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")

# Set the top and bottom grid boundaries to open.
mg.set_closed_boundaries_at_grid_edges(
    right_is_closed=True,
    top_is_closed=False,
    left_is_closed=True,
    bottom_is_closed=False,
)

# Plot the elevation field.
mg.imshow("topographic__elevation", colorbar_label="elevation (m)", shrink=0.4)

"""
### Create a grid field of air temperature at the land surface

We set a surface air temperature at base level (upper and lower boundaries). We use a lapse rate to create a  surface air temperature field at all nodes of the grid. The lapse rate, *L* is modeled as the decrease of temperature, *T* with increasing elevation, *z* as

\begin{align*}
L = -\frac{\delta t}{\delta z}
\end{align*}

We use a constant lapse rate of -5&deg;C / km.
"""

# Set a rate of temperature decrease per meter of elevation increase.
lapse_rate = -0.005

# Create a surface air temperature field.
temperature_at_base_level = 26
T = lapse_rate * mg.at_node["topographic__elevation"] + temperature_at_base_level
mg.add_field("land_surface_air__temperature", T, at="node")

# Plot temperature field.
mg.imshow(
    "land_surface_air__temperature",
    colorbar_label="surface air\ntemperature (C$\\degree$)",
    shrink=0.4,
    cmap="bwr",
)

"""
## Setup SpeciesEvolver and zones

The general workflow of working with zones and zone-based taxa is

* Initialize the SpeciesEvolver component.
* Setup zones and zone-based taxa:
    * Define a function that identifies the grid nodes where all zones will be created.
    * Initialize a ZoneController that will create and manage zones.
    * Populate zones with taxa.
* Introduce species to SpeciesEvolver so the component will track them over time.
"""

"""
### Initialize SpeciesEvolver

This component requires only one parameter, a model grid.
"""

se = SpeciesEvolver(mg)

"""
View `record_data_frame` of our SpeciesEvolver instance. Time and other model variables are stored in this attribute that is a Pandas DataFrame. The first and second columns are the row number and model time, respectively. In the third column we see that 0 taxa exist. We have yet to introduce taxa.
"""

se.record_data_frame

"""
### About zones

Zones help to evaluate the spatial aspect of `ZoneTaxon` macroevolutionary processes. A zone represents a portion of a model grid. It is made up of spatially continuous grid nodes. Along with SpeciesEvolver, zones can be utilized to track habitats or potential taxa geographic extents over time. In this notebook, zones will be created at each time step where temperature is within the suitable temperature range of the vegetation species. Multiple zones will be created at time steps if grid nodes with suitable temperature are not spatially continuous.

At each time step, the spatial connectivity of the zones between the current (*t*) and prior (*t*-1) time steps are identified. For example, consider two consecutive time steps where a zone in the prior time intersects two zones in the current time. This type of connection in the zones of SpeciesEvolver is referred to as 'one-to-many' represented here

<img src="./img/zone_connectivity__one_to_many.svg" width="40" height="40" /> 

where the red arrows represent zone connectivity over time, and

<img style="float: left;" src="./img/zone__prior_time.svg" width="20" height="20" /> &nbsp; a zone in *t*-1, the time step preceeding *t*

<img style="float: left;" src="./img/zone__current_time.svg" width="20" height="20" /> &nbsp; a zone in *t*, the current time step<br><br>


Behind the scenes, macroevolutionary rules programmed into `ZoneTaxon` are evaluated considering the type of zone connectivity. The outcome of the rules given the connectivity type are described in the table below.

<center>connectivity<br>type</center> | <center>graphical<br>represention</center> | <center>connectivity description</center> | <center>macroevolution implications</center>
--- | --- | --- | ---
one-to-none | <img src="./img/zone__prior_time.svg" width="20" height="20" />  | a zone in *t*-1 does not intersect a zone in *t*. | The taxa in the zone of the prior time will become extinct. 
one-to-one | <img src="./img/zone__one_to_one.svg" width="30" height="30" /> | a zone in *t*-1 intersects a zone in *t*. | The taxa in the zone of the prior time moves along with the zone of the current time. This connectivity type also occurs where a zone of the prior time does not relocate in the current time.
one-to-many | <img src="./img/zone__one_to_many.svg" width="30" height="30" /> | a zone in *t*-1 intersects multiple zones in *t*. | The taxa in the zone of the prior time disperses across the multiple zones in the current time. The taxa in the zones of the current time are geographically disconnected, thus speciation is triggered.
many-to-one | <img src="./img/zone__many_to_one.svg" width="30" height="30" /> | Multiple zones in *t*-1 intersect a zone in *t*. | The taxa in the prior time zones are relocated to a zone in the current time. Taxa density increases if zone<sub>*t*</sub> is smaller than the prior time step zones combined.
many-to-many | <img src="./img/zone__many_to_many.svg" width="40" height="40" /> | Multiple zones in *t*-1 intersect multiple zones in *t*. | The taxa in connected zones of *t*-1 relocates to the connected zones in *t*. Speciation is triggered for the taxa extant at the prior time step because their range becomes fragmented in the current time step.

Attributes of a zone include `mask` that indicates where in the grid the zone exists and `taxa`, which are the extant `Taxon` objects within the zone.
"""

def zone_func(grid):
    """Get a mask of the total zone extent."""
    T = grid.at_node["land_surface_air__temperature"]
    T_max = 25
    T_min = 18
    zone_extent_mask = np.all([T >= T_min, T <= T_max], 0)
    return zone_extent_mask

"""
To demonstrate the output of this function, `True` values are shaded white in the plot below. Zones will be created in the masked area (in white). Later we will see that two zones are created, one for each cluster of `True` values.
"""

mg.imshow(zone_func(mg), allow_colorbar=False, plot_name="zone extent in white")

"""
### Initialize ZoneController

Next, we instantiate a ZoneController that will create and manage the zones. We used an optional parameter, `minimum_area` to indicate the minimum area of the zones to be created. Zones will be created upon initialization of this controller.
"""

zc = ZoneController(mg, zone_func, minimum_area=50000)

"""
Above, the mask returned by the `zone_func` indicates where zones should be created.

Below, we see ZoneController created two zones designated by the different colors, one for each spatially distinct node cluster in the `zone_func` mask.
"""

# Create a map of all zones.
zone_map = np.zeros(mg.number_of_nodes)
for i, zone in enumerate(zc.zones):
    zone_map[zone.mask] = i + 1

# Plot zone map.
cmap = plt.cm.tab20
cmap.set_under("w")
title = f"zone count = {len(zc.zones)}"
mg.imshow(zone_map, cmap=cmap, allow_colorbar=False, plot_name=title, vmin=1)

"""
Multiple instances of ZoneController may be used with the same instance of SpeciesEvolver. This is useful when you wish to model groups of taxa within the same grid where each group needs a different zone function, for instance, fish and bears.
"""

"""
### Plot initial profile

Species dispersal at each time step will be considered by plotting the zone temperature interval alongside a topographic profile.

This initial profile is plotted across the main west-east divide.
"""

# Plot profile in map view.

endpoints = [29874, 174]
profiler = Profiler(mg, endpoints)
profiler.run_one_step()
profiler.plot_profiles_in_map_view(
    color="k",
    field=zone_map,
    cmap=cmap,
    allow_colorbar=False,
    plot_name="Profile (trace in black)",
    vmin=1,
)

# Plot profile.

fig, ax0 = plt.subplots()
profiler.plot_profiles(ylabel="Topographic Elevation (m)", color="k", title="Profile")
ax0.set_ylim([0, 3000])

ax1 = ax0.twinx()
ax1.set_ylim(ax0.get_ylim())
ax1.set_yticklabels(lapse_rate * ax0.get_yticks() + temperature_at_base_level)
ax1.set_ylabel("Surface Air Temperature (\N{DEGREE SIGN}C)")

# Include species temperature bounds.

upper = (18 - temperature_at_base_level) / lapse_rate
ax0.plot([0, 5000], [upper, upper], "c--", label="zone minimum temperature")

lower = (25 - temperature_at_base_level) / lapse_rate
ax0.plot([0, 5000], [lower, lower], "r--", label="zone maximum temperature")

ax0.legend();

"""
The profile (north is on the left) also illustrates that the two zones are seperated by the area around the main divide. This area is below the minimum zone temperature, therefore the ZoneController excluded zone creation here.
"""

"""
### Seed zones with taxa

A taxa is populated to each of the two initial zones using the ZoneController method, `populate_zones_uniformly`. This method creates species and populates it to each zone. (Any number of taxa can be populated to zones, and zones can be populated with different numbers of species.)
"""

taxa = zc.populate_zones_uniformly(1)

"""
### Introduce taxa to SpeciesEvolver

All taxa must be introduced using the SpeciesEvolver method, `track_taxa` in order for the taxa to be tracked by SpeciesEvolver.
"""

se.track_taxa(taxa)

"""
Two taxa now exist in SpeciesEvolver. In this notebook, each represents a vegetation species. In this model, nothing specific to vegetation species is needed, beyond setting the zone extent by air temperature using the zone function, thus the built functionality of ``ZoneTaxon`` is sufficient.
"""

se.record_data_frame

"""
The SpeciesEvolver attribute, `taxa_data_frame` provides data about all of the tracked taxa, both extant and extinct. The data is presented in a Pandas DataFrame. Each row is data about a taxon.
"""

se.taxa_data_frame

"""
`tid` is the identifier used to reference and retrieve ``Taxon`` objects, demostrated later in this notebook. Taxa are assigned identifiers in the order they are introduced to SpeciesEvolver.

`pid` is the identifier of the parent taxon. The parent of a taxon is the object that produced it. `<NA>` indicates no parent, which is typically the case of the model founder taxa.

`type` is the type of Taxon object.

`t_first` is the model time when the taxon emerged.

`t_final` is the final time of the taxon and when it was recognized as extinct. `<NA>` indicates a taxon is extant at the current model time.
"""

"""
## Model time step 1

Initial conditions were established in time 0. Next, climate change is modeled by increasing the temperature at base level by 5&deg;C.
"""

# Update the temperature field.
temperature_at_base_level += 5
mg.at_node["land_surface_air__temperature"] = (
    lapse_rate * mg.at_node["topographic__elevation"] + temperature_at_base_level
)

# Plot the temperature field.
mg.imshow(
    "land_surface_air__temperature",
    colorbar_label="surface air\ntemperature (C$\\degree$)",
    shrink=0.4,
    cmap="bwr",
)

"""
Here we advance ZoneController and SpeciesEvolver in time by one time step. ZoneController is advanced first in order to update the zones prior to calling SpeciesEvolver.

`dt` is set to 1 only because the duration of a time step is not prescribed in this tutorial. This `1` does not signify that one time step is run. We use 1 herein to make it easy to think about the time step sequence. Often, you may wish to make `dt` be the number of years in a time step, especially when you are running surface processes components alongside SpeciesEvolver.
"""

dt = 1
zc.run_one_step(dt)
se.run_one_step(dt)

"""
One zone now exists because the temperature increase raised the area that falls within the temperature range prescribed in `zone_func`.

Plot the zones.
"""

# Create a map of all zones.
zone_map = np.zeros(mg.number_of_nodes)
for i, zone in enumerate(zc.zones):
    zone_map[zone.mask] = i + 1

# Plot zone map.
title = f"zone count = {len(zc.zones)} (zone is shaded)"
mg.imshow(zone_map, cmap=cmap, allow_colorbar=False, plot_name=title, vmin=0.5)

"""
A 'many-to-one' zone connectivity occurred in this time step relative to the previous time step, meaning neither speciation or extinction were triggered by zone change. (See zone connectivity table above.)

The same two taxa of time 0 exist in time 1. Their geographic range is all that changed.
"""

se.taxa_data_frame

"""
### Plot a profile across the main divide
"""

# Plot profile in map view.

endpoints = [174, 29874]
profiler = Profiler(mg, endpoints)
profiler.run_one_step()
profiler.plot_profiles_in_map_view(
    color="k",
    field=zone_map,
    cmap=cmap,
    allow_colorbar=False,
    plot_name="Profile (trace in black)",
    vmin=0.5,
)

# Plot profile.

fig, ax0 = plt.subplots()
profiler.plot_profiles(ylabel="Topographic Elevation (m)", color="k", title="Profile")
ax0.set_ylim([0, 3000])

ax1 = ax0.twinx()
ax1.set_ylim(ax0.get_ylim())
ax1.set_yticklabels(lapse_rate * ax0.get_yticks() + temperature_at_base_level)
ax1.set_ylabel("Surface Air Temperature (\N{DEGREE SIGN}C)")

# Include species temperature bounds.

upper = (18 - temperature_at_base_level) / lapse_rate
ax0.plot([0, 5000], [upper, upper], "c--", label="zone minimum temperature")

lower = (25 - temperature_at_base_level) / lapse_rate
ax0.plot([0, 5000], [lower, lower], "r--", label="zone maximum temperature")

ax0.legend();

"""
Species were able to cross the main divide following the temperature increase. The two species now exist in the same area along the main divide. Coexisting has no effect because ZoneTaxon do not interact in the default implemention of the code for this species, although species can be made to influence each other by extending `ZoneTaxon` (see the documentation of this class).
"""

"""
## Model time step 2

Temperature is again increased by 5&deg;C in time step 2.
"""

# Update the surface temperature field.
temperature_at_base_level += 5
mg.at_node["land_surface_air__temperature"] = (
    lapse_rate * mg.at_node["topographic__elevation"] + temperature_at_base_level
)

# Plot temperature field.
mg.imshow(
    "land_surface_air__temperature",
    colorbar_label="surface air\ntemperature (C$\\degree$)",
    shrink=0.4,
    cmap="bwr",
)

"""
Advance ZoneController and SpeciesEvolver, and plot zones.
"""

zc.run_one_step(dt)
se.run_one_step(dt)

# Create a map of all zones.
zone_map = np.zeros(mg.number_of_nodes)
for i, zone in enumerate(zc.zones):
    zone_map[zone.mask] = i + 1

# Plot zone map.
title = f"zone count = {len(zc.zones)}"
mg.imshow(zone_map, cmap=cmap, allow_colorbar=False, plot_name=title, vmin=0.5)

"""
The grid now contains more zones than the prior time step. The macroevolutionary effect of this `one-to-many` zone connectivity relationship is examined in the next section.
"""

"""
## Examine model outcome

We see 22 extant taxa in the taxa DataFrame. We know all taxa are extant because `t_final` is `<NA>`. Taxon 0 is the parent of taxa 2...11. Taxon 1 is parent to taxa 12...21. The child taxa appeared at time 2 (see `t_first`) as temperature increased for the second time.
"""

se.taxa_data_frame

"""
In the SpeciesEvolver record DataFrame, we see 20 speciations at time 2.
"""

se.record_data_frame

"""
Next we will examine the model history using the plot below
"""

# Create a plot of key model variables over time.

time = se.record_data_frame.time
temperature = [26, 31, 36]
n_zones = zc.record_data_frame.zones
n_species = se.record_data_frame.taxa

plt.plot(time, temperature, "o-c", label="temperature (\N{DEGREE SIGN}C)")
plt.plot(time, n_zones, "s-m", label="zone count")
plt.plot(time, se.record_data_frame.taxa, "d-y", label="species count")
plt.xlabel("time")
plt.xticks(time)
plt.legend();

"""
### Plot time 1 profile along the main divide
"""

# Plot profile in map view.

endpoints = [15720, 15790]
profiler2 = Profiler(mg, endpoints)
profiler2.run_one_step()
profiler2.plot_profiles_in_map_view(
    color="k",
    field=zone_map,
    cmap=cmap,
    allow_colorbar=False,
    plot_name="Profile (trace in black)",
    vmin=1,
)

# Plot profile.

fig, ax0 = plt.subplots()
profiler2.plot_profiles(ylabel="Topographic Elevation (m)", color="k", title="Profile")
ax0.axis(ymin=1200, ymax=2600)

air_temp = lapse_rate * ax0.get_yticks() + temperature_at_base_level

ax1 = ax0.twinx()
ax1.set_ylim(ax0.get_ylim())
ax1.yaxis.set_ticks(ax0.get_yticks(), labels=air_temp)
ax1.set_ylabel("Surface Air Temperature (\N{DEGREE SIGN}C)")

# Include species min elevation line.

z_min = (25 - temperature_at_base_level) / lapse_rate
ax0.plot([0, 3500], [z_min, z_min], "c--", label="species minimum temperature")
ax0.legend();

"""
The profile trace crosses two zones (upper figure). The topography is above the elevation with the minimum species temperature for these two zones (lower figure).

An additional increase in temperature drove species to become isolated on mountain peaks along the main divide. Species could not reach adjacent peaks because valleys were too warm. Each peak that was below the maximum species temperature led to an isolated population that produced a child species. In the model we ran, 11 peaks/divide areas met these qualifications, thus species 0 and 1 produced 10 child species each. The original population of each founding species remained in one zone. Child taxa populated the other 10 zones.
"""

"""
## Examine the species

SpeciesEvolver automatically creates a `taxa__richness` grid field. We can use this field to see that there are two species in each zone. (taxa richness = number of taxa). Each zone contains a founder or descendent species from each of the two founder species.
"""

mg.imshow("taxa__richness", colorbar_label="taxa richness", shrink=0.4, cmap="viridis")

"""
Similar to SpeciesEvolver, ZoneController has a `record_data_frame` that stores model variables over time. The ZoneController stores variables pertinent to zones.

In the ZoneController record, 'fragmentation_count' in time 2 is 11. The one zone in time 1 split into 11 fragments, or zones, essentially between times 1 and 2.

We see capture statistics in this record as well. Here, a capture indicates that a zone captured area from a zone in a prior time step. The one zone in time 1 captured the two zones in time 0.
"""

zc.record_data_frame

"""
Pandas DataFrame methods can be used on `record_data_frame`. For example, here we get the maximum capture count.
"""

zc.record_data_frame.zones.max()

"""
### Retrieve taxon objects

Metadata of taxa can be viewed in `taxa_data_frame`, although taxon objects cannot be retrieved from this DataFrame. The objects of those taxa extant at the current model time can be retrieved using the SpeciesEvolver method, `get_extant_taxon_objects`. With a `Taxon` object you can examine its current properties, including plotting its geographic range as demonstrated below.

All of the extant taxa are returned when no parameters are inputted into `get_taxon_objects`.
"""

se.get_extant_taxon_objects()

"""
The taxa can be filtered by the time they existed. To do so, we can use the optional parameter, `time` to indicate we want the taxa extant at time 0, the two taxa introduced at the beginning of the model.
"""

se.get_extant_taxon_objects(time=0)

"""
Get taxa by their identifier using the  `tid` parameter. Here we request only one taxon, the one with a tid of 12. This method always returns a list so we index the first and only element in this list.
"""

taxon_12 = se.get_extant_taxon_objects(tids=[12])[0]
taxon_12

"""
With a taxon object retrieved, we can work with it as we need. Here we plot its geographic range. The `range_mask` attribute of a taxon is a mask of its geographic range.
"""

mask = taxon_12.range_mask
mg.imshow(mask, plot_name="taxon 12 range in white", allow_colorbar=False)

"""
The taxa with a common ancestor can be retrieved with the `ancestor` parameter. Here we get the taxa that descended from taxon 0 and then print only the identifiers of these descendents.
"""

filtered_taxa = se.get_extant_taxon_objects(ancestor=0)
[t.tid for t in filtered_taxa]

"""
Taxon 0 is one of the initial taxa and speciated taxa 2...11 when the zone fragmented at time 2. The same sequence of events occurred for taxon 1 and its descendents, 12...21. This phylogeny is explained by the one zone capture that brought together the two initial taxa, followed by the 11 zones fragmentations that drove the 20 speciations of the child taxa descended from the two initial taxa.
"""




================================================
File: docs/source/tutorials/tectonics/listric_kinematic_extender.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the Landlab ListricKinematicExtender component

*(Greg Tucker, University of Colorado Boulder, March 2021; revised June 2023 to use AdvectionSolverTVD instead of stepwise extension algorithm)*

This tutorial demonstrates how to use the `ListricKinematicExtender` component. `ListricKinematicExtender` models the vertical subsidence and lateral tectonic motion associated with a listric detachment fault. A listric fault is one that shallows with depth, such that the fault plane has a concave-upward profile. The word "kinematic" indicates that this component does not calculate the mechanics of stress and strain involved in an extensional fault; it simply aims to mimic them geometrically. The basic concept is to solve the advection equation for a hangingwall block of thickness $H(x,y,t)$ moving at velocity $u(x,y,t)$ relative to an underlying footwall block, to is fixed relative to the grid. 
"""

"""
## Theory

### Describing a listric fault plane

Consider a fault plane with dip angle $\alpha$ relative to the horizontal. The fault plane has a listric shape, in which the dip angle at the surface is $\alpha_0$, and it becomes increasingly shallow with depth, ultimately asymptoting to horizontal at depth $h$ (we'll refer to $h$ as the detachment depth). We can express the dip angle in terms of gradient $G = \tan\alpha$, and $G_0 = \tan\alpha_0$. Let the gradient decay exponentially with distance from its zero-surface trace, $x_f$, starting from the surface value $G_0$:

$$G(x) = G_0 e^{-x_f/\lambda}$$

where $\lambda$ is a length scale that we'll define in a moment. "Zero-surface trace" here means the line of intersection of the fault plane with the horizontal plane at zero elevation (the actual surface trace would depend on the elevation field). Because $G$ is the rate of change of fault plane elevation, $z_f$, with distance $x$, we can write:

$$\frac{dz_f}{dx_f} = -G_0 e^{-x_f/\lambda}\hskip1em\mbox{(1)}$$

Integrating,

$$z_f(x) = G_0\lambda e^{-x_f/\lambda} + C$$

We can evaluate the constant of integration by noting that $z_f = 0$ at $x_f = 0$ (in other words, by definition the fault plane elevation is zero at the line where it intersects the zero-elevation horizontal plane), so

$$C = -G_0\lambda$$

Plugging this back in,

$$z_f(x_f) = -G_0\lambda (1 - e^{-x_f/\lambda})$$

Note that the fault elevation asymptotes to a detachment depth $h = G_0\lambda$. This gives us a physical basis for $\lambda$, and means we can express our fault plane geometry by $h$ instead of $\lambda$:

$$\boxed{z_f(x_f) = -h \left(1 - e^{-x_f G_0 / h}\right)}$$

Let's plot it:
"""

import matplotlib.pyplot as plt
import numpy as np

alpha0 = 60.0  # fault dip at surface, degrees
h = 10.0  # detachment depth, km

G0 = np.tan(np.deg2rad(alpha0))
x = np.arange(0, 41.0)
z = -h * (1.0 - np.exp(-x * G0 / h))

plt.plot(x, z, "k")
plt.xlabel("Distance (km)")
plt.ylabel("Fault plane elevation (km)")

"""
If the topographic elevation is $z(x,y,t)$, then the hangingwall thickness is

$$H(x,y,t) = \max (z - z_f, 0)$$

### Rate of change of hangingwall thickness

Imagine that the hangingwall "block" is moving at velocity $\mathbf{u} = (u_x, u_y)$ relative to our coordinate system. This motion can be described by an advection (wave) equation,

$$\frac{\partial H}{\partial t} = -\left( u_x \frac{\partial H}{\partial x} + u_y \frac{\partial H}{\partial y}\right)$$

The topographic surface is the sum of the height of the footwall block, $z_{fw}$, and the thickness of the hangingwall $H$ (which might be zero), so the evolution equation for topographic elevation is

$$\frac{\partial z}{\partial t} = \frac{\partial z_{fw}}{\partial t} + \frac{\partial H}{\partial t}$$

or

$$\frac{\partial z}{\partial t} = \frac{\partial z_{fw}}{\partial t} -\left( u_x \frac{\partial H}{\partial x} + u_y \frac{\partial H}{\partial y}\right)$$

In principle, the height of the footwall surface could change through several mechanisms: isostatic uplift or subsidence, dynamic topography effects, and where the hangingwall is absent, erosion and sedimentation. From the point of view of the listrict kinematic extender component, these are considered external processes that are to be handled elsewhere.

The fault plane comes into the picture as an initial condition. The height of the footwall block starts out as the lesser of the fault plane or the initial topographic surface:

$$z_{fw}(x,y,0) = \min \left(z_f, z(x,y,0)\right)$$

For example, suppose $z(x,y,0) = 0$. Then

$$z_{fw} = \min \left[ -h \left(1 - e^{-x_f G_0 / h}\right), 0 \right]$$
"""

"""
## Implementation

The implementation in `ListricKinemticExtender` initializes fields for $z_f$ (`fault_plane__elevation`), $H$ (`hangingwall__thickness`), and  $\mathbf{u}$ (`advection__velocity`). The component then uses the `AdvectionSolverTVD` component to compute lateral motion and resulting changes in $H$.

### Initialization

#### Zero-surface fault trace

It's useful to represent the zero-surface fault trace as a parametric line. If the strike angle is $\alpha$ and the parameter is $t$, the equations are:

$$x_{ft} = x_0 + t \cos \alpha$$

$$y_{ft} = y_0 + t \sin \alpha$$

This is handy because it represents the trace in terms of an intercept point $(x_0, y_0)$ and a strike angle $\alpha$.

The closest distance of a point $(P_x, P_y)$ to the line is

$$d(P_x, P_y) = \sin\alpha (P_x-x_0) - \cos\alpha (P_y-y_0)$$

The below code uses a Landlab `RasterModelGrid` to illustrate this with three cases:

- Horizontal line: $x_0 = 0, y_0 = 0.5, \alpha = 0^\circ$
- Vertical line: $x_0 = 0.5, y_0 = 0, \alpha = 90^\circ$
- Diagonal line: $x_0 = y_0 = 0, \alpha = 45^\circ$
"""

def dist_to_line(Px, Py, x0, y0, alpha):
    alpha_r = np.radians(alpha)
    return np.sin(alpha_r) * (Px - x0) - np.cos(alpha_r) * (Py - y0)

from landlab import RasterModelGrid, imshow_grid

grid = RasterModelGrid((101, 101), xy_spacing=0.01)

d2l = dist_to_line(grid.x_of_node, grid.y_of_node, 0, 0.5, 0)
imshow_grid(grid, d2l)

d2l = dist_to_line(grid.x_of_node, grid.y_of_node, 0.5, 0, 90)
imshow_grid(grid, d2l)

d2l = dist_to_line(grid.x_of_node, grid.y_of_node, 0, 0, 45)
imshow_grid(grid, d2l)

"""
#### Fault-plane surface and hangingwall thickness

Once we have distance-to-fault-trace, we can use that to calculate the fault plane elevation at each grid node, and from that, the thickness of the hangingwall. Here's a very simple example case:

- 3x3 raster grid with a node spacing of 1,000 m
- elevation is zero everywhere
- surface fault dip is 60 degrees
- detachment depth is 10 km
- fault is oriented north-south, intercepting (0, 0)

In this case, the center node (which is also the only core node) is located at $x=1,000$ m, $y=1,000 m$ relative to the origin. That puts it 1,000 m from the zero-elevation fault trace. Thus, the elevation of the footwall should be:

$$z_{fw} = \min \left[ -(10,000) \left(1 - e^{-(1,000) (\tan 60) / (10,000)}\right), 0 \right]$$

The hangingwall thickness is:

$$H = z_0 - z_{fw}$$

Here's the calculation:
"""

def calc_fw_and_hw(xf, h, G0, z0):
    zfw = np.minimum(-h * (1.0 - np.exp(-xf * np.tan(np.radians(G0)) / h)), z0)
    H = z0 - zfw
    return zfw, H


zfw, H = calc_fw_and_hw(1000.0, 10000.0, 60.0, 0.0)
print("Footwall elevation =", zfw)
print("Hangingwall thickness =", H)

"""
Here's what the fault plane and hangingwall thickness look like in an example calculated using the default values in `ListricKinematicExtender`:
"""

from landlab import RasterModelGrid, imshow_grid
from landlab.components import ListricKinematicExtender

grid = RasterModelGrid((51, 51), xy_spacing=1000.0)
elev = grid.add_zeros("topographic__elevation", at="node")
extender = ListricKinematicExtender(grid)

imshow_grid(grid, grid.at_node["fault_plane__elevation"])
plt.figure()
imshow_grid(grid, grid.at_node["hangingwall__thickness"])

"""
### Processing extension

To calculate changes in hangingwall thickness and surface elevation, the `ListricKinematicExtender` component relies on another, more general, component: `AdvectionSolverTVD`. The basic concept is to calculate changes in local hangingwall thickness resulting from its horizontal motion, and from that update the surface elevation.

`AdvectionSolverTVD` implements a numerical solution to the 2D advection equation using a second-order, nonlinear, Total Variation Diminishing (TVD) method. For more information, see the documentation and tutorial for that component.

The following are simple tests to verify that it is working properly. 

#### Simple test cases

Consider westward motion of a hangingwall relative to a north-south fault trace. After a time interval $T$ at a speed $u$, the hangingwall will have moved a distance $uT$ relative to the fixed footwall. This means that the thickness at a distance $x$ from the zero-surface fault trace will have changed from an original thickness $H(x)$ to a new thickness $H(x-uT)$. Suppose the starting elevation field (before any extensional movement) is $z_0$. From above, and assuming that both $x$ and $x-uT$ are locations where $H>0$, before motion the thickness is:

$$H_\text{before} = z_0 + h \left(1 - e^{-x G_0 / h}\right)$$

After motion (and assuming no independent changes in elevation) the thickness becomes:

$$H_\text{after} = z_0 + h \left(1 - e^{-(x-uT) G_0 / h}\right)$$

For a concrete example, consider a case in which $h=10,000$ m, $G_0=\tan 60^\circ$,  $x=1,000$ m, $u=0.001$ m/y, and $T=5\times 10^5$ y. Then the value of $H$ after motion should be:
"""

G0 = np.tan(np.radians(60.0))
print("G0", G0)
h = 10000.0
u = 0.001
T = 5.0e5
z0 = 0.0
x = 1000.0
H_before = z0 + h * (1.0 - np.exp(-G0 * x / h))
H_before500 = z0 + h * (1.0 - np.exp(-G0 * 500.0 / h))
H_after = z0 + h * (1.0 - np.exp(-G0 * (x - u * T) / h))
print("Thickness at x = 1000 m before motion =", H_before)
print("Thickness at x = 1000 m before motion =", H_before500)
print("Thickness at x = 1000 m after 500 years of motion at 0.001 m/y =", H_after)

"""
The following code tests this using a simple Landlab grid:
"""

dx = 10.0  # node spacing, m
fault_x0 = 100.0
grid = RasterModelGrid((3, 130), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")
extender = ListricKinematicExtender(grid, fault_x0=fault_x0, fault_strike=90.0)

# Verify that node 240 is at xf=1000 and node 190 is at xf=500
print("Node 240 xf =", grid.x_of_node[240] - fault_x0)
print("Node 190 xf =", grid.x_of_node[190] - fault_x0)

H = grid.at_node["hangingwall__thickness"]
print("Initial thickness at xf = 1000 m:", H[240])
print("Initial thickness at xf = 500 m:", H[190])

dt = 0.2 * dx / u  # time-step duration, y
nsteps = int(500000.0 / dt)
print(nsteps)
for _ in range(nsteps):
    extender.run_one_step(dt)
print("After extension, thickness at xf = 1000 m (node 240) is", H[240])

print(nsteps, dt)

"""
The component will also automatically update elevation as the sum of fault-plane elevation and hangingwall thickness. In the above example, at $x_f = 1000$ m, elevation should decline by the difference between the old and new hangingwall thickness, which is approximately 1590 - 830 = 760 m. Because it starts from zero elevation, the new elevation should be about -760 m:
"""

print("New elevation at xf = 1000 m is", elev[240])

"""
The plot below shows a profile of the hangingwall and topography after 500 ky of extension (the "spike" in elevation on the right is just the initial condition, which does not change on the boundary nodes unless we force it to):
"""

midrow = np.arange(130, 260, dtype=int)
xmid = grid.x_of_node[midrow]
plt.plot(xmid, grid.at_node["fault_plane__elevation"][midrow], "r", label="Fault plane")
plt.plot(xmid, elev[midrow], "k", label="Surface")
plt.xlabel("Distance (m)")
plt.ylabel("Elevation (m)")
plt.legend()

"""
## Examples

### Example 1: Quasi-1D

The first example uses a quasi-1D setup to represent an initially level topography on which subsidence progressively accumulates. 
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import ListricKinematicExtender

# parameters
nrows = 3
ncols = 51
dx = 1000.0  # grid spacing, m
nsteps = 20  # number of iterations
dt = 2.5e5  # time step, y
extension_rate = 0.001  # m/y
detachment_depth = 10000.0  # m
fault_dip = 60.0  # fault dip angle, degrees
fault_x0 = 10000.0  # m from left side of model

# Create grid and elevation field
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")

# Instantiate component
extender = ListricKinematicExtender(
    grid,
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_x0=fault_x0,
    fault_y0=0.0,
    fault_strike=90.0,
    detachment_depth=detachment_depth,
)

# Plot the starting elevations, in cross-section (middle row)
midrow = np.arange(ncols, 2 * ncols, dtype=int)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")
plt.xlabel("Distance (km)")
plt.ylabel("Elevation (m)")
plt.xlim([10.0, 40.0])

# Add a plot of the fault plane
dist_from_fault = grid.x_of_node - fault_x0
dist_from_fault[dist_from_fault < 0.0] = 0.0
x0 = detachment_depth / np.tan(np.deg2rad(fault_dip))
fault_plane = -(detachment_depth * (1.0 - np.exp(-dist_from_fault / x0)))
plt.plot(grid.x_of_node[midrow] / 1000.0, fault_plane[midrow], "r")

for i in range(nsteps):
    extender.run_one_step(dt)
    plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")

# Add the analytic solution
total_time = nsteps * dt
G0 = np.tan(np.deg2rad(fault_dip))
shifted_dist_from_fault = np.maximum(dist_from_fault - extension_rate * total_time, 0.0)
elev_pred = detachment_depth * (
    np.exp(-dist_from_fault * G0 / h) - np.exp(-(shifted_dist_from_fault * G0 / h))
)
elev_pred = np.maximum(elev_pred, fault_plane)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev_pred[midrow], "b:")

"""
### Example 2: quasi-1D with topography
"""

period = 15000.0  # period of sinusoidal variations in initial topography, m
ampl = 500.0  # amplitude of variations, m

# Create grid and elevation field
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = ampl * np.sin(2 * np.pi * grid.x_of_node / period)

# Instantiate component
extender = ListricKinematicExtender(
    grid,
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_strike=90.0,
    fault_x0=fault_x0,
    fault_y0=0.0,
    detachment_depth=detachment_depth,
)

# Plot the starting elevations, in cross-section (middle row)
midrow = np.arange(ncols, 2 * ncols, dtype=int)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")
plt.xlabel("Distance (km)")
plt.ylabel("Elevation (m)")
plt.grid(True)

# Add a plot of the fault plane
dist_from_fault = grid.x_of_node - fault_x0
x0 = detachment_depth / np.tan(np.deg2rad(fault_dip))
fault_plane = -(detachment_depth * (1.0 - np.exp(-dist_from_fault / x0)))
fault_plane = np.minimum(fault_plane, elev)
plt.plot(grid.x_of_node[midrow] / 1000.0, fault_plane[midrow], "r")

for i in range(nsteps):
    extender.run_one_step(dt)
    c = 1.0 - i / nsteps
    plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], color=[c, c, c])

"""
### Example 3: extending to 2D
"""

# parameters
nrows = 31
ncols = 51
dx = 1000.0  # grid spacing, m
nsteps = 20  # number of iterations
dt = 2.5e5  # time step, y
extension_rate = 0.001  # m/y
detachment_depth = 10000.0  # m
fault_dip = 60.0  # fault dip angle, degrees
fault_x0 = 10000.0  # m from left side of model
period = 15000.0  # period of sinusoidal variations in initial topography, m
ampl = 500.0  # amplitude of variations, m

# Create grid and elevation field
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (
    ampl
    * np.sin(2 * np.pi * grid.x_of_node / period)
    * np.sin(2 * np.pi * grid.y_of_node / period)
)

# Instantiate component
extender = ListricKinematicExtender(
    grid,
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_strike=90.0,
    fault_x0=fault_x0,
    fault_y0=0.0,
    detachment_depth=detachment_depth,
)

# Plot the starting topography
imshow_grid(grid, elev)

for i in range(nsteps // 2):
    extender.run_one_step(dt)
imshow_grid(grid, elev)

for i in range(nsteps // 2):
    extender.run_one_step(dt)
imshow_grid(grid, elev)

# Plot a cross-section
start_node = 6 * ncols
end_node = start_node + ncols
midrow = np.arange(start_node, end_node, dtype=int)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")
plt.xlabel("Distance (km)")
plt.ylabel("Elevation (m)")
plt.grid(True)

# Add a plot of the fault plane
dist_from_fault = grid.x_of_node - fault_x0
x0 = detachment_depth / np.tan(np.deg2rad(fault_dip))
fault_plane = -(detachment_depth * (1.0 - np.exp(-dist_from_fault / x0)))
fault_plane = np.minimum(fault_plane, elev)
plt.plot(grid.x_of_node[midrow] / 1000.0, fault_plane[midrow], "r")

"""
### Example 4: hex grid
"""

from landlab import HexModelGrid

# parameters
nrows = 31
ncols = 51
dx = 1000.0  # grid spacing, m
nsteps = 20  # number of iterations
dt = 2.5e5  # time step, y
extension_rate = 0.001  # m/y
detachment_depth = 10000.0  # m
fault_dip = 60.0  # fault dip angle, degrees
fault_x0 = 10000.0  # m from left side of model
fault_strike = 60.0  # strike, degrees ccw from east
period = 15000.0  # period of sinusoidal variations in initial topography, m
ampl = 500.0  # amplitude of variations, m

# Create grid and elevation field
grid = HexModelGrid((nrows, ncols), spacing=dx, node_layout="rect")

elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (
    ampl
    * np.sin(2 * np.pi * grid.x_of_node / period)
    * np.sin(2 * np.pi * grid.y_of_node / period)
)

# Instantiate component
extender = ListricKinematicExtender(
    grid,
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_strike=fault_strike,
    fault_x0=fault_x0,
    fault_y0=0.0,
    detachment_depth=detachment_depth,
)

# Plot the starting topography
imshow_grid(grid, elev)

for i in range(nsteps // 2):
    extender.run_one_step(dt)
imshow_grid(grid, elev)

for i in range(nsteps // 2):
    extender.run_one_step(dt)
imshow_grid(grid, elev)

# Plot a cross-section
start_node = 6 * ncols
end_node = start_node + ncols
midrow = np.arange(start_node, end_node, dtype=int)
plt.plot(
    grid.x_of_node[midrow] / 1000.0, grid.at_node["fault_plane__elevation"][midrow], "r"
)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")
plt.xlabel("Distance (km)")
plt.ylabel("Elevation (m)")
plt.grid(True)

"""
### Example 5: Integrating with flexure

By itself, `ListricKinematicExtender` does not include rift-shoulder uplift, which in nature (at least in the author's understanding) occurs as a result of flexural isostatic uplift in response to extensional thinning of the crust, and also possibly as a result of thermal isostatic uplift in the underlying mantle. To handle the first of these, `ListricKinematicExtender` is designed to work together with a flexural isostasy component. The basic idea is to calculate explicitly the thinning of the crustal column that results from extension, so that this reduction in crustal thickness can be used by an isostasy component such as `Flexure`.

The basic concept behind `ListricKinematicExtender` is that thinning occurs when the hangingwall block is dragged away from the footwall, in effect sliding down the fault plane, as illustrated in the plot of topography and fault plane above. In order to combine with a flexural isostasy component, we need to keep track of the progressive reduction in crustal thickness. In the example below, we do this by keeping track of a quantity called "footwall thickness", which represents the thickness of material above an arbitrary datum fixed to the crustal column called "crust datum". The total thickness of material is then the sum of footwall and hangingwall thickness, and changes in this thickness create a positive or negative load. We use the `Flexure` component to calculate the net deflection (positive downward) resulting from this load. Because the initial condition itself will create a deflection, we record this initial deflection and then subtract it from subsequent deflection, to arrive at the net deflection resulting from crustal extension.
"""

from landlab.components import Flexure

# parameters
nrows = 31
ncols = 51
dx = 1000.0  # grid spacing, m
nsteps = 20  # number of iterations
dt = 2.5e5  # time step, y
extension_rate = 0.001  # m/y
detachment_depth = 10000.0  # m
fault_dip = 60.0  # fault dip angle, degrees
fault_x0 = 10000.0  # m from left side of model
period = 15000.0  # period of sinusoidal variations in initial topography, m
ampl = 500.0  # amplitude of variations, m

# flexural parameters
eet = 5000.0  # effective elastic thickness, m (here very thin)
crust_datum = -10000.0  # elevation of crustal reference datum, m
rhoc = 2700.0  # crust density, kg/m3
g = 9.8  # guess what?

# Create grid and elevation field
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (
    ampl
    * np.sin(2 * np.pi * grid.x_of_node / period)
    * np.sin(2 * np.pi * grid.y_of_node / period)
)
total_thickness = grid.add_zeros("upper_crust_thickness", at="node")
fw_thickness = grid.add_zeros("footwall__thickness", at="node")
load = grid.add_zeros("lithosphere__overlying_pressure_increment", at="node")

# Instantiate components
extender = ListricKinematicExtender(
    grid,
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_strike=90.0,
    fault_x0=fault_x0,
    fault_y0=0.0,
    detachment_depth=detachment_depth,
)

hw_thickness = grid.at_node["hangingwall__thickness"]
fw_thickness = grid.at_node["fault_plane__elevation"] - crust_datum

flexer = Flexure(grid, eet=eet, method="flexure")
deflection = grid.at_node["lithosphere_surface__elevation_increment"]

# set up thickness and flexure
unit_wt = rhoc * g
total_thickness[:] = elev - crust_datum
load[:] = unit_wt * total_thickness

flexer.update()
init_flex = deflection.copy()

# show initial deflection field (positive downward)
imshow_grid(grid, init_flex)

for i in range(nsteps):
    extender.run_one_step(dt)
    total_thickness = fw_thickness + hw_thickness
    load[:] = unit_wt * total_thickness
    flexer.update()
    net_deflection = deflection - init_flex
    elev[:] = crust_datum + total_thickness - net_deflection

imshow_grid(grid, total_thickness)

imshow_grid(grid, net_deflection)

imshow_grid(grid, elev)

plt.plot(elev.reshape(31, 51)[:, 9], label="Rift shoulder")
plt.plot(elev.reshape(31, 51)[:, 15], label="Rift basin")
plt.plot(-net_deflection.reshape(31, 51)[:, 9], label="Isostatic uplift profile")
plt.xlabel("North-south distance (km)")
plt.ylabel("Height (m)")
plt.legend()

"""
### Example 6: Multiple materials

The examples above apply tectonic advection to one layer of material: the stuff in the hangingwall. But what if we want a model in which the hangingwall contains two or more layers of material? For example, what if we want to track both rock and sediment?

The following example illustrates how we can do this. The underlying code in `ListricKinematicExtender` takes advantage of the ability of `AdvectionSolverTVD` to apply advection to multiple fields.
"""

# parameters
nrows = 31
ncols = 51
dx = 1000.0  # grid spacing, m
nsteps = 20  # number of iterations
dt = 2.5e5  # time step, y
extension_rate = 0.001  # m/y
detachment_depth = 10000.0  # m
fault_dip = 60.0  # fault dip angle, degrees
fault_x0 = 10000.0  # m from left side of model
period = 15000.0  # period of sinusoidal variations in initial topography, m
ampl = 500.0  # amplitude of variations, m
mean_sed_thickness = 100.0  # average thickness of sediment, m
sed_period = 18000.0  # period of sinusoidal undulations in sediment thickness, m

# flexural parameters
eet = 5000.0  # effective elastic thickness, m (here very thin)
crust_datum = -10000.0  # elevation of crustal reference datum, m
rhoc = 2700.0  # crust density, kg/m3
g = 9.8  # guess what?

# Create grid and elevation field
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)
elev = grid.add_zeros("topographic__elevation", at="node")
elev[:] = (
    ampl
    * np.sin(2 * np.pi * grid.x_of_node / period)
    * np.sin(2 * np.pi * grid.y_of_node / period)
)
sed = grid.add_zeros("soil__depth", at="node")
sed[:] = mean_sed_thickness * (
    1.0
    + np.sin(2 * np.pi * grid.x_of_node / period + np.pi)
    * np.sin(2 * np.pi * grid.y_of_node / period + 0)
)
total_thickness = grid.add_zeros("upper_crust_thickness", at="node")
fw_thickness = grid.add_zeros("footwall__thickness", at="node")
hw_sed = grid.add_zeros("hangingwall_sediment__thickness", at="node")
fw_sed = grid.add_zeros("footwall_sediment__thickness", at="node")
load = grid.add_zeros("lithosphere__overlying_pressure_increment", at="node")

# Instantiate components
extender = ListricKinematicExtender(
    grid,
    fields_to_advect=["hangingwall__thickness", "hangingwall_sediment__thickness"],
    extension_rate_x=extension_rate,
    extension_rate_y=0.0,
    fault_dip=fault_dip,
    fault_strike=90.0,
    fault_x0=fault_x0,
    fault_y0=0.0,
    detachment_depth=detachment_depth,
)

hw_thickness = grid.at_node["hangingwall__thickness"]
fw_thickness = grid.at_node["fault_plane__elevation"] - crust_datum
hw_sed[:] = np.minimum(hw_thickness, sed)
fw_sed[:] = sed - hw_sed

flexer = Flexure(grid, eet=eet, method="flexure")
deflection = grid.at_node["lithosphere_surface__elevation_increment"]

imshow_grid(grid, hw_sed)

imshow_grid(grid, fw_sed)

# set up thickness and flexure
unit_wt = (
    rhoc * g
)  # note we are approximating rock and sed as same density...could do better
total_thickness[:] = elev - crust_datum
load[:] = unit_wt * total_thickness

flexer.update()
init_flex = deflection.copy()

for i in range(nsteps):
    extender.run_one_step(dt)
    total_thickness = fw_thickness + hw_thickness
    load[:] = unit_wt * total_thickness
    flexer.update()
    net_deflection = deflection - init_flex
    elev[:] = crust_datum + total_thickness - net_deflection

sed[:] = fw_sed + hw_sed
plt.plot(elev.reshape(31, 51)[:, 9], label="Rift shoulder")
plt.plot((elev - sed).reshape(31, 51)[:, 9], ":", label="Rift shoulder sed")
plt.plot(elev.reshape(31, 51)[:, 15], label="Rift basin")
plt.plot((elev - sed).reshape(31, 51)[:, 15], ":", label="Rift basin sed")
plt.plot(-net_deflection.reshape(31, 51)[:, 9], label="Isostatic uplift profile")
plt.xlabel("North-south distance (km)")
plt.ylabel("Height (m)")
plt.legend()

# Plot a cross-section
start_node = 6 * ncols
end_node = start_node + ncols
midrow = np.arange(start_node, end_node, dtype=int)
plt.plot(
    grid.x_of_node[midrow] / 1000.0, grid.at_node["fault_plane__elevation"][midrow], "r"
)
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow] - sed[midrow], "c")
plt.plot(grid.x_of_node[midrow] / 1000.0, elev[midrow], "k")
plt.xlabel("Distance (km)")
plt.ylabel("Elevation (m)")
plt.grid(True)



================================================
File: docs/source/tutorials/terrain_analysis/chi_finder/chi_finder.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the ChiFinder Component

The `ChiFinder` component creates a map of the $\chi$ drainage network index from a digital elevation model. The $\chi$ index, described by Perron and Royden (2013), is a function of drainage area, $A$, and elevation, $\eta$:

\begin{equation}
\chi = \int\limits_{x_b}^{x} \left(\frac{A_0}{A(x)}\right)^\theta dx
\end{equation}

where $x_b$ is the location of the outlet of a watershed of interest, $x$ is a position on a channel somewhere upstream, $A_0$ is a drainage area scale, and $\theta$ is the concavity index parameter, often taken to be $\approx$ 0.5.

This tutorial shows briefly how to use the `ChiFinder` on natural or synthetic data.
"""

"""
## Imports and inline docs

First, import what we'll need.
"""

import numpy as np

from landlab import RasterModelGrid
from landlab.components import ChiFinder, FlowAccumulator
from landlab.io import esri_ascii

"""
The docstring describes the component and provides some simple examples.
"""

print(ChiFinder.__doc__)

"""
## Example

In this example, we read in a small digital elevation model (DEM) from NASADEM for an area on the Colorado high plains (USA) that includes a portion of an escarpment along the west side of a drainage known as West Bijou Creek (see Rengers & Tucker, 2014).

The DEM file is in ESRI Ascii format, but is in a geographic projection, with horizontal units of decimal degrees. To calculate slope gradients properly, we'll first read the DEM into a Landlab grid object that has this geographic projec. Then we'll create a second grid with 30 m cell spacing (approximately equal to the NASADEM's resolution), and copy the elevation field from the geographic DEM. This isn't a proper projection of course, but it will do for purposes of this example.
"""

# read the DEM
with open("west_bijou_escarpment_snippet.asc") as fp:
    grid_info, data = esri_ascii.lazy_load(fp, name="topographic__elevation", at="node")

grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.add_field("topographic__elevation", data, at="node")

grid.imshow(data, colorbar_label="Elevation (m)")

"""
The `ChiFinder` needs to have drainage areas pre-calculated. We'll do that with the `FlowAccumulator` component. We'll have the component do D8 flow routing (each DEM cell drains to whichever of its 8 neighbors lies in the steepest downslope direction), and fill pits (depressions in the DEM that would otherwise block the flow) using the `LakeMapperBarnes` component. The latter two arguments below tell the lake mapper to update the flow directions and drainage areas after filling the pits.
"""

fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

grid.imshow(
    np.log10(grid.at_node["drainage_area"] + 1.0),  # log10 helps show drainage
    cmap="Blues",
    colorbar_label="Log10(drainage area (m2))",
)

"""
Now run the `ChiFinder` and display the map of $\chi$ values.
"""

cf = ChiFinder(
    grid,
    reference_concavity=0.5,
    min_drainage_area=1.0,
    clobber=True,
)
cf.calculate_chi()

grid.imshow(
    grid.at_node["channel__chi_index"], cmap="viridis", colorbar_label="Chi index"
)

"""
## References

Perron, J., Royden, L. (2012). An integral approach to bedrock river
profile analysis Earth Surface Processes and Landforms  38(6), 570-576. https://dx.doi.org/10.1002/esp.3302

Rengers, F. K., & Tucker, G. E. (2014). Analysis and modeling of gully headcut dynamics, North American high plains. Journal of Geophysical Research: Earth Surface, 119(5), 983-1003. https://doi.org/10.1002/2013JF002962
"""



================================================
File: docs/source/tutorials/terrain_analysis/chi_finder/west_bijou_escarpment_snippet.prj
================================================
GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]



================================================
File: docs/source/tutorials/terrain_analysis/drainage_density/drainage_density.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the DrainageDensity Component


## Overview

Drainage density is defined as the total map-view length of stream channels, $\Lambda$, within a region with map-view surface area $A$, divided by that area:

$$D_d = \Lambda / A$$

The measure has dimensions of inverse length. The traditional method for measuring drainage density was to measure $\Lambda$ on a paper map by tracing out each stream. An alternative method, which lends itself to automated calculation from digital elevation models (DEMs), is to derive drainage density from a digital map that depicts the flow-path distance from each grid node to the nearest channel node, $L$ ([Tucker et al., 2001](https://doi.org/10.1016/S0169-555X(00)00056-8)). If the average flow-path distance to channels is $\overline{L}$, then the corresponding average drainage density is:

$$D_d = \frac{1}{2\overline{L}}$$

An advantage of this alternative approach is that $L$ can be mapped and analyzed statistically to reveal spatial variations, correlations with other geospatial attributes, and so on.

The `DrainageDensity` component is designed to calculate $L$, and then derive $D_d$ from it using the second equation above. Given a grid with drainage directions and drainage area, along with either a grid of channel locations or a threshold from which to generate channel locations, `DrainageDensity` component calculates the flow-path distance to the nearest channel node for each node in the grid. The values of $L$ are stored in a new at-node field called `surface_to_channel__minimum_distance`.

The component assumes that drainage directions and drainage area have already been calculated and the results stored in the following node fields:

- `flow__receiver_node`: ID of the neighboring node to which each node sends flow (its "receiver")
- `flow__link_to_receiver_node`: ID of the link along which each node sends flow to its receiver
- `flow__upstream_node_order`: downstream-to-upstream ordered array of node IDs
- `topographic__steepest_slope`: gradient from each node to its receiver

The `FlowAccumulator` generates all four of these fields, and should normally be run before `DrainageDensity`.

## Identifying channels

The `DrainageDensity` component is NOT very sophisticated about identifying channels. There are (currently) two options for handling channel identification:

1. specify the parameters of an area-slope channelization threshold, or
2. map the channels separately, and pass the result to `DrainageDensity` as a "channel mask" array

### Area-slope channel threshold

This option identifies a channel as occurring at any grid node where the actual drainage area, represented by the field `drainage_area`, exceeds a threshold, $T_c$:

$$C_A A^{m_r} C_s S^{n_r} > T_c$$

Here $A$ is `drainage_area`, $S$ is `topographic__steepest_slope`, and $C_A$, $C_s$, $m_r$, and $n_r$ are parameters. For example, to create a channel mask in which nodes with a drainage area greater than $10^5$ m$^2$ are identified as channels, the `DrainageDensity` component would be initialized as:

```python
dd = DrainageDensity(
    grid,
    area_coefficient=1.0,
    slope_coefficient=1.0,
    area_exponent=1.0,
    slope_exponent=0.0,
    channelization_threshold=1.0e5,
)
```

### Channel mask

This option involves creating a number-of-nodes-long array, of type `np.uint8`, containing a 1 for channel nodes and a 0 for others.

"""

"""
## Imports and inline docs

First, import what we'll need:
"""

import numpy as np

from landlab import RasterModelGrid
from landlab.components import DrainageDensity, FlowAccumulator
from landlab.io import esri_ascii

"""
The docstring describes the component and provides some simple examples:
"""

print(DrainageDensity.__doc__)

"""
The `__init__` docstring lists the parameters:
"""

print(DrainageDensity.__init__.__doc__)

"""
## Example 1: channelization threshold

In this example, we read in a small digital elevation model (DEM) from NASADEM for an area on the Colorado high plains (USA) that includes a portion of an escarpment along the west side of a drainage known as West Bijou Creek (see Rengers & Tucker, 2014).

The DEM file is in ESRI Ascii format, but is in a geographic projection, with horizontal units of decimal degrees. To calculate slope gradients properly, we'll first read the DEM into a Landlab grid object that has this geographic projection. Then we'll create a second grid with 30 m cell spacing (approximately equal to the NASADEM's resolution), and copy the elevation field from the geographic DEM. This isn't a proper projection of course, but it will do for purposes of this example.
"""

# read the DEM
with open("west_bijou_escarpment_snippet.asc") as fp:
    grid_info, data = esri_ascii.lazy_load(fp, name="topographic__elevation", at="node")

grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.add_field("topographic__elevation", data, at="node")

grid.imshow(grid.at_node["topographic__elevation"], colorbar_label="Elevation (m)")

"""
To use `DrainageDensity`, we need to have drainage directions and areas pre-calculated. We'll do that with the `FlowAccumulator` component. We'll have the component do D8 flow routing (each DEM cell drains to whichever of its 8 neighbors lies in the steepest downslope direction), and fill pits (depressions in the DEM that would otherwise block the flow) using the `LakeMapperBarnes` component. The latter two arguments below tell the lake mapper to update the flow directions and drainage areas after filling the pits.
"""

fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

grid.imshow(
    np.log10(grid.at_node["drainage_area"] + 1.0),  # log10 helps show drainage
    colorbar_label="Log10(drainage area (m2))",
)

"""
Now run `DrainageDensity` and display the map of $L$ values:
"""

dd = DrainageDensity(
    grid,
    area_coefficient=1.0,
    slope_coefficient=1.0,
    area_exponent=1.0,
    slope_exponent=0.0,
    channelization_threshold=2.0e4,
)
ddens = dd.calculate_drainage_density()
grid.imshow(
    grid.at_node["surface_to_channel__minimum_distance"],
    cmap="viridis",
    colorbar_label="Distance to channel (m)",
)
print(f"Drainage density = {ddens} m/m2")

"""
Display the channel mask:
"""

grid.imshow(grid.at_node["channel__mask"], colorbar_label="Channel present (1 = yes)")

"""
## Example 2: calculating from an independently derived channel mask

This example demonstrates how to run the component with an independently derived channel mask. For the sake of illustration, we will just use the channel mask from the previous example, in which case the $L$ field should look identical.
"""

# make a copy of the mask from the previous example
chanmask = grid.at_node["channel__mask"].copy()

# re-make the grid (this will remove all the previously created fields)
grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.add_field("topographic__elevation", data, at="node")

# instatiated and run flow accumulator
fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

# instantiate and run DrainageDensity component
dd = DrainageDensity(grid, channel__mask=chanmask)
ddens = dd.calculate_drainage_density()

# display distance-to-channel
grid.imshow(
    grid.at_node["surface_to_channel__minimum_distance"],
    cmap="viridis",
    colorbar_label="Distance to channel (m)",
)
print(f"Drainage density = {ddens} m/m2")

"""
## References

Rengers, F. K., & Tucker, G. E. (2014). Analysis and modeling of gully headcut dynamics, North American high plains. Journal of Geophysical Research: Earth Surface, 119(5), 983-1003. https://doi.org/10.1002/2013JF002962

Tucker, G. E., Catani, F., Rinaldo, A., & Bras, R. L. (2001). Statistical analysis of drainage density from digital terrain data. Geomorphology, 36(3-4), 187-202, [https://doi.org/10.1016/S0169-555X(00)00056-8](https://doi.org/10.1016/S0169-555X(00)00056-8).
"""



================================================
File: docs/source/tutorials/terrain_analysis/flow__distance_utility/application_of_flow__distance_utility.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Application of the flow__distance utility on a Sicilian basin
"""

"""
This notebook illustrates how to run the ``flow__distance`` utility on a digital elevation model (DEM) that represents a real basin in Sicily. First, a watershed will be extracted from the input DEM by using the watershed utility. Then, the distances from each node to the watershed's outlet will be obtained with the ``flow__distance`` utility. Flow is routed using the D8 algorithm.
"""

"""
First, import what we'll need:
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab.components import FlowAccumulator
from landlab.io import esri_ascii
from landlab.utils import watershed
from landlab.utils.flow__distance import calculate_flow__distance

"""
Import a square DEM that includes the watershed:
"""

with open("nocella_resampled.txt") as fp:
    mg = esri_ascii.load(fp, name="topographic__elevation", at="node")

"""
Run the FlowAccumulator and the DepressionFinderAndRouter components to find depressions, to route the flow across them and to calculate flow direction and drainage area:
"""

fr = FlowAccumulator(
    mg, flow_director="D8", depression_finder="DepressionFinderAndRouter"
)
fr.run_one_step()

"""
Set the id of the outlet. The value indicated here is the node id of the entire watershed's outlet:
"""

outlet_node = 15324

"""
Run the watershed utility and show the watershed mask:
"""

ws_mask = watershed.get_watershed_mask(mg, outlet_node)
mg.imshow(ws_mask, allow_colorbar=False)
plt.plot(mg.x_of_node[outlet_node], mg.y_of_node[outlet_node], "*", markersize=20)

"""
Run the ``flow__distance`` utility:
"""

flow_distance = calculate_flow__distance(mg, add_to_grid=True, clobber=True)

"""
Mask the ``flow__distance`` to the watershed mask. This operation has to be done because the ``flow__distance`` utility is applied to the entire grid that contains other streams not connected with our stream network and, for this reason, not belonging to our watershed.
"""

flow_distance_to_outlet = np.zeros(mg.number_of_nodes)
flow_distance_to_outlet[ws_mask] = flow_distance[ws_mask] - flow_distance[outlet_node]

"""
Plot the spatial distribution of the distances from each node to the watershed's outlet:
"""

mg.imshow(flow_distance_to_outlet, colorbar_label="flow distance (m)")
plt.plot(mg.x_of_node[outlet_node], mg.y_of_node[outlet_node], "*", markersize=20)



================================================
File: docs/source/tutorials/terrain_analysis/hack_calculator/hack_calculator.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the HackCalculator Component


## Background

Hack's Law refers to a commonly observed power-law relationship between the length of the longest stream in a drainage basin, $L$, and the area that it drains, $A$:

$$L = C A^h$$

where $h$ is commonly in the neighborhood of 0.5 or 0.6. It is named for the American geomorphologist John Hack (see Hack, 1957). A value of 0.5 represents perfect geometry similarity between the areal measure, $A$, and the embedded length $L$. Montgomery and Dietrich (1992) noted a useful "rule of thumb" empirical relationship:

$$A \approx \frac{1}{3} L^2$$

which says that, roughly speaking, the surface area of a typical drainage basin is on the order of 1/3 times the square of its longest stream length. But individual drainage basins often deviate somewhat from this idealized behavior, and often it is useful to extract the values of $C$ and $h$ for particular basins.

## Component overview

The `HackCalculator` provides estimates of the best-fit $C$ and $h$ values for one or more drainage basins within a given area represented by a digital elevation model, which is contained in a grid field called `topographic__elevation`. The component requires a grid that includes the following fields:

- `topographic__elevation` (node) elevation data for the region of interest
- `drainage_area` (node) contributing drainage area for each node
- `flow__receiver_node` (node) ID of the receiver (node that receives flow) for each node
- `flow__link_to_receiver_node` (node) ID of the link connecting node and receiver for each node
- `flow__upstream_node_order` (node) array of node IDs in downstream-to-upstream order

Apart from `topographic__elevation`, each of these fields are created and calculated by running the `FlowAccumulator` component.

The component uses the `ChannelProfiler` component to calculate cumulative downstream length for one or more channels in the terrain. Parameters for the `ChannelProfiler` may be given as arguments to `HackCalculator`.

When run (using the method `calculate_hack_parameters`), the component creates a Pandas DataFrame called `hack_coefficient_dataframe`. It is a pandas dataframe with one row for each basin for which Hack parameters are calculated. Thus, there are as many rows as the number of watersheds identified by the ChannelProfiler.

The dataframe has the following index and columns:

- Index
     - **basin_outlet_id**: The node ID of the watershed outlet where each set of Hack parameters was estimated.
- Columns
     - **A_max**: The drainage area of the watershed outlet.
     - **C**: The Hack coefficient as defined in the equations above.
     - **h**: The Hack exponent as defined in the equations above.

If you pass the argument `save_full_df=True`, `HackCalculator` will generate an additional DataFrame called `full_hack_dataframe`. It is pandas dataframe with a row for every model grid cell used to estimate the Hack parameters. It has the following index and columns:

- Index
    - **node_id**: The node ID of the model grid cell.
- Columns
     - **basin_outlet_id**: The node IDs of watershed outlet
     - **A**: The drainage are of the model grid cell.
     - **L_obs**: The observed distance to the divide.
     - **L_est**: The predicted distance to divide based on the Hack coefficient fit.

"""

"""
## Imports and inline docs

First, import what we'll need:
"""

from landlab import RasterModelGrid
from landlab.components import FlowAccumulator, HackCalculator
from landlab.io import esri_ascii

"""
The docstring describes the component and provides some simple examples:
"""

print(HackCalculator.__doc__)

"""
The `__init__` docstring lists the parameters:
"""

print(HackCalculator.__init__.__doc__)

"""
## Example 1

In this example, we read in a small digital elevation model (DEM) from NASADEM for an area on the Colorado high plains (USA) that includes a portion of an escarpment along the west side of a drainage known as West Bijou Creek (see Rengers & Tucker, 2014).

The DEM file is in ESRI Ascii format, but is in a geographic projection, with horizontal units of decimal degrees. To calculate slope gradients properly, we'll first read the DEM into a Landlab grid object that has this geographic projection. Then we'll create a second grid with 30 m cell spacing (approximately equal to the NASADEM's resolution), and copy the elevation field from the geographic DEM. This isn't a proper projection of course, but it will do for purposes of this example.

We use the ``lazy_load`` function rather than ``load`` function because we just want to just read the metadata from the data file needed to create a new grid. We will use this metadata to create a new grid for each of the examples below.
"""

with open("west_bijou_escarpment_snippet.asc") as fp:
    grid_info, data = esri_ascii.lazy_load(fp, name="topographic__elevation", at="node")

grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.at_node["topographic__elevation"] = data

grid.imshow("topographic__elevation", colorbar_label="Elevation (m)")

"""
Next, we run the `HackCalculator` on this DEM. First we need to instantiate and run `FlowAccumulator` to calculate flow directions and drainage area.
"""

# instatiated and run flow accumulator
fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

# instantiate and run HackCalculator component
hc = HackCalculator(grid)
hc.calculate_hack_parameters()

"""
Here is the resulting DataFrame, containing the area of the largest drainage basin and its corresponding $C$ and $h$ values:
"""

hc.hack_coefficient_dataframe

"""
You can access the embedded `ChannelProfiler` via `HackCalculator.profiler`:
"""

"""
The `ChannelProfiler` data is an ordered dict, in this case containing data for one watershed: the one that drains to node 6576 (for details see the [reference documentation](https://landlab.csdms.io/generated/api/landlab.components.profiler.channel_profiler.html#landlab.components.profiler.channel_profiler.ChannelProfiler) and tutorial resources for `ChannelProfiler`).

For this example, we might wish to visualize the main channel for which the Hack coefficient and exponent were calculated. We can do that with the profiler's `plot_profiles_in_map_view` method:
"""

hc.profiler.plot_profiles_in_map_view(colorbar_label="Elevation (m)")

"""
The component also provides a node field called `distance_to_divide` that, as the name implies, contains the streamwise distance between a node and its source at a drainage divide:
"""

grid.imshow("distance_to_divide", colorbar_label="Distance from drainage divide (m)")

"""
## Example 2: full data frame

The next example is the same as the first, but here we request and examine the "full dataframe":
"""

# create grid and copy DEM into it
grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.at_node["topographic__elevation"] = data

# instatiated and run flow accumulator
fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

# instantiate and run HackCalculator component
hc = HackCalculator(grid, save_full_df=True)
hc.calculate_hack_parameters()

hc.hack_coefficient_dataframe

hc.full_hack_dataframe

"""
## Example 3: multiple watersheds

By default, the `ChannelProfiler` extracts data from just one watershed, which is why the above example reports Hack parameters for just one basin. Here we re-run the analysis with five basins.
"""

# create grid and copy DEM into it
grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.at_node["topographic__elevation"] = data

# instatiated and run flow accumulator
fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

# instantiate and run HackCalculator component
hc = HackCalculator(grid, number_of_watersheds=5)
hc.calculate_hack_parameters()

hc.hack_coefficient_dataframe

hc.profiler.plot_profiles_in_map_view(colorbar_label="Elevation (m)")

"""
## Example 4: multiple channels per basin

So far, we have only performed the calculation on the main channel in each drainage basin. We can operate on all the channels in each basin by setting the `ChannelProfiler` parameter `main_channel_only` to `False`. While we're at it, we will also specify a drainage area threshold for channels of 20,000 m$^2$.
"""

# create grid and copy DEM into it
grid = RasterModelGrid(grid_info.shape, xy_spacing=30.0)
grid.at_node["topographic__elevation"] = data

# instatiated and run flow accumulator
fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
    depression_finder="LakeMapperBarnes",  # pit filler
    method="D8",  # pit filler use D8 too
    redirect_flow_steepest_descent=True,  # re-calculate flow dirs
    reaccumulate_flow=True,  # re-calculate drainagea area
)
fa.run_one_step()  # run the flow accumulator

# instantiate and run HackCalculator component
hc = HackCalculator(
    grid,
    number_of_watersheds=5,
    main_channel_only=False,
    minimum_channel_threshold=2.0e4,
)
hc.calculate_hack_parameters()

hc.hack_coefficient_dataframe

hc.profiler.plot_profiles_in_map_view(colorbar_label="Elevation (m)")

"""
## References

Hack, J. T. (1957). Studies of longitudinal stream profiles in Virginia and Maryland. Geological Survey Professional Paper 294-B. US Government Printing Office.

Montgomery, D. R., & Dietrich, W. E. (1992). Channel initiation and the problem of landscape scale. Science, 255(5046), 826-830.
"""



================================================
File: docs/source/tutorials/terrain_analysis/steepness_finder/steepness_finder.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Using the SteepnessFinder Component

## Background

Given an input digital elevation model (DEM), the `SteepnessFinder` component calculates the **steepness index** for nodes or stream segments in the drainage network. The steepness index is measure of channel gradient that is normalized to compensate for the correlation between gradient and drainage area. The definition of the steepness index derives from an idealized mathematical relationship between channel gradient and drainage area,

$$S = k_{sn} A^\theta$$

where $S$ is local channel gradient, $A$ is drainage area, $k_{sn}$ is the steepness index, and $\theta$ is the **concavity index** (because its value reflects the upward concavity of the stream profile; a value of 0 would represent a linear profile with no concavity). The definition of steepness index is therefore

$$k_{sn} = \frac{S}{A^\theta}$$

The occurrence of an approximate power-law relationship between gradient and drainage area was noted by, for example, Hack (1957, his equation 2) and Flint (1974) (it is sometimes called "Flint's Law", John Hack having already had a different scaling relation named for him; see the *HackCalculator* component tutorial). The emergence of DEMs and computers powerful enough to analyze them opened the door to statistical exploration of the slope-area relation (Tarboton and Bras, 1989), and the recognition that the relationship can be interpreted in terms of geomorphic processes (Willgoose et al., 1991). The concavity and steepness indices are defined and discussed in Whipple and Tucker (1999). The steepness index, and the related metric the chi index (see the *ChiFinder* tutorial) have become widely used as methods for identifying anomalies in channel gradient that may related to tectonics, lithology, or landscape transience (see, e.g., Wobus et al., 2006; Kirby and Whipple, 2012).
"""

"""
## Imports

First, import what we'll need:
"""

import copy

import matplotlib as mpl
import numpy as np

from landlab import imshow_grid
from landlab.components import FlowAccumulator, SteepnessFinder
from landlab.io import esri_ascii

"""
## Documentation
"""

"""
The [Reference Documentation](https://landlab.csdms.io/generated/api/landlab.components.steepness_index.channel_steepness.html#landlab.components.steepness_index.channel_steepness.SteepnessFinder) provides information about the SteepnessFinder class, describes its methods and attributes, and provides a link to the source code.

The SteepnessFinder class docstring describes the component and provides some simple examples:
"""

print(SteepnessFinder.__doc__)

"""
The `__init__` docstring lists the parameters:
"""

print(SteepnessFinder.__init__.__doc__)

"""
## Example 1

In this example, we read in a small digital elevation model (DEM) from the Sevilleta National Wildlife Refuge, NM, USA.

The DEM file is in ESRI Ascii format, with NODATA codes for cells outside the main watershed. We'll use the Landlab grid method `set_watershed_boundary_condition` to assign closed-boundary status to NODATA cells.
"""

with open("hugo_site_filled.asc") as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
grid.set_watershed_boundary_condition(grid.at_node["topographic__elevation"])

cmap = copy.copy(mpl.colormaps["pink"])
grid.imshow("topographic__elevation", cmap=cmap, colorbar_label="Elevation (m)")

"""
The `SteepnessFinder` needs to have drainage areas pre-calculated. We'll do that with the `FlowAccumulator` component. We'll have the component do D8 flow routing (each DEM cell drains to whichever of its 8 neighbors lies in the steepest downslope direction), and fill pits (depressions in the DEM that would otherwise block the flow) using the `LakeMapperBarnes` component. The latter two arguments below tell the lake mapper to update the flow directions and drainage areas after filling the pits.
"""

fa = FlowAccumulator(
    grid,
    flow_director="FlowDirectorD8",  # use D8 routing
)
fa.run_one_step()  # run the flow accumulator
cmap = copy.copy(mpl.colormaps["Blues"])
imshow_grid(
    grid,
    np.log10(grid.at_node["drainage_area"] + 1.0),  # sq root helps show drainage
    cmap=cmap,
    colorbar_label="Log10(drainage area (m2))",
)

"""
Now run the `SteepnessFinder` and display the map of $k_{sn}$ values:
"""

sf = SteepnessFinder(grid, min_drainage_area=2.0e4)
sf.calculate_steepnesses()
cmap = copy.copy(mpl.colormaps["viridis"])
imshow_grid(
    grid,
    grid.at_node["channel__steepness_index"],
    cmap=cmap,
    colorbar_label="Steepness index",
)

"""
## Example 2: fixed elevation drop

One challenge in extracting $k_{sn}$ from digital elevation data is noise: cell-to-cell variations in slope can make it hard to visualize coherent patterns, as the above example demonstrates. One solution, discussed by Wobus et al. (2006), is to use a fixed elevation drop: one starts from a given pixel and iterates from pixel-to-pixel downstream until the elevation difference from the starting point is equal to or greater than a specified drop distance. One advantage of this method prevents the analyzed segments from having zero slope. Another is that it effectively averages gradient over a longer horizontal distance that depends on the local gradient: lower gradients, which are generally more prone to noise, will be averaged over a longer distance, and vice versa. The example below shows how to do this with SteepnessFinder:
"""

# calculate steepness
sf = SteepnessFinder(grid, elev_step=4.0, min_drainage_area=2.0e4)
sf.calculate_steepnesses()
cmap = copy.copy(mpl.colormaps["viridis"])
imshow_grid(
    grid,
    grid.at_node["channel__steepness_index"],
    cmap=cmap,
    colorbar_label="Steepness index",
)

"""
## References

Flint, J. J. (1974). Stream gradient as a function of order, magnitude, and discharge. Water Resources Research, 10(5), 969-973.

Hack, J. T. (1957). Studies of longitudinal stream profiles in Virginia and Maryland. Geological Survey Professional Paper 294-B. US Government Printing Office.

Kirby, E., & Whipple, K. X. (2012). Expression of active tectonics in erosional landscapes. Journal of Structural Geology, 44, 54-75.

Tarboton, D. G., Bras, R. L., & Rodriguez‐Iturbe, I. (1989). Scaling and elevation in river networks. Water Resources Research, 25(9), 2037-2051.

Whipple, K. X., & Tucker, G. E. (1999). Dynamics of the stream‐power river incision model: Implications for height limits of mountain ranges, landscape response timescales, and research needs. Journal of Geophysical Research: Solid Earth, 104(B8), 17661-17674.

Willgoose, G., Bras, R. L., & Rodriguez‐Iturbe, I. (1991). A physical explanation of an observed link area‐slope relationship. Water Resources Research, 27(7), 1697-1702.

Wobus, C. W., Whipple, K. X., Kirby, E., Snyder, N. P., Johnson, J., Spyropolou, K., Crosby, B. T., and Sheenan, D.: Tectonics from topography: Procedures, promise, and pitfalls, in: Tectonics, Climate, and Landscape Evolution, edited by: Willett, S. D., Hovius, N., Brandon, M. T., and Fisher, D., Geological Society of America Special Paper 398, Geological Society of America, Boulder, CO, USA, 55–74, 2006.
"""



================================================
File: docs/source/tutorials/tidal_flow/tidal_flow_calculator.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Tidal Flow Calculator

*(Greg Tucker, August 2020)*

This tutorial explains the theory behind the `TidalFlowCalculator` Landlab component, and shows several examples of how to use the component in various different configurations.
"""

"""
## Theory

The `TidalFlowCalculator` computes a tidal-cycle averaged flow velocity field, given a topography (bathymetry), mean sea level, tidal range, and tidal period. The approach that the component uses is based on Mariotti (2018). The idea is to calculate a flow velocity field that is just sufficient to bring in (flood tide) or send out (ebb tide) all of the water that enters or leaves the system during one tidal cycle.

The inertial terms in the shallow-water momentum equations are assumed to be negligible, so that the operative driving forces are gravity and pressure (represented by the water-surface slope), and the resisting force is friction. The resulting relationship between velocity, depth, roughness, and water-surface slope is linearized into the following form:

$$U = -\frac{h^{4/3}}{n^2\chi} \nabla\eta$$ (1)

Here, $U$ is velocity (2D vector), $h$ is tidal-averaged water depth, $n$ is roughness, $\chi$ is a scale velocity (here assumed to be 1 m/s), and $\eta = h + z$ is water surface elevation (and $z$ is bed surface elevation). The equation above represents momentum conservation. Note that $U$ and $\nabla\eta$ are vectors, representing the $x$ and $y$ components of flow velocity and water-surface gradient, respectively.

The method uses a steady form of the mass-conservation equation---again, the idea is that we're seeking a flow velocity field that is just sufficient to carry in or out all the water that enters or exits during a tidal cycle. The mass conservation equation is:

$$\nabla \cdot \mathbf{q} = I$$

Here, $\mathbf{q} = U h$ is the volume flow per unit width (again, a two-dimensional vector). The variable $I$ is "the distributed input of water over half a tidal cycle" (Mariotti, 2018), defined as

$$I(x,y) = \left[r/2 − \max(−r/2, \min(z(x,y), r/2))\right]/(T/2)$$

where $r$ is the tidal range [L] and $T$ is the tidal period [T]. In the expression above, if the water at a point $(x,y)$ is deeper than the tidal amplitude (i.e, half the tidal range, or $r/2$), then the depth of inundation or drainage during half of a tidal cycle is simply the tidal range $r$. All of this water must enter or leave during half a tidal cycle, or $T/2$. Therefore the **rate** [L/T] of inundation or drainage is equal to the depth divided by $T/2$. Again, if the water is deeper than $r/2$, the rate is just $2r/T$.

Our goal is to calculate $U$ at each location. We get it by solving for $\eta$ then using equation (1) to calculate $U$. It turns out that we can formulate this as a Poisson equation: a steady diffusion equation, in this case in two (horizontal) dimensions. First, approximate that $h$, $n$ are uniform (even though they aren't, in the general problem). Substituting, we have

$$\nabla U h = \nabla \frac{h^{7/3}}{n^2\chi} \nabla\cdot\eta = \frac{h^{7/3}}{n^2\chi} \nabla^2 \eta$$

Plugging this into our mass conservation law

$$\frac{h^{7/3}}{n^2\chi} \nabla^2 \eta = I$$

This can be rearranged to:

$$\boxed{\nabla^2\eta = \frac{In^2\chi}{h^{7/3}}} \text{ (equation 1)}$$

This is the Poisson problem to be solved numerically.

Note that $I$ is positive on the flood tide and negative on the ebb tide. In practice, the component solves for the ebb tide velocity, than calculates the flood tide velocity as -1 times the ebb tide velocity (i.e., just the reverse of the ebb tide).
"""

"""
## Numerical methods

The `TidalFlowCalculator` uses a finite-volume method to solve equation (1) numerically at the core nodes of a Landlab grid. The grid must be either a `RasterModelGrid` or a `HexModelGrid`. You can find a discussion of finite-volume methods in the tutorial for Landlab's matrix-building utility. Here, a quick sketch of the solution method is as follows. The governing mass conservation equation is:

$$\nabla\cdot \mathbf{q} = I$$

The basis for the 2d finite-volume method is to integrate both sides of the equation over a region $R$, representing a grid cell. Then Green's theorem is used to turn the divergence term into a line integral of the flux around the perimeter of the region, $S$. The above equation becomes

$$\oint_S \mathbf{q} \mathbf{n} dS = IA_c$$

where $A_c$ is the surface area of the region and $\mathbf{n}$ is the outward unit vector normal to the perimeter of the region. When the region is a grid cell with $N$ faces of width $w$, the above becomes

$$\sum_{k=1}^N q_k \delta_k w = IA_c$$

where $q_k$ is the magnitude of $q$ in the face-perpendicular direction at cell face $k$, and $\delta$ is either 1 or -1, depending on the orientation of the grid link that crosses the face. The flux strength $q$ is positive when flow is in the direction of the link, and negative when it is in the opposite direction. For a `RasterModelGrid`, $N=4$, and for a `HexModelGrid`, $N=6$.

As discussed in the tutorial *Building a matrix for numerical methods using a Landlab grid*, when $q$ depends on the gradient in some field (in this case, water-surface elevation), the above equation can be translated into a matrix equation of the form $A\mathbf{x}=\mathbf{b}$, whose solution gives the solution to the Poisson equation.
"""

"""
## Examples

### One-dimensional case

Consider a one dimensional domain with open water at the east (right) side and a closed boundary (e.g., seawall) at the west (left) side, where by definition the distance from the seawall is $x=0$. Assume that the mean water depth is larger than the tidal amplitude, so that the sea bed is never exposed, even at low tide. Imagine that our tidal range is 2 meters, the water depth is 50 meters, and (to make the math a bit easier) the tidal period is 40,000 seconds. The analytical solution for flow discharge, $q$, can be found by noting that at any given distance from the sea wall, $q$ must be just enough to carry out all the outgoing water (ebb tide) or carry in all the incoming water (flood tide). The rate of inflow or outflow is equal to the inundation/drainage rate $I$ times distance from the sea wall, $x$:

$$q = -I x$$

The negative sign just means that $q$ is positive (flow to the right/east) when the tide is going out (negative $I$) and negative (flow to the left/west) when the tide is coming in. The velocity is

$$U = -I x / h$$

Here, $h$ is a function of $x$, but with a modest roughness (Manning's $n$) of 0.01 and relatively deep water, we can get a good approximation using just the tidal-average depth of 50 m. With this approximation, we expect the solution to be:

$$U = \pm \frac{(2 m)}{(50 m) \cdot (2\times 10^4 s)} x = 2\times 10^{-6} x$$

The code below runs the component for these conditions, and compares the solution with this analytical solution.
"""

import matplotlib.pyplot as plt
import numpy as np

from landlab import RasterModelGrid
from landlab.components import TidalFlowCalculator

# set up the grid
# only 1 row of core nodes, between 2 boundary rows
grid = RasterModelGrid((3, 101), xy_spacing=2.0)

# only east/right side open
grid.set_closed_boundaries_at_grid_edges(False, True, True, True)

# create the bathymetry field
z = grid.add_zeros("topographic__elevation", at="node")
z[:] = -50.0  # mean water depth is 50 m below MSL, which is our vertical datum

# create the component
tfc = TidalFlowCalculator(grid, tidal_range=2.0, tidal_period=4.0e4, roughness=0.01)

# run the component
tfc.run_one_step()

# calculate the analytical solution
x = np.arange(3.0, 200.0, 2.0)
vel_analytical = 2.0e-6 * x

# plot both
plt.plot(x, grid.at_link["ebb_tide_flow__velocity"][grid.active_links], "b.")
plt.plot(x, vel_analytical, "r")
plt.xlabel("Distance from sea wall (x)")
plt.ylabel("Ebb tide velocity (m/s)")
plt.legend(["numerical", "analytical"])

"""
As we would expect, the numerical solution is slightly lower than the analytical solution, because our simplified analytical solution does not take into account the extra water depth whose gradient propels the ebb tide. (Exercise to the reader: develop the analytical solution for water surface elevation, and then use it to derive a correct flow velocity that accounts for a little bit of extra depth at ebb tide, and a little less depth at flood tide.)
"""

"""
### Idealized two-dimensional cases

#### Two open boundaries

Here we use a rectangular domain with two open sides and two closed sides. Start by defining a generic plotting function:
"""

from landlab.grid.mappers import map_link_vector_components_to_node


def map_velocity_components_to_nodes(grid):
    """Map the velocity components from the links to the nodes, and return the node arrays."""
    ebb_vel_x, ebb_vel_y = map_link_vector_components_to_node(
        grid, grid.at_link["ebb_tide_flow__velocity"]
    )
    flood_vel_x = -ebb_vel_x
    flood_vel_y = -ebb_vel_y
    return (ebb_vel_x, ebb_vel_y, flood_vel_x, flood_vel_y)


def plot_tidal_flow(grid, resample=1):
    (ebb_x, ebb_y, flood_x, flood_y) = map_velocity_components_to_nodes(grid)

    # depth
    plt.figure()
    grid.imshow(grid.at_node["mean_water__depth"], cmap="YlGnBu", color_for_closed="g")
    plt.title("Water depth (m)")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

    # down-sample for legible quiver plots if needed
    if resample != 1:
        xr = grid.x_of_node.reshape(
            (grid.number_of_node_rows, grid.number_of_node_columns)
        )[::resample, ::resample]
        yr = grid.y_of_node.reshape(
            (grid.number_of_node_rows, grid.number_of_node_columns)
        )[::resample, ::resample]
        ebb_xr = ebb_x.reshape((grid.number_of_node_rows, grid.number_of_node_columns))[
            ::resample, ::resample
        ]
        ebb_yr = ebb_y.reshape((grid.number_of_node_rows, grid.number_of_node_columns))[
            ::resample, ::resample
        ]
        fld_xr = flood_x.reshape(
            (grid.number_of_node_rows, grid.number_of_node_columns)
        )[::resample, ::resample]
        fld_yr = flood_y.reshape(
            (grid.number_of_node_rows, grid.number_of_node_columns)
        )[::resample, ::resample]
    else:
        xr = grid.x_of_node
        yr = grid.y_of_node
        ebb_xr = ebb_x
        ebb_yr = ebb_y
        fld_xr = flood_x
        fld_yr = flood_y

    # ebb tide
    plt.figure()
    grid.imshow(grid.at_node["topographic__elevation"])
    plt.quiver(xr, yr, ebb_xr, ebb_yr)
    plt.title("Ebb Tide")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

    ebb_vel_magnitude = np.sqrt(ebb_x * ebb_x + ebb_y * ebb_y)
    plt.figure()
    grid.imshow(ebb_vel_magnitude, cmap="magma", color_for_closed="g")
    plt.title("Ebb Tide Velocity Magnitude (m/s)")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

    # flood tide
    plt.figure()
    grid.imshow(grid.at_node["topographic__elevation"])
    plt.quiver(xr, yr, fld_xr, fld_yr)
    plt.title("Flood Tide")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

    plt.figure()
    flood_vel_magnitude = np.sqrt(flood_x * flood_x + flood_y * flood_y)
    grid.imshow(flood_vel_magnitude, cmap="magma", color_for_closed="g")
    plt.title("Flood Tide Velocity Magnitude (m/s)")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

# parameters
nrows = 15
ncols = 25
grid_spacing = 100.0  # m
mean_depth = 2.0  # m
tidal_range = 2.0  # m
roughness = 0.01  # s/m^1/3, i.e., Manning's n

# create and set up the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=grid_spacing)
z = grid.add_zeros("topographic__elevation", at="node")
z[:] = -mean_depth
grid.set_closed_boundaries_at_grid_edges(False, False, True, True)

# instantiate the TidalFlowCalculator
tfc = TidalFlowCalculator(grid, tidal_range=2.0, roughness=0.01)

# run it
tfc.run_one_step()

# make plots...
plot_tidal_flow(grid)

"""
#### Uniform with one open boundary
"""

# parameters
nrows = 400
ncols = 200
grid_spacing = 2.0  # m
mean_depth = 2.0  # m
tidal_range = 3.1  # m
tidal_period = 12.5 * 3600.0  # s
roughness = 0.01  # s/m^1/3, i.e., Manning's n
open_nodes = np.arange(95, 105, dtype=int)

# create and set up the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=grid_spacing)
z = grid.add_zeros("topographic__elevation", at="node")
z[:] = -mean_depth
grid.set_closed_boundaries_at_grid_edges(True, True, True, False)

# instantiate the TidalFlowCalculator
tfc = TidalFlowCalculator(
    grid, tidal_range=tidal_range, tidal_period=tidal_period, roughness=0.01
)

# run it
tfc.run_one_step()

# make plots...
plot_tidal_flow(grid, resample=5)

"""
#### Uniform with narrow open boundary
"""

# parameters
nrows = 400
ncols = 200
grid_spacing = 2.0  # m
mean_depth = 2.0  # m
tidal_range = 3.1  # m
tidal_period = 12.5 * 3600.0  # s
roughness = 0.01  # s/m^1/3, i.e., Manning's n
open_nodes = np.arange(95, 105, dtype=int)

# create and set up the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=grid_spacing)
z = grid.add_zeros("topographic__elevation", at="node")
z[:] = -mean_depth
grid.set_closed_boundaries_at_grid_edges(True, True, True, True)
grid.status_at_node[open_nodes] = grid.BC_NODE_IS_FIXED_VALUE

# instantiate the TidalFlowCalculator
tfc = TidalFlowCalculator(
    grid, tidal_range=tidal_range, tidal_period=tidal_period, roughness=0.01
)

# run it
tfc.run_one_step()

# make plots...
plot_tidal_flow(grid, resample=5)

"""
#### Straight channel
"""

from landlab.grid.mappers import map_max_of_link_nodes_to_link

# parameters
nrows = 400
ncols = 200
grid_spacing = 2.0  # m
marsh_height = 1.0  # m
channel_depth = 2.0  # m
tidal_range = 3.1  # m
tidal_period = 12.5 * 3600.0  # s
open_nodes = np.arange(
    94, 105, dtype=int
)  # IDs of open-boundary nodes (along channel at bottom/south boundary)
roughness_shallow = 0.2  # Manning's n for areas above mean sea level (i.e., the marsh)
roughness_deep = 0.01  # Manning's n for areas below mean sea level (i.e., the channel)

# create and set up the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=grid_spacing)
z = grid.add_zeros("topographic__elevation", at="node")
z[grid.core_nodes] = marsh_height
channel = np.logical_and(grid.x_of_node >= 188.0, grid.x_of_node <= 208.0)
z[channel] = -channel_depth
grid.set_closed_boundaries_at_grid_edges(True, True, True, True)
grid.status_at_node[open_nodes] = grid.BC_NODE_IS_FIXED_VALUE

# set up roughness field (calculate on nodes, then map to links)
roughness_at_nodes = roughness_shallow + np.zeros(z.size)
roughness_at_nodes[z < 0.0] = roughness_deep
roughness = grid.add_zeros("roughness", at="link")
map_max_of_link_nodes_to_link(grid, roughness_at_nodes, out=roughness)

# instantiate the TidalFlowCalculator
tfc = TidalFlowCalculator(
    grid, tidal_range=tidal_range, tidal_period=tidal_period, roughness="roughness"
)

# run it
tfc.run_one_step()

# make plots...
plot_tidal_flow(grid, resample=10)

"""
### Case study based on example in Giulio Mariotti's MarshMorpho2D package

This example reads topography/bathymetry from a 2-meter resolution digital elevation model. Locations above mean high tide are flagged as closed boundaries.
"""

from landlab.io import esri_ascii

# Set parameters (these are from the MarshMorpho2D source code)
tidal_period = 12.5 * 3600.0  # tidal period in seconds
tidal_range = 3.1  # tidal range in meters
roughness = 0.02  # Manning's n
mean_sea_level = 0.0  # mean sea level in meters
min_water_depth = (
    0.01  # minimum depth for water on areas higher than low tide water surface, meters
)
nodata_code = 999  # code for a DEM cell with no valid data

# Read the DEM to create a grid and topography field
with open("zSW3.asc") as fp:
    grid = esri_ascii.load(fp, name="topographic__elevation", at="node")
z = grid.at_node["topographic__elevation"]

# Configure boundaries: any nodata nodes, plus any nodes higher than mean high tide
grid.status_at_node[z == nodata_code] = grid.BC_NODE_IS_CLOSED
grid.status_at_node[z > 1.8] = grid.BC_NODE_IS_CLOSED
boundaries_above_msl = np.logical_and(
    grid.status_at_node == grid.BC_NODE_IS_FIXED_VALUE, z > 0.0
)
grid.status_at_node[boundaries_above_msl] = grid.BC_NODE_IS_CLOSED

# Instantiate a TidalFlowCalculator component
tfc = TidalFlowCalculator(
    grid,
    tidal_period=tidal_period,
    tidal_range=tidal_range,
    roughness=roughness,
    mean_sea_level=mean_sea_level,
    min_water_depth=min_water_depth,
)

# Calculate tidal flow
tfc.run_one_step()

# make plots...
plot_tidal_flow(grid, resample=5)

"""
### Example with hex grid

The following example demonstrates that the `TidalFlowCalculator` can operate on a hex grid

(Note that the slightly odd flow patterns along the two closed edges are just artifacts of the method used to map velocity vectors from links onto nodes for plotting purposes; the current method doesn't accurately handle nodes adjacent to closed boundaries.)
"""

def plot_tidal_flow_hex(grid):
    (ebb_x, ebb_y) = map_link_vector_components_to_node(
        grid, grid.at_link["ebb_tide_flow__velocity"]
    )

    # ebb tide velocity vectors & magnitude
    ebb_vel_magnitude = np.sqrt(ebb_x * ebb_x + ebb_y * ebb_y)
    plt.figure()
    grid.imshow(ebb_vel_magnitude, cmap="magma")
    plt.quiver(grid.x_of_node, grid.y_of_node, ebb_x, ebb_y)
    plt.title("Ebb Tide")
    plt.xlabel("Distance (m)")
    plt.ylabel("Distance (m)")

from landlab import HexModelGrid

# parameters
nrows = 15
ncols = 25
grid_spacing = 100.0  # m
mean_depth = 2.0  # m
tidal_range = 2.0  # m
roughness = 0.01  # s/m^1/3, i.e., Manning's n

# create and set up the grid
grid = HexModelGrid((nrows, ncols), spacing=grid_spacing, node_layout="rect")
z = grid.add_zeros("topographic__elevation", at="node")
z[:] = -mean_depth
grid.status_at_node[grid.nodes_at_bottom_edge] = grid.BC_NODE_IS_CLOSED
grid.status_at_node[grid.nodes_at_left_edge] = grid.BC_NODE_IS_CLOSED

# instantiate the TidalFlowCalculator
tfc = TidalFlowCalculator(grid, tidal_range=2.0, roughness=0.01)

# run it
tfc.run_one_step()

# make plots...
plot_tidal_flow_hex(grid)



================================================
File: docs/source/tutorials/visualization/blender/landlab_to_blender.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Importing Landlab .obj format output into Blender

*(This tutorial was written as a collaboration between geology professor Greg Tucker and Vancouver-based visual effects artist Rees Tucker. First version August 2023.)*
"""

"""
[Blender](https://www.blender.org/) is a free and open source 3D computer graphics software package. The Blender developers' vision is that "Everyone should be free to create 3D CG content, with free technical and creative production means and free access to markets." This tutorial describes the basics of getting Landlab output into Blender, using the Wavefront .obj output format.
"""

"""
## Creating a Landlab model as an example

To provide an example, we will create a little landscape evolution simulation using Landlab components, and export its final configuration at the end of the run as an `.obj` format file. (You can learn more about this file format [here](https://www.marxentlabs.com/obj-files/)).

Begin with some imports:
"""

import numpy as np

from landlab import HexModelGrid, imshow_grid
from landlab.components import (
    FlowAccumulator,
    StreamPowerEroder,
    TaylorNonLinearDiffuser,
)
from landlab.io.obj import write_obj

"""
Set some parameters:
"""

nrows = 50  # number of node rows
ncols = 80  # number of node columns
node_spacing = 50.0  # distance between adjacent nodes, m
K_sp_mean = 1.0e-5  # stream power erosion coefficient, 1/y, spatial mean
K_sp_std = 2.0e-6  # stream power erosion coefficient, 1/y, standard deviation
seed = 0  # random seed
dt = 1000.0  # time-step duration, y
uprate = 0.001  # maximum uplift rate, m/y
num_steps = 1000  # number of time steps

"""
Define an "uplift function" that will generate a mountain range surrounded by an area of lower relief.
"""

def uplift_fn(x, y):
    xmax = np.amax(x)
    ymax = np.amax(y)
    u = (x / xmax) * (y / ymax) * (xmax**2 - x**2) * (ymax**2 - y**2)
    return u / np.amax(u)

"""
Create a grid (in this case, a `HexModelGrid`, though raster would work too), and initialize an elevation field with some random noise. Also create an array of erodibility values with some random noise, plus an array to represent the uplift rate in space.
"""

grid = HexModelGrid((nrows, ncols), spacing=node_spacing, node_layout="rect")
grid.dx = (
    grid.spacing
)  # temporary hack to enable TaylorNonLinearDiffuser to work with hex grid
elev = grid.add_zeros("topographic__elevation", at="node")
elev[grid.core_nodes] = np.random.rand(grid.number_of_core_nodes)
K_sp = K_sp_mean + K_sp_std * np.random.randn(grid.number_of_nodes)
u = uplift_fn(grid.x_of_node, grid.y_of_node)

"""
Instantiate three Landlab components: a `FlowAccumulator` to route flow across the gridded terrain, a `StreamPowerEroder` to simulate erosion by running water, and a `TaylorNonLinearDiffuser` to represent mass transport by gravitational processes.
"""

fa = FlowAccumulator(grid)
sp = StreamPowerEroder(grid, K_sp=K_sp)
td = TaylorNonLinearDiffuser(grid, linear_diffusivity=0.005)

"""
Loop to simulate the evolution of the landscape.
"""

for i in range(num_steps):
    elev[grid.core_nodes] += u[grid.core_nodes] * uprate * dt
    fa.run_one_step()
    sp.run_one_step(dt)
    td.run_one_step(dt)

"""
Inspect the resulting terrain with an image color-coded to represent cell elevation values.
"""

imshow_grid(grid, elev)

"""
Write the grid nodes and associated elevations to an `.obj` format file (note: the `topographic__elevation` field is the default choice for the $z$ coordinate of nodes).
"""

write_obj("test_mts.obj", grid, clobber=True)

"""
## Installing Blender

The first step is to download and install the Blender application from [https://www.blender.org/download/](https://www.blender.org/download/).
"""

"""
## Reading the output file into Blender

*(Note that this tutorial is written around Blender version 3.6.2 for MacOS; future versions may appear different from the screenshots below)*

1. Open Blender. By default the session starts with a single object: a cube. Type `x` to delete the cube, and verify this in the pop-up window that asks whether you really want to delete it.

2. From the `File` menu select `Import` then `Wavefront (.obj)`. Locate a file called `test_mts.obj` in the same folder as this notebook, and select it.

![after_initial_import.jpg](attachment:after_initial_import.jpg)



"""

"""
3. Before we go any further, it will be helpful to change the *clipping plane* to make our image completely visible. In the upper right of the main view pane, look for a small left-pointing chevron (just to the right of a colorful set of axes labeled X Y Z, see red circle in image below):

![view_pane_access.png](attachment:view_pane_access.png)


"""

"""
4. Click this to open a small window, then select the View tab next to it:

![clip_extent.png](attachment:clip_extent.png)

5. Change the value under "End" from 1000 m to 10000 m.


"""

"""
## Viewing the model in Blender

*(Note 1: Blender is a powerful 3D modeling package, and the following only scratches the surface a little bit to help you get started!)*

*(Note 2: To do the next steps, it really helps to have a mouse with a scroll wheel)*

* Zoom in and out of the image with the mouse scroll wheel (trying zooming out until the entire terrain is visible in the window)

* Rotate your view of the image by holding down the middle mouse button / scroll wheel and dragging

* Pan your view of the image by holding down the shift key and the middle mouse button / wheel and dragging while the image is selected

### Some default keyboard shortcuts

#### On the numeric keypad (if your keyboard has one)

2, 4, 6, 8 = rotate view down / left / right / up (respectively)

0 = place the viewpoint at the position of the camera

1, 3, 7 = snap view along y-axis / x-axis / z-axis (respectively) (notice how the guide axes in upper right change)

5 = toggle between perspective and orthographic view

9 = rotate view 180 degrees

#### On the "main" part of the keyboard

Tab = toggle between object mode and edit mode; note that you need to be in edit mode for the following keyboard shortcuts.

1 = toggle vertex select mode

2 = toggle edge select mode

3 = toggle face select mode

a = select all (alt-a to unselect all)

r = toggle rotate mode. You can rotate the whole object or an individually selected element; holding down the `x` key while you rotate will limit rotation to the x-axis; holding Shift-x will limit rotation to the other two axes. The same functionality applies with `y` and `z`. Holding the control key while rotating causes rotation to snap to finite increments (e.g., 15 degrees). Left-click keeps the rotation, and right-click discards it.

s = toggle scale mode. Limiting scale to x, y, or z axes works the same as with rotation.

g = toggle grab mode, which allows you to "grab" the object and move it around. As above, motion can be limited to just one or two axes.

z = hold this key down to select the view mode. Options are *Solid* (the default), *Wireframe*, *Material preview*, and *Rendered*. 




"""

"""
## Applying Subdivision

Blender can automatically subdivide a model, adding additional vertices and faces to increase the level of detail. For a Landlab-generated model, this can help add smoothness to the image. (Be careful: too much subdivision and the model can become too big for the computer to handle.)

To apply subdivision:

1. From the column of icons just to the (lower) right of the main view pane, select the one that looks like a blue wrench.

2. From the drop-down menu *Add Modifier* select *Subdivision Surface*

3. The *Levels Viewport* allows you to choose a number of levels of subdivision for the model as it appears in the viewport. The subdivision level represents the number of times subdivision will be applied. Try setting it to 2, meaning that the original grid elements will be subdivided into smaller elements once, and then those smaller elements will again be subdivided on a second pass. (The *Render* box sets the recursion levels for the rendered image; often 3D designers will keep the viewport subdivision smaller than the rendered version for the purpose of speed in object editing)

Here's a version of our terrain model with 2 levels of subdivision, with the lighting on viewport shading also changed to a brownish hue (hint: see the buttons and drop-down arrow on the upper-right of the viewport):

![muddy_terrain.jpg](attachment:muddy_terrain.jpg)

"""

"""
Blender is an incredibly powerful package, and this brief tutorial has only scratched the surface of what's possible. If you find interesting new tricks or applications, we would love to hear about it on the [CSDMS Forum](https://github.com/csdms/welcomes/discussions) or elsewhere!

The Forum can be found at:

https://github.com/csdms/welcomes/discussions

"""



================================================
File: docs/source/tutorials/visualization/paraview/importing_landlab_netcdf_to_paraview.ipynb
================================================
# Jupyter notebook converted to Python script.

"""
# Viewing Landlab output in ParaView

*(GE Tucker, CU Boulder, June 2023)*
"""

"""
[ParaView](https://www.paraview.org/) is a powerful open-source visualization engine developed by kitware. It provides fast 3D rendering of surfaces and volumes, and is a great way to inspect output from a Landlab-built model. There are currently two ways to write Landlab grid and field data in a format that ParaView can read. The first, for raster grids, is to use the NetCDF file format. The second, and still under development as of this writing, is to use the Legacy VTK file format, which works for hex grid and in principle other grid types as well. This tutorial covers the first method: writing Landlab output to NetCDF file(s) for input into ParaView. It explains, with a worked example, how to create NetCDF output, how to read this into ParaView, how to convert the flat images into 3D surfaces, how to color them according to different fields, and how to create animations.


"""

"""
## Creating a Landlab model as an example

In the example, we'll create a simple landscape evolution model in which the landscape consists of a layer of soil on top of a layer of rock. Weathering of rock to soil will be calculated using an inverse exponential function, as implemented by the `ExponentialWeatherer` component. Soil creep will be represented with a nonlinear diffusion model, using the `DepthDependentTaylorDiffuser` component (Barnhart et al., 2019). Runoff routing will be modeled with a steepest descent "D8" algorithm using the `FlowAccumulator` component (Barnhart et al., 2020). Fluvial erosion, transport, and deposition will be modeled using the `SPACE` component (Shobe et al., 2017). To learn more about the theory, math, and numerics behind these, see the references listed.

Begin with some imports:
"""

import numpy as np

from landlab import RasterModelGrid, imshow_grid
from landlab.components import (
    DepthDependentTaylorDiffuser,
    ExponentialWeatherer,
    FlowAccumulator,
    SpaceLargeScaleEroder,
)
from landlab.io.netcdf import write_raster_netcdf

# Parameters
nrows = 100  # number of node rows
ncols = 160  # number of node columns
dx = 10.0  # grid node spacing, m
max_soil_prod_rate = 0.001  # maximum soil production rate, m/y
soil_prod_decay_depth = 0.5  # decay depth for soil production, m
soil_transport_velocity = 0.02  # transport coefficient for soil creep, m/y
slope_crit = 1.0  # threshold slope factor for soil cree, -
soil_transport_decay_depth = 0.5  # decay depth for transport rate, m
nterms = 2  # number of terms for diffusion equation
K_sed = 0.001  # erosion coefficient for sediment
K_br = 0.0001  # erosion coefficient for rock
nsteps = 200  # number of time steps
dt = 10.0  # time-step duration, years
base_output_name = "eroding_landscape"  # base name for output files
output_interval = 100.0  # interval for output, y
fields_to_output = [
    "topographic__elevation",
    "soil__depth",
    "bedrock__elevation",
    "soil_production__rate",
    "drainage_area",
    "surface_water__discharge",
    "topographic__steepest_slope",
    "sediment__influx",
    "sediment__outflux",
]

# Create the grid
grid = RasterModelGrid((nrows, ncols), xy_spacing=dx)

# Create input fields
elev = grid.add_zeros("topographic__elevation", at="node")
soil = grid.add_zeros("soil__depth", at="node")
rock = grid.add_zeros("bedrock__elevation", at="node")

# Instantiate components
weatherer = ExponentialWeatherer(grid, max_soil_prod_rate, soil_prod_decay_depth)
diffuser = DepthDependentTaylorDiffuser(
    grid,
    soil_transport_velocity=soil_transport_velocity,
    slope_crit=slope_crit,
    soil_transport_decay_depth=soil_transport_decay_depth,
    nterms=nterms,
)
router = FlowAccumulator(grid, flow_director="FlowDirectorD8")
space = SpaceLargeScaleEroder(grid, K_sed=K_sed, K_br=K_br)

# Setup initial topography in the fashion of a couple of strath terraces
high_terrace = 20.0
low_terrace = 10.0
elev[:] = high_terrace
high_terr_cutout_amp = 380.0
high_terr_cutout_pd = 1300.0
low_terr_cutout_amp = 90.0
low_terr_cutout_pd = 700.0
init_soil_high_terr = 2.0
init_soil_low_terr = 1.0
init_soil_base = 0.5

# Make a sinusoidal cutout into the high terrace
trace_y = high_terr_cutout_amp * np.sin(
    2.0 * np.pi * grid.x_of_node / high_terr_cutout_pd
)
elev[grid.y_of_node < trace_y] = low_terrace
elev[grid.y_of_node > trace_y + 2 * high_terr_cutout_amp] = low_terrace

# ...and the low terrace
trace_y = low_terr_cutout_amp * np.sin(
    2.0 * np.pi * grid.x_of_node / low_terr_cutout_pd
)
elev[grid.y_of_node < trace_y + low_terr_cutout_amp] = 0.0
elev[grid.y_of_node > trace_y + 10 * low_terr_cutout_amp] = 0.0

# add some random noise and smooth it with a moving average
elev[:] += np.random.rand(grid.number_of_nodes)

soil[:] = init_soil_low_terr
soil[elev > low_terrace + 1.0] = init_soil_high_terr
soil[elev < low_terrace] = init_soil_base
rock[:] = elev - soil

imshow_grid(grid, elev)

imshow_grid(grid, soil)

# Setup for output, and write first file
router.run_one_step()  # to generate some flow accumulation for the 0th output
weatherer.calc_soil_prod_rate()  # ditto for soil prod rate
frame_number = 0
write_raster_netcdf(
    base_output_name + str(frame_number).zfill(4) + ".nc",
    grid,
    names=fields_to_output,
)
next_output = output_interval

# Run model
for i in range(1, nsteps + 1):
    router.run_one_step()
    weatherer.calc_soil_prod_rate()
    diffuser.run_one_step(dt)
    space.run_one_step(dt)
    if i * dt >= next_output:
        frame_number += 1
        write_raster_netcdf(
            base_output_name + str(frame_number).zfill(4) + ".nc",
            grid,
            names=fields_to_output,
        )
        next_output += output_interval

"""
## Installing ParaView

The first step is to download and install the ParaView application from [https://www.paraview.org/download/](https://www.paraview.org/download/).
"""

"""
## Reading output files into ParaView

1. Open ParaView
2. Click the open-file icon in the upper left, or choose File -> Open from the menu bar

<div>
<img src="assets/paraview_open_file.png" width="400">
</div>

3. Choose NetCDF Reader

<div>
<img src="assets/paraview_netcdf_reader.png" width="300">
</div>
    
4. Click the blue Apply button

<div>
<img src="assets/paraview_apply_new_file.png" width="300">
</div>
    

"""

"""
### Inspecting different fields

The drop-down menu toward the upper left gives you a list of fields to choose from. Try selecting different ones.

<div>
    <img src="assets/paraview_color_by.png" width="300">
    </div>
"""

"""
### Running animations

Look for the playback controls at the top of the window. Use the right arrow to play an animation.

<div>
    <img src="assets/paraview_playback_controls.png" width="300">
    </div>
"""

"""
### Viewing in 3D

So far the images are just that: 2D images. To make the landscape 3D, we have to tell ParaView which field to use for the 3rd dimension, and then "extrude" it. The command to do this is actually a plugin "filter":

1. From the menu bar, select Filters -> Alphabetical -> (scroll waaay down) Warp By Scalar

<div>
    <img src="assets/paraview_filters.png" width="300">
    </div>

2. Around the center left of the main window, look for a pop-up menu called "Scalars", and select "topographic__elevation"

<div>
    <img src="assets/paraview_warp_by_topo.png" width="300">
    </div>

3. Click the Apply button. You should notice that the terrain image now has some shading to it.

4. To view it in 3D, look for the little button just above the main view panel called "2D". Click it and it will switch to saying "3D", meaning you are now in 3D view mode.

<div>
    <img src="assets/paraview_view_mode.png" width="300">
    </div>

You should now be able to use the mouse to rotate the 3D image and zoom in or out.


## Closing thoughts

This tutorial just gives a small taste of what's possible using ParaView. Check out their documentation to learn more. And see the upcoming tutorial on using Legacy VTK file output as an alternative way to get Landlab output into ParaView, which also works for Hex grids.

## References

Barnhart, K. R., Glade, R. C., Shobe, C. M., and Tucker, G. E. (2019) Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution. Geosci. Model Dev., v. 12, p. 1267-1297, doi:10.5194/gmd-12-1267-2019.

Barnhart, K.R., Hutton, E.W.H., Tucker, G.E., Gasparini, N.M., Istanbulluoglu, E., Hobley, D.E.J., Lyons⁠, N.J., Mouchene, M., Nudurupati, S.S., Adams, J.M., and Bandaragoda, C. (2020) Short communication: Landlab 2.0: A software package for Earth surface dynamics. Earth Surface Dynamics, 8, 379–397, doi:10.5194/esurf-8-379-2020.

Shobe, C.M., Tucker, G.E., and Barnhart, K.R. The SPACE 1.0 model: a Landlab component for 2-D calculation of sediment transport, bedrock erosion, and landscape evolution. Geoscientific Model Development, 2017, doi:10.5194/gmd-10-4577-2017. 
"""




================================================
File: requirements/README.md
================================================
This directory contains several files that specify the versions of
our dependencies used in our CI workflows. *Landlab* does not require
these exact version numbers to work properly, these are what we
test against to ensure that things don't break as new versions
of our dependencies are released.

## Managed by dependabot

All files with a `.txt` extension are managed by dependabot and **should
not be manually edited** unless you need to add or remove a dependency.



================================================
File: requirements/docs.txt
================================================
furo==2024.8.6
ipython==8.29.0
myst-parser==4.0.0
nbsphinx==0.9.5
numpy==2.1.3
sphinx-copybutton==0.5.2
sphinx-inline-tabs==2023.4.21
sphinx-jinja==2.0.2
sphinx==8.1.3
sphinx_design==0.6.1
sphinxcontrib-towncrier==0.4.0a0
towncrier==23.11.0



================================================
File: requirements/notebooks.txt
================================================
bmi-topography==0.8.3
dask[array]==2024.6.2
holoviews==1.20.0
jupyter==1.1.1
mesa[network]==3.0.3



================================================
File: requirements/required.txt
================================================
bmipy==2.0.1
importlib-resources==6.4.0; python_version < '3.12'
matplotlib==3.10.0
netcdf4==1.7.2
numpy==2.2.3
pandas==2.2.3
pyshp==2.3.1
pyyaml==6.0.2
rich-click==1.8.5
scipy==1.15.1
statsmodels==0.14.4
xarray==2025.1.2



================================================
File: requirements/testing.txt
================================================
coverage==7.6.12
flaky==3.7.0
hypothesis==6.125.3
pytest==8.0.1
pytest-datadir==1.5.0
pytest-xdist==3.5.0






