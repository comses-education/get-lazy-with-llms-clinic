# tests/test_output_formatting.py
# (Keep other imports and helper functions as they were in the last full version)
import pytest
import json
import re 
import os 
from click.testing import CliRunner
from pathlib import Path
from unittest import mock

from dirdigest import cli as dirdigest_cli
from dirdigest.constants import TOOL_VERSION

def get_included_files_from_json(json_output_str: str) -> set[str]:
    try:
        data = json.loads(json_output_str)
    except json.JSONDecodeError as e: 
        pytest.fail(f"Output was not valid JSON for helper. Error: {e}. Output: '{json_output_str[:500]}...'")
    included_files = set()
    def recurse_node(node):
        if node.get("type") == "file":
            if "relative_path" in node:
                included_files.add(node["relative_path"])
        if "children" in node and isinstance(node["children"], list):
            for child in node["children"]:
                recurse_node(child)
    if "root" in data:
        recurse_node(data["root"])
    return included_files

def structure_text_contains(markdown_output: str, substring: str) -> bool:
    match = re.search(r"## Directory Structure\n+```text\n(.*?)\n```", markdown_output, re.DOTALL)
    if not match: return False
    return substring in match.group(1)

@pytest.mark.parametrize("temp_test_dir", ["simple_project"], indirect=True)
def test_markdown_output_basic_structure_simple_project(runner: CliRunner, temp_test_dir: Path):
    markdown_output = ""
    with mock.patch("dirdigest.utils.logger.stdout_console.print") as mock_rich_print:
        result = runner.invoke(dirdigest_cli.main_cli, ["--format", "markdown"]) 
        if mock_rich_print.call_args_list:
            markdown_output = "".join(str(call.args[0]) for call in mock_rich_print.call_args_list if call.args)
    assert result.exit_code == 0
    assert len(markdown_output) > 0
    assert f"# Directory Digest: {str(temp_test_dir.resolve())}" in markdown_output
    assert re.search(rf"\*Generated by dirdigest v{TOOL_VERSION} on \d{{4}}-\d{{2}}-\d{{2}}T\d{{2}}:\d{{2}}:\d{{2}}(\.\d+)?\*", markdown_output)
    assert re.search(r"\*Included files: \d+, Total content size: [\d\.]+ KB\*", markdown_output)
    assert "\n---\n" in markdown_output
    assert "\n## Directory Structure\n" in markdown_output
    assert "\n```text\n" in markdown_output
    assert structure_text_contains(markdown_output, ".\n")
    assert structure_text_contains(markdown_output, "├── file1.txt")
    assert structure_text_contains(markdown_output, "└── sub_dir1/") # Trailing / is important for dir nodes in visual
    assert structure_text_contains(markdown_output, "    └── script.py") # Note: script.py doesn't end with /
    assert "\n```\n" in markdown_output 
    assert "\n## Contents\n" in markdown_output
    assert re.search(r"### `./file1\.txt`\s*```(.*?\s*)*?```", markdown_output, re.DOTALL)
    assert re.search(r"### `./sub_dir1/script\.py`\s*```py(.*?\s*)*?```", markdown_output, re.DOTALL)


@pytest.mark.parametrize("temp_test_dir", ["complex_project"], indirect=True)
def test_markdown_directory_structure_visualization_complex(runner: CliRunner, temp_test_dir: Path):
    markdown_output = ""
    with mock.patch("dirdigest.utils.logger.stdout_console.print") as mock_rich_print:
        result = runner.invoke(dirdigest_cli.main_cli, ["--format", "markdown", "--max-depth", "2"]) 
        if mock_rich_print.call_args_list:
            markdown_output = "".join(str(call.args[0]) for call in mock_rich_print.call_args_list if call.args)

    assert result.exit_code == 0
    match = re.search(r"## Directory Structure\n+```text\n(.*?)\n```", markdown_output, re.DOTALL)
    assert match, "Directory structure block not found"
    structure_text = match.group(1)
    structure_lines = [line.strip() for line in structure_text.strip().split('\n')] # Strip lines for comparison

    # Expected structure based on your complex_project spec and alphabetical sort
    # Root elements (config.yaml, data/, docs/, README.md, src/, tests/)
    # tests/ is last.
    # src/ contains feature/, main.py, utils.py (sorted: feature, main, utils)
    # docs/ contains api.md, index.md (sorted: api.md, index.md) 
    #   and docs/api/ (subdir based on log) with reference.md
    
    # Define expected lines carefully, removing potential leading/trailing spaces from split lines
    # for more robust comparison.
    expected_tree_lines_in_order = [
        ".",
        "├── README.md",          # Alphabetical: R
        "├── config.yaml",        # Alphabetical: c
        "├── data/",              # Alphabetical: d (data)
        "│   └── small_data.csv",
        "├── docs/",              # Alphabetical: d (docs)
        "│   ├── api.md",           # Alphabetical: a (api dir)
        "│   └── index.md",       # Alphabetical: i (index.md)
        "├── src/",               # Alphabetical: s (src)
        "│   ├── feature/",
        "│   │   └── module.py",
        "│   ├── main.py",
        "│   └── utils.py",
        "└── tests/",             # Alphabetical: t (tests) - this should be last
        "    ├── test_main.py",
        "    └── test_utils.py"
    ]
    
    # Corrected assertions, searching within the whole structure_text for simplicity,
    # or checking against structure_lines (which is probably more robust).
    # Let's use structure_text with `\n` for expected newlines between lines.

    # Assert root
    assert ".\n" in structure_text

    # Assert structure for docs/ (based on previous log analysis for your fixture)
    # Assuming docs/ is NOT the last root item, so it has ├──
    # And children of docs/ are: api/ (dir), api.md (file), index.md (file)
    # Sorted: api/ (dir), api.md (file), index.md (file)
    # This also means the connecting line for children of docs/ should be '│'
    assert "├── docs/\n" in structure_text
    assert "│   ├── api.md\n" in structure_text         # file
    assert "│   └── index.md\n" in structure_text       # file (last under docs)
    
    # Assert structure for src/
    # Assuming src/ is NOT the last root item
    assert "├── src/\n" in structure_text
    assert "│   ├── feature/\n" in structure_text
    assert "│   │   └── module.py\n" in structure_text
    assert "│   ├── main.py\n" in structure_text
    assert "│   └── utils.py\n" in structure_text # last under src

    # Assert structure for tests/
    # Assuming tests/ IS the last root item
    assert "└── tests/\n" in structure_text
    assert "    ├── test_main.py\n" in structure_text # Indented with spaces
    assert "    └── test_utils.py" in structure_text  # Last line in structure, might not have \n in structure_text itself
                                                      # but the join in formatter adds it.
                                                      # The structure_text from regex group(1) will contain it with a \n IF it's not the very last char of group(1).
                                                      # If "    └── test_utils.py" is the absolute end of match.group(1), it won't have \n after it.
                                                      # The previous output showed it as the end: "...    └── test_utils.py"
                                                      # So, assert without \n for this specific one if it's the true end.
                                                      # Or, ensure structure_text always ends with \n if it's non-empty.
                                                      # The regex (.*?) captures up to the final \n```.

    # Let's assume the formatter ensures all lines internally end with \n before final join,
    # or that the overall join ensures this.
    # The string `structure_text` from your error log:
    # '.\n├── README.md\n...main.py\n    └── test_utils.py' (no final \n here)
    # This means the `(test_utils.py)` is the last part of `match.group(1)`.

    # So the assertion should be:
    assert "    └── test_utils.py" in structure_text # No \n if it's the very end of the block
    # And ensure it's not followed by another line of the tree:
    assert structure_text.endswith("    └── test_utils.py")


    # Verify default ignored are not present
    assert ".git/" not in structure_text
    assert "__pycache__/" not in structure_text
    assert "node_modules/" not in structure_text


@pytest.mark.parametrize("temp_test_dir", ["lang_hint_project"], indirect=True)
def test_markdown_code_block_language_hints(runner: CliRunner, temp_test_dir: Path):
    markdown_output = ""
    with mock.patch("dirdigest.utils.logger.stdout_console.print") as mock_rich_print:
        result = runner.invoke(dirdigest_cli.main_cli, ["--format", "markdown", "--no-default-ignore"])
        if mock_rich_print.call_args_list:
            markdown_output = "".join(str(call.args[0]) for call in mock_rich_print.call_args_list if call.args)
    assert result.exit_code == 0
    # Using re.escape on content might be needed if content has regex special chars
    # For simple content, direct string is fine. The echo command adds a newline.
    assert re.search(r"### `./script\.py`\s*```py\s*print\(\"python\"\)\n\s*```", markdown_output, re.DOTALL)
    assert re.search(r"### `./styles\.css`\s*```css\s*body \{ color: blue; \}\n\s*```", markdown_output, re.DOTALL)
    assert re.search(r"### `./data\.json`\s*```json\s*\{\"key\": \"value\"\}\n\s*```", markdown_output, re.DOTALL)
    assert re.search(r"### `./README\.md`\s*```md\s*# Markdown\n\s*```", markdown_output, re.DOTALL)
    assert re.search(r"### `./unknown\.xyz`\s*```(xyz)?\s*some data\n\s*```", markdown_output, re.DOTALL)
    assert re.search(r"### `./no_ext_file`\s*```\s*text with no extension\n\s*```", markdown_output, re.DOTALL)


@pytest.mark.parametrize("temp_test_dir", ["content_processing_dir"], indirect=True)
def test_markdown_file_with_read_error(runner: CliRunner, temp_test_dir: Path):
    markdown_output = ""
    file_to_make_unreadable = Path("permission_denied_file.txt")
    original_permissions = None
    try:
        if file_to_make_unreadable.exists():
            original_permissions = file_to_make_unreadable.stat().st_mode
            os.chmod(file_to_make_unreadable, 0o000)
        with mock.patch("dirdigest.utils.logger.stdout_console.print") as mock_rich_print:
            result = runner.invoke(dirdigest_cli.main_cli, [
                "--format", "markdown", "--ignore-errors", "--no-default-ignore"
            ])
            if mock_rich_print.call_args_list:
                markdown_output = "".join(str(call.args[0]) for call in mock_rich_print.call_args_list if call.args)
    finally:
        if original_permissions is not None and file_to_make_unreadable.exists():
            os.chmod(file_to_make_unreadable, original_permissions) 
    assert result.exit_code == 0
    assert f"\n### `./{file_to_make_unreadable.name}`\n" in markdown_output
    assert re.search(r"```(text)?\s*Error reading file:.*?Permission denied.*?\s*```", markdown_output, re.DOTALL)


@pytest.mark.parametrize("temp_test_dir", ["simple_project"], indirect=True)
def test_json_output_metadata_and_root_structure(runner: CliRunner, temp_test_dir: Path):
    json_output_str = ""
    with mock.patch("dirdigest.utils.logger.stdout_console.print") as mock_rich_print:
        result = runner.invoke(dirdigest_cli.main_cli, ["--format", "json"])
        if mock_rich_print.call_args_list:
            json_output_str = "".join(str(call.args[0]) for call in mock_rich_print.call_args_list if call.args)
    assert result.exit_code == 0
    try:
        data = json.loads(json_output_str)
    except json.JSONDecodeError:
        pytest.fail(f"Output was not valid JSON: {json_output_str}")
    assert "metadata" in data
    metadata = data["metadata"]
    assert metadata["tool_version"] == TOOL_VERSION
    assert "created_at" in metadata 
    assert Path(metadata["base_directory"]) == temp_test_dir.resolve()
    assert "included_files_count" in metadata
    assert "excluded_files_count" in metadata
    assert "total_content_size_kb" in metadata
    assert isinstance(metadata["included_files_count"], int)
    assert isinstance(metadata["excluded_files_count"], int)
    assert isinstance(metadata["total_content_size_kb"], (float, int))
    assert metadata["included_files_count"] == 3 
    assert metadata["excluded_files_count"] == 0 
    assert "root" in data
    root_node = data["root"]
    assert root_node["relative_path"] == "."
    assert root_node["type"] == "folder"
    assert "children" in root_node
    assert isinstance(root_node["children"], list)
    assert len(root_node["children"]) == 3